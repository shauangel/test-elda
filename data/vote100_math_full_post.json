[{"link": "https://stackoverflow.com/questions/944700/how-can-i-check-for-nan-values", "question": {"id": "944700", "title": "How can I check for NaN values?", "content": "<p><code>float('nan')</code> represents NaN (not a number). But how do I check for it?</p>\n", "abstract": "float('nan') represents NaN (not a number). But how do I check for it?"}, "answers": [{"id": 944733, "score": 1882, "vote": 0, "content": "<p>Use <a href=\"http://docs.python.org/library/math.html#math.isnan\" rel=\"noreferrer\"><code>math.isnan</code></a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; x = float('nan')\n&gt;&gt;&gt; math.isnan(x)\nTrue\n</code></pre>\n", "abstract": "Use math.isnan:"}, {"id": 944712, "score": 543, "vote": 0, "content": "<p>The usual way to test for a NaN is to see if it's equal to itself:</p>\n<pre><code class=\"python\">def isNaN(num):\n    return num != num\n</code></pre>\n", "abstract": "The usual way to test for a NaN is to see if it's equal to itself:"}, {"id": 944756, "score": 254, "vote": 0, "content": "<p><code>numpy.isnan(number)</code> tells you if it's <code>NaN</code> or not.</p>\n", "abstract": "numpy.isnan(number) tells you if it's NaN or not."}, {"id": 54967010, "score": 203, "vote": 0, "content": "<p><strong>Here are three ways where you can test a variable is \"NaN\" or not.</strong></p>\n<pre><code class=\"python\">import pandas as pd\nimport numpy as np\nimport math\n\n# For single variable all three libraries return single boolean\nx1 = float(\"nan\")\n\nprint(f\"It's pd.isna: {pd.isna(x1)}\")\nprint(f\"It's np.isnan: {np.isnan(x1)}}\")\nprint(f\"It's math.isnan: {math.isnan(x1)}}\")\n</code></pre>\n<p><strong>Output</strong></p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">It's pd.isna: True\nIt's np.isnan: True\nIt's math.isnan: True\n</code></pre>\n", "abstract": "Here are three ways where you can test a variable is \"NaN\" or not. Output"}, {"id": 44154660, "score": 48, "vote": 0, "content": "<p>here is an answer working with:</p>\n<ul>\n<li>NaN implementations respecting IEEE 754 standard \n\n<ul>\n<li>ie: python's NaN: <code>float('nan')</code>, <code>numpy.nan</code>...</li>\n</ul></li>\n<li>any other objects: string or whatever (does not raise exceptions if encountered)</li>\n</ul>\n<p>A NaN implemented following the standard, is the only value for which the inequality comparison with itself should return True:</p>\n<pre><code class=\"python\">def is_nan(x):\n    return (x != x)\n</code></pre>\n<p>And some examples:</p>\n<pre><code class=\"python\">import numpy as np\nvalues = [float('nan'), np.nan, 55, \"string\", lambda x : x]\nfor value in values:\n    print(f\"{repr(value):&lt;8} : {is_nan(value)}\")\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">nan      : True\nnan      : True\n55       : False\n'string' : False\n&lt;function &lt;lambda&gt; at 0x000000000927BF28&gt; : False\n</code></pre>\n", "abstract": "here is an answer working with: A NaN implemented following the standard, is the only value for which the inequality comparison with itself should return True: And some examples: Output:"}, {"id": 62171968, "score": 47, "vote": 0, "content": "<p><strong>It seems that checking if it's equal to itself</strong></p>\n<pre><code class=\"python\">x!=x\n</code></pre>\n<p><strong>is the fastest.</strong></p>\n<pre><code class=\"python\">import pandas as pd \nimport numpy as np \nimport math \n\nx = float('nan')\n\n%timeit x!=x                                                                                                                                                                                                                        \n44.8 ns \u00b1 0.152 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n\n%timeit math.isnan(x)                                                                                                                                                                                                               \n94.2 ns \u00b1 0.955 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n\n%timeit pd.isna(x) \n281 ns \u00b1 5.48 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n\n%timeit np.isnan(x)                                                                                                                                                                                                                 \n1.38 \u00b5s \u00b1 15.7 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n\n</code></pre>\n", "abstract": "It seems that checking if it's equal to itself is the fastest."}, {"id": 12588878, "score": 34, "vote": 0, "content": "<p>I actually just ran into this, but for me it was checking for nan, -inf, or inf. I just used</p>\n<pre><code class=\"python\">if float('-inf') &lt; float(num) &lt; float('inf'):\n</code></pre>\n<p>This is true for numbers, false for nan and both inf, and will raise an exception for things like strings or other types (which is probably a good thing). Also this does not require importing any libraries like math or numpy (numpy is so damn big it doubles the size of any compiled application).</p>\n", "abstract": "I actually just ran into this, but for me it was checking for nan, -inf, or inf. I just used This is true for numbers, false for nan and both inf, and will raise an exception for things like strings or other types (which is probably a good thing). Also this does not require importing any libraries like math or numpy (numpy is so damn big it doubles the size of any compiled application)."}, {"id": 944734, "score": 27, "vote": 0, "content": "<p><a href=\"http://docs.python.org/library/math.html#math.isnan\" rel=\"noreferrer\">math.isnan()</a></p>\n<p>or compare the number to itself. NaN is always != NaN, otherwise (e.g. if it <em>is</em> a number) the comparison should succeed.</p>\n", "abstract": "math.isnan() or compare the number to itself. NaN is always != NaN, otherwise (e.g. if it is a number) the comparison should succeed."}, {"id": 11334997, "score": 25, "vote": 0, "content": "<p>Well I entered this post, because i've had some issues with the function:</p>\n<pre><code class=\"python\">math.isnan()\n</code></pre>\n<p>There are problem when you run this code:</p>\n<pre><code class=\"python\">a = \"hello\"\nmath.isnan(a)\n</code></pre>\n<p>It raises exception.\nMy solution for that is to make another check:</p>\n<pre><code class=\"python\">def is_nan(x):\n    return isinstance(x, float) and math.isnan(x)\n</code></pre>\n", "abstract": "Well I entered this post, because i've had some issues with the function: There are problem when you run this code: It raises exception.\nMy solution for that is to make another check:"}, {"id": 2138383, "score": 17, "vote": 0, "content": "<p>Another method if you're stuck on &lt;2.6, you don't have numpy, and you don't have IEEE 754 support:</p>\n<pre><code class=\"python\">def isNaN(x):\n    return str(x) == str(1e400*0)\n</code></pre>\n", "abstract": "Another method if you're stuck on <2.6, you don't have numpy, and you don't have IEEE 754 support:"}, {"id": 3060088, "score": 11, "vote": 0, "content": "<p>With python &lt; 2.6 I ended up with</p>\n<pre><code class=\"python\">def isNaN(x):\n    return str(float(x)).lower() == 'nan'\n</code></pre>\n<p>This works for me with python 2.5.1 on a Solaris 5.9 box and with python 2.6.5 on Ubuntu 10 </p>\n", "abstract": "With python < 2.6 I ended up with This works for me with python 2.5.1 on a Solaris 5.9 box and with python 2.6.5 on Ubuntu 10 "}, {"id": 37985974, "score": 8, "vote": 0, "content": "<p>I am receiving the data from a web-service that sends <code>NaN</code> as a string <code>'Nan'</code>. But there could be other sorts of string in my data as well, so a simple <code>float(value)</code> could throw an exception. I used the following variant of the accepted answer:</p>\n<pre><code class=\"python\">def isnan(value):\n  try:\n      import math\n      return math.isnan(float(value))\n  except:\n      return False\n</code></pre>\n<p>Requirement:</p>\n<pre><code class=\"python\">isnan('hello') == False\nisnan('NaN') == True\nisnan(100) == False\nisnan(float('nan')) = True\n</code></pre>\n", "abstract": "I am receiving the data from a web-service that sends NaN as a string 'Nan'. But there could be other sorts of string in my data as well, so a simple float(value) could throw an exception. I used the following variant of the accepted answer: Requirement:"}, {"id": 41011102, "score": 5, "vote": 0, "content": "<p>All the methods to tell if the variable is NaN or None:</p>\n<p><strong>None type</strong></p>\n<pre><code class=\"python\">In [1]: from numpy import math\n\nIn [2]: a = None\nIn [3]: not a\nOut[3]: True\n\nIn [4]: len(a or ()) == 0\nOut[4]: True\n\nIn [5]: a == None\nOut[5]: True\n\nIn [6]: a is None\nOut[6]: True\n\nIn [7]: a != a\nOut[7]: False\n\nIn [9]: math.isnan(a)\nTraceback (most recent call last):\n  File \"&lt;ipython-input-9-6d4d8c26d370&gt;\", line 1, in &lt;module&gt;\n    math.isnan(a)\nTypeError: a float is required\n\nIn [10]: len(a) == 0\nTraceback (most recent call last):\n  File \"&lt;ipython-input-10-65b72372873e&gt;\", line 1, in &lt;module&gt;\n    len(a) == 0\nTypeError: object of type 'NoneType' has no len()\n</code></pre>\n<p><strong>NaN type</strong></p>\n<pre><code class=\"python\">In [11]: b = float('nan')\nIn [12]: b\nOut[12]: nan\n\nIn [13]: not b\nOut[13]: False\n\nIn [14]: b != b\nOut[14]: True\n\nIn [15]: math.isnan(b)\nOut[15]: True\n</code></pre>\n", "abstract": "All the methods to tell if the variable is NaN or None: None type NaN type"}, {"id": 54396886, "score": 5, "vote": 0, "content": "<p><strong>How to remove NaN (float) item(s) from a list of mixed data types</strong></p>\n<p>If you have mixed types in an iterable, here is a solution that does not use numpy:</p>\n<pre><code class=\"python\">from math import isnan\n\nZ = ['a','b', float('NaN'), 'd', float('1.1024')]\n\n[x for x in Z if not (\n                      type(x) == float # let's drop all float values\u2026\n                      and isnan(x) # \u2026 but only if they are nan\n                      )]\n</code></pre>\n<pre>['a', 'b', 'd', 1.1024]</pre>\n<p>Short-circuit evaluation means that <code>isnan</code> will not be called on values that are not of type 'float', as <code>False and (\u2026)</code> quickly evaluates to <code>False</code> without having to evaluate the right-hand side.</p>\n", "abstract": "How to remove NaN (float) item(s) from a list of mixed data types If you have mixed types in an iterable, here is a solution that does not use numpy: Short-circuit evaluation means that isnan will not be called on values that are not of type 'float', as False and (\u2026) quickly evaluates to False without having to evaluate the right-hand side."}, {"id": 59722642, "score": 5, "vote": 0, "content": "<p>In Python 3.6 checking on a string value x math.isnan(x) and np.isnan(x) raises an error. \nSo I can't check if the given value is NaN or not if I don't know beforehand it's a number.\nThe following seems to solve this issue</p>\n<pre><code class=\"python\">if str(x)=='nan' and type(x)!='str':\n    print ('NaN')\nelse:\n    print ('non NaN')\n</code></pre>\n", "abstract": "In Python 3.6 checking on a string value x math.isnan(x) and np.isnan(x) raises an error. \nSo I can't check if the given value is NaN or not if I don't know beforehand it's a number.\nThe following seems to solve this issue"}, {"id": 68168892, "score": 5, "vote": 0, "content": "<p>Comparison <code>pd.isna</code>, <code>math.isnan</code> and <code>np.isnan</code> and their flexibility dealing with different type of objects.</p>\n<p>The table below shows if the type of object can be checked with the given method:</p>\n<pre><code class=\"python\">\n+------------+-----+---------+------+--------+------+\n|   Method   | NaN | numeric | None | string | list |\n+------------+-----+---------+------+--------+------+\n| pd.isna    | yes | yes     | yes  | yes    | yes  |\n| math.isnan | yes | yes     | no   | no     | no   |\n| np.isnan   | yes | yes     | no   | no     | yes  | &lt;-- # will error on mixed type list\n+------------+-----+---------+------+--------+------+\n\n</code></pre>\n<h3><a href=\"https://pandas.pydata.org/docs/reference/api/pandas.isna.html\" rel=\"noreferrer\"><code>pd.isna</code></a></h3>\n<p>The most flexible method to check for different types of missing values.</p>\n<hr/>\n<p>None of the answers cover the flexibility of <code>pd.isna</code>. While <code>math.isnan</code> and <code>np.isnan</code> will return <code>True</code> for <code>NaN</code> values, you cannot check for different type of objects like <code>None</code> or strings. Both methods will return an error, so checking a list with mixed types will be cumbersom. This while <code>pd.isna</code> is flexible and will return the correct boolean for different kind of types:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">In [1]: import pandas as pd\n\nIn [2]: import numpy as np\n\nIn [3]: missing_values = [3, None, np.NaN, pd.NA, pd.NaT, '10']\n\nIn [4]: pd.isna(missing_values)\nOut[4]: array([False,  True,  True,  True,  True, False])\n</code></pre>\n", "abstract": "Comparison pd.isna, math.isnan and np.isnan and their flexibility dealing with different type of objects. The table below shows if the type of object can be checked with the given method: The most flexible method to check for different types of missing values. None of the answers cover the flexibility of pd.isna. While math.isnan and np.isnan will return True for NaN values, you cannot check for different type of objects like None or strings. Both methods will return an error, so checking a list with mixed types will be cumbersom. This while pd.isna is flexible and will return the correct boolean for different kind of types:"}, {"id": 51373482, "score": 1, "vote": 0, "content": "<blockquote>\n<p>For nan of type float  </p>\n</blockquote>\n<pre><code class=\"python\">&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; value = float(nan)\n&gt;&gt;&gt; type(value)\n&gt;&gt;&gt; &lt;class 'float'&gt;\n&gt;&gt;&gt; pd.isnull(value)\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; value = 'nan'\n&gt;&gt;&gt; type(value)\n&gt;&gt;&gt; &lt;class 'str'&gt;\n&gt;&gt;&gt; pd.isnull(value)\nFalse\n</code></pre>\n", "abstract": "For nan of type float  "}, {"id": 51382112, "score": -4, "vote": 0, "content": "<p>for strings in panda take pd.isnull:</p>\n<pre><code class=\"python\">if not pd.isnull(atext):\n  for word in nltk.word_tokenize(atext):\n</code></pre>\n<p>the function as feature extraction for NLTK</p>\n<pre><code class=\"python\">def act_features(atext):\nfeatures = {}\nif not pd.isnull(atext):\n  for word in nltk.word_tokenize(atext):\n    if word not in default_stopwords:\n      features['cont({})'.format(word.lower())]=True\nreturn features\n</code></pre>\n", "abstract": "for strings in panda take pd.isnull: the function as feature extraction for NLTK"}]}, {"link": "https://stackoverflow.com/questions/183853/what-is-the-difference-between-and-when-used-for-division", "question": {"id": "183853", "title": "What is the difference between &#39;/&#39; and &#39;//&#39; when used for division?", "content": "<p>Is there a benefit to using one over the other? In Python 2, they both seem to return the same results:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 6/3\n2\n&gt;&gt;&gt; 6//3\n2\n</code></pre>\n", "abstract": "Is there a benefit to using one over the other? In Python 2, they both seem to return the same results:"}, "answers": [{"id": 183870, "score": 756, "vote": 0, "content": "<p>In Python 3.x, <code>5 / 2</code> will return <code>2.5</code> and <code>5 // 2</code> will return <code>2</code>.  The former is floating point division, and the latter is <em><strong>floor division</strong></em>, sometimes also called <em><strong>integer division</strong></em>.</p>\n<p>In Python 2.2 or later in the 2.x line, there is no difference for integers unless you perform a <code>from __future__ import division</code>, which causes Python 2.x to adopt the 3.x behavior.</p>\n<p>Regardless of the future import, <code>5.0 // 2</code> will return <code>2.0</code> since that's the floor division result of the operation.</p>\n<p>You can find a detailed description at <em><a href=\"https://docs.python.org/whatsnew/2.2.html#pep-238-changing-the-division-operator\" rel=\"noreferrer\">PEP 238: Changing the Division Operator</a></em>.</p>\n", "abstract": "In Python 3.x, 5 / 2 will return 2.5 and 5 // 2 will return 2.  The former is floating point division, and the latter is floor division, sometimes also called integer division. In Python 2.2 or later in the 2.x line, there is no difference for integers unless you perform a from __future__ import division, which causes Python 2.x to adopt the 3.x behavior. Regardless of the future import, 5.0 // 2 will return 2.0 since that's the floor division result of the operation. You can find a detailed description at PEP 238: Changing the Division Operator."}, {"id": 11604247, "score": 75, "vote": 0, "content": "<h3>Python 2.x Clarification:</h3>\n<p>To clarify for the Python 2.x line, <code>/</code> is neither floor division nor true division.</p>\n<p><code>/</code> is floor division when <strong>both</strong> args are <code>int</code>, but is true division when <em><strong>either</strong></em> of the args are <code>float</code>.</p>\n", "abstract": "To clarify for the Python 2.x line, / is neither floor division nor true division. / is floor division when both args are int, but is true division when either of the args are float."}, {"id": 183866, "score": 37, "vote": 0, "content": "<p><code>//</code> implements \"floor division\", regardless of your type. So\n<code>1.0/2.0</code> will give <code>0.5</code>, but both <code>1/2</code>, <code>1//2</code> and <code>1.0//2.0</code> will give <code>0</code>.</p>\n<p>See <em><a href=\"https://docs.python.org/whatsnew/2.2.html#pep-238-changing-the-division-operator\" rel=\"nofollow noreferrer\">PEP 238: Changing the Division Operator</a></em> for details.</p>\n", "abstract": "// implements \"floor division\", regardless of your type. So\n1.0/2.0 will give 0.5, but both 1/2, 1//2 and 1.0//2.0 will give 0. See PEP 238: Changing the Division Operator for details."}, {"id": 38552114, "score": 31, "vote": 0, "content": "<p><strong>/</strong> \u2192 Floating point division</p>\n<p><strong>//</strong> \u2192 Floor division</p>\n<p>Let\u2019s see some examples in both Python 2.7 and in Python 3.5.</p>\n<p><strong>Python 2.7.10 vs. Python 3.5</strong></p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">print (2/3)  ----&gt; 0                   Python 2.7\nprint (2/3)  ----&gt; 0.6666666666666666  Python 3.5\n</code></pre>\n<p><strong>Python 2.7.10 vs. Python 3.5</strong></p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">print (4/2)  ----&gt; 2         Python 2.7\nprint (4/2)  ----&gt; 2.0       Python 3.5\n</code></pre>\n<p>Now if you want to have (in Python 2.7) the same output as in Python\u00a03.5, you can do the following:</p>\n<p><strong>Python 2.7.10</strong></p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">from __future__ import division\nprint (2/3)  ----&gt; 0.6666666666666666   # Python 2.7\nprint (4/2)  ----&gt; 2.0                  # Python 2.7\n</code></pre>\n<p>Whereas there isn't any difference between <em>floor</em> division in both Python 2.7 and in Python 3.5.</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">138.93//3 ---&gt; 46.0        # Python 2.7\n138.93//3 ---&gt; 46.0        # Python 3.5\n4//3      ---&gt; 1           # Python 2.7\n4//3      ---&gt; 1           # Python 3.5\n</code></pre>\n", "abstract": "/ \u2192 Floating point division // \u2192 Floor division Let\u2019s see some examples in both Python 2.7 and in Python 3.5. Python 2.7.10 vs. Python 3.5 Python 2.7.10 vs. Python 3.5 Now if you want to have (in Python 2.7) the same output as in Python\u00a03.5, you can do the following: Python 2.7.10 Whereas there isn't any difference between floor division in both Python 2.7 and in Python 3.5."}, {"id": 1704753, "score": 23, "vote": 0, "content": "<p>As everyone has already answered, <code>//</code> is floor division.</p>\n<p>Why this is important is that <code>//</code> is unambiguously floor division, in all Python versions from 2.2, including Python 3.x versions.</p>\n<p>The behavior of <code>/</code> can change depending on:</p>\n<ul>\n<li>Active <code>__future__</code> import or not (module-local)</li>\n<li>Python command line option, either <code>-Q old</code> or <code>-Q new</code></li>\n</ul>\n", "abstract": "As everyone has already answered, // is floor division. Why this is important is that // is unambiguously floor division, in all Python versions from 2.2, including Python 3.x versions. The behavior of / can change depending on:"}, {"id": 22487879, "score": 13, "vote": 0, "content": "<pre><code class=\"python\">&gt;&gt;&gt; print 5.0 / 2\n2.5\n\n&gt;&gt;&gt; print 5.0 // 2\n2.0\n</code></pre>\n", "abstract": ""}, {"id": 42053200, "score": 7, "vote": 0, "content": "<p>Python 2.7 and other upcoming versions of Python:</p>\n<ul>\n<li>Division (<code>/</code>)</li>\n</ul>\n<p>Divides left hand operand by right hand operand</p>\n<p>Example: <code>4 / 2 = 2</code></p>\n<ul>\n<li>Floor division (<code>//</code>)</li>\n</ul>\n<p>The division of operands where the result is the quotient in which the digits after the decimal point are removed. But if one of the operands is negative, the result is floored, i.e., rounded away from zero (towards negative infinity):</p>\n<p>Examples: <code>9//2 = 4</code> and <code>9.0//2.0 = 4.0</code>, <code>-11//3 = -4</code>, <code>-11.0//3 = -4.0</code></p>\n<p>Both <code>/</code> division and <code>//</code> floor division operator are operating in similar fashion.</p>\n", "abstract": "Python 2.7 and other upcoming versions of Python: Divides left hand operand by right hand operand Example: 4 / 2 = 2 The division of operands where the result is the quotient in which the digits after the decimal point are removed. But if one of the operands is negative, the result is floored, i.e., rounded away from zero (towards negative infinity): Examples: 9//2 = 4 and 9.0//2.0 = 4.0, -11//3 = -4, -11.0//3 = -4.0 Both / division and // floor division operator are operating in similar fashion."}, {"id": 183863, "score": 5, "vote": 0, "content": "<p><code>//</code> is floor division. It will always give you the integer floor of the result.  The other is 'regular' division.</p>\n", "abstract": "// is floor division. It will always give you the integer floor of the result.  The other is 'regular' division."}, {"id": 183865, "score": 5, "vote": 0, "content": "<p>The double slash, <code>//</code>, is floor division:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 7//3\n2\n</code></pre>\n", "abstract": "The double slash, //, is floor division:"}, {"id": 56470206, "score": 3, "vote": 0, "content": "<p>The previous answers are good. I want to add another point. Up to some values both of them result in the same quotient. After that floor division operator (<code>//</code>) works fine but not division (<code>/</code>) operator:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; int(755349677599789174 / 2) # Wrong answer\n377674838799894592\n</code></pre>\n<pre><code class=\"python\">&gt;&gt;&gt; 755349677599789174 // 2     # Correct answer\n377674838799894587\n</code></pre>\n", "abstract": "The previous answers are good. I want to add another point. Up to some values both of them result in the same quotient. After that floor division operator (//) works fine but not division (/) operator:"}, {"id": 30624406, "score": 2, "vote": 0, "content": "<p>The answer of the equation is rounded to the next smaller integer or float with .0 as decimal point. </p>\n<pre><code class=\"python\">&gt;&gt;&gt;print 5//2\n2\n&gt;&gt;&gt; print 5.0//2\n2.0\n&gt;&gt;&gt;print 5//2.0\n2.0\n&gt;&gt;&gt;print 5.0//2.0\n2.0\n</code></pre>\n", "abstract": "The answer of the equation is rounded to the next smaller integer or float with .0 as decimal point. "}, {"id": 68579034, "score": 1, "vote": 0, "content": "<h2>Summary</h2>\n<ul>\n<li>x//y : <strong>EXACT</strong> integer division</li>\n<li>int(x/y) OR math.floor(x/y): <strong>INEXACT</strong> integer division (but almost correct)</li>\n<li>x/y: floating point division (that has the loss of significance)</li>\n</ul>\n<h2>Remarkable Calculation Result</h2>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import math\nN = 1004291331219602346 # huge number \n\nprint(N//100) #=&gt; 10042913312196023 is correct answer\nprint(math.floor(N/100)) #=&gt; 10042913312196024 is wrong answer\nprint(math.ceil(N/100)) #=&gt; 10042913312196024 is wrong answer\nprint(int(N/100)) #=&gt; 10042913312196024 is wrong answer\n</code></pre>\n<h2>Consideration</h2>\n<p>I think about the evaluation of <code>int(x/y)</code>.<br/>\nAt first, Python evaluate the expression <code>x/y</code> and get INEXACT floating number z.<br/>\nSecond, Python evaluate the expression <code>int(z)</code>.<br/>\nWe get a wrong result when the loss of significance cannot be ignored.</p>\n", "abstract": "I think about the evaluation of int(x/y).\nAt first, Python evaluate the expression x/y and get INEXACT floating number z.\nSecond, Python evaluate the expression int(z).\nWe get a wrong result when the loss of significance cannot be ignored."}, {"id": 55317456, "score": 0, "vote": 0, "content": "<ul>\n<li><code>//</code> is floor division. It will always give you the floor value of the result.</li>\n<li>And the other one, <code>/</code>, is the floating-point division.</li>\n</ul>\n<p>In the following is the difference between <code>/</code> and <code>//</code>;\nI have run these arithmetic operations in Python 3.7.2.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print (11 / 3)\n3.6666666666666665\n\n&gt;&gt;&gt; print (11 // 3)\n3\n\n&gt;&gt;&gt; print (11.3 / 3)\n3.7666666666666667\n\n&gt;&gt;&gt; print (11.3 // 3)\n3.0\n</code></pre>\n", "abstract": "In the following is the difference between / and //;\nI have run these arithmetic operations in Python 3.7.2."}, {"id": 66189553, "score": 0, "vote": 0, "content": "<p><strong>Python 3.x Clarification</strong></p>\n<p>Just to complement some previous answers.</p>\n<p>It is important to remark that:</p>\n<blockquote>\n<p>a // b</p>\n</blockquote>\n<ul>\n<li><p>Is <strong>floor division</strong>. As in:</p>\n<blockquote>\n<p>math.floor(a/b)</p>\n</blockquote>\n</li>\n<li><p>Is not <strong>int division</strong>. As in:</p>\n<blockquote>\n<p>int(a/b)</p>\n</blockquote>\n</li>\n<li><p>Is not <strong>round to 0 float division</strong>. As in:</p>\n<blockquote>\n<p>round(a/b,0)</p>\n</blockquote>\n</li>\n</ul>\n<p>As a consequence, the way of behaving is different when it comes to positives an negatives numbers as in the following example:</p>\n<p>1 // 2 is  0, as in:</p>\n<blockquote>\n<p>math.floor(1/2)</p>\n</blockquote>\n<p>-1 // 2 is -1, as in:</p>\n<blockquote>\n<p>math.floor(-1/2)</p>\n</blockquote>\n", "abstract": "Python 3.x Clarification Just to complement some previous answers. It is important to remark that: a // b Is floor division. As in: math.floor(a/b) Is not int division. As in: int(a/b) Is not round to 0 float division. As in: round(a/b,0) As a consequence, the way of behaving is different when it comes to positives an negatives numbers as in the following example: 1 // 2 is  0, as in: math.floor(1/2) -1 // 2 is -1, as in: math.floor(-1/2)"}, {"id": 66835078, "score": 0, "vote": 0, "content": "<h3><a href=\"https://docs.python.org/3/library/stdtypes.html#typesnumeric\" rel=\"nofollow noreferrer\">Python 3</a></h3>\n<blockquote>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Operation</th>\n<th>Result</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>x / y</code></td>\n<td>quotient of <em>x</em> and <em>y</em></td>\n<td></td>\n</tr>\n<tr>\n<td><code>x // y</code></td>\n<td>floored quotient of <em>x</em> and <em>y</em></td>\n<td>(1)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Notes:</p>\n<ol>\n<li>Also referred to as integer division. The resultant value is a whole integer, though the result\u2019s type is not necessarily int. The result is always rounded towards minus infinity: <code>1//2</code> is <code>0</code>, <code>(-1)//2</code> is <code>-1</code>, <code>1//(-2)</code> is <code>-1</code>, and <code>(-1)//(-2)</code> is <code>0</code>.</li>\n</ol>\n</blockquote>\n<h3><a href=\"https://docs.python.org/2/library/stdtypes.html#typesnumeric\" rel=\"nofollow noreferrer\">Python 2</a></h3>\n<blockquote>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Operation</th>\n<th>Result</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>x / y</code></td>\n<td>quotient of <em>x</em> and <em>y</em></td>\n<td>(1)</td>\n</tr>\n<tr>\n<td><code>x // y</code></td>\n<td>(floored) quotient of <em>x</em> and <em>y</em></td>\n<td>(4)(5)</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Notes:</p>\n<p>1. For (plain or long) integer division, the result is an integer. The result is always rounded towards minus infinity: 1/2 is 0, (-1)/2 is -1, 1/(-2) is -1, and (-1)/(-2) is 0. Note that the result is a long integer if either operand is a long integer, regardless of the numeric value.</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>4. <em>Deprecated since version 2.3:</em> The floor division operator, the modulo operator, and the <a href=\"https://docs.python.org/2/library/functions.html#divmod\" rel=\"nofollow noreferrer\"><code>divmod()</code></a> function are no longer defined for complex numbers. Instead, convert to a floating point number using the <a href=\"https://docs.python.org/2/library/functions.html#abs\" rel=\"nofollow noreferrer\"><code>abs()</code></a> function if appropriate.</th>\n</tr>\n</thead>\n</table>\n</div>\n<p>5. Also referred to as integer division. The resultant value is a whole integer, though the result\u2019s type is not necessarily int.</p>\n</blockquote>\n", "abstract": "Notes: Notes: 1. For (plain or long) integer division, the result is an integer. The result is always rounded towards minus infinity: 1/2 is 0, (-1)/2 is -1, 1/(-2) is -1, and (-1)/(-2) is 0. Note that the result is a long integer if either operand is a long integer, regardless of the numeric value. 5. Also referred to as integer division. The resultant value is a whole integer, though the result\u2019s type is not necessarily int."}, {"id": 53234075, "score": -1, "vote": 0, "content": "<p><code>5.0//2</code> results in <code>2.0</code>, and not <code>2</code>, because the <strong>return type</strong> of the return value from <code>//</code> operator follows Python coercion (type casting) rules.</p>\n<p>Python promotes conversion of lower data type (integer) to higher data type (float) to avoid data loss.</p>\n", "abstract": "5.0//2 results in 2.0, and not 2, because the return type of the return value from // operator follows Python coercion (type casting) rules. Python promotes conversion of lower data type (integer) to higher data type (float) to avoid data loss."}]}, {"link": "https://stackoverflow.com/questions/100210/what-is-the-standard-way-to-add-n-seconds-to-datetime-time-in-python", "question": {"id": "100210", "title": "What is the standard way to add N seconds to datetime.time in Python?", "content": "<p>Given a <code>datetime.time</code> value in Python, is there a standard way to add an integer number of seconds to it, so that <code>11:34:59</code> + 3 = <code>11:35:02</code>, for example?</p>\n<p>These obvious ideas don't work:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; datetime.time(11, 34, 59) + 3\nTypeError: unsupported operand type(s) for +: 'datetime.time' and 'int'\n&gt;&gt;&gt; datetime.time(11, 34, 59) + datetime.timedelta(0, 3)\nTypeError: unsupported operand type(s) for +: 'datetime.time' and 'datetime.timedelta'\n&gt;&gt;&gt; datetime.time(11, 34, 59) + datetime.time(0, 0, 3)\nTypeError: unsupported operand type(s) for +: 'datetime.time' and 'datetime.time'\n</code></pre>\n<p>In the end I have written functions like this:</p>\n<pre><code class=\"python\">def add_secs_to_time(timeval, secs_to_add):\n    secs = timeval.hour * 3600 + timeval.minute * 60 + timeval.second\n    secs += secs_to_add\n    return datetime.time(secs // 3600, (secs % 3600) // 60, secs % 60)\n</code></pre>\n<p>I can't help thinking that I'm missing an easier way to do this though.</p>\n<h3>Related</h3>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/656297/python-time-timedelta-equivalent\">python time + timedelta equivalent</a></li>\n</ul>\n", "abstract": "Given a datetime.time value in Python, is there a standard way to add an integer number of seconds to it, so that 11:34:59 + 3 = 11:35:02, for example? These obvious ideas don't work: In the end I have written functions like this: I can't help thinking that I'm missing an easier way to do this though."}, "answers": [{"id": 100345, "score": 652, "vote": 0, "content": "<p>You can use full <code>datetime</code> variables with <code>timedelta</code>, and by providing a dummy date then using <code>time</code> to just get the time value.</p>\n<p>For example:</p>\n<pre><code class=\"python\">import datetime\na = datetime.datetime(100,1,1,11,34,59)\nb = a + datetime.timedelta(0,3) # days, seconds, then other fields.\nprint(a.time())\nprint(b.time())\n</code></pre>\n<p>results in the two values, three seconds apart:</p>\n<pre><code class=\"python\">11:34:59\n11:35:02\n</code></pre>\n<p>You could also opt for the more readable</p>\n<pre><code class=\"python\">b = a + datetime.timedelta(seconds=3)\n</code></pre>\n<p>if you're so inclined.</p>\n<hr/>\n<p>If you're after a function that can do this, you can look into using <code>addSecs</code> below:</p>\n<pre><code class=\"python\">import datetime\n\ndef addSecs(tm, secs):\n    fulldate = datetime.datetime(100, 1, 1, tm.hour, tm.minute, tm.second)\n    fulldate = fulldate + datetime.timedelta(seconds=secs)\n    return fulldate.time()\n\na = datetime.datetime.now().time()\nb = addSecs(a, 300)\nprint(a)\nprint(b)\n</code></pre>\n<p>This outputs:</p>\n<pre><code class=\"python\"> 09:11:55.775695\n 09:16:55\n</code></pre>\n", "abstract": "You can use full datetime variables with timedelta, and by providing a dummy date then using time to just get the time value. For example: results in the two values, three seconds apart: You could also opt for the more readable if you're so inclined. If you're after a function that can do this, you can look into using addSecs below: This outputs:"}, {"id": 101947, "score": 69, "vote": 0, "content": "<p>As others here have stated, you can just use full datetime objects throughout:</p>\n<pre><code class=\"python\">from datetime import datetime, date, time, timedelta\nsometime = time(8,00) # 8am\nlater = (datetime.combine(date.today(), sometime) + timedelta(seconds=3)).time()\n</code></pre>\n<p>However, I think it's worth explaining why full datetime objects are required.  Consider what would happen if I added 2 hours to 11pm.  What's the correct behavior?  An exception, because you can't have a time larger than 11:59pm?  Should it wrap back around?</p>\n<p>Different programmers will expect different things, so whichever result they picked would surprise a lot of people.  Worse yet, programmers would write code that worked just fine when they tested it initially, and then have it break later by doing something unexpected.  This is very bad, which is why you're not allowed to add timedelta objects to time objects.</p>\n", "abstract": "As others here have stated, you can just use full datetime objects throughout: However, I think it's worth explaining why full datetime objects are required.  Consider what would happen if I added 2 hours to 11pm.  What's the correct behavior?  An exception, because you can't have a time larger than 11:59pm?  Should it wrap back around? Different programmers will expect different things, so whichever result they picked would surprise a lot of people.  Worse yet, programmers would write code that worked just fine when they tested it initially, and then have it break later by doing something unexpected.  This is very bad, which is why you're not allowed to add timedelta objects to time objects."}, {"id": 100404, "score": 29, "vote": 0, "content": "<p>One little thing, might add clarity to override the default value for seconds</p>\n<pre><code class=\"python\">&gt;&gt;&gt; b = a + datetime.timedelta(seconds=3000)\n&gt;&gt;&gt; b\ndatetime.datetime(1, 1, 1, 12, 24, 59)\n</code></pre>\n", "abstract": "One little thing, might add clarity to override the default value for seconds"}, {"id": 100776, "score": 12, "vote": 0, "content": "<p>Thanks to @Pax Diablo, @bvmou and @Arachnid for the suggestion of using full datetimes throughout.  If I have to accept datetime.time objects from an external source, then this seems to be an alternative <code>add_secs_to_time()</code> function:</p>\n<pre><code class=\"python\">def add_secs_to_time(timeval, secs_to_add):\n    dummy_date = datetime.date(1, 1, 1)\n    full_datetime = datetime.datetime.combine(dummy_date, timeval)\n    added_datetime = full_datetime + datetime.timedelta(seconds=secs_to_add)\n    return added_datetime.time()\n</code></pre>\n<p>This verbose code can be compressed to this one-liner:</p>\n<pre><code class=\"python\">(datetime.datetime.combine(datetime.date(1, 1, 1), timeval) + datetime.timedelta(seconds=secs_to_add)).time()\n</code></pre>\n<p>but I think I'd want to wrap that up in a function for code clarity anyway.</p>\n", "abstract": "Thanks to @Pax Diablo, @bvmou and @Arachnid for the suggestion of using full datetimes throughout.  If I have to accept datetime.time objects from an external source, then this seems to be an alternative add_secs_to_time() function: This verbose code can be compressed to this one-liner: but I think I'd want to wrap that up in a function for code clarity anyway."}, {"id": 48315879, "score": 11, "vote": 0, "content": "<p>You cannot simply add number to <code>datetime</code> because it's unclear what unit is used: seconds, hours, weeks...</p>\n<p>There is <code>timedelta</code> class for manipulations with date and time. <code>datetime</code> minus <code>datetime</code> gives <code>timedelta</code>, <code>datetime</code> plus <code>timedelta</code> gives <code>datetime</code>, two <code>datetime</code> objects cannot be added although two <code>timedelta</code> can.</p>\n<p>Create <code>timedelta</code> object with how many seconds you want to add and add it to <code>datetime</code> object:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from datetime import datetime, timedelta\n&gt;&gt;&gt; t = datetime.now() + timedelta(seconds=3000)\n&gt;&gt;&gt; print(t)\ndatetime.datetime(2018, 1, 17, 21, 47, 13, 90244)\n</code></pre>\n<p>There is same concept in C++: <code>std::chrono::duration</code>.</p>\n", "abstract": "You cannot simply add number to datetime because it's unclear what unit is used: seconds, hours, weeks... There is timedelta class for manipulations with date and time. datetime minus datetime gives timedelta, datetime plus timedelta gives datetime, two datetime objects cannot be added although two timedelta can. Create timedelta object with how many seconds you want to add and add it to datetime object: There is same concept in C++: std::chrono::duration."}, {"id": 6839259, "score": 9, "vote": 0, "content": "<p>If it's worth adding another file / dependency to your project, I've just written a tiny little class that extends <code>datetime.time</code> with the ability to do arithmetic.  When you go past midnight, it wraps around zero.  Now, \"What time will it be, 24 hours from now\" has a lot of corner cases, including daylight savings time, leap seconds, historical timezone changes, and so on.  But sometimes you really do need the simple case, and that's what this will do.</p>\n<p>Your example would be written:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import nptime\n&gt;&gt;&gt; nptime.nptime(11, 34, 59) + datetime.timedelta(0, 3)\nnptime(11, 35, 2)\n</code></pre>\n<p><code>nptime</code> inherits from <code>datetime.time</code>, so any of those methods should be usable, too.</p>\n<p>It's available from PyPi as <code>nptime</code> (\"non-pedantic time\"), or on GitHub: <a href=\"https://github.com/tgs/nptime\" rel=\"noreferrer\">https://github.com/tgs/nptime</a></p>\n", "abstract": "If it's worth adding another file / dependency to your project, I've just written a tiny little class that extends datetime.time with the ability to do arithmetic.  When you go past midnight, it wraps around zero.  Now, \"What time will it be, 24 hours from now\" has a lot of corner cases, including daylight savings time, leap seconds, historical timezone changes, and so on.  But sometimes you really do need the simple case, and that's what this will do. Your example would be written: nptime inherits from datetime.time, so any of those methods should be usable, too. It's available from PyPi as nptime (\"non-pedantic time\"), or on GitHub: https://github.com/tgs/nptime"}, {"id": 46653858, "score": 5, "vote": 0, "content": "<p>For completeness' sake, here's the way to do it with <a href=\"http://arrow.readthedocs.io/en/latest/\" rel=\"nofollow noreferrer\"><code>arrow</code></a> (better dates and times for Python):</p>\n<pre><code class=\"python\">sometime = arrow.now()\nabitlater = sometime.shift(seconds=3)\n</code></pre>\n", "abstract": "For completeness' sake, here's the way to do it with arrow (better dates and times for Python):"}, {"id": 65920435, "score": 2, "vote": 0, "content": "<p>In a real world environment it's never a good idea to work solely with <code>time</code>, always use <code>datetime</code>, even better <code>utc</code>, to avoid conflicts like overnight, daylight saving, different timezones between user and server etc.</p>\n<p>So I'd recommend this approach:</p>\n<pre><code class=\"python\">import datetime as dt\n\n_now = dt.datetime.now()  # or dt.datetime.now(dt.timezone.utc)\n_in_5_sec = _now + dt.timedelta(seconds=5)\n\n# get '14:39:57':\n_in_5_sec.strftime('%H:%M:%S')\n</code></pre>\n", "abstract": "In a real world environment it's never a good idea to work solely with time, always use datetime, even better utc, to avoid conflicts like overnight, daylight saving, different timezones between user and server etc. So I'd recommend this approach:"}, {"id": 100250, "score": 0, "vote": 0, "content": "<p>Try adding a <code>datetime.datetime</code> to a <code>datetime.timedelta</code>. If you only want the time portion, you can call the <code>time()</code> method on the resultant <code>datetime.datetime</code> object to get it.</p>\n", "abstract": "Try adding a datetime.datetime to a datetime.timedelta. If you only want the time portion, you can call the time() method on the resultant datetime.datetime object to get it."}, {"id": 57498235, "score": 0, "vote": 0, "content": "<p>Old question, but I figured I'd throw in a function that handles timezones. The key parts are passing the <code>datetime.time</code> object's <code>tzinfo</code> attribute into combine, and then using <code>timetz()</code> instead of <code>time()</code> on the resulting dummy datetime. This answer partly inspired by the other answers here.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def add_timedelta_to_time(t, td):\n    \"\"\"Add a timedelta object to a time object using a dummy datetime.\n\n    :param t: datetime.time object.\n    :param td: datetime.timedelta object.\n\n    :returns: datetime.time object, representing the result of t + td.\n\n    NOTE: Using a gigantic td may result in an overflow. You've been\n    warned.\n    \"\"\"\n    # Create a dummy date object.\n    dummy_date = date(year=100, month=1, day=1)\n\n    # Combine the dummy date with the given time.\n    dummy_datetime = datetime.combine(date=dummy_date, time=t, tzinfo=t.tzinfo)\n\n    # Add the timedelta to the dummy datetime.\n    new_datetime = dummy_datetime + td\n\n    # Return the resulting time, including timezone information.\n    return new_datetime.timetz()\n</code></pre>\n<p>And here's a really simple test case class (using built-in <code>unittest</code>):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import unittest\nfrom datetime import datetime, timezone, timedelta, time\n\nclass AddTimedeltaToTimeTestCase(unittest.TestCase):\n    \"\"\"Test add_timedelta_to_time.\"\"\"\n\n    def test_wraps(self):\n        t = time(hour=23, minute=59)\n        td = timedelta(minutes=2)\n        t_expected = time(hour=0, minute=1)\n        t_actual = add_timedelta_to_time(t=t, td=td)\n        self.assertEqual(t_expected, t_actual)\n\n    def test_tz(self):\n        t = time(hour=4, minute=16, tzinfo=timezone.utc)\n        td = timedelta(hours=10, minutes=4)\n        t_expected = time(hour=14, minute=20, tzinfo=timezone.utc)\n        t_actual = add_timedelta_to_time(t=t, td=td)\n        self.assertEqual(t_expected, t_actual)\n\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre>\n", "abstract": "Old question, but I figured I'd throw in a function that handles timezones. The key parts are passing the datetime.time object's tzinfo attribute into combine, and then using timetz() instead of time() on the resulting dummy datetime. This answer partly inspired by the other answers here. And here's a really simple test case class (using built-in unittest):"}, {"id": 71674257, "score": 0, "vote": 0, "content": "<p>If you don't already have a timedelta object, another possibility would be to just initialize a new time object instead with the attributes of the old one and add values where needed:</p>\n<pre><code class=\"python\">   new_time:time = time(\n       hour=curr_time.hour + n_hours,\n       minute=curr_time.minute + n_minutes,\n       seconds=curr_time.second + n_seconds\n    )\n</code></pre>\n<p>Admittedly this only works if you make a few assumptions about your values, since overflow is not handled here. But I just thought it was worth to keep this in mind\nas it can save a line or two</p>\n", "abstract": "If you don't already have a timedelta object, another possibility would be to just initialize a new time object instead with the attributes of the old one and add values where needed: Admittedly this only works if you make a few assumptions about your values, since overflow is not handled here. But I just thought it was worth to keep this in mind\nas it can save a line or two"}]}, {"link": "https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n", "question": {"id": "2068372", "title": "Fastest way to list all primes below N", "content": "<p>This is the best algorithm I could come up.</p>\n<pre><code class=\"python\">def get_primes(n):\n    numbers = set(range(n, 1, -1))\n    primes = []\n    while numbers:\n        p = numbers.pop()\n        primes.append(p)\n        numbers.difference_update(set(range(p*2, n+1, p)))\n    return primes\n\n&gt;&gt;&gt; timeit.Timer(stmt='get_primes.get_primes(1000000)', setup='import   get_primes').timeit(1)\n1.1499958793645562\n</code></pre>\n<p>Can it be made even faster?</p>\n<p>This code has a flaw: Since <code>numbers</code> is an unordered set, there is no guarantee that <code>numbers.pop()</code> will remove the lowest number from the set. Nevertheless, it works (at least for me) for some input numbers:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; sum(get_primes(2000000))\n142913828922L\n#That's the correct sum of all numbers below 2 million\n&gt;&gt;&gt; 529 in get_primes(1000)\nFalse\n&gt;&gt;&gt; 529 in get_primes(530)\nTrue\n</code></pre>\n", "abstract": "This is the best algorithm I could come up. Can it be made even faster? This code has a flaw: Since numbers is an unordered set, there is no guarantee that numbers.pop() will remove the lowest number from the set. Nevertheless, it works (at least for me) for some input numbers:"}, "answers": [{"id": 2068548, "score": 409, "vote": 0, "content": "<p><strong>Warning:</strong> <code>timeit</code> results may vary due to differences in hardware or\nversion of Python.  </p>\n<p>Below is a script which compares a number of implementations: \n<ul>\n<li>ambi_sieve_plain,\n<li><a href=\"https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\">rwh_primes</a>, \n<li><a href=\"https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\">rwh_primes1</a>, \n<li><a href=\"https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\">rwh_primes2</a>, \n<li><a href=\"https://web.archive.org/web/20080324064651/http://krenzel.info/?p=83\" rel=\"noreferrer\">sieveOfAtkin</a>, \n<li><a href=\"http://groups.google.com/group/comp.lang.python/msg/f1f10ced88c68c2d\" rel=\"noreferrer\">sieveOfEratosthenes</a>, \n<li><a href=\"https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/2073279#2073279\">sundaram3</a>,\n<li><a href=\"http://zerovolt.com/?p=88\" rel=\"noreferrer\">sieve_wheel_30</a>,\n<li><a href=\"http://tommih.blogspot.com/2009/04/fast-prime-number-generator.html\" rel=\"noreferrer\">ambi_sieve</a> (requires numpy)\n<li><a href=\"https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\">primesfrom3to</a> (requires numpy)\n<li><a href=\"https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\">primesfrom2to</a> (requires numpy)\n</li></li></li></li></li></li></li></li></li></li></li></ul></p>\n<p>Many thanks to <a href=\"https://stackoverflow.com/users/92092/stephan\">stephan</a> for bringing sieve_wheel_30 to my attention.\nCredit goes to <a href=\"https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\">Robert William Hanks</a> for primesfrom2to, primesfrom3to, rwh_primes, rwh_primes1, and rwh_primes2.</p>\n<p>Of the plain Python methods tested, <strong>with psyco</strong>, for n=1000000,\n<strong>rwh_primes1</strong> was the fastest tested.</p>\n<pre><code class=\"python\">+---------------------+-------+\n| Method              | ms    |\n+---------------------+-------+\n| rwh_primes1         | 43.0  |\n| sieveOfAtkin        | 46.4  |\n| rwh_primes          | 57.4  |\n| sieve_wheel_30      | 63.0  |\n| rwh_primes2         | 67.8  |    \n| sieveOfEratosthenes | 147.0 |\n| ambi_sieve_plain    | 152.0 |\n| sundaram3           | 194.0 |\n+---------------------+-------+\n</code></pre>\n<p>Of the plain Python methods tested, <strong>without psyco</strong>, for n=1000000,\n<strong>rwh_primes2</strong> was the fastest.</p>\n<pre><code class=\"python\">+---------------------+-------+\n| Method              | ms    |\n+---------------------+-------+\n| rwh_primes2         | 68.1  |\n| rwh_primes1         | 93.7  |\n| rwh_primes          | 94.6  |\n| sieve_wheel_30      | 97.4  |\n| sieveOfEratosthenes | 178.0 |\n| ambi_sieve_plain    | 286.0 |\n| sieveOfAtkin        | 314.0 |\n| sundaram3           | 416.0 |\n+---------------------+-------+\n</code></pre>\n<p>Of all the methods tested, <em>allowing numpy</em>, for n=1000000,\n<strong>primesfrom2to</strong> was the fastest tested.</p>\n<pre><code class=\"python\">+---------------------+-------+\n| Method              | ms    |\n+---------------------+-------+\n| primesfrom2to       | 15.9  |\n| primesfrom3to       | 18.4  |\n| ambi_sieve          | 29.3  |\n+---------------------+-------+\n</code></pre>\n<p>Timings were measured using the command:</p>\n<pre><code class=\"python\">python -mtimeit -s\"import primes\" \"primes.{method}(1000000)\"\n</code></pre>\n<p>with <code>{method}</code> replaced by each of the method names.</p>\n<p>primes.py:</p>\n<pre><code class=\"python\">#!/usr/bin/env python\nimport psyco; psyco.full()\nfrom math import sqrt, ceil\nimport numpy as np\n\ndef rwh_primes(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * n\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)\n    return [2] + [i for i in xrange(3,n,2) if sieve[i]]\n\ndef rwh_primes1(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * (n/2)\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i/2]:\n            sieve[i*i/2::i] = [False] * ((n-i*i-1)/(2*i)+1)\n    return [2] + [2*i+1 for i in xrange(1,n/2) if sieve[i]]\n\ndef rwh_primes2(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Input n&gt;=6, Returns a list of primes, 2 &lt;= p &lt; n \"\"\"\n    correction = (n%6&gt;1)\n    n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6]\n    sieve = [True] * (n/3)\n    sieve[0] = False\n    for i in xrange(int(n**0.5)/3+1):\n      if sieve[i]:\n        k=3*i+1|1\n        sieve[      ((k*k)/3)      ::2*k]=[False]*((n/6-(k*k)/6-1)/k+1)\n        sieve[(k*k+4*k-2*k*(i&amp;1))/3::2*k]=[False]*((n/6-(k*k+4*k-2*k*(i&amp;1))/6-1)/k+1)\n    return [2,3] + [3*i+1|1 for i in xrange(1,n/3-correction) if sieve[i]]\n\ndef sieve_wheel_30(N):\n    # http://zerovolt.com/?p=88\n    ''' Returns a list of primes &lt;= N using wheel criterion 2*3*5 = 30\n\nCopyright 2009 by zerovolt.com\nThis code is free for non-commercial purposes, in which case you can just leave this comment as a credit for my work.\nIf you need this code for commercial purposes, please contact me by sending an email to: info [at] zerovolt [dot] com.'''\n    __smallp = ( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\n    61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,\n    149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\n    229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,\n    313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,\n    409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,\n    499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\n    601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683,\n    691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\n    809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\n    907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997)\n\n    wheel = (2, 3, 5)\n    const = 30\n    if N &lt; 2:\n        return []\n    if N &lt;= const:\n        pos = 0\n        while __smallp[pos] &lt;= N:\n            pos += 1\n        return list(__smallp[:pos])\n    # make the offsets list\n    offsets = (7, 11, 13, 17, 19, 23, 29, 1)\n    # prepare the list\n    p = [2, 3, 5]\n    dim = 2 + N // const\n    tk1  = [True] * dim\n    tk7  = [True] * dim\n    tk11 = [True] * dim\n    tk13 = [True] * dim\n    tk17 = [True] * dim\n    tk19 = [True] * dim\n    tk23 = [True] * dim\n    tk29 = [True] * dim\n    tk1[0] = False\n    # help dictionary d\n    # d[a , b] = c  ==&gt; if I want to find the smallest useful multiple of (30*pos)+a\n    # on tkc, then I need the index given by the product of [(30*pos)+a][(30*pos)+b]\n    # in general. If b &lt; a, I need [(30*pos)+a][(30*(pos+1))+b]\n    d = {}\n    for x in offsets:\n        for y in offsets:\n            res = (x*y) % const\n            if res in offsets:\n                d[(x, res)] = y\n    # another help dictionary: gives tkx calling tmptk[x]\n    tmptk = {1:tk1, 7:tk7, 11:tk11, 13:tk13, 17:tk17, 19:tk19, 23:tk23, 29:tk29}\n    pos, prime, lastadded, stop = 0, 0, 0, int(ceil(sqrt(N)))\n    # inner functions definition\n    def del_mult(tk, start, step):\n        for k in xrange(start, len(tk), step):\n            tk[k] = False\n    # end of inner functions definition\n    cpos = const * pos\n    while prime &lt; stop:\n        # 30k + 7\n        if tk7[pos]:\n            prime = cpos + 7\n            p.append(prime)\n            lastadded = 7\n            for off in offsets:\n                tmp = d[(7, off)]\n                start = (pos + prime) if off == 7 else (prime * (const * (pos + 1 if tmp &lt; 7 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 11\n        if tk11[pos]:\n            prime = cpos + 11\n            p.append(prime)\n            lastadded = 11\n            for off in offsets:\n                tmp = d[(11, off)]\n                start = (pos + prime) if off == 11 else (prime * (const * (pos + 1 if tmp &lt; 11 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 13\n        if tk13[pos]:\n            prime = cpos + 13\n            p.append(prime)\n            lastadded = 13\n            for off in offsets:\n                tmp = d[(13, off)]\n                start = (pos + prime) if off == 13 else (prime * (const * (pos + 1 if tmp &lt; 13 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 17\n        if tk17[pos]:\n            prime = cpos + 17\n            p.append(prime)\n            lastadded = 17\n            for off in offsets:\n                tmp = d[(17, off)]\n                start = (pos + prime) if off == 17 else (prime * (const * (pos + 1 if tmp &lt; 17 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 19\n        if tk19[pos]:\n            prime = cpos + 19\n            p.append(prime)\n            lastadded = 19\n            for off in offsets:\n                tmp = d[(19, off)]\n                start = (pos + prime) if off == 19 else (prime * (const * (pos + 1 if tmp &lt; 19 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 23\n        if tk23[pos]:\n            prime = cpos + 23\n            p.append(prime)\n            lastadded = 23\n            for off in offsets:\n                tmp = d[(23, off)]\n                start = (pos + prime) if off == 23 else (prime * (const * (pos + 1 if tmp &lt; 23 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 29\n        if tk29[pos]:\n            prime = cpos + 29\n            p.append(prime)\n            lastadded = 29\n            for off in offsets:\n                tmp = d[(29, off)]\n                start = (pos + prime) if off == 29 else (prime * (const * (pos + 1 if tmp &lt; 29 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # now we go back to top tk1, so we need to increase pos by 1\n        pos += 1\n        cpos = const * pos\n        # 30k + 1\n        if tk1[pos]:\n            prime = cpos + 1\n            p.append(prime)\n            lastadded = 1\n            for off in offsets:\n                tmp = d[(1, off)]\n                start = (pos + prime) if off == 1 else (prime * (const * pos + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n    # time to add remaining primes\n    # if lastadded == 1, remove last element and start adding them from tk1\n    # this way we don't need an \"if\" within the last while\n    if lastadded == 1:\n        p.pop()\n    # now complete for every other possible prime\n    while pos &lt; len(tk1):\n        cpos = const * pos\n        if tk1[pos]: p.append(cpos + 1)\n        if tk7[pos]: p.append(cpos + 7)\n        if tk11[pos]: p.append(cpos + 11)\n        if tk13[pos]: p.append(cpos + 13)\n        if tk17[pos]: p.append(cpos + 17)\n        if tk19[pos]: p.append(cpos + 19)\n        if tk23[pos]: p.append(cpos + 23)\n        if tk29[pos]: p.append(cpos + 29)\n        pos += 1\n    # remove exceeding if present\n    pos = len(p) - 1\n    while p[pos] &gt; N:\n        pos -= 1\n    if pos &lt; len(p) - 1:\n        del p[pos+1:]\n    # return p list\n    return p\n\ndef sieveOfEratosthenes(n):\n    \"\"\"sieveOfEratosthenes(n): return the list of the primes &lt; n.\"\"\"\n    # Code from: &lt;dickinsm@gmail.com&gt;, Nov 30 2006\n    # http://groups.google.com/group/comp.lang.python/msg/f1f10ced88c68c2d\n    if n &lt;= 2:\n        return []\n    sieve = range(3, n, 2)\n    top = len(sieve)\n    for si in sieve:\n        if si:\n            bottom = (si*si - 3) // 2\n            if bottom &gt;= top:\n                break\n            sieve[bottom::si] = [0] * -((bottom - top) // si)\n    return [2] + [el for el in sieve if el]\n\ndef sieveOfAtkin(end):\n    \"\"\"sieveOfAtkin(end): return a list of all the prime numbers &lt;end\n    using the Sieve of Atkin.\"\"\"\n    # Code by Steve Krenzel, &lt;Sgk284@gmail.com&gt;, improved\n    # Code: https://web.archive.org/web/20080324064651/http://krenzel.info/?p=83\n    # Info: http://en.wikipedia.org/wiki/Sieve_of_Atkin\n    assert end &gt; 0\n    lng = ((end-1) // 2)\n    sieve = [False] * (lng + 1)\n\n    x_max, x2, xd = int(sqrt((end-1)/4.0)), 0, 4\n    for xd in xrange(4, 8*x_max + 2, 8):\n        x2 += xd\n        y_max = int(sqrt(end-x2))\n        n, n_diff = x2 + y_max*y_max, (y_max &lt;&lt; 1) - 1\n        if not (n &amp; 1):\n            n -= n_diff\n            n_diff -= 2\n        for d in xrange((n_diff - 1) &lt;&lt; 1, -1, -8):\n            m = n % 12\n            if m == 1 or m == 5:\n                m = n &gt;&gt; 1\n                sieve[m] = not sieve[m]\n            n -= d\n\n    x_max, x2, xd = int(sqrt((end-1) / 3.0)), 0, 3\n    for xd in xrange(3, 6 * x_max + 2, 6):\n        x2 += xd\n        y_max = int(sqrt(end-x2))\n        n, n_diff = x2 + y_max*y_max, (y_max &lt;&lt; 1) - 1\n        if not(n &amp; 1):\n            n -= n_diff\n            n_diff -= 2\n        for d in xrange((n_diff - 1) &lt;&lt; 1, -1, -8):\n            if n % 12 == 7:\n                m = n &gt;&gt; 1\n                sieve[m] = not sieve[m]\n            n -= d\n\n    x_max, y_min, x2, xd = int((2 + sqrt(4-8*(1-end)))/4), -1, 0, 3\n    for x in xrange(1, x_max + 1):\n        x2 += xd\n        xd += 6\n        if x2 &gt;= end: y_min = (((int(ceil(sqrt(x2 - end))) - 1) &lt;&lt; 1) - 2) &lt;&lt; 1\n        n, n_diff = ((x*x + x) &lt;&lt; 1) - 1, (((x-1) &lt;&lt; 1) - 2) &lt;&lt; 1\n        for d in xrange(n_diff, y_min, -8):\n            if n % 12 == 11:\n                m = n &gt;&gt; 1\n                sieve[m] = not sieve[m]\n            n += d\n\n    primes = [2, 3]\n    if end &lt;= 3:\n        return primes[:max(0,end-2)]\n\n    for n in xrange(5 &gt;&gt; 1, (int(sqrt(end))+1) &gt;&gt; 1):\n        if sieve[n]:\n            primes.append((n &lt;&lt; 1) + 1)\n            aux = (n &lt;&lt; 1) + 1\n            aux *= aux\n            for k in xrange(aux, end, 2 * aux):\n                sieve[k &gt;&gt; 1] = False\n\n    s  = int(sqrt(end)) + 1\n    if s  % 2 == 0:\n        s += 1\n    primes.extend([i for i in xrange(s, end, 2) if sieve[i &gt;&gt; 1]])\n\n    return primes\n\ndef ambi_sieve_plain(n):\n    s = range(3, n, 2)\n    for m in xrange(3, int(n**0.5)+1, 2): \n        if s[(m-3)/2]: \n            for t in xrange((m*m-3)/2,(n&gt;&gt;1)-1,m):\n                s[t]=0\n    return [2]+[t for t in s if t&gt;0]\n\ndef sundaram3(max_n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/2073279#2073279\n    numbers = range(3, max_n+1, 2)\n    half = (max_n)//2\n    initial = 4\n\n    for step in xrange(3, max_n+1, 2):\n        for i in xrange(initial, half, step):\n            numbers[i-1] = 0\n        initial += 2*(step+1)\n\n        if initial &gt; half:\n            return [2] + filter(None, numbers)\n\n################################################################################\n# Using Numpy:\ndef ambi_sieve(n):\n    # http://tommih.blogspot.com/2009/04/fast-prime-number-generator.html\n    s = np.arange(3, n, 2)\n    for m in xrange(3, int(n ** 0.5)+1, 2): \n        if s[(m-3)/2]: \n            s[(m*m-3)/2::m]=0\n    return np.r_[2, s[s&gt;0]]\n\ndef primesfrom3to(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Returns a array of primes, p &lt; n \"\"\"\n    assert n&gt;=2\n    sieve = np.ones(n/2, dtype=np.bool)\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i/2]:\n            sieve[i*i/2::i] = False\n    return np.r_[2, 2*np.nonzero(sieve)[0][1::]+1]    \n\ndef primesfrom2to(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Input n&gt;=6, Returns a array of primes, 2 &lt;= p &lt; n \"\"\"\n    sieve = np.ones(n/3 + (n%6==2), dtype=np.bool)\n    sieve[0] = False\n    for i in xrange(int(n**0.5)/3+1):\n        if sieve[i]:\n            k=3*i+1|1\n            sieve[      ((k*k)/3)      ::2*k] = False\n            sieve[(k*k+4*k-2*k*(i&amp;1))/3::2*k] = False\n    return np.r_[2,3,((3*np.nonzero(sieve)[0]+1)|1)]\n\nif __name__=='__main__':\n    import itertools\n    import sys\n\n    def test(f1,f2,num):\n        print('Testing {f1} and {f2} return same results'.format(\n            f1=f1.func_name,\n            f2=f2.func_name))\n        if not all([a==b for a,b in itertools.izip_longest(f1(num),f2(num))]):\n            sys.exit(\"Error: %s(%s) != %s(%s)\"%(f1.func_name,num,f2.func_name,num))\n\n    n=1000000\n    test(sieveOfAtkin,sieveOfEratosthenes,n)\n    test(sieveOfAtkin,ambi_sieve,n)\n    test(sieveOfAtkin,ambi_sieve_plain,n) \n    test(sieveOfAtkin,sundaram3,n)\n    test(sieveOfAtkin,sieve_wheel_30,n)\n    test(sieveOfAtkin,primesfrom3to,n)\n    test(sieveOfAtkin,primesfrom2to,n)\n    test(sieveOfAtkin,rwh_primes,n)\n    test(sieveOfAtkin,rwh_primes1,n)         \n    test(sieveOfAtkin,rwh_primes2,n)\n</code></pre>\n<p>Running the script tests that all implementations give the same result.</p>\n", "abstract": "Warning: timeit results may vary due to differences in hardware or\nversion of Python.   Below is a script which compares a number of implementations: \n\nambi_sieve_plain,\nrwh_primes, \nrwh_primes1, \nrwh_primes2, \nsieveOfAtkin, \nsieveOfEratosthenes, \nsundaram3,\nsieve_wheel_30,\nambi_sieve (requires numpy)\nprimesfrom3to (requires numpy)\nprimesfrom2to (requires numpy)\n Many thanks to stephan for bringing sieve_wheel_30 to my attention.\nCredit goes to Robert William Hanks for primesfrom2to, primesfrom3to, rwh_primes, rwh_primes1, and rwh_primes2. Of the plain Python methods tested, with psyco, for n=1000000,\nrwh_primes1 was the fastest tested. Of the plain Python methods tested, without psyco, for n=1000000,\nrwh_primes2 was the fastest. Of all the methods tested, allowing numpy, for n=1000000,\nprimesfrom2to was the fastest tested. Timings were measured using the command: with {method} replaced by each of the method names. primes.py: Running the script tests that all implementations give the same result."}, {"id": 3035188, "score": 155, "vote": 0, "content": "<p>Faster &amp; more memory-wise pure Python code:</p>\n<pre><code class=\"python\">def primes(n):\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * n\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)//(2*i)+1)\n    return [2] + [i for i in range(3,n,2) if sieve[i]]\n</code></pre>\n<p>or starting with half sieve</p>\n<pre><code class=\"python\">def primes1(n):\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * (n//2)\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i//2]:\n            sieve[i*i//2::i] = [False] * ((n-i*i-1)//(2*i)+1)\n    return [2] + [2*i+1 for i in range(1,n//2) if sieve[i]]\n</code></pre>\n<p>Faster &amp; more memory-wise numpy code:</p>\n<pre><code class=\"python\">import numpy\ndef primesfrom3to(n):\n    \"\"\" Returns a array of primes, 3 &lt;= p &lt; n \"\"\"\n    sieve = numpy.ones(n//2, dtype=bool)\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i//2]:\n            sieve[i*i//2::i] = False\n    return 2*numpy.nonzero(sieve)[0][1::]+1\n</code></pre>\n<p>a faster variation starting with a third of a sieve:</p>\n<pre><code class=\"python\">import numpy\ndef primesfrom2to(n):\n    \"\"\" Input n&gt;=6, Returns a array of primes, 2 &lt;= p &lt; n \"\"\"\n    sieve = numpy.ones(n//3 + (n%6==2), dtype=bool)\n    for i in range(1,int(n**0.5)//3+1):\n        if sieve[i]:\n            k=3*i+1|1\n            sieve[       k*k//3     ::2*k] = False\n            sieve[k*(k-2*(i&amp;1)+4)//3::2*k] = False\n    return numpy.r_[2,3,((3*numpy.nonzero(sieve)[0][1:]+1)|1)]\n</code></pre>\n<p>A (hard-to-code) pure-python version of the above code would be:</p>\n<pre><code class=\"python\">def primes2(n):\n    \"\"\" Input n&gt;=6, Returns a list of primes, 2 &lt;= p &lt; n \"\"\"\n    n, correction = n-n%6+6, 2-(n%6&gt;1)\n    sieve = [True] * (n//3)\n    for i in range(1,int(n**0.5)//3+1):\n      if sieve[i]:\n        k=3*i+1|1\n        sieve[      k*k//3      ::2*k] = [False] * ((n//6-k*k//6-1)//k+1)\n        sieve[k*(k-2*(i&amp;1)+4)//3::2*k] = [False] * ((n//6-k*(k-2*(i&amp;1)+4)//6-1)//k+1)\n    return [2,3] + [3*i+1|1 for i in range(1,n//3-correction) if sieve[i]]\n</code></pre>\n<p>Unfortunately pure-python don't adopt the simpler and faster numpy way of doing assignment, and calling <code>len()</code> inside the loop as in <code>[False]*len(sieve[((k*k)//3)::2*k])</code> is too slow. So I had to improvise to correct input (&amp; avoid more math) and do some extreme (&amp; painful) math-magic.</p>\n<p>Personally I think it is a shame that numpy (which is so widely used) is not part of Python standard library, and that the improvements in syntax and speed seem to be completely overlooked by Python developers.</p>\n", "abstract": "Faster & more memory-wise pure Python code: or starting with half sieve Faster & more memory-wise numpy code: a faster variation starting with a third of a sieve: A (hard-to-code) pure-python version of the above code would be: Unfortunately pure-python don't adopt the simpler and faster numpy way of doing assignment, and calling len() inside the loop as in [False]*len(sieve[((k*k)//3)::2*k]) is too slow. So I had to improvise to correct input (& avoid more math) and do some extreme (& painful) math-magic. Personally I think it is a shame that numpy (which is so widely used) is not part of Python standard library, and that the improvements in syntax and speed seem to be completely overlooked by Python developers."}, {"id": 2068412, "score": 42, "vote": 0, "content": "<p>There's a pretty neat sample from the Python Cookbook <a href=\"http://oreilly.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=last\" rel=\"noreferrer\">here</a> -- the fastest version proposed on that URL is:</p>\n<pre><code class=\"python\">import itertools\ndef erat2( ):\n    D = {  }\n    yield 2\n    for q in itertools.islice(itertools.count(3), 0, None, 2):\n        p = D.pop(q, None)\n        if p is None:\n            D[q*q] = q\n            yield q\n        else:\n            x = p + q\n            while x in D or not (x&amp;1):\n                x += p\n            D[x] = p\n</code></pre>\n<p>so that would give</p>\n<pre><code class=\"python\">def get_primes_erat(n):\n  return list(itertools.takewhile(lambda p: p&lt;n, erat2()))\n</code></pre>\n<p>Measuring at the shell prompt (as I prefer to do) with this code in pri.py, I observe:</p>\n<pre><code class=\"python\">$ python2.5 -mtimeit -s'import pri' 'pri.get_primes(1000000)'\n10 loops, best of 3: 1.69 sec per loop\n$ python2.5 -mtimeit -s'import pri' 'pri.get_primes_erat(1000000)'\n10 loops, best of 3: 673 msec per loop\n</code></pre>\n<p>so it looks like the Cookbook solution is over twice as fast.</p>\n", "abstract": "There's a pretty neat sample from the Python Cookbook here -- the fastest version proposed on that URL is: so that would give Measuring at the shell prompt (as I prefer to do) with this code in pri.py, I observe: so it looks like the Cookbook solution is over twice as fast."}, {"id": 2073279, "score": 28, "vote": 0, "content": "<p>Using <a href=\"http://plus.maths.org/issue50/features/havil/index.html\" rel=\"noreferrer\">Sundaram's Sieve</a>, I think I broke pure-Python's record:</p>\n<pre><code class=\"python\">def sundaram3(max_n):\n    numbers = range(3, max_n+1, 2)\n    half = (max_n)//2\n    initial = 4\n\n    for step in xrange(3, max_n+1, 2):\n        for i in xrange(initial, half, step):\n            numbers[i-1] = 0\n        initial += 2*(step+1)\n\n        if initial &gt; half:\n            return [2] + filter(None, numbers)\n</code></pre>\n<p>Comparasion:</p>\n<pre><code class=\"python\">C:\\USERS&gt;python -m timeit -n10 -s \"import get_primes\" \"get_primes.get_primes_erat(1000000)\"\n10 loops, best of 3: 710 msec per loop\n\nC:\\USERS&gt;python -m timeit -n10 -s \"import get_primes\" \"get_primes.daniel_sieve_2(1000000)\"\n10 loops, best of 3: 435 msec per loop\n\nC:\\USERS&gt;python -m timeit -n10 -s \"import get_primes\" \"get_primes.sundaram3(1000000)\"\n10 loops, best of 3: 327 msec per loop\n</code></pre>\n", "abstract": "Using Sundaram's Sieve, I think I broke pure-Python's record: Comparasion:"}, {"id": 2068522, "score": 20, "vote": 0, "content": "<p>The algorithm is fast, but it has a serious flaw:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; sorted(get_primes(530))\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\n79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163,\n167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251,\n257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349,\n353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443,\n449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 527, 529]\n&gt;&gt;&gt; 17*31\n527\n&gt;&gt;&gt; 23*23\n529\n</code></pre>\n<p>You assume that <code>numbers.pop()</code> would return the smallest number in the set, but this is not guaranteed at all. Sets are unordered and <code>pop()</code> removes and returns an <a href=\"http://docs.python.org/library/stdtypes.html#set.pop\" rel=\"noreferrer\"><strong>arbitrary</strong></a> element, so it cannot be used to select the next prime from the remaining numbers.</p>\n", "abstract": "The algorithm is fast, but it has a serious flaw: You assume that numbers.pop() would return the smallest number in the set, but this is not guaranteed at all. Sets are unordered and pop() removes and returns an arbitrary element, so it cannot be used to select the next prime from the remaining numbers."}, {"id": 2070175, "score": 18, "vote": 0, "content": "<p>For <strong>truly</strong> fastest solution with sufficiently large N would be to download a <a href=\"http://primes.utm.edu/lists/small/millions/\" rel=\"noreferrer\">pre-calculated list of primes</a>, store it as a tuple and do something like:</p>\n<pre><code class=\"python\">for pos,i in enumerate(primes):\n    if i &gt; N:\n        print primes[:pos]\n</code></pre>\n<p>If <code>N &gt; primes[-1]</code> <em>only</em> then calculate more primes and save the new list in your code, so next time it is equally as fast.</p>\n<p><em>Always think outside the box.</em></p>\n", "abstract": "For truly fastest solution with sufficiently large N would be to download a pre-calculated list of primes, store it as a tuple and do something like: If N > primes[-1] only then calculate more primes and save the new list in your code, so next time it is equally as fast. Always think outside the box."}, {"id": 31221522, "score": 13, "vote": 0, "content": "<p>If you don't want to reinvent the wheel, you can install the symbolic maths library <a href=\"http://www.sympy.org/en/index.html\" rel=\"noreferrer\">sympy</a> (yes it's Python 3 compatible)</p>\n<pre><code class=\"python\">pip install sympy\n</code></pre>\n<p>And use the <a href=\"http://docs.sympy.org/dev/modules/ntheory.html#sympy.ntheory.generate.Sieve.primerange\" rel=\"noreferrer\">primerange</a> function</p>\n<pre><code class=\"python\">from sympy import sieve\nprimes = list(sieve.primerange(1, 10**6))\n</code></pre>\n", "abstract": "If you don't want to reinvent the wheel, you can install the symbolic maths library sympy (yes it's Python 3 compatible) And use the primerange function"}, {"id": 33356284, "score": 11, "vote": 0, "content": "<p>If you accept itertools but not numpy, here is an adaptation of rwh_primes2 for Python 3 that runs about twice as fast on my machine.  The only substantial change is using a bytearray instead of a list for the boolean, and using compress instead of a list comprehension to build the final list.  (I'd add this as a comment like moarningsun if I were able.)</p>\n<pre><code class=\"python\">import itertools\nizip = itertools.zip_longest\nchain = itertools.chain.from_iterable\ncompress = itertools.compress\ndef rwh_primes2_python3(n):\n    \"\"\" Input n&gt;=6, Returns a list of primes, 2 &lt;= p &lt; n \"\"\"\n    zero = bytearray([False])\n    size = n//3 + (n % 6 == 2)\n    sieve = bytearray([True]) * size\n    sieve[0] = False\n    for i in range(int(n**0.5)//3+1):\n      if sieve[i]:\n        k=3*i+1|1\n        start = (k*k+4*k-2*k*(i&amp;1))//3\n        sieve[(k*k)//3::2*k]=zero*((size - (k*k)//3 - 1) // (2 * k) + 1)\n        sieve[  start ::2*k]=zero*((size -   start  - 1) // (2 * k) + 1)\n    ans = [2,3]\n    poss = chain(izip(*[range(i, n, 6) for i in (1,5)]))\n    ans.extend(compress(poss, sieve))\n    return ans\n</code></pre>\n<p>Comparisons:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; timeit.timeit('primes.rwh_primes2(10**6)', setup='import primes', number=1)\n0.0652179726976101\n&gt;&gt;&gt; timeit.timeit('primes.rwh_primes2_python3(10**6)', setup='import primes', number=1)\n0.03267321276325674\n</code></pre>\n<p>and</p>\n<pre><code class=\"python\">&gt;&gt;&gt; timeit.timeit('primes.rwh_primes2(10**8)', setup='import primes', number=1)\n6.394284538007014\n&gt;&gt;&gt; timeit.timeit('primes.rwh_primes2_python3(10**8)', setup='import primes', number=1)\n3.833829450302801\n</code></pre>\n", "abstract": "If you accept itertools but not numpy, here is an adaptation of rwh_primes2 for Python 3 that runs about twice as fast on my machine.  The only substantial change is using a bytearray instead of a list for the boolean, and using compress instead of a list comprehension to build the final list.  (I'd add this as a comment like moarningsun if I were able.) Comparisons: and"}, {"id": 31322423, "score": 9, "vote": 0, "content": "<p>It's instructive to write your own prime finding code, but it's also useful to have a fast reliable library at hand. I wrote a wrapper around the <a href=\"http://primesieve.org/\" rel=\"noreferrer\">C++ library primesieve</a>, named it <a href=\"https://github.com/hickford/primesieve-python\" rel=\"noreferrer\">primesieve-python</a></p>\n<p>Try it <code>pip install primesieve</code></p>\n<pre><code class=\"python\">import primesieve\nprimes = primesieve.generate_primes(10**8)\n</code></pre>\n<p>I'd be curious to see the speed compared.</p>\n", "abstract": "It's instructive to write your own prime finding code, but it's also useful to have a fast reliable library at hand. I wrote a wrapper around the C++ library primesieve, named it primesieve-python Try it pip install primesieve I'd be curious to see the speed compared."}, {"id": 46635266, "score": 8, "vote": 0, "content": "<p>Here is two updated (pure Python 3.6) versions of one of the fastest functions,</p>\n<pre><code class=\"python\">from itertools import compress\n\ndef rwh_primes1v1(n):\n    \"\"\" Returns  a list of primes &lt; n for n &gt; 2 \"\"\"\n    sieve = bytearray([True]) * (n//2)\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i//2]:\n            sieve[i*i//2::i] = bytearray((n-i*i-1)//(2*i)+1)\n    return [2,*compress(range(3,n,2), sieve[1:])]\n\ndef rwh_primes1v2(n):\n    \"\"\" Returns a list of primes &lt; n for n &gt; 2 \"\"\"\n    sieve = bytearray([True]) * (n//2+1)\n    for i in range(1,int(n**0.5)//2+1):\n        if sieve[i]:\n            sieve[2*i*(i+1)::2*i+1] = bytearray((n//2-2*i*(i+1))//(2*i+1)+1)\n    return [2,*compress(range(3,n,2), sieve[1:])]\n</code></pre>\n", "abstract": "Here is two updated (pure Python 3.6) versions of one of the fastest functions,"}, {"id": 58983866, "score": 7, "vote": 0, "content": "<p>I've updated much of the code for Python 3 and threw it at <a href=\"https://github.com/nschloe/perfplot\" rel=\"nofollow noreferrer\">perfplot</a> (a project of mine) to see which is actually fastest. Turns out that, for large <code>n</code>, <code>primesfrom{2,3}to</code> takes the cake:</p>\n<p><a href=\"https://i.stack.imgur.com/kaA9s.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/kaA9s.png\"/></a></p>\n<hr/>\n<p>Code to reproduce the plot:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import perfplot\nfrom math import sqrt, ceil\nimport numpy as np\nimport sympy\n\n\ndef rwh_primes(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * n\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if sieve[i]:\n            sieve[i * i::2 * i] = [False] * ((n - i * i - 1) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n, 2) if sieve[i]]\n\n\ndef rwh_primes1(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * (n // 2)\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if sieve[i // 2]:\n            sieve[i * i // 2::i] = [False] * ((n - i * i - 1) // (2 * i) + 1)\n    return [2] + [2 * i + 1 for i in range(1, n // 2) if sieve[i]]\n\n\ndef rwh_primes2(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\"Input n&gt;=6, Returns a list of primes, 2 &lt;= p &lt; n\"\"\"\n    assert n &gt;= 6\n    correction = n % 6 &gt; 1\n    n = {0: n, 1: n - 1, 2: n + 4, 3: n + 3, 4: n + 2, 5: n + 1}[n % 6]\n    sieve = [True] * (n // 3)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[((k * k) // 3)::2 * k] = [False] * (\n                (n // 6 - (k * k) // 6 - 1) // k + 1\n            )\n            sieve[(k * k + 4 * k - 2 * k * (i &amp; 1)) // 3::2 * k] = [False] * (\n                (n // 6 - (k * k + 4 * k - 2 * k * (i &amp; 1)) // 6 - 1) // k + 1\n            )\n    return [2, 3] + [3 * i + 1 | 1 for i in range(1, n // 3 - correction) if sieve[i]]\n\n\ndef sieve_wheel_30(N):\n    # http://zerovolt.com/?p=88\n    \"\"\" Returns a list of primes &lt;= N using wheel criterion 2*3*5 = 30\n\nCopyright 2009 by zerovolt.com\nThis code is free for non-commercial purposes, in which case you can just leave this comment as a credit for my work.\nIf you need this code for commercial purposes, please contact me by sending an email to: info [at] zerovolt [dot] com.\"\"\"\n    __smallp = (\n        2,\n        3,\n        5,\n        7,\n        11,\n        13,\n        17,\n        19,\n        23,\n        29,\n        31,\n        37,\n        41,\n        43,\n        47,\n        53,\n        59,\n        61,\n        67,\n        71,\n        73,\n        79,\n        83,\n        89,\n        97,\n        101,\n        103,\n        107,\n        109,\n        113,\n        127,\n        131,\n        137,\n        139,\n        149,\n        151,\n        157,\n        163,\n        167,\n        173,\n        179,\n        181,\n        191,\n        193,\n        197,\n        199,\n        211,\n        223,\n        227,\n        229,\n        233,\n        239,\n        241,\n        251,\n        257,\n        263,\n        269,\n        271,\n        277,\n        281,\n        283,\n        293,\n        307,\n        311,\n        313,\n        317,\n        331,\n        337,\n        347,\n        349,\n        353,\n        359,\n        367,\n        373,\n        379,\n        383,\n        389,\n        397,\n        401,\n        409,\n        419,\n        421,\n        431,\n        433,\n        439,\n        443,\n        449,\n        457,\n        461,\n        463,\n        467,\n        479,\n        487,\n        491,\n        499,\n        503,\n        509,\n        521,\n        523,\n        541,\n        547,\n        557,\n        563,\n        569,\n        571,\n        577,\n        587,\n        593,\n        599,\n        601,\n        607,\n        613,\n        617,\n        619,\n        631,\n        641,\n        643,\n        647,\n        653,\n        659,\n        661,\n        673,\n        677,\n        683,\n        691,\n        701,\n        709,\n        719,\n        727,\n        733,\n        739,\n        743,\n        751,\n        757,\n        761,\n        769,\n        773,\n        787,\n        797,\n        809,\n        811,\n        821,\n        823,\n        827,\n        829,\n        839,\n        853,\n        857,\n        859,\n        863,\n        877,\n        881,\n        883,\n        887,\n        907,\n        911,\n        919,\n        929,\n        937,\n        941,\n        947,\n        953,\n        967,\n        971,\n        977,\n        983,\n        991,\n        997,\n    )\n    # wheel = (2, 3, 5)\n    const = 30\n    if N &lt; 2:\n        return []\n    if N &lt;= const:\n        pos = 0\n        while __smallp[pos] &lt;= N:\n            pos += 1\n        return list(__smallp[:pos])\n    # make the offsets list\n    offsets = (7, 11, 13, 17, 19, 23, 29, 1)\n    # prepare the list\n    p = [2, 3, 5]\n    dim = 2 + N // const\n    tk1 = [True] * dim\n    tk7 = [True] * dim\n    tk11 = [True] * dim\n    tk13 = [True] * dim\n    tk17 = [True] * dim\n    tk19 = [True] * dim\n    tk23 = [True] * dim\n    tk29 = [True] * dim\n    tk1[0] = False\n    # help dictionary d\n    # d[a , b] = c  ==&gt; if I want to find the smallest useful multiple of (30*pos)+a\n    # on tkc, then I need the index given by the product of [(30*pos)+a][(30*pos)+b]\n    # in general. If b &lt; a, I need [(30*pos)+a][(30*(pos+1))+b]\n    d = {}\n    for x in offsets:\n        for y in offsets:\n            res = (x * y) % const\n            if res in offsets:\n                d[(x, res)] = y\n    # another help dictionary: gives tkx calling tmptk[x]\n    tmptk = {1: tk1, 7: tk7, 11: tk11, 13: tk13, 17: tk17, 19: tk19, 23: tk23, 29: tk29}\n    pos, prime, lastadded, stop = 0, 0, 0, int(ceil(sqrt(N)))\n\n    # inner functions definition\n    def del_mult(tk, start, step):\n        for k in range(start, len(tk), step):\n            tk[k] = False\n\n    # end of inner functions definition\n    cpos = const * pos\n    while prime &lt; stop:\n        # 30k + 7\n        if tk7[pos]:\n            prime = cpos + 7\n            p.append(prime)\n            lastadded = 7\n            for off in offsets:\n                tmp = d[(7, off)]\n                start = (\n                    (pos + prime)\n                    if off == 7\n                    else (prime * (const * (pos + 1 if tmp &lt; 7 else 0) + tmp)) // const\n                )\n                del_mult(tmptk[off], start, prime)\n        # 30k + 11\n        if tk11[pos]:\n            prime = cpos + 11\n            p.append(prime)\n            lastadded = 11\n            for off in offsets:\n                tmp = d[(11, off)]\n                start = (\n                    (pos + prime)\n                    if off == 11\n                    else (prime * (const * (pos + 1 if tmp &lt; 11 else 0) + tmp)) // const\n                )\n                del_mult(tmptk[off], start, prime)\n        # 30k + 13\n        if tk13[pos]:\n            prime = cpos + 13\n            p.append(prime)\n            lastadded = 13\n            for off in offsets:\n                tmp = d[(13, off)]\n                start = (\n                    (pos + prime)\n                    if off == 13\n                    else (prime * (const * (pos + 1 if tmp &lt; 13 else 0) + tmp)) // const\n                )\n                del_mult(tmptk[off], start, prime)\n        # 30k + 17\n        if tk17[pos]:\n            prime = cpos + 17\n            p.append(prime)\n            lastadded = 17\n            for off in offsets:\n                tmp = d[(17, off)]\n                start = (\n                    (pos + prime)\n                    if off == 17\n                    else (prime * (const * (pos + 1 if tmp &lt; 17 else 0) + tmp)) // const\n                )\n                del_mult(tmptk[off], start, prime)\n        # 30k + 19\n        if tk19[pos]:\n            prime = cpos + 19\n            p.append(prime)\n            lastadded = 19\n            for off in offsets:\n                tmp = d[(19, off)]\n                start = (\n                    (pos + prime)\n                    if off == 19\n                    else (prime * (const * (pos + 1 if tmp &lt; 19 else 0) + tmp)) // const\n                )\n                del_mult(tmptk[off], start, prime)\n        # 30k + 23\n        if tk23[pos]:\n            prime = cpos + 23\n            p.append(prime)\n            lastadded = 23\n            for off in offsets:\n                tmp = d[(23, off)]\n                start = (\n                    (pos + prime)\n                    if off == 23\n                    else (prime * (const * (pos + 1 if tmp &lt; 23 else 0) + tmp)) // const\n                )\n                del_mult(tmptk[off], start, prime)\n        # 30k + 29\n        if tk29[pos]:\n            prime = cpos + 29\n            p.append(prime)\n            lastadded = 29\n            for off in offsets:\n                tmp = d[(29, off)]\n                start = (\n                    (pos + prime)\n                    if off == 29\n                    else (prime * (const * (pos + 1 if tmp &lt; 29 else 0) + tmp)) // const\n                )\n                del_mult(tmptk[off], start, prime)\n        # now we go back to top tk1, so we need to increase pos by 1\n        pos += 1\n        cpos = const * pos\n        # 30k + 1\n        if tk1[pos]:\n            prime = cpos + 1\n            p.append(prime)\n            lastadded = 1\n            for off in offsets:\n                tmp = d[(1, off)]\n                start = (\n                    (pos + prime)\n                    if off == 1\n                    else (prime * (const * pos + tmp)) // const\n                )\n                del_mult(tmptk[off], start, prime)\n    # time to add remaining primes\n    # if lastadded == 1, remove last element and start adding them from tk1\n    # this way we don't need an \"if\" within the last while\n    if lastadded == 1:\n        p.pop()\n    # now complete for every other possible prime\n    while pos &lt; len(tk1):\n        cpos = const * pos\n        if tk1[pos]:\n            p.append(cpos + 1)\n        if tk7[pos]:\n            p.append(cpos + 7)\n        if tk11[pos]:\n            p.append(cpos + 11)\n        if tk13[pos]:\n            p.append(cpos + 13)\n        if tk17[pos]:\n            p.append(cpos + 17)\n        if tk19[pos]:\n            p.append(cpos + 19)\n        if tk23[pos]:\n            p.append(cpos + 23)\n        if tk29[pos]:\n            p.append(cpos + 29)\n        pos += 1\n    # remove exceeding if present\n    pos = len(p) - 1\n    while p[pos] &gt; N:\n        pos -= 1\n    if pos &lt; len(p) - 1:\n        del p[pos + 1 :]\n    # return p list\n    return p\n\n\ndef sieve_of_eratosthenes(n):\n    \"\"\"sieveOfEratosthenes(n): return the list of the primes &lt; n.\"\"\"\n    # Code from: &lt;dickinsm@gmail.com&gt;, Nov 30 2006\n    # http://groups.google.com/group/comp.lang.python/msg/f1f10ced88c68c2d\n    if n &lt;= 2:\n        return []\n    sieve = list(range(3, n, 2))\n    top = len(sieve)\n    for si in sieve:\n        if si:\n            bottom = (si * si - 3) // 2\n            if bottom &gt;= top:\n                break\n            sieve[bottom::si] = [0] * -((bottom - top) // si)\n    return [2] + [el for el in sieve if el]\n\n\ndef sieve_of_atkin(end):\n    \"\"\"return a list of all the prime numbers &lt;end using the Sieve of Atkin.\"\"\"\n    # Code by Steve Krenzel, &lt;Sgk284@gmail.com&gt;, improved\n    # Code: https://web.archive.org/web/20080324064651/http://krenzel.info/?p=83\n    # Info: http://en.wikipedia.org/wiki/Sieve_of_Atkin\n    assert end &gt; 0\n    lng = (end - 1) // 2\n    sieve = [False] * (lng + 1)\n\n    x_max, x2, xd = int(sqrt((end - 1) / 4.0)), 0, 4\n    for xd in range(4, 8 * x_max + 2, 8):\n        x2 += xd\n        y_max = int(sqrt(end - x2))\n        n, n_diff = x2 + y_max * y_max, (y_max &lt;&lt; 1) - 1\n        if not (n &amp; 1):\n            n -= n_diff\n            n_diff -= 2\n        for d in range((n_diff - 1) &lt;&lt; 1, -1, -8):\n            m = n % 12\n            if m == 1 or m == 5:\n                m = n &gt;&gt; 1\n                sieve[m] = not sieve[m]\n            n -= d\n\n    x_max, x2, xd = int(sqrt((end - 1) / 3.0)), 0, 3\n    for xd in range(3, 6 * x_max + 2, 6):\n        x2 += xd\n        y_max = int(sqrt(end - x2))\n        n, n_diff = x2 + y_max * y_max, (y_max &lt;&lt; 1) - 1\n        if not (n &amp; 1):\n            n -= n_diff\n            n_diff -= 2\n        for d in range((n_diff - 1) &lt;&lt; 1, -1, -8):\n            if n % 12 == 7:\n                m = n &gt;&gt; 1\n                sieve[m] = not sieve[m]\n            n -= d\n\n    x_max, y_min, x2, xd = int((2 + sqrt(4 - 8 * (1 - end))) / 4), -1, 0, 3\n    for x in range(1, x_max + 1):\n        x2 += xd\n        xd += 6\n        if x2 &gt;= end:\n            y_min = (((int(ceil(sqrt(x2 - end))) - 1) &lt;&lt; 1) - 2) &lt;&lt; 1\n        n, n_diff = ((x * x + x) &lt;&lt; 1) - 1, (((x - 1) &lt;&lt; 1) - 2) &lt;&lt; 1\n        for d in range(n_diff, y_min, -8):\n            if n % 12 == 11:\n                m = n &gt;&gt; 1\n                sieve[m] = not sieve[m]\n            n += d\n\n    primes = [2, 3]\n    if end &lt;= 3:\n        return primes[: max(0, end - 2)]\n\n    for n in range(5 &gt;&gt; 1, (int(sqrt(end)) + 1) &gt;&gt; 1):\n        if sieve[n]:\n            primes.append((n &lt;&lt; 1) + 1)\n            aux = (n &lt;&lt; 1) + 1\n            aux *= aux\n            for k in range(aux, end, 2 * aux):\n                sieve[k &gt;&gt; 1] = False\n\n    s = int(sqrt(end)) + 1\n    if s % 2 == 0:\n        s += 1\n    primes.extend([i for i in range(s, end, 2) if sieve[i &gt;&gt; 1]])\n\n    return primes\n\n\ndef ambi_sieve_plain(n):\n    s = list(range(3, n, 2))\n    for m in range(3, int(n ** 0.5) + 1, 2):\n        if s[(m - 3) // 2]:\n            for t in range((m * m - 3) // 2, (n &gt;&gt; 1) - 1, m):\n                s[t] = 0\n    return [2] + [t for t in s if t &gt; 0]\n\n\ndef sundaram3(max_n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/2073279#2073279\n    numbers = range(3, max_n + 1, 2)\n    half = (max_n) // 2\n    initial = 4\n\n    for step in range(3, max_n + 1, 2):\n        for i in range(initial, half, step):\n            numbers[i - 1] = 0\n        initial += 2 * (step + 1)\n\n        if initial &gt; half:\n            return [2] + filter(None, numbers)\n\n\n# Using Numpy:\ndef ambi_sieve(n):\n    # http://tommih.blogspot.com/2009/04/fast-prime-number-generator.html\n    s = np.arange(3, n, 2)\n    for m in range(3, int(n ** 0.5) + 1, 2):\n        if s[(m - 3) // 2]:\n            s[(m * m - 3) // 2::m] = 0\n    return np.r_[2, s[s &gt; 0]]\n\n\ndef primesfrom3to(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Returns an array of primes, p &lt; n \"\"\"\n    assert n &gt;= 2\n    sieve = np.ones(n // 2, dtype=bool)\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if sieve[i // 2]:\n            sieve[i * i // 2::i] = False\n    return np.r_[2, 2 * np.nonzero(sieve)[0][1::] + 1]\n\n\ndef primesfrom2to(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Input n&gt;=6, Returns an array of primes, 2 &lt;= p &lt; n \"\"\"\n    assert n &gt;= 6\n    sieve = np.ones(n // 3 + (n % 6 == 2), dtype=bool)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[((k * k) // 3)::2 * k] = False\n            sieve[(k * k + 4 * k - 2 * k * (i &amp; 1)) // 3::2 * k] = False\n    return np.r_[2, 3, ((3 * np.nonzero(sieve)[0] + 1) | 1)]\n\n\ndef sympy_sieve(n):\n    return list(sympy.sieve.primerange(1, n))\n\n\nb = perfplot.bench(\n    setup=lambda n: n,\n    kernels=[\n        rwh_primes,\n        rwh_primes1,\n        rwh_primes2,\n        sieve_wheel_30,\n        sieve_of_eratosthenes,\n        sieve_of_atkin,\n        # ambi_sieve_plain,\n        # sundaram3,\n        ambi_sieve,\n        primesfrom3to,\n        primesfrom2to,\n        sympy_sieve,\n    ],\n    n_range=[2 ** k for k in range(3, 25)],\n    xlabel=\"n\",\n)\nb.save(\"out.png\")\nb.show()\n</code></pre>\n", "abstract": "I've updated much of the code for Python 3 and threw it at perfplot (a project of mine) to see which is actually fastest. Turns out that, for large n, primesfrom{2,3}to takes the cake:  Code to reproduce the plot:"}, {"id": 2106069, "score": 4, "vote": 0, "content": "<p>A deterministic implementation of Miller-Rabin's Primality test on the assumption that N &lt; 9,080,191</p>\n<pre><code class=\"python\">import sys\n\ndef miller_rabin_pass(a, n):\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d &gt;&gt;= 1\n        s += 1\n\n    a_to_power = pow(a, d, n)\n    if a_to_power == 1:\n        return True\n    for i in range(s-1):\n        if a_to_power == n - 1:\n            return True\n        a_to_power = (a_to_power * a_to_power) % n\n    return a_to_power == n - 1\n\n\ndef miller_rabin(n):\n    if n &lt;= 2:\n        return n == 2\n\n    if n &lt; 2_047:\n        return miller_rabin_pass(2, n)\n\n    return all(miller_rabin_pass(a, n) for a in (31, 73))\n\n\nn = int(sys.argv[1])\nprimes = [2]\nfor p in range(3,n,2):\n  if miller_rabin(p):\n    primes.append(p)\nprint len(primes)\n</code></pre>\n<p>According to the article on Wikipedia (<a href=\"http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/Miller\u2013Rabin_primality_test</a>) testing N &lt; 9,080,191 for a = 37 and 73 is enough to decide whether N is composite or not.</p>\n<p>And I adapted the source code from the probabilistic implementation of original Miller-Rabin's test found here: <a href=\"https://www.literateprograms.org/miller-rabin_primality_test__python_.html\" rel=\"nofollow noreferrer\">https://www.literateprograms.org/miller-rabin_primality_test__python_.html</a></p>\n", "abstract": "A deterministic implementation of Miller-Rabin's Primality test on the assumption that N < 9,080,191 According to the article on Wikipedia (http://en.wikipedia.org/wiki/Miller\u2013Rabin_primality_test) testing N < 9,080,191 for a = 37 and 73 is enough to decide whether N is composite or not. And I adapted the source code from the probabilistic implementation of original Miller-Rabin's test found here: https://www.literateprograms.org/miller-rabin_primality_test__python_.html"}, {"id": 2106085, "score": 4, "vote": 0, "content": "<p>If you have control over N, the very fastest way to list all primes is to precompute them. Seriously. Precomputing is a way overlooked optimization.</p>\n", "abstract": "If you have control over N, the very fastest way to list all primes is to precompute them. Seriously. Precomputing is a way overlooked optimization."}, {"id": 2110724, "score": 4, "vote": 0, "content": "<p>Here's the code I normally use to generate primes in Python:</p>\n<pre><code class=\"python\">$ python -mtimeit -s'import sieve' 'sieve.sieve(1000000)' \n10 loops, best of 3: 445 msec per loop\n$ cat sieve.py\nfrom math import sqrt\n\ndef sieve(size):\n prime=[True]*size\n rng=xrange\n limit=int(sqrt(size))\n\n for i in rng(3,limit+1,+2):\n  if prime[i]:\n   prime[i*i::+i]=[False]*len(prime[i*i::+i])\n\n return [2]+[i for i in rng(3,size,+2) if prime[i]]\n\nif __name__=='__main__':\n print sieve(100)\n</code></pre>\n<p>It can't compete with the faster solutions posted here, but at least it is pure python.</p>\n<p>Thanks for posting this question. I really learnt a lot today. </p>\n", "abstract": "Here's the code I normally use to generate primes in Python: It can't compete with the faster solutions posted here, but at least it is pure python. Thanks for posting this question. I really learnt a lot today. "}, {"id": 3638617, "score": 4, "vote": 0, "content": "<p>A slightly different implementation of a half sieve using Numpy:</p>\n<p><a href=\"http://rebrained.com/?p=458\" rel=\"nofollow noreferrer\">http://rebrained.com/?p=458</a></p>\n<pre>\nimport math\nimport numpy\ndef prime6(upto):\n    primes=numpy.arange(3,upto+1,2)\n    isprime=numpy.ones((upto-1)/2,dtype=bool)\n    for factor in primes[:int(math.sqrt(upto))]:\n        if isprime[(factor-2)/2]: isprime[(factor*3-2)/2:(upto-1)/2:factor]=0\n    return numpy.insert(primes[isprime],0,2)\n</pre>\n<p>Can someone compare this with the other timings?  On my machine it seems pretty comparable to the other Numpy half-sieve.</p>\n", "abstract": "A slightly different implementation of a half sieve using Numpy: http://rebrained.com/?p=458 Can someone compare this with the other timings?  On my machine it seems pretty comparable to the other Numpy half-sieve."}, {"id": 39879618, "score": 4, "vote": 0, "content": "<p>It's all written and tested. So there is no need to reinvent the wheel.</p>\n<pre><code class=\"python\">python -m timeit -r10 -s\"from sympy import sieve\" \"primes = list(sieve.primerange(1, 10**6))\"\n</code></pre>\n<p>gives us a record breaking <strong>12.2 msec</strong>!</p>\n<pre><code class=\"python\">10 loops, best of 10: 12.2 msec per loop\n</code></pre>\n<p>If this is not fast enough, you can try PyPy:</p>\n<pre><code class=\"python\">pypy -m timeit -r10 -s\"from sympy import sieve\" \"primes = list(sieve.primerange(1, 10**6))\"\n</code></pre>\n<p>which results in:</p>\n<pre><code class=\"python\">10 loops, best of 10: 2.03 msec per loop\n</code></pre>\n<p>The answer with 247 up-votes lists 15.9 ms for the best solution.\nCompare this!!!</p>\n", "abstract": "It's all written and tested. So there is no need to reinvent the wheel. gives us a record breaking 12.2 msec! If this is not fast enough, you can try PyPy: which results in: The answer with 247 up-votes lists 15.9 ms for the best solution.\nCompare this!!!"}, {"id": 56284894, "score": 4, "vote": 0, "content": "<p><strong>Fastest prime sieve in <em>Pure Python</em></strong>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from itertools import compress\n\ndef half_sieve(n):\n    \"\"\"\n    Returns a list of prime numbers less than `n`.\n    \"\"\"\n    if n &lt;= 2:\n        return []\n    sieve = bytearray([True]) * (n // 2)\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if sieve[i // 2]:\n            sieve[i * i // 2::i] = bytearray((n - i * i - 1) // (2 * i) + 1)\n    primes = list(compress(range(1, n, 2), sieve))\n    primes[0] = 2\n    return primes\n</code></pre>\n<p>I optimised <em>Sieve of Eratosthenes</em> for speed and memory. <br/></p>\n<h1>Benchmark</h1>\n<pre><code class=\"python\">from time import clock\nimport platform\n\ndef benchmark(iterations, limit):\n    start = clock()\n    for x in range(iterations):\n        half_sieve(limit)\n    end = clock() - start\n    print(f'{end/iterations:.4f} seconds for primes &lt; {limit}')\n\nif __name__ == '__main__':\n    print(platform.python_version())\n    print(platform.platform())\n    print(platform.processor())\n    it = 10\n    for pw in range(4, 9):\n        benchmark(it, 10**pw)\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; 3.6.7\n&gt;&gt;&gt; Windows-10-10.0.17763-SP0\n&gt;&gt;&gt; Intel64 Family 6 Model 78 Stepping 3, GenuineIntel\n&gt;&gt;&gt; 0.0003 seconds for primes &lt; 10000\n&gt;&gt;&gt; 0.0021 seconds for primes &lt; 100000\n&gt;&gt;&gt; 0.0204 seconds for primes &lt; 1000000\n&gt;&gt;&gt; 0.2389 seconds for primes &lt; 10000000\n&gt;&gt;&gt; 2.6702 seconds for primes &lt; 100000000\n</code></pre>\n", "abstract": "Fastest prime sieve in Pure Python: I optimised Sieve of Eratosthenes for speed and memory.  Output"}, {"id": 2070107, "score": 3, "vote": 0, "content": "<p>For the fastest code, the numpy solution is the best. For purely academic reasons, though, I'm posting my pure python version, which is a bit less than 50% faster than the cookbook version posted above. Since I make the entire list in memory, you need enough space to hold everything, but it seems to scale fairly well.</p>\n<pre><code class=\"python\">def daniel_sieve_2(maxNumber):\n    \"\"\"\n    Given a number, returns all numbers less than or equal to\n    that number which are prime.\n    \"\"\"\n    allNumbers = range(3, maxNumber+1, 2)\n    for mIndex, number in enumerate(xrange(3, maxNumber+1, 2)):\n        if allNumbers[mIndex] == 0:\n            continue\n        # now set all multiples to 0\n        for index in xrange(mIndex+number, (maxNumber-3)/2+1, number):\n            allNumbers[index] = 0\n    return [2] + filter(lambda n: n!=0, allNumbers)\n</code></pre>\n<p>And the results:</p>\n<pre><code class=\"python\">&gt;&gt;&gt;mine = timeit.Timer(\"daniel_sieve_2(1000000)\",\n...                    \"from sieves import daniel_sieve_2\")\n&gt;&gt;&gt;prev = timeit.Timer(\"get_primes_erat(1000000)\",\n...                    \"from sieves import get_primes_erat\")\n&gt;&gt;&gt;print \"Mine: {0:0.4f} ms\".format(min(mine.repeat(3, 1))*1000)\nMine: 428.9446 ms\n&gt;&gt;&gt;print \"Previous Best {0:0.4f} ms\".format(min(prev.repeat(3, 1))*1000)\nPrevious Best 621.3581 ms\n</code></pre>\n", "abstract": "For the fastest code, the numpy solution is the best. For purely academic reasons, though, I'm posting my pure python version, which is a bit less than 50% faster than the cookbook version posted above. Since I make the entire list in memory, you need enough space to hold everything, but it seems to scale fairly well. And the results:"}, {"id": 18944432, "score": 3, "vote": 0, "content": "<p>I know the competition is closed for some years. \u2026</p>\n<p>Nonetheless this is my suggestion for a pure python prime sieve, based on omitting the multiples of 2, 3 and 5 by using appropriate steps while processing the sieve forward. Nonetheless it is actually slower for N&lt;10^9 than @Robert William Hanks superior solutions rwh_primes2 and rwh_primes1. By using a ctypes.c_ushort sieve array above 1.5* 10^8 it is somehow adaptive to memory limits.</p>\n<p>10^6</p>\n<p>$ python -mtimeit -s\"import primeSieveSpeedComp\" \"primeSieveSpeedComp.primeSieveSeq(1000000)\"\n10 loops, best of 3: 46.7 msec per loop</p>\n<blockquote>\n<p>to compare:$ python -mtimeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes1(1000000)\" 10 loops, best of 3: 43.2\n  msec per loop\n  to compare: $ python -m timeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes2(1000000)\" 10 loops, best of 3: 34.5\n  msec per loop</p>\n</blockquote>\n<p>10^7</p>\n<p>$ python -mtimeit -s\"import primeSieveSpeedComp\" \"primeSieveSpeedComp.primeSieveSeq(10000000)\"\n10 loops, best of 3: 530 msec per loop</p>\n<blockquote>\n<p>to compare:$ python -mtimeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes1(10000000)\" 10 loops, best of 3: 494\n  msec per loop\n  to compare: $ python -m timeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes2(10000000)\" 10 loops, best of 3: 375\n  msec per loop</p>\n</blockquote>\n<p>10^8</p>\n<p>$ python -mtimeit -s\"import primeSieveSpeedComp\" \"primeSieveSpeedComp.primeSieveSeq(100000000)\"\n10 loops, best of 3: 5.55 sec per loop</p>\n<blockquote>\n<p>to compare: $ python -mtimeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes1(100000000)\" 10 loops, best of 3: 5.33\n  sec per loop\n  to compare: $ python -m timeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes2(100000000)\" 10 loops, best of 3: 3.95\n  sec per loop</p>\n</blockquote>\n<p>10^9</p>\n<p>$ python -mtimeit -s\"import primeSieveSpeedComp\" \"primeSieveSpeedComp.primeSieveSeq(1000000000)\"\n10 loops, best of 3: <strong>61.2</strong> sec per loop</p>\n<blockquote>\n<p>to compare: $ python -mtimeit -n 3 -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes1(1000000000)\" 3 loops, best of 3: <strong>97.8</strong>\n  sec per loop</p>\n<p>to compare: $ python -m timeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes2(1000000000)\" 10 loops, best of 3:\n  41.9 sec per loop</p>\n</blockquote>\n<p>You may copy the code below into ubuntus primeSieveSpeedComp to review this tests.</p>\n<pre><code class=\"python\">def primeSieveSeq(MAX_Int):\n    if MAX_Int &gt; 5*10**8:\n        import ctypes\n        int16Array = ctypes.c_ushort * (MAX_Int &gt;&gt; 1)\n        sieve = int16Array()\n        #print 'uses ctypes \"unsigned short int Array\"'\n    else:\n        sieve = (MAX_Int &gt;&gt; 1) * [False]\n        #print 'uses python list() of long long int'\n    if MAX_Int &lt; 10**8:\n        sieve[4::3] = [True]*((MAX_Int - 8)/6+1)\n        sieve[12::5] = [True]*((MAX_Int - 24)/10+1)\n    r = [2, 3, 5]\n    n = 0\n    for i in xrange(int(MAX_Int**0.5)/30+1):\n        n += 3\n        if not sieve[n]:\n            n2 = (n &lt;&lt; 1) + 1\n            r.append(n2)\n            n2q = (n2**2) &gt;&gt; 1\n            sieve[n2q::n2] = [True]*(((MAX_Int &gt;&gt; 1) - n2q - 1) / n2 + 1)\n        n += 2\n        if not sieve[n]:\n            n2 = (n &lt;&lt; 1) + 1\n            r.append(n2)\n            n2q = (n2**2) &gt;&gt; 1\n            sieve[n2q::n2] = [True]*(((MAX_Int &gt;&gt; 1) - n2q - 1) / n2 + 1)\n        n += 1\n        if not sieve[n]:\n            n2 = (n &lt;&lt; 1) + 1\n            r.append(n2)\n            n2q = (n2**2) &gt;&gt; 1\n            sieve[n2q::n2] = [True]*(((MAX_Int &gt;&gt; 1) - n2q - 1) / n2 + 1)\n        n += 2\n        if not sieve[n]:\n            n2 = (n &lt;&lt; 1) + 1\n            r.append(n2)\n            n2q = (n2**2) &gt;&gt; 1\n            sieve[n2q::n2] = [True]*(((MAX_Int &gt;&gt; 1) - n2q - 1) / n2 + 1)\n        n += 1\n        if not sieve[n]:\n            n2 = (n &lt;&lt; 1) + 1\n            r.append(n2)\n            n2q = (n2**2) &gt;&gt; 1\n            sieve[n2q::n2] = [True]*(((MAX_Int &gt;&gt; 1) - n2q - 1) / n2 + 1)\n        n += 2\n        if not sieve[n]:\n            n2 = (n &lt;&lt; 1) + 1\n            r.append(n2)\n            n2q = (n2**2) &gt;&gt; 1\n            sieve[n2q::n2] = [True]*(((MAX_Int &gt;&gt; 1) - n2q - 1) / n2 + 1)\n        n += 3\n        if not sieve[n]:\n            n2 = (n &lt;&lt; 1) + 1\n            r.append(n2)\n            n2q = (n2**2) &gt;&gt; 1\n            sieve[n2q::n2] = [True]*(((MAX_Int &gt;&gt; 1) - n2q - 1) / n2 + 1)\n        n += 1\n        if not sieve[n]:\n            n2 = (n &lt;&lt; 1) + 1\n            r.append(n2)\n            n2q = (n2**2) &gt;&gt; 1\n            sieve[n2q::n2] = [True]*(((MAX_Int &gt;&gt; 1) - n2q - 1) / n2 + 1)\n    if MAX_Int &lt; 10**8:\n        return [2, 3, 5]+[(p &lt;&lt; 1) + 1 for p in [n for n in xrange(3, MAX_Int &gt;&gt; 1) if not sieve[n]]]\n    n = n &gt;&gt; 1\n    try:\n        for i in xrange((MAX_Int-2*n)/30 + 1):\n            n += 3\n            if not sieve[n]:\n                r.append((n &lt;&lt; 1) + 1)\n            n += 2\n            if not sieve[n]:\n                r.append((n &lt;&lt; 1) + 1)\n            n += 1\n            if not sieve[n]:\n                r.append((n &lt;&lt; 1) + 1)\n            n += 2\n            if not sieve[n]:\n                r.append((n &lt;&lt; 1) + 1)\n            n += 1\n            if not sieve[n]:\n                r.append((n &lt;&lt; 1) + 1)\n            n += 2\n            if not sieve[n]:\n                r.append((n &lt;&lt; 1) + 1)\n            n += 3\n            if not sieve[n]:\n                r.append((n &lt;&lt; 1) + 1)\n            n += 1\n            if not sieve[n]:\n                r.append((n &lt;&lt; 1) + 1)\n    except:\n        pass\n    return r\n</code></pre>\n", "abstract": "I know the competition is closed for some years. \u2026 Nonetheless this is my suggestion for a pure python prime sieve, based on omitting the multiples of 2, 3 and 5 by using appropriate steps while processing the sieve forward. Nonetheless it is actually slower for N<10^9 than @Robert William Hanks superior solutions rwh_primes2 and rwh_primes1. By using a ctypes.c_ushort sieve array above 1.5* 10^8 it is somehow adaptive to memory limits. 10^6 $ python -mtimeit -s\"import primeSieveSpeedComp\" \"primeSieveSpeedComp.primeSieveSeq(1000000)\"\n10 loops, best of 3: 46.7 msec per loop to compare:$ python -mtimeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes1(1000000)\" 10 loops, best of 3: 43.2\n  msec per loop\n  to compare: $ python -m timeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes2(1000000)\" 10 loops, best of 3: 34.5\n  msec per loop 10^7 $ python -mtimeit -s\"import primeSieveSpeedComp\" \"primeSieveSpeedComp.primeSieveSeq(10000000)\"\n10 loops, best of 3: 530 msec per loop to compare:$ python -mtimeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes1(10000000)\" 10 loops, best of 3: 494\n  msec per loop\n  to compare: $ python -m timeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes2(10000000)\" 10 loops, best of 3: 375\n  msec per loop 10^8 $ python -mtimeit -s\"import primeSieveSpeedComp\" \"primeSieveSpeedComp.primeSieveSeq(100000000)\"\n10 loops, best of 3: 5.55 sec per loop to compare: $ python -mtimeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes1(100000000)\" 10 loops, best of 3: 5.33\n  sec per loop\n  to compare: $ python -m timeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes2(100000000)\" 10 loops, best of 3: 3.95\n  sec per loop 10^9 $ python -mtimeit -s\"import primeSieveSpeedComp\" \"primeSieveSpeedComp.primeSieveSeq(1000000000)\"\n10 loops, best of 3: 61.2 sec per loop to compare: $ python -mtimeit -n 3 -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes1(1000000000)\" 3 loops, best of 3: 97.8\n  sec per loop to compare: $ python -m timeit -s\"import primeSieveSpeedComp\"\n  \"primeSieveSpeedComp.rwh_primes2(1000000000)\" 10 loops, best of 3:\n  41.9 sec per loop You may copy the code below into ubuntus primeSieveSpeedComp to review this tests."}, {"id": 40101683, "score": 3, "vote": 0, "content": "<p>I tested  some <a href=\"https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n?answertab=active#tab-top\">unutbu's functions</a>, i computed it with hungred millions number</p>\n<p>The winners are the functions that use numpy library, </p>\n<p><strong>Note</strong>: It would also interesting make a memory utilization test :)</p>\n<p><a href=\"https://i.stack.imgur.com/LYfjc.png\" rel=\"nofollow noreferrer\"><img alt=\"Computation time result\" src=\"https://i.stack.imgur.com/LYfjc.png\"/></a></p>\n<p><strong>Sample code</strong></p>\n<p><a href=\"https://github.com/badele/prime-number\" rel=\"nofollow noreferrer\">Complete code on my github repository</a></p>\n<pre><code class=\"python\">#!/usr/bin/env python\n\nimport lib\nimport timeit\nimport sys\nimport math\nimport datetime\n\nimport prettyplotlib as ppl\nimport numpy as np\n\nimport matplotlib.pyplot as plt\nfrom prettyplotlib import brewer2mpl\n\nprimenumbers_gen = [\n    'sieveOfEratosthenes',\n    'ambi_sieve',\n    'ambi_sieve_plain',\n    'sundaram3',\n    'sieve_wheel_30',\n    'primesfrom3to',\n    'primesfrom2to',\n    'rwh_primes',\n    'rwh_primes1',\n    'rwh_primes2',\n]\n\ndef human_format(num):\n    # https://stackoverflow.com/questions/579310/formatting-long-numbers-as-strings-in-python?answertab=active#tab-top\n    magnitude = 0\n    while abs(num) &gt;= 1000:\n        magnitude += 1\n        num /= 1000.0\n    # add more suffixes if you need them\n    return '%.2f%s' % (num, ['', 'K', 'M', 'G', 'T', 'P'][magnitude])\n\n\nif __name__=='__main__':\n\n    # Vars\n    n = 10000000 # number itereration generator\n    nbcol = 5 # For decompose prime number generator\n    nb_benchloop = 3 # Eliminate false positive value during the test (bench average time)\n    datetimeformat = '%Y-%m-%d %H:%M:%S.%f'\n    config = 'from __main__ import n; import lib'\n    primenumbers_gen = {\n        'sieveOfEratosthenes': {'color': 'b'},\n        'ambi_sieve': {'color': 'b'},\n        'ambi_sieve_plain': {'color': 'b'},\n         'sundaram3': {'color': 'b'},\n        'sieve_wheel_30': {'color': 'b'},\n# # #        'primesfrom2to': {'color': 'b'},\n        'primesfrom3to': {'color': 'b'},\n        # 'rwh_primes': {'color': 'b'},\n        # 'rwh_primes1': {'color': 'b'},\n        'rwh_primes2': {'color': 'b'},\n    }\n\n\n    # Get n in command line\n    if len(sys.argv)&gt;1:\n        n = int(sys.argv[1])\n\n    step = int(math.ceil(n / float(nbcol)))\n    nbs = np.array([i * step for i in range(1, int(nbcol) + 1)])\n    set2 = brewer2mpl.get_map('Paired', 'qualitative', 12).mpl_colors\n\n    print datetime.datetime.now().strftime(datetimeformat)\n    print(\"Compute prime number to %(n)s\" % locals())\n    print(\"\")\n\n    results = dict()\n    for pgen in primenumbers_gen:\n        results[pgen] = dict()\n        benchtimes = list()\n        for n in nbs:\n            t = timeit.Timer(\"lib.%(pgen)s(n)\" % locals(), setup=config)\n            execute_times = t.repeat(repeat=nb_benchloop,number=1)\n            benchtime = np.mean(execute_times)\n            benchtimes.append(benchtime)\n        results[pgen] = {'benchtimes':np.array(benchtimes)}\n\nfig, ax = plt.subplots(1)\nplt.ylabel('Computation time (in second)')\nplt.xlabel('Numbers computed')\ni = 0\nfor pgen in primenumbers_gen:\n\n    bench = results[pgen]['benchtimes']\n    avgs = np.divide(bench,nbs)\n    avg = np.average(bench, weights=nbs)\n\n    # Compute linear regression\n    A = np.vstack([nbs, np.ones(len(nbs))]).T\n    a, b = np.linalg.lstsq(A, nbs*avgs)[0]\n\n    # Plot\n    i += 1\n    #label=\"%(pgen)s\" % locals()\n    #ppl.plot(nbs, nbs*avgs, label=label, lw=1, linestyle='--', color=set2[i % 12])\n    label=\"%(pgen)s avg\" % locals()\n    ppl.plot(nbs, a * nbs + b, label=label, lw=2, color=set2[i % 12])\nprint datetime.datetime.now().strftime(datetimeformat)\n\nppl.legend(ax, loc='upper left', ncol=4)\n\n# Change x axis label\nax.get_xaxis().get_major_formatter().set_scientific(False)\nfig.canvas.draw()\nlabels = [human_format(int(item.get_text())) for item in ax.get_xticklabels()]\n\nax.set_xticklabels(labels)\nax = plt.gca()\n\nplt.show()\n</code></pre>\n", "abstract": "I tested  some unutbu's functions, i computed it with hungred millions number The winners are the functions that use numpy library,  Note: It would also interesting make a memory utilization test :)  Sample code Complete code on my github repository"}, {"id": 45189992, "score": 3, "vote": 0, "content": "<p>For Python 3</p>\n<pre><code class=\"python\">def rwh_primes2(n):\n    correction = (n%6&gt;1)\n    n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6]\n    sieve = [True] * (n//3)\n    sieve[0] = False\n    for i in range(int(n**0.5)//3+1):\n      if sieve[i]:\n        k=3*i+1|1\n        sieve[      ((k*k)//3)      ::2*k]=[False]*((n//6-(k*k)//6-1)//k+1)\n        sieve[(k*k+4*k-2*k*(i&amp;1))//3::2*k]=[False]*((n//6-(k*k+4*k-2*k*(i&amp;1))//6-1)//k+1)\n    return [2,3] + [3*i+1|1 for i in range(1,n//3-correction) if sieve[i]]\n</code></pre>\n", "abstract": "For Python 3"}, {"id": 70804184, "score": 3, "vote": 0, "content": "<p>I'm surprised nobody mentioned <a href=\"https://numba.pydata.org/numba-doc/dev/reference/jit-compilation.html\" rel=\"nofollow noreferrer\"><code>numba</code></a> yet.</p>\n<p>This version gets to the 1M mark in 2.47 ms \u00b1 36.5 \u00b5s.</p>\n<p>Years ago, pseudo-code for <em>a version</em> of Atkin's sieve was given on the Wikipedia page <a href=\"http://en.wikipedia.org/wiki/Prime_number\" rel=\"nofollow noreferrer\">Prime number</a>. This isn't there anymore, and a reference to the <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Atkin\" rel=\"nofollow noreferrer\">Sieve of Atkin</a> seems to be a different algorithm. A 2007/03/01 version of the Wikipedia page, <a href=\"https://en.wikipedia.org/w/index.php?title=Prime_number&amp;oldid=111775466\" rel=\"nofollow noreferrer\">Primer number as of 2007-03-01</a>, shows the pseudo-code I used as reference.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import numpy as np\nfrom numba import njit\n\n@njit\ndef nb_primes(n):\n    # Generates prime numbers 2 &lt;= p &lt;= n\n    # Atkin's sieve -- see https://en.wikipedia.org/w/index.php?title=Prime_number&amp;oldid=111775466\n    sqrt_n = int(np.sqrt(n)) + 1\n\n    # initialize the sieve\n    s = np.full(n + 1, -1, dtype=np.int8)\n    s[2] = 1\n    s[3] = 1\n\n    # put in candidate primes:\n    # integers which have an odd number of\n    # representations by certain quadratic forms\n    for x in range(1, sqrt_n):\n        x2 = x * x\n        for y in range(1, sqrt_n):\n            y2 = y * y\n            k = 4 * x2 + y2\n            if k &lt;= n and (k % 12 == 1 or k % 12 == 5): s[k] *= -1\n            k = 3 * x2 + y2\n            if k &lt;= n and (k % 12 == 7): s[k] *= -1\n            k = 3 * x2 - y2\n            if k &lt;= n and x &gt; y and k % 12 == 11: s[k] *= -1\n\n    # eliminate composites by sieving\n    for k in range(5, sqrt_n):\n        if s[k]:\n            k2 = k*k\n            # k is prime, omit multiples of its square; this is sufficient because\n            # composites which managed to get on the list cannot be square-free\n            for i in range(1, n // k2 + 1):\n                j = i * k2 # j \u2208 {k\u00b2, 2k\u00b2, 3k\u00b2, ..., n}\n                s[j] = -1\n    return np.nonzero(s&gt;0)[0]\n\n# initial run for \"compilation\" \nnb_primes(10)\n</code></pre>\n<h2>Timing</h2>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">In[10]:\n%timeit nb_primes(1_000_000)\n\nOut[10]:\n2.47 ms \u00b1 36.5 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n\nIn[11]:\n%timeit nb_primes(10_000_000)\n\nOut[11]:\n33.4 ms \u00b1 373 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\nIn[12]:\n%timeit nb_primes(100_000_000)\n\nOut[12]:\n828 ms \u00b1 5.64 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code></pre>\n", "abstract": "I'm surprised nobody mentioned numba yet. This version gets to the 1M mark in 2.47 ms \u00b1 36.5 \u00b5s. Years ago, pseudo-code for a version of Atkin's sieve was given on the Wikipedia page Prime number. This isn't there anymore, and a reference to the Sieve of Atkin seems to be a different algorithm. A 2007/03/01 version of the Wikipedia page, Primer number as of 2007-03-01, shows the pseudo-code I used as reference."}, {"id": 14972126, "score": 2, "vote": 0, "content": "<p>First time using python, so some of the methods I use in this might seem a bit cumbersome. I just straight converted my c++ code to python and this is what I have (albeit a tad bit slowww in python)</p>\n<pre><code class=\"python\">#!/usr/bin/env python\nimport time\n\ndef GetPrimes(n):\n\n    Sieve = [1 for x in xrange(n)]\n\n    Done = False\n    w = 3\n\n    while not Done:\n\n        for q in xrange (3, n, 2):\n            Prod = w*q\n            if Prod &lt; n:\n                Sieve[Prod] = 0\n            else:\n                break\n\n        if w &gt; (n/2):\n            Done = True\n        w += 2\n\n    return Sieve\n\n\n\nstart = time.clock()\n\nd = 10000000\nPrimes = GetPrimes(d)\n\ncount = 1 #This is for 2\n\nfor x in xrange (3, d, 2):\n    if Primes[x]:\n        count+=1\n\nelapsed = (time.clock() - start)\nprint \"\\nFound\", count, \"primes in\", elapsed, \"seconds!\\n\"\n</code></pre>\n<blockquote>\n<p>pythonw Primes.py</p>\n<p>Found 664579 primes in 12.799119 seconds!</p>\n</blockquote>\n<pre><code class=\"python\">#!/usr/bin/env python\nimport time\n\ndef GetPrimes2(n):\n\n    Sieve = [1 for x in xrange(n)]\n\n    for q in xrange (3, n, 2):\n        k = q\n        for y in xrange(k*3, n, k*2):\n            Sieve[y] = 0\n\n    return Sieve\n\n\n\nstart = time.clock()\n\nd = 10000000\nPrimes = GetPrimes2(d)\n\ncount = 1 #This is for 2\n\nfor x in xrange (3, d, 2):\n    if Primes[x]:\n        count+=1\n\nelapsed = (time.clock() - start)\nprint \"\\nFound\", count, \"primes in\", elapsed, \"seconds!\\n\"\n</code></pre>\n<blockquote>\n<p>pythonw Primes2.py</p>\n<p>Found 664579 primes in 10.230172 seconds!</p>\n</blockquote>\n<pre><code class=\"python\">#!/usr/bin/env python\nimport time\n\ndef GetPrimes3(n):\n\n    Sieve = [1 for x in xrange(n)]\n\n    for q in xrange (3, n, 2):\n        k = q\n        for y in xrange(k*k, n, k &lt;&lt; 1):\n            Sieve[y] = 0\n\n    return Sieve\n\n\n\nstart = time.clock()\n\nd = 10000000\nPrimes = GetPrimes3(d)\n\ncount = 1 #This is for 2\n\nfor x in xrange (3, d, 2):\n    if Primes[x]:\n        count+=1\n\nelapsed = (time.clock() - start)\nprint \"\\nFound\", count, \"primes in\", elapsed, \"seconds!\\n\"\n</code></pre>\n<blockquote>\n<p>python Primes2.py</p>\n<p>Found 664579 primes in 7.113776 seconds!</p>\n</blockquote>\n", "abstract": "First time using python, so some of the methods I use in this might seem a bit cumbersome. I just straight converted my c++ code to python and this is what I have (albeit a tad bit slowww in python) pythonw Primes.py Found 664579 primes in 12.799119 seconds! pythonw Primes2.py Found 664579 primes in 10.230172 seconds! python Primes2.py Found 664579 primes in 7.113776 seconds!"}, {"id": 58143286, "score": 2, "vote": 0, "content": "<p>The simplest way I've found of doing this is:</p>\n<pre><code class=\"python\">primes = []\nfor n in range(low, high + 1):\n    if all(n % i for i in primes):\n        primes.append(n)\n</code></pre>\n", "abstract": "The simplest way I've found of doing this is:"}, {"id": 2129681, "score": 1, "vote": 0, "content": "<p>My guess is that the <em>fastest</em> of all ways is to hard code the primes in your code.</p>\n<p>So why not just write a slow script that generates another source file that has all numbers hardwired in it, and then import that source file when you run your actual program.</p>\n<p>Of course, this works only if you know the upper bound of N at compile time, but thus is the case for (almost) all project Euler problems. </p>\n<p>\u00a0</p>\n<p><strong>PS:</strong> <em>I might be wrong though iff parsing the source with hard-wired primes is slower than computing them in the first place, but as far I know Python runs from compiled <code>.pyc</code> files so reading a binary array with all primes up to N should be bloody fast in that case.</em></p>\n", "abstract": "My guess is that the fastest of all ways is to hard code the primes in your code. So why not just write a slow script that generates another source file that has all numbers hardwired in it, and then import that source file when you run your actual program. Of course, this works only if you know the upper bound of N at compile time, but thus is the case for (almost) all project Euler problems.  \u00a0 PS: I might be wrong though iff parsing the source with hard-wired primes is slower than computing them in the first place, but as far I know Python runs from compiled .pyc files so reading a binary array with all primes up to N should be bloody fast in that case."}, {"id": 3476592, "score": 1, "vote": 0, "content": "<p>Sorry to bother but erat2() has a serious flaw in the algorithm.</p>\n<p>While searching for the next composite, we need to test odd numbers only.\nq,p both are odd; then q+p is even and doesn't need to be tested, but q+2*p is always odd. This eliminates the \"if even\" test in the while loop condition and saves about 30% of the runtime.</p>\n<p>While we're at it: instead of the elegant 'D.pop(q,None)' get and delete method use 'if q in D: p=D[q],del D[q]' which is twice as fast! At least on my machine (P3-1Ghz).\nSo I suggest this implementation of this clever algorithm:</p>\n<pre><code class=\"python\">def erat3( ):\n    from itertools import islice, count\n\n    # q is the running integer that's checked for primeness.\n    # yield 2 and no other even number thereafter\n    yield 2\n    D = {}\n    # no need to mark D[4] as we will test odd numbers only\n    for q in islice(count(3),0,None,2):\n        if q in D:                  #  is composite\n            p = D[q]\n            del D[q]\n            # q is composite. p=D[q] is the first prime that\n            # divides it. Since we've reached q, we no longer\n            # need it in the map, but we'll mark the next\n            # multiple of its witnesses to prepare for larger\n            # numbers.\n            x = q + p+p        # next odd(!) multiple\n            while x in D:      # skip composites\n                x += p+p\n            D[x] = p\n        else:                  # is prime\n            # q is a new prime.\n            # Yield it and mark its first multiple that isn't\n            # already marked in previous iterations.\n            D[q*q] = q\n            yield q\n</code></pre>\n", "abstract": "Sorry to bother but erat2() has a serious flaw in the algorithm. While searching for the next composite, we need to test odd numbers only.\nq,p both are odd; then q+p is even and doesn't need to be tested, but q+2*p is always odd. This eliminates the \"if even\" test in the while loop condition and saves about 30% of the runtime. While we're at it: instead of the elegant 'D.pop(q,None)' get and delete method use 'if q in D: p=D[q],del D[q]' which is twice as fast! At least on my machine (P3-1Ghz).\nSo I suggest this implementation of this clever algorithm:"}, {"id": 16004075, "score": 1, "vote": 0, "content": "<p>I may be late to the party but will have to add my own code for this. It uses approximately n/2 in space because we don't need to store even numbers and I also make use of the bitarray python module, further draStically cutting down on memory consumption and enabling computing all primes up to 1,000,000,000</p>\n<pre><code class=\"python\">from bitarray import bitarray\ndef primes_to(n):\n    size = n//2\n    sieve = bitarray(size)\n    sieve.setall(1)\n    limit = int(n**0.5)\n    for i in range(1,limit):\n        if sieve[i]:\n            val = 2*i+1\n            sieve[(i+i*val)::val] = 0\n    return [2] + [2*i+1 for i, v in enumerate(sieve) if v and i &gt; 0]\n\npython -m timeit -n10 -s \"import euler\" \"euler.primes_to(1000000000)\"\n10 loops, best of 3: 46.5 sec per loop\n</code></pre>\n<p>This was run on a 64bit 2.4GHZ MAC OSX 10.8.3</p>\n", "abstract": "I may be late to the party but will have to add my own code for this. It uses approximately n/2 in space because we don't need to store even numbers and I also make use of the bitarray python module, further draStically cutting down on memory consumption and enabling computing all primes up to 1,000,000,000 This was run on a 64bit 2.4GHZ MAC OSX 10.8.3"}, {"id": 48645005, "score": 1, "vote": 0, "content": "<p>Here is an interesting technique to generate prime numbers (yet not the most efficient) using python's list comprehensions:</p>\n<pre><code class=\"python\">noprimes = [j for i in range(2, 8) for j in range(i*2, 50, i)]\nprimes = [x for x in range(2, 50) if x not in noprimes]\n</code></pre>\n", "abstract": "Here is an interesting technique to generate prime numbers (yet not the most efficient) using python's list comprehensions:"}, {"id": 56077387, "score": 1, "vote": 0, "content": "<p>Here is a numpy version of Sieve of Eratosthenes having both good complexity (lower than sorting an array of length n) and vectorization.  Compared to @unutbu times this just as fast as the packages with 46 microsecons to find all primes below a million. </p>\n<pre><code class=\"python\">import numpy as np \ndef generate_primes(n):\n    is_prime = np.ones(n+1,dtype=bool)\n    is_prime[0:2] = False\n    for i in range(int(n**0.5)+1):\n        if is_prime[i]:\n            is_prime[i**2::i]=False\n    return np.where(is_prime)[0]\n</code></pre>\n<p>Timings: </p>\n<pre><code class=\"python\">import time    \nfor i in range(2,10):\n    timer =time.time()\n    generate_primes(10**i)\n    print('n = 10^',i,' time =', round(time.time()-timer,6))\n\n&gt;&gt; n = 10^ 2  time = 5.6e-05\n&gt;&gt; n = 10^ 3  time = 6.4e-05\n&gt;&gt; n = 10^ 4  time = 0.000114\n&gt;&gt; n = 10^ 5  time = 0.000593\n&gt;&gt; n = 10^ 6  time = 0.00467\n&gt;&gt; n = 10^ 7  time = 0.177758\n&gt;&gt; n = 10^ 8  time = 1.701312\n&gt;&gt; n = 10^ 9  time = 19.322478\n</code></pre>\n", "abstract": "Here is a numpy version of Sieve of Eratosthenes having both good complexity (lower than sorting an array of length n) and vectorization.  Compared to @unutbu times this just as fast as the packages with 46 microsecons to find all primes below a million.  Timings: "}, {"id": 68295105, "score": 1, "vote": 0, "content": "<p>As of (late) writing, this is the fastest working solution posted (at least it is on my machine).  It uses both numpy and bitarray, and is inspired by <code>primesfrom2to</code> from <a href=\"https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\">this answer</a>.</p>\n<pre><code class=\"python\">import numpy as np\nfrom bitarray import bitarray\n\n\ndef bit_primes(n):\n    bit_sieve = bitarray(n // 3 + (n % 6 == 2))\n    bit_sieve.setall(1)\n    bit_sieve[0] = False\n\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if bit_sieve[i]:\n            k = 3 * i + 1 | 1\n            bit_sieve[k * k // 3::2 * k] = False\n            bit_sieve[(k * k + 4 * k - 2 * k * (i &amp; 1)) // 3::2 * k] = False\n\n    np_sieve = np.unpackbits(np.frombuffer(bit_sieve.tobytes(), dtype=np.uint8)).view(bool)\n    return np.concatenate(((2, 3), ((3 * np.flatnonzero(np_sieve) + 1) | 1)))\n</code></pre>\n<p>Here's a comparison with <code>primesfrom2to</code>, which was previously found to be the fastest solution in <a href=\"https://stackoverflow.com/a/2068548/6338179\">unutbu's comparison</a>:</p>\n<pre><code class=\"python\">python3 -m timeit -s \"import fast_primes\" \"fast_primes.bit_primes(1000000)\"\n200 loops, best of 5: 1.19 msec per loop\n\npython3 -m timeit -s \"import fast_primes\" \"fast_primes.primesfrom2to(1000000)\"\n200 loops, best of 5: 1.23 msec per loop\n</code></pre>\n<p>For finding primes under 1 million, <code>bit_primes</code> was slightly faster.\nFor larger values of <code>n</code>, the difference can be more significant.  In some cases, <code>bit_primes</code> was over twice as fast:</p>\n<pre><code class=\"python\">python3 -m timeit -s \"import fast_primes\" \"fast_primes.bit_primes(500_000_000)\"\n1 loop, best of 5: 540 msec per loop\n\npython3 -m timeit -s \"import fast_primes\" \"fast_primes.primesfrom2to(500_000_000)\"\n1 loop, best of 5: 1.15 sec per loop\n</code></pre>\n<p>For reference, here's the minimally modified (to work in Python 3) version of <code>primesfrom2to</code> I compared with:</p>\n<pre><code class=\"python\">def primesfrom2to(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Input n&gt;=6, Returns a array of primes, 2 &lt;= p &lt; n\"\"\"\n    sieve = np.ones(n // 3 + (n % 6 == 2), dtype=np.bool)\n    sieve[0] = False\n    for i in range(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[((k * k) // 3)::2 * k] = False\n            sieve[(k * k + 4 * k - 2 * k * (i &amp; 1)) // 3::2 * k] = False\n    return np.r_[2, 3, ((3 * np.nonzero(sieve)[0] + 1) | 1)]\n</code></pre>\n", "abstract": "As of (late) writing, this is the fastest working solution posted (at least it is on my machine).  It uses both numpy and bitarray, and is inspired by primesfrom2to from this answer. Here's a comparison with primesfrom2to, which was previously found to be the fastest solution in unutbu's comparison: For finding primes under 1 million, bit_primes was slightly faster.\nFor larger values of n, the difference can be more significant.  In some cases, bit_primes was over twice as fast: For reference, here's the minimally modified (to work in Python 3) version of primesfrom2to I compared with:"}, {"id": 3796455, "score": 0, "vote": 0, "content": "<p>The fastest method I've tried so far is based on the <a href=\"http://oreilly.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=last\" rel=\"nofollow noreferrer\">Python cookbook <code>erat2</code></a> function:</p>\n<pre><code class=\"python\">import itertools as it\ndef erat2a( ):\n    D = {  }\n    yield 2\n    for q in it.islice(it.count(3), 0, None, 2):\n        p = D.pop(q, None)\n        if p is None:\n            D[q*q] = q\n            yield q\n        else:\n            x = q + 2*p\n            while x in D:\n                x += 2*p\n            D[x] = p\n</code></pre>\n<p>See <a href=\"https://stackoverflow.com/questions/2211990/how-to-implement-an-efficient-infinite-generator-of-prime-numbers-in-python/3796442#3796442\">this</a> answer for an explanation of the speeding-up.</p>\n", "abstract": "The fastest method I've tried so far is based on the Python cookbook erat2 function: See this answer for an explanation of the speeding-up."}, {"id": 26704740, "score": 0, "vote": 0, "content": "<p>I collected several prime number sieves over time. The fastest on my computer is this:</p>\n<pre><code class=\"python\">from time import time\n# 175 ms for all the primes up to the value 10**6\ndef primes_sieve(limit):\n    a = [True] * limit\n    a[0] = a[1] = False\n    #a[2] = True\n    for n in xrange(4, limit, 2):\n        a[n] = False\n    root_limit = int(limit**.5)+1\n    for i in xrange(3,root_limit):\n        if a[i]:\n            for n in xrange(i*i, limit, 2*i):\n                a[n] = False\n    return a\n\nLIMIT = 10**6\ns=time()\nprimes = primes_sieve(LIMIT)\nprint time()-s\n</code></pre>\n", "abstract": "I collected several prime number sieves over time. The fastest on my computer is this:"}, {"id": 28517084, "score": 0, "vote": 0, "content": "<p>I'm slow responding to this question but it seemed like a fun exercise. I'm using numpy which might be cheating and I doubt this method is the fastest but it should be clear. It sieves a Boolean array referring to its indices only and elicits prime numbers from the indices of all True values. No modulo needed.</p>\n<pre><code class=\"python\">import numpy as np\ndef ajs_primes3a(upto):\n    mat = np.ones((upto), dtype=bool)\n    mat[0] = False\n    mat[1] = False\n    mat[4::2] = False\n    for idx in range(3, int(upto ** 0.5)+1, 2):\n        mat[idx*2::idx] = False\n    return np.where(mat == True)[0]\n</code></pre>\n", "abstract": "I'm slow responding to this question but it seemed like a fun exercise. I'm using numpy which might be cheating and I doubt this method is the fastest but it should be clear. It sieves a Boolean array referring to its indices only and elicits prime numbers from the indices of all True values. No modulo needed."}, {"id": 57879041, "score": 0, "vote": 0, "content": "<p>I found a pure Python 2 prime generator <a href=\"https://programmingpraxis.com/2012/01/06/pritchards-wheel-sieve/\" rel=\"nofollow noreferrer\">here </a>, in a comment by Willy Good, that is faster than rwh2_primes.  </p>\n<pre><code class=\"python\">def primes235(limit):\nyield 2; yield 3; yield 5\nif limit &lt; 7: return\nmodPrms = [7,11,13,17,19,23,29,31]\ngaps = [4,2,4,2,4,6,2,6,4,2,4,2,4,6,2,6] # 2 loops for overflow\nndxs = [0,0,0,0,1,1,2,2,2,2,3,3,4,4,4,4,5,5,5,5,5,5,6,6,7,7,7,7,7,7]\nlmtbf = (limit + 23) // 30 * 8 - 1 # integral number of wheels rounded up\nlmtsqrt = (int(limit ** 0.5) - 7)\nlmtsqrt = lmtsqrt // 30 * 8 + ndxs[lmtsqrt % 30] # round down on the wheel\nbuf = [True] * (lmtbf + 1)\nfor i in xrange(lmtsqrt + 1):\n    if buf[i]:\n        ci = i &amp; 7; p = 30 * (i &gt;&gt; 3) + modPrms[ci]\n        s = p * p - 7; p8 = p &lt;&lt; 3\n        for j in range(8):\n            c = s // 30 * 8 + ndxs[s % 30]\n            buf[c::p8] = [False] * ((lmtbf - c) // p8 + 1)\n            s += p * gaps[ci]; ci += 1\nfor i in xrange(lmtbf - 6 + (ndxs[(limit - 7) % 30])): # adjust for extras\n    if buf[i]: yield (30 * (i &gt;&gt; 3) + modPrms[i &amp; 7])\n</code></pre>\n<p>My results:</p>\n<pre><code class=\"python\">$ time ./prime_rwh2.py 1e8\n5761455 primes found &lt; 1e8\n\nreal    0m3.201s\nuser    0m2.609s\nsys     0m0.578s\n$ time ./prime_wheel.py 1e8\n5761455 primes found &lt; 1e8\n\nreal    0m2.710s\nuser    0m2.469s\nsys     0m0.219s\n</code></pre>\n<p>...on my recent midrange laptop (i5 8265U 1.6GHz) running Ubuntu on Win 10.</p>\n<p>This is a mod 30 wheel sieve which skips multiples of 2, 3, and 5.  It works great for me up to about 2.5e9, when my laptop starts running out of 8G RAM and swapping a lot.  </p>\n<p>I like mod 30 since it has only 8 remainders that aren't multiples of 2, 3, or 5. That enables using shifts and \"&amp;\" for multiplication, division and mod, and should allow packing results for one mod 30 wheel into a byte.  I have morphed Willy's code into a segmented mod 30 wheel sieve to eliminate the thrashing for big N and posted it <a href=\"https://codereview.stackexchange.com/q/229813/210384\">here</a>.</p>\n<p>There is an even faster <a href=\"https://stackoverflow.com/a/57108107/11943198\">Javascript version</a> which is segmented and uses a mod 210 wheel (no multiples of 2, 3, 5, or 7) by @GordonBGood with an in depth explanation that is useful to me.</p>\n", "abstract": "I found a pure Python 2 prime generator here , in a comment by Willy Good, that is faster than rwh2_primes.   My results: ...on my recent midrange laptop (i5 8265U 1.6GHz) running Ubuntu on Win 10. This is a mod 30 wheel sieve which skips multiples of 2, 3, and 5.  It works great for me up to about 2.5e9, when my laptop starts running out of 8G RAM and swapping a lot.   I like mod 30 since it has only 8 remainders that aren't multiples of 2, 3, or 5. That enables using shifts and \"&\" for multiplication, division and mod, and should allow packing results for one mod 30 wheel into a byte.  I have morphed Willy's code into a segmented mod 30 wheel sieve to eliminate the thrashing for big N and posted it here. There is an even faster Javascript version which is segmented and uses a mod 210 wheel (no multiples of 2, 3, 5, or 7) by @GordonBGood with an in depth explanation that is useful to me."}, {"id": 63428414, "score": 0, "vote": 0, "content": "<p>This is a variation of the solution in the question that should be faster than what's in the question. It uses a static sieve of Eratosthenes with no other optimizations.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from typing import List\n\ndef list_primes(limit: int) -&gt; List[int]:\n    primes = set(range(2, limit + 1))\n    for i in range(2, limit + 1):\n        if i in primes:\n            primes.difference_update(set(list(range(i, limit + 1, i))[1:]))\n    return sorted(primes)\n\n&gt;&gt;&gt; list_primes(100)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n</code></pre>\n", "abstract": "This is a variation of the solution in the question that should be faster than what's in the question. It uses a static sieve of Eratosthenes with no other optimizations."}, {"id": 69244164, "score": 0, "vote": 0, "content": "<p>You have a faster code and also the simplest code generating primes.\nbut for the higher number, it's not working for <code>n=10000, 10000000</code> it failed maybe it's <code>.pop()</code> method</p>\n<p>Consider: is N prime?</p>\n<ul>\n<li><p>case 1:</p>\n<p>You got some factors of N,</p>\n<pre><code class=\"python\">for i in range(2, N):\n</code></pre>\n<p>If N is prime loop is performed  for ~(N-2) times. else less number of times</p>\n</li>\n<li><p>case 2:</p>\n<pre><code class=\"python\">for i in range(2, int(math.sqrt(N)): \n</code></pre>\n<p>Loop is performed for almost ~(sqrt(N)-2) times if N is prime else will break somewhere</p>\n</li>\n<li><p>case 3:</p>\n<p>Better We Divide N With Only number of <strong>primes&lt;=sqrt(N)</strong></p>\n<p>Where loop is performed for only \u03c0(sqrt(N)) times</p>\n<p><strong>\u03c0(sqrt(N)) &lt;&lt; sqrt(N) as N increases</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from math import sqrt\nfrom time import *\nprime_list = [2]\nn = int(input())\ns = time()\nfor n0 in range(2,n+1):\n    for i0 in prime_list:\n        if n0%i0==0:\n            break\n        elif i0&gt;=int(sqrt(n0)):\n            prime_list.append(n0)\n            break\ne = time()\nprint(e-s)\n#print(prime_list); print(f'pi({n})={len(prime_list)}')\nprint(f'{n}: {len(prime_list)}, time: {e-s}')\n</code></pre>\n</li>\n<li><p>Output</p>\n<pre><code class=\"python\">100: 25, time: 0.00010275840759277344\n1000: 168, time: 0.0008606910705566406\n10000: 1229, time: 0.015588521957397461\n100000: 9592, time: 0.023436546325683594\n1000000: 78498, time: 4.1965954303741455\n10000000: 664579, time: 109.24591708183289\n100000000: 5761455, time: 2289.130858898163\n</code></pre>\n</li>\n</ul>\n<p>For less than 1000 seems slow but then for &lt;10^6 I think it's faster.</p>\n<p>Though, I couldn't understand the time complexity.</p>\n", "abstract": "You have a faster code and also the simplest code generating primes.\nbut for the higher number, it's not working for n=10000, 10000000 it failed maybe it's .pop() method Consider: is N prime? case 1: You got some factors of N, If N is prime loop is performed  for ~(N-2) times. else less number of times case 2: Loop is performed for almost ~(sqrt(N)-2) times if N is prime else will break somewhere case 3: Better We Divide N With Only number of primes<=sqrt(N) Where loop is performed for only \u03c0(sqrt(N)) times \u03c0(sqrt(N)) << sqrt(N) as N increases Output For less than 1000 seems slow but then for <10^6 I think it's faster. Though, I couldn't understand the time complexity."}, {"id": 72310515, "score": 0, "vote": 0, "content": "<p>Starting from <a href=\"https://stackoverflow.com/a/68295105/1190453\">this 2021 answer</a>, I haven't found <code>bitarray</code> approach to be beneficial for primes below 1 billion.</p>\n<p>But I was able to speedup <code>primesfrom2to</code> almost x2 with several tricks:</p>\n<ul>\n<li>use <code>numexpr</code> library to convert numpy expressions to tight loops with less allocations</li>\n<li>replace <code>np.ones</code> with a faster alternative</li>\n<li>manipulate first 9 elements of a sieve in a way, so there is no need to change array shape later</li>\n</ul>\n<p>All in all, time for primes &lt;1 billion went from 25s to 14.5s on my machine</p>\n<pre><code class=\"python\">import numexpr as ne\nimport numpy as np\n\ndef primesfrom2to_numexpr(n):\n    # https://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Input n&gt;=24, Returns a array of primes, 2 &lt;= p &lt; n + a few over\"\"\"\n    sieve = np.zeros((n // 3 + (n % 6 == 2))//4+1, dtype=np.int32)\n    ne.evaluate('sieve + 0x01010101', out=sieve)\n    sieve = sieve.view('int8')\n    #sieve = np.ones(n // 3 + (n % 6 == 2), dtype=np.bool_)\n    sieve[0] = 0\n    for i in np.arange(int(n ** 0.5) // 3 + 1):\n        if sieve[i]:\n            k = 3 * i + 1 | 1\n            sieve[((k * k) // 3)::2 * k] = 0\n            sieve[(k * k + 4 * k - 2 * k * (i &amp; 1)) // 3::2 * k] = 0\n    sieve[[0,8]] = 1\n    result = np.flatnonzero(sieve)\n    ne.evaluate('result * 3 + 1 + result%2', out=result)\n    result[:9] = [2,3,5,7,11,13,17,19,23]\n    return result\n</code></pre>\n", "abstract": "Starting from this 2021 answer, I haven't found bitarray approach to be beneficial for primes below 1 billion. But I was able to speedup primesfrom2to almost x2 with several tricks: All in all, time for primes <1 billion went from 25s to 14.5s on my machine"}, {"id": 21505621, "score": -1, "vote": 0, "content": "<p>This is an elegant and simpler solution to find primes using a stored list. Starts with a 4 variables, you only have to test odd primes for divisors, and you only have to test up to a half of what number you are testing as a prime (no point in testing whether 9, 11, 13 divide into 17). It tests previously stored primes as divisors.`</p>\n<pre><code class=\"python\">    # Program to calculate Primes\n primes = [1,3,5,7]\nfor n in range(9,100000,2):\n    for x in range(1,(len(primes)/2)):\n        if n % primes[x] == 0:\n            break\n    else:\n        primes.append(n)\nprint primes\n</code></pre>\n", "abstract": "This is an elegant and simpler solution to find primes using a stored list. Starts with a 4 variables, you only have to test odd primes for divisors, and you only have to test up to a half of what number you are testing as a prime (no point in testing whether 9, 11, 13 divide into 17). It tests previously stored primes as divisors.`"}, {"id": 28504698, "score": -4, "vote": 0, "content": "<p>This is the way you can compare with others.</p>\n<pre><code class=\"python\"># You have to list primes upto n\nnums = xrange(2, n)\nfor i in range(2, 10):\n    nums = filter(lambda s: s==i or s%i, nums)\nprint nums\n</code></pre>\n<p>So simple...</p>\n", "abstract": "This is the way you can compare with others. So simple..."}]}, {"link": "https://stackoverflow.com/questions/929103/convert-a-number-range-to-another-range-maintaining-ratio", "question": {"id": "929103", "title": "Convert a number range to another range, maintaining ratio", "content": "<p>I'm trying to convert one range of numbers to another, maintaining ratio. Maths is not my strong point.</p>\n<p>I have an image file where point values may range from -16000.00 to 16000.00 though the typical range may be much less. What I want to do is compress these values into the integer range 0-100, where 0 is the value of the smallest point, and 100 is the value of the largest. All points in between should keep a relative ratio even though some precision is being lost I'd like to do this in python but even a general algorithm should suffice. I'd prefer an algorithm where the min/max or either range can be adjusted (ie, the second range could be -50 to 800 instead of 0 to 100).</p>\n", "abstract": "I'm trying to convert one range of numbers to another, maintaining ratio. Maths is not my strong point. I have an image file where point values may range from -16000.00 to 16000.00 though the typical range may be much less. What I want to do is compress these values into the integer range 0-100, where 0 is the value of the smallest point, and 100 is the value of the largest. All points in between should keep a relative ratio even though some precision is being lost I'd like to do this in python but even a general algorithm should suffice. I'd prefer an algorithm where the min/max or either range can be adjusted (ie, the second range could be -50 to 800 instead of 0 to 100)."}, "answers": [{"id": 929107, "score": 705, "vote": 0, "content": "<pre><code class=\"python\">NewValue = (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin\n</code></pre>\n<p>Or a little more readable:  </p>\n<pre><code class=\"python\">OldRange = (OldMax - OldMin)  \nNewRange = (NewMax - NewMin)  \nNewValue = (((OldValue - OldMin) * NewRange) / OldRange) + NewMin\n</code></pre>\n<p>Or if you want to protect for the case where the old range is 0 (<em>OldMin = OldMax</em>):</p>\n<pre><code class=\"python\">OldRange = (OldMax - OldMin)\nif (OldRange == 0)\n    NewValue = NewMin\nelse\n{\n    NewRange = (NewMax - NewMin)  \n    NewValue = (((OldValue - OldMin) * NewRange) / OldRange) + NewMin\n}\n</code></pre>\n<p>Note that in this case we're forced to pick one of the possible new range values arbitrarily. Depending on context, sensible choices could be: <code>NewMin</code> (<em>see sample</em>), <code>NewMax</code> or <code>(NewMin + NewMax) / 2</code></p>\n", "abstract": "Or a little more readable:   Or if you want to protect for the case where the old range is 0 (OldMin = OldMax): Note that in this case we're forced to pick one of the possible new range values arbitrarily. Depending on context, sensible choices could be: NewMin (see sample), NewMax or (NewMin + NewMax) / 2"}, {"id": 929104, "score": 83, "vote": 0, "content": "<p>That's a simple linear conversion.</p>\n<pre><code class=\"python\">new_value = ( (old_value - old_min) / (old_max - old_min) ) * (new_max - new_min) + new_min\n</code></pre>\n<p>So converting 10000 on the scale of -16000 to 16000 to a new scale of 0 to 100 yields:</p>\n<pre><code class=\"python\">old_value = 10000\nold_min = -16000\nold_max = 16000\nnew_min = 0\nnew_max = 100\n\nnew_value = ( ( 10000 - -16000 ) / (16000 - -16000) ) * (100 - 0) + 0\n          = 81.25\n</code></pre>\n", "abstract": "That's a simple linear conversion. So converting 10000 on the scale of -16000 to 16000 to a new scale of 0 to 100 yields:"}, {"id": 15537393, "score": 25, "vote": 0, "content": "<p>Actually there are some cases that above answers would break.\nSuch as wrongly input value, wrongly input range, negative input/output ranges.</p>\n<pre><code class=\"python\">def remap( x, oMin, oMax, nMin, nMax ):\n\n    #range check\n    if oMin == oMax:\n        print \"Warning: Zero input range\"\n        return None\n\n    if nMin == nMax:\n        print \"Warning: Zero output range\"\n        return None\n\n    #check reversed input range\n    reverseInput = False\n    oldMin = min( oMin, oMax )\n    oldMax = max( oMin, oMax )\n    if not oldMin == oMin:\n        reverseInput = True\n\n    #check reversed output range\n    reverseOutput = False   \n    newMin = min( nMin, nMax )\n    newMax = max( nMin, nMax )\n    if not newMin == nMin :\n        reverseOutput = True\n\n    portion = (x-oldMin)*(newMax-newMin)/(oldMax-oldMin)\n    if reverseInput:\n        portion = (oldMax-x)*(newMax-newMin)/(oldMax-oldMin)\n\n    result = portion + newMin\n    if reverseOutput:\n        result = newMax - portion\n\n    return result\n\n#test cases\nprint remap( 25.0, 0.0, 100.0, 1.0, -1.0 ), \"==\", 0.5\nprint remap( 25.0, 100.0, -100.0, -1.0, 1.0 ), \"==\", -0.25\nprint remap( -125.0, -100.0, -200.0, 1.0, -1.0 ), \"==\", 0.5\nprint remap( -125.0, -200.0, -100.0, -1.0, 1.0 ), \"==\", 0.5\n#even when value is out of bound\nprint remap( -20.0, 0.0, 100.0, 0.0, 1.0 ), \"==\", -0.2\n</code></pre>\n", "abstract": "Actually there are some cases that above answers would break.\nSuch as wrongly input value, wrongly input range, negative input/output ranges."}, {"id": 11405720, "score": 9, "vote": 0, "content": "<p>There is a condition, when all of the values that you are checking are the same, where @jerryjvl's code would return NaN.</p>\n<pre><code class=\"python\">if (OldMin != OldMax &amp;&amp; NewMin != NewMax):\n    return (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin\nelse:\n    return (NewMax + NewMin) / 2\n</code></pre>\n", "abstract": "There is a condition, when all of the values that you are checking are the same, where @jerryjvl's code would return NaN."}, {"id": 43567380, "score": 9, "vote": 0, "content": "<p>I didn't dig up the <a href=\"https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form\" rel=\"noreferrer\">BNF</a> for this, but the Arduino documentation had a great example of the function and it's breakdown. I was able to use this in Python by simply adding a def renaming to remap (cause map is a built-in) and removing the type casts and curly braces (ie just remove all the 'long's).</p>\n<p>Original</p>\n<pre><code class=\"python\">long map(long x, long in_min, long in_max, long out_min, long out_max)\n{\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n</code></pre>\n<p>Python</p>\n<pre><code class=\"python\">def remap(x, in_min, in_max, out_min, out_max):\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min\n</code></pre>\n<p><a href=\"https://www.arduino.cc/en/reference/map\" rel=\"noreferrer\">https://www.arduino.cc/en/reference/map</a></p>\n", "abstract": "I didn't dig up the BNF for this, but the Arduino documentation had a great example of the function and it's breakdown. I was able to use this in Python by simply adding a def renaming to remap (cause map is a built-in) and removing the type casts and curly braces (ie just remove all the 'long's). Original Python https://www.arduino.cc/en/reference/map"}, {"id": 42095130, "score": 8, "vote": 0, "content": "<p>Here's some short Python functions for your copy and paste ease, including a function to scale an entire list.</p>\n<pre><code class=\"python\">def scale_number(unscaled, to_min, to_max, from_min, from_max):\n    return (to_max-to_min)*(unscaled-from_min)/(from_max-from_min)+to_min\n\ndef scale_list(l, to_min, to_max):\n    return [scale_number(i, to_min, to_max, min(l), max(l)) for i in l]\n</code></pre>\n<p>Which can be used like so:</p>\n<pre><code class=\"python\">scale_list([1,3,4,5], 0, 100)\n</code></pre>\n<blockquote>\n<p>[0.0, 50.0, 75.0, 100.0]</p>\n</blockquote>\n<p>In my case I wanted to scale a logarithmic curve, like so:</p>\n<pre><code class=\"python\">scale_list([math.log(i+1) for i in range(5)], 0, 50)\n</code></pre>\n<blockquote>\n<p>[0.0, 21.533827903669653, 34.130309724299266, 43.06765580733931, 50.0]</p>\n</blockquote>\n", "abstract": "Here's some short Python functions for your copy and paste ease, including a function to scale an entire list. Which can be used like so: [0.0, 50.0, 75.0, 100.0] In my case I wanted to scale a logarithmic curve, like so: [0.0, 21.533827903669653, 34.130309724299266, 43.06765580733931, 50.0]"}, {"id": 63028878, "score": 4, "vote": 0, "content": "<h2>Added KOTLIN version with Mathematical Explanation</h2>\n<p>Consider we have a scale between <strong>(OMin, Omax)</strong> and we we have a value <strong>X</strong> in this range</p>\n<p>We want to convert it to scale  <strong>(NMin, NMax)</strong></p>\n<p>We know X and we need to find Y, the ratio must be same:</p>\n<pre><code class=\"python\"> =&gt; (Y-NMin)/(NMax-NMin) = (X-OMin)/(OMax-OMin)  \n      \n =&gt;  (Y-NMin)/NewRange = (X-OMin)/OldRange \n\n =&gt;   Y = ((X-OMin)*NewRange)/oldRange)+NMin  Answer\n   \n</code></pre>\n<p><strong>Pragmatically we can write this rquation like this:</strong></p>\n<pre><code class=\"python\"> private fun  convertScale(oldValueToConvert:Int): Float {\n       // Old Scale 50-100\n       val oldScaleMin = 50\n       val oldScaleMax = 100\n       val oldScaleRange= (oldScaleMax - oldScaleMin)\n\n       //new Scale 0-1\n       val newScaleMin = 0.0f\n       val newScaleMax = 1.0f\n       val newScaleRange=  (newScaleMax - newScaleMin)\n     \n       return ((oldValueToConvert - oldScaleMin)* newScaleRange/ oldScaleRange) + newScaleMin\n    }\n</code></pre>\n<p><strong>JAVA</strong></p>\n<pre><code class=\"python\">/**\n     * \n     * @param x\n     * @param inMin\n     * @param inMax\n     * @param outMin\n     * @param outMax\n     * @return\n     */\n        private long normalize(long x, long inMin, long inMax, long outMin, long outMax) {\n          long outRange = outMax - outMin;\n          long inRange  = inMax - inMin;\n          return (x - inMin) *outRange / inRange + outMin;\n        }\n</code></pre>\n<p><strong>Usage:</strong></p>\n<pre><code class=\"python\">float brightness = normalize(progress, 0, 10, 0,255);\n</code></pre>\n", "abstract": "Consider we have a scale between (OMin, Omax) and we we have a value X in this range We want to convert it to scale  (NMin, NMax) We know X and we need to find Y, the ratio must be same: Pragmatically we can write this rquation like this: JAVA Usage:"}, {"id": 43525215, "score": 3, "vote": 0, "content": "<p>I personally use the helper class which supports generics (Swift 3, 4.x compatible)</p>\n<pre><code class=\"python\">struct Rescale&lt;Type : BinaryFloatingPoint&gt; {\n    typealias RescaleDomain = (lowerBound: Type, upperBound: Type)\n\n    var fromDomain: RescaleDomain\n    var toDomain: RescaleDomain\n\n    init(from: RescaleDomain, to: RescaleDomain) {\n        self.fromDomain = from\n        self.toDomain = to\n    }\n\n    func interpolate(_ x: Type ) -&gt; Type {\n        return self.toDomain.lowerBound * (1 - x) + self.toDomain.upperBound * x;\n    }\n\n    func uninterpolate(_ x: Type) -&gt; Type {\n        let b = (self.fromDomain.upperBound - self.fromDomain.lowerBound) != 0 ? self.fromDomain.upperBound - self.fromDomain.lowerBound : 1 / self.fromDomain.upperBound;\n        return (x - self.fromDomain.lowerBound) / b\n    }\n\n    func rescale(_ x: Type )  -&gt; Type {\n        return interpolate( uninterpolate(x) )\n    }\n}\n</code></pre>\n<p>Ex:</p>\n<pre><code class=\"python\">   let rescaler = Rescale&lt;Float&gt;(from: (-1, 1), to: (0, 100))\n    \n   print(rescaler.rescale(0)) // OUTPUT: 50\n</code></pre>\n", "abstract": "I personally use the helper class which supports generics (Swift 3, 4.x compatible) Ex:"}, {"id": 24658800, "score": 2, "vote": 0, "content": "<p>I used this solution in a problem I was solving in js, so I thought I would share the translation. Thanks for the explanation and solution.</p>\n<pre><code class=\"python\">function remap( x, oMin, oMax, nMin, nMax ){\n//range check\nif (oMin == oMax){\n    console.log(\"Warning: Zero input range\");\n    return None;\n};\n\nif (nMin == nMax){\n    console.log(\"Warning: Zero output range\");\n    return None\n}\n\n//check reversed input range\nvar reverseInput = false;\noldMin = Math.min( oMin, oMax );\noldMax = Math.max( oMin, oMax );\nif (oldMin != oMin){\n    reverseInput = true;\n}\n\n//check reversed output range\nvar reverseOutput = false;  \nnewMin = Math.min( nMin, nMax )\nnewMax = Math.max( nMin, nMax )\nif (newMin != nMin){\n    reverseOutput = true;\n};\n\nvar portion = (x-oldMin)*(newMax-newMin)/(oldMax-oldMin)\nif (reverseInput){\n    portion = (oldMax-x)*(newMax-newMin)/(oldMax-oldMin);\n};\n\nvar result = portion + newMin\nif (reverseOutput){\n    result = newMax - portion;\n}\n\nreturn result;\n}\n</code></pre>\n", "abstract": "I used this solution in a problem I was solving in js, so I thought I would share the translation. Thanks for the explanation and solution."}, {"id": 27497644, "score": 2, "vote": 0, "content": "<p>In the listing provided by PenguinTD, I do not understand why the ranges are reversed, it works without having to reverse the ranges. Linear range conversion is based upon the linear equation <code>Y=Xm+n</code>, where <code>m</code> and <code>n</code> are derived from the given ranges. Rather than refer to the ranges as <code>min</code> and <code>max</code>, it would be better to refer to them as 1 and 2. So the formula would be:</p>\n<pre><code class=\"python\">Y = (((X - x1) * (y2 - y1)) / (x2 - x1)) + y1\n</code></pre>\n<p>Where <code>Y=y1</code> when <code>X=x1</code>, and <code>Y=y2</code> when <code>X=x2</code>. <code>x1</code>, <code>x2</code>, <code>y1</code> &amp; <code>y2</code> can be given any <code>positive</code> or <code>negative</code> value. Defining the expression in a macro makes it more useful,it can then be used with any argument names.</p>\n<pre><code class=\"python\">#define RangeConv(X, x1, x2, y1, y2) (((float)((X - x1) * (y2 - y1)) / (x2 - x1)) + y1)\n</code></pre>\n<p>The <code>float</code> cast would ensure floating point division in the case where all the arguments are <code>integer</code> values.\nDepending on the application it may not be necessary to check the ranges <code>x1=x2</code> and <code>y1==y2</code>.</p>\n", "abstract": "In the listing provided by PenguinTD, I do not understand why the ranges are reversed, it works without having to reverse the ranges. Linear range conversion is based upon the linear equation Y=Xm+n, where m and n are derived from the given ranges. Rather than refer to the ranges as min and max, it would be better to refer to them as 1 and 2. So the formula would be: Where Y=y1 when X=x1, and Y=y2 when X=x2. x1, x2, y1 & y2 can be given any positive or negative value. Defining the expression in a macro makes it more useful,it can then be used with any argument names. The float cast would ensure floating point division in the case where all the arguments are integer values.\nDepending on the application it may not be necessary to check the ranges x1=x2 and y1==y2."}, {"id": 27137732, "score": 1, "vote": 0, "content": "<p>C++ Variant</p>\n<p>I found PenguinTD's Solution usefull, so i ported it to C++ if anyone needs it:</p>\n<blockquote>\n<p>float remap(float x, float oMin, float oMax, float nMin, float nMax ){</p>\n<pre><code class=\"python\">//range check\nif( oMin == oMax) {\n    //std::cout&lt;&lt; \"Warning: Zero input range\";\n    return -1;    }\n\nif( nMin == nMax){\n    //std::cout&lt;&lt;\"Warning: Zero output range\";\n    return -1;        }\n\n//check reversed input range\nbool reverseInput = false;\nfloat oldMin = min( oMin, oMax );\nfloat oldMax = max( oMin, oMax );\nif (oldMin == oMin)\n    reverseInput = true;\n\n//check reversed output range\nbool reverseOutput = false;  \nfloat newMin = min( nMin, nMax );\nfloat newMax = max( nMin, nMax );\nif (newMin == nMin)\n    reverseOutput = true;\n\nfloat portion = (x-oldMin)*(newMax-newMin)/(oldMax-oldMin);\nif (reverseInput)\n    portion = (oldMax-x)*(newMax-newMin)/(oldMax-oldMin);\n\nfloat result = portion + newMin;\nif (reverseOutput)\n    result = newMax - portion;\n\nreturn result; }\n</code></pre>\n</blockquote>\n", "abstract": "C++ Variant I found PenguinTD's Solution usefull, so i ported it to C++ if anyone needs it: float remap(float x, float oMin, float oMax, float nMin, float nMax ){"}, {"id": 36244586, "score": 1, "vote": 0, "content": "<p>PHP Port</p>\n<p>Found PenguinTD's solution helpful so I ported it to PHP. Help yourself!</p>\n<pre><code class=\"python\">/**\n* =====================================\n*              Remap Range            \n* =====================================\n* - Convert one range to another. (including value)\n*\n* @param    int $intValue   The value in the old range you wish to convert\n* @param    int $oMin       The minimum of the old range\n* @param    int $oMax       The maximum of the old range\n* @param    int $nMin       The minimum of the new range\n* @param    int $nMax       The maximum of the new range\n*\n* @return   float $fResult  The old value converted to the new range\n*/\nfunction remapRange($intValue, $oMin, $oMax, $nMin, $nMax) {\n    // Range check\n    if ($oMin == $oMax) {\n        echo 'Warning: Zero input range';\n        return false;\n    }\n\n    if ($nMin == $nMax) {\n        echo 'Warning: Zero output range';\n        return false;\n    }\n\n    // Check reversed input range\n    $bReverseInput = false;\n    $intOldMin = min($oMin, $oMax);\n    $intOldMax = max($oMin, $oMax);\n    if ($intOldMin != $oMin) {\n        $bReverseInput = true;\n    }\n\n    // Check reversed output range\n    $bReverseOutput = false;\n    $intNewMin = min($nMin, $nMax);\n    $intNewMax = max($nMin, $nMax);\n    if ($intNewMin != $nMin) {\n        $bReverseOutput = true;\n    }\n\n    $fRatio = ($intValue - $intOldMin) * ($intNewMax - $intNewMin) / ($intOldMax - $intOldMin);\n    if ($bReverseInput) {\n        $fRatio = ($intOldMax - $intValue) * ($intNewMax - $intNewMin) / ($intOldMax - $intOldMin);\n    }\n\n    $fResult = $fRatio + $intNewMin;\n    if ($bReverseOutput) {\n        $fResult = $intNewMax - $fRatio;\n    }\n\n    return $fResult;\n}\n</code></pre>\n", "abstract": "PHP Port Found PenguinTD's solution helpful so I ported it to PHP. Help yourself!"}, {"id": 55088673, "score": 1, "vote": 0, "content": "<p>Here is a Javascript version that returns a function that does the rescaling for predetermined source and destination ranges, minimizing the amount of computation that has to be done each time.</p>\n<pre><code class=\"python\">// This function returns a function bound to the \n// min/max source &amp; target ranges given.\n// oMin, oMax = source\n// nMin, nMax = dest.\nfunction makeRangeMapper(oMin, oMax, nMin, nMax ){\n    //range check\n    if (oMin == oMax){\n        console.log(\"Warning: Zero input range\");\n        return undefined;\n    };\n\n    if (nMin == nMax){\n        console.log(\"Warning: Zero output range\");\n        return undefined\n    }\n\n    //check reversed input range\n    var reverseInput = false;\n    let oldMin = Math.min( oMin, oMax );\n    let oldMax = Math.max( oMin, oMax );\n    if (oldMin != oMin){\n        reverseInput = true;\n    }\n\n    //check reversed output range\n    var reverseOutput = false;  \n    let newMin = Math.min( nMin, nMax )\n    let newMax = Math.max( nMin, nMax )\n    if (newMin != nMin){\n        reverseOutput = true;\n    }\n\n    // Hot-rod the most common case.\n    if (!reverseInput &amp;&amp; !reverseOutput) {\n        let dNew = newMax-newMin;\n        let dOld = oldMax-oldMin;\n        return (x)=&gt;{\n            return ((x-oldMin)* dNew / dOld) + newMin;\n        }\n    }\n\n    return (x)=&gt;{\n        let portion;\n        if (reverseInput){\n            portion = (oldMax-x)*(newMax-newMin)/(oldMax-oldMin);\n        } else {\n            portion = (x-oldMin)*(newMax-newMin)/(oldMax-oldMin)\n        }\n        let result;\n        if (reverseOutput){\n            result = newMax - portion;\n        } else {\n            result = portion + newMin;\n        }\n\n        return result;\n    }   \n}\n</code></pre>\n<p>Here is an example of using this function to scale 0-1 into -0x80000000, 0x7FFFFFFF</p>\n<pre><code class=\"python\">let normTo32Fn = makeRangeMapper(0, 1, -0x80000000, 0x7FFFFFFF);\nlet fs = normTo32Fn(0.5);\nlet fs2 = normTo32Fn(0);\n</code></pre>\n", "abstract": "Here is a Javascript version that returns a function that does the rescaling for predetermined source and destination ranges, minimizing the amount of computation that has to be done each time. Here is an example of using this function to scale 0-1 into -0x80000000, 0x7FFFFFFF"}, {"id": 57571692, "score": 1, "vote": 0, "content": "<h1>List comprehension one liner solution</h1>\n<pre><code class=\"python\">color_array_new = [int((((x - min(node_sizes)) * 99) / (max(node_sizes) - min(node_sizes))) + 1) for x in node_sizes]\n</code></pre>\n<h1>Longer version</h1>\n<pre><code class=\"python\">def colour_specter(waste_amount):\ncolor_array = []\nOldRange = max(waste_amount) - min(waste_amount)\nNewRange = 99\nfor number_value in waste_amount:\n    NewValue = int((((number_value - min(waste_amount)) * NewRange) / OldRange) + 1)\n    color_array.append(NewValue)\nprint(color_array)\nreturn color_array\n</code></pre>\n", "abstract": ""}, {"id": 61514280, "score": 1, "vote": 0, "content": "<h1>Java Version</h1>\n<p>Always works no matter what you feed it!</p>\n<p>I left everything expanded out so that it's easier to follow for learning. Rounding at the end, of course, is optional.</p>\n<pre><code class=\"python\">    private long remap(long p, long Amin, long Amax, long Bmin, long Bmax ) {\n\n    double deltaA = Amax - Amin;\n    double deltaB = Bmax - Bmin;\n    double scale  = deltaB / deltaA;\n    double negA   = -1 * Amin;\n    double offset = (negA * scale) + Bmin;\n    double q      = (p * scale) + offset;\n    return Math.round(q);\n\n}\n</code></pre>\n", "abstract": "Always works no matter what you feed it! I left everything expanded out so that it's easier to follow for learning. Rounding at the end, of course, is optional."}, {"id": 63527358, "score": 1, "vote": 0, "content": "<p>I wrote a function to do this in R. The method is the same as above, but I needed to do this a bunch of times in R, so I thought I'd share in case it helps anybody.</p>\n<pre><code class=\"python\">convertRange &lt;- function(\n  oldValue,\n  oldRange = c(-16000.00, 16000.00), \n  newRange = c(0, 100),\n  returnInt = TRUE # the poster asked for an integer, so this is an option\n){\n  oldMin &lt;- oldRange[1]\n  oldMax &lt;- oldRange[2]\n  newMin &lt;- newRange[1]\n  newMax &lt;- newRange[2]\n  newValue = (((oldValue - oldMin)* (newMax - newMin)) / (oldMax - oldMin)) + newMin\n  \n  if(returnInt){\n   return(round(newValue))\n  } else {\n   return(newValue)\n  }\n}\n</code></pre>\n", "abstract": "I wrote a function to do this in R. The method is the same as above, but I needed to do this a bunch of times in R, so I thought I'd share in case it helps anybody."}, {"id": 69263528, "score": 1, "vote": 0, "content": "<p>Using <code>Numpy</code> and <code>interp</code> function, you can <strong>convert your value from old range to new range</strong>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; np.interp(0, [-16000,16000], [0,100])\n50.0\n</code></pre>\n<p>You can also try it to <strong>map a list of values</strong>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; np.interp([-16000,0,12000] ,[-16000,16000], [0,100])\narray([ 0. , 50. , 87.5])\n</code></pre>\n", "abstract": "Using Numpy and interp function, you can convert your value from old range to new range: You can also try it to map a list of values:"}, {"id": 29505969, "score": 0, "vote": 0, "content": "<p><strong>Short-cut/simplified proposal</strong> </p>\n<pre><code class=\"python\"> NewRange/OldRange = Handy multiplicand or HM\n Convert OldValue in OldRange to NewValue in NewRange = \n (OldValue - OldMin x HM) + NewMin\n</code></pre>\n<p>wayne</p>\n", "abstract": "Short-cut/simplified proposal  wayne"}, {"id": 47213855, "score": 0, "vote": 0, "content": "<p>This example converts a songs current position into an angle range of 20 - 40.  </p>\n<pre><code class=\"python\">    /// &lt;summary&gt;\n    /// This test converts Current songtime to an angle in a range. \n    /// &lt;/summary&gt;\n    [Fact]\n    public void ConvertRangeTests()\n    {            \n       //Convert a songs time to an angle of a range 20 - 40\n        var result = ConvertAndGetCurrentValueOfRange(\n            TimeSpan.Zero, TimeSpan.FromMinutes(5.4),\n            20, 40, \n            2.7\n            );\n\n        Assert.True(result == 30);\n    }\n\n    /// &lt;summary&gt;\n    /// Gets the current value from the mixValue maxValue range.        \n    /// &lt;/summary&gt;\n    /// &lt;param name=\"startTime\"&gt;Start of the song&lt;/param&gt;\n    /// &lt;param name=\"duration\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"minValue\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"maxValue\"&gt;&lt;/param&gt;\n    /// &lt;param name=\"value\"&gt;Current time&lt;/param&gt;\n    /// &lt;returns&gt;&lt;/returns&gt;\n    public double ConvertAndGetCurrentValueOfRange(\n                TimeSpan startTime,\n                TimeSpan duration,\n                double minValue,\n                double maxValue,\n                double value)\n    {\n        var timeRange = duration - startTime;\n        var newRange = maxValue - minValue;\n        var ratio = newRange / timeRange.TotalMinutes;\n        var newValue = value * ratio;\n        var currentValue= newValue + minValue;\n        return currentValue;\n    }\n</code></pre>\n", "abstract": "This example converts a songs current position into an angle range of 20 - 40.  "}]}, {"link": "https://stackoverflow.com/questions/4941753/is-there-a-math-ncr-function-in-python", "question": {"id": "4941753", "title": "Is there a math nCr function in python?", "content": "<p>I'm looking to see if built in with the math library in python is the nCr (n Choose r) function:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/OZj2Y.png\"/></p>\n<p>I understand that this can be programmed but I thought that I'd check to see if it's already built in before I do.</p>\n", "abstract": "I'm looking to see if built in with the math library in python is the nCr (n Choose r) function:  I understand that this can be programmed but I thought that I'd check to see if it's already built in before I do."}, "answers": [{"id": 4941932, "score": 347, "vote": 0, "content": "<p>The following program calculates <code>nCr</code> in an efficient manner (compared to calculating factorials etc.)</p>\n<pre><code class=\"python\">import operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\n    denom = reduce(op.mul, range(1, r+1), 1)\n    return numer // denom  # or / in Python 2\n</code></pre>\n<hr/>\n<p>As of Python 3.8, binomial coefficients are available in the standard library as <code>math.comb</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from math import comb\n&gt;&gt;&gt; comb(10,3)\n120\n</code></pre>\n", "abstract": "The following program calculates nCr in an efficient manner (compared to calculating factorials etc.) As of Python 3.8, binomial coefficients are available in the standard library as math.comb:"}, {"id": 4941846, "score": 232, "vote": 0, "content": "<p>Do you want iteration? <a href=\"http://docs.python.org/library/itertools.html?highlight=itertools.combinations#itertools.combinations\" rel=\"nofollow noreferrer\">itertools.combinations</a>.  Common usage:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; itertools.combinations('abcd',2)\n&lt;itertools.combinations object at 0x01348F30&gt;\n&gt;&gt;&gt; list(itertools.combinations('abcd',2))\n[('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'c'), ('b', 'd'), ('c', 'd')]\n&gt;&gt;&gt; [''.join(x) for x in itertools.combinations('abcd',2)]\n['ab', 'ac', 'ad', 'bc', 'bd', 'cd']\n</code></pre>\n<p>If you just need to compute the formula, <a href=\"http://docs.python.org/library/math.html?highlight=math.factorial#math.factorial\" rel=\"nofollow noreferrer\">math.factorial</a> can be used, but is not fast for large combinations, but see <code>math.comb</code> below for an optimized calculation available in Python 3.8+:</p>\n<pre><code class=\"python\">import math\n\ndef nCr(n,r):\n    f = math.factorial\n    return f(n) // f(r) // f(n-r)\n\nif __name__ == '__main__':\n    print nCr(4,2)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">6\n</code></pre>\n<p>As of Python 3.8, <code>math.comb</code> can be used and is much faster:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.comb(4,2)\n6\n</code></pre>\n", "abstract": "Do you want iteration? itertools.combinations.  Common usage: If you just need to compute the formula, math.factorial can be used, but is not fast for large combinations, but see math.comb below for an optimized calculation available in Python 3.8+: Output: As of Python 3.8, math.comb can be used and is much faster:"}]}, {"link": "https://stackoverflow.com/questions/3387655/safest-way-to-convert-float-to-integer-in-python", "question": {"id": "3387655", "title": "Safest way to convert float to integer in python?", "content": "<p>Python's math module contain handy functions like <code>floor</code> &amp; <code>ceil</code>. These functions take a floating point number and return the nearest integer below or above it. However these functions return the answer as a floating point number. For example:</p>\n<pre><code class=\"python\">import math\nf=math.floor(2.3)\n</code></pre>\n<p>Now <code>f</code> returns:</p>\n<pre><code class=\"python\">2.0\n</code></pre>\n<p>What is the safest way to get an integer out of this float, without running the risk of rounding errors (for example if the float is the equivalent of 1.99999) or perhaps I should use another function altogether?</p>\n", "abstract": "Python's math module contain handy functions like floor & ceil. These functions take a floating point number and return the nearest integer below or above it. However these functions return the answer as a floating point number. For example: Now f returns: What is the safest way to get an integer out of this float, without running the risk of rounding errors (for example if the float is the equivalent of 1.99999) or perhaps I should use another function altogether?"}, "answers": [{"id": 3387715, "score": 206, "vote": 0, "content": "<p>All integers that can be represented by floating point numbers have an exact representation. So you can safely use <code>int</code> on the result. Inexact representations occur only if you are trying to represent a rational number with a denominator that is not a power of two.</p>\n<p>That this works is not trivial at all! It's a property of the IEEE floating point representation that int\u2218floor = \u230a\u22c5\u230b if the magnitude of the numbers in question is small enough, but different representations are possible where int(floor(2.3)) might be 1.</p>\n<p>To quote from <a href=\"http://en.wikipedia.org/w/index.php?title=Floating_point&amp;oldid=376101741#IEEE_754:_floating_point_in_modern_computers\" rel=\"noreferrer\">Wikipedia</a>,</p>\n<blockquote>\n<p>Any integer with absolute value less than or equal to 2<sup>24</sup> can be exactly represented in the single precision format, and any integer with absolute value less than or equal to 2<sup>53</sup> can be exactly represented in the double precision format.</p>\n</blockquote>\n", "abstract": "All integers that can be represented by floating point numbers have an exact representation. So you can safely use int on the result. Inexact representations occur only if you are trying to represent a rational number with a denominator that is not a power of two. That this works is not trivial at all! It's a property of the IEEE floating point representation that int\u2218floor = \u230a\u22c5\u230b if the magnitude of the numbers in question is small enough, but different representations are possible where int(floor(2.3)) might be 1. To quote from Wikipedia, Any integer with absolute value less than or equal to 224 can be exactly represented in the single precision format, and any integer with absolute value less than or equal to 253 can be exactly represented in the double precision format."}, {"id": 14536398, "score": 146, "vote": 0, "content": "<p>Use <code>int(your non integer number)</code> will nail it.</p>\n<pre><code class=\"python\">print int(2.3) # \"2\"\nprint int(math.sqrt(5)) # \"2\"\n</code></pre>\n", "abstract": "Use int(your non integer number) will nail it."}, {"id": 3387769, "score": 57, "vote": 0, "content": "<p>You could use the round function.  If you use no second parameter (# of significant digits) then I think you will get the behavior you want.</p>\n<p>IDLE output.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; round(2.99999999999)\n3\n&gt;&gt;&gt; round(2.6)\n3\n&gt;&gt;&gt; round(2.5)\n3\n&gt;&gt;&gt; round(2.4)\n2\n</code></pre>\n", "abstract": "You could use the round function.  If you use no second parameter (# of significant digits) then I think you will get the behavior you want. IDLE output."}, {"id": 24342897, "score": 47, "vote": 0, "content": "<p>Combining two of the previous results, we have:</p>\n<pre><code class=\"python\">int(round(some_float))\n</code></pre>\n<p>This converts a float to an integer fairly dependably.</p>\n", "abstract": "Combining two of the previous results, we have: This converts a float to an integer fairly dependably."}, {"id": 14538905, "score": 19, "vote": 0, "content": "<blockquote>\n<p>That this works is not trivial at all! It's a property of the IEEE floating point representation that int\u2218floor = \u230a\u22c5\u230b if the magnitude of the numbers in question is small enough, but different representations are possible where int(floor(2.3)) might be 1.</p>\n</blockquote>\n<p><em>This post explains why it works in that range</em>.</p>\n<p>In a double, you can represent 32bit integers without any problems. There <em>cannot</em> be any rounding issues. More precisely, doubles can represent <strong><em>all</em></strong> integers between and including <em>2<sup>53</sup></em> and <em>-2<sup>53</sup></em>.</p>\n<p><strong>Short explanation</strong>: A double can store up to 53 binary digits. When you require more, the number is padded with zeroes on the right.</p>\n<p>It follows that 53 ones is the largest number that can be stored without padding. Naturally, all (integer) numbers requiring less digits can be stored accurately.</p>\n<p>Adding one to <em>111(omitted)111</em> (53 ones) yields 100...000, (53 zeroes). As we know, we can store 53 digits, that makes the rightmost zero padding.</p>\n<p>This is where 2<sup>53</sup> comes from.</p>\n<hr/>\n<p><strong>More detail:</strong> We need to consider how IEEE-754 floating point works.</p>\n<pre><code class=\"python\">  1 bit    11 / 8     52 / 23      # bits double/single precision\n[ sign |  exponent | mantissa ]\n</code></pre>\n<p>The number is then calculated as follows (excluding special cases that are irrelevant here):</p>\n<blockquote>\n<p><em>-1<sup>sign</sup> \u00d7 1.mantissa \u00d72<sup>exponent - bias</sup></em></p>\n</blockquote>\n<p>where <em>bias = 2<sup>exponent - 1</sup> - 1</em>, i.e. 1023 and 127 for double/single precision respectively.</p>\n<p>Knowing that multiplying by <em>2<sup>X</sup></em> simply shifts all bits <em>X</em> places to the left, it's easy to see that any integer must have all bits in the mantissa that end up right of the decimal point to zero.</p>\n<p>Any integer except zero has the following form in binary:</p>\n<blockquote>\n<p><em>1x...x</em> where the <em>x</em>-es represent the bits to the right of the MSB (most significant bit).</p>\n</blockquote>\n<p>Because we excluded zero, there will <em>always</em> be a MSB that is one\u2014which is why it's not stored. To store the integer, we must bring it into the aforementioned form: <em>-1<sup>sign</sup> \u00d7 1.mantissa \u00d72<sup>exponent - bias</sup></em>.</p>\n<p>That's saying the same as shifting the bits over the decimal point until there's only the MSB towards the left of the MSB. All the bits right of the decimal point are then stored in the mantissa.</p>\n<p>From this, we can see that we can store at most 52 binary digits apart from the MSB.</p>\n<p>It follows that the highest number where all bits are explicitly stored is</p>\n<pre><code class=\"python\">111(omitted)111.   that's 53 ones (52 + implicit 1) in the case of doubles.\n</code></pre>\n<p>For this, we need to set the exponent, such that the decimal point will be shifted 52 places. If we were to increase the exponent by one, we cannot know the digit right to the left after the decimal point.</p>\n<pre><code class=\"python\">111(omitted)111x.\n</code></pre>\n<p>By convention, it's 0. Setting the entire mantissa to zero, we receive the following number:</p>\n<pre><code class=\"python\">100(omitted)00x. = 100(omitted)000.\n</code></pre>\n<p>That's a 1 followed by 53 zeroes, 52 stored and 1 added due to the exponent.</p>\n<p>It represents <em>2<sup>53</sup></em>, which marks the boundary (both negative and positive) between which we can accurately represent all integers. If we wanted to add one to <em>2<sup>53</sup></em>, we would have to set the implicit zero (denoted by the <code>x</code>) to one, but that's impossible.</p>\n", "abstract": "That this works is not trivial at all! It's a property of the IEEE floating point representation that int\u2218floor = \u230a\u22c5\u230b if the magnitude of the numbers in question is small enough, but different representations are possible where int(floor(2.3)) might be 1. This post explains why it works in that range. In a double, you can represent 32bit integers without any problems. There cannot be any rounding issues. More precisely, doubles can represent all integers between and including 253 and -253. Short explanation: A double can store up to 53 binary digits. When you require more, the number is padded with zeroes on the right. It follows that 53 ones is the largest number that can be stored without padding. Naturally, all (integer) numbers requiring less digits can be stored accurately. Adding one to 111(omitted)111 (53 ones) yields 100...000, (53 zeroes). As we know, we can store 53 digits, that makes the rightmost zero padding. This is where 253 comes from. More detail: We need to consider how IEEE-754 floating point works. The number is then calculated as follows (excluding special cases that are irrelevant here): -1sign \u00d7 1.mantissa \u00d72exponent - bias where bias = 2exponent - 1 - 1, i.e. 1023 and 127 for double/single precision respectively. Knowing that multiplying by 2X simply shifts all bits X places to the left, it's easy to see that any integer must have all bits in the mantissa that end up right of the decimal point to zero. Any integer except zero has the following form in binary: 1x...x where the x-es represent the bits to the right of the MSB (most significant bit). Because we excluded zero, there will always be a MSB that is one\u2014which is why it's not stored. To store the integer, we must bring it into the aforementioned form: -1sign \u00d7 1.mantissa \u00d72exponent - bias. That's saying the same as shifting the bits over the decimal point until there's only the MSB towards the left of the MSB. All the bits right of the decimal point are then stored in the mantissa. From this, we can see that we can store at most 52 binary digits apart from the MSB. It follows that the highest number where all bits are explicitly stored is For this, we need to set the exponent, such that the decimal point will be shifted 52 places. If we were to increase the exponent by one, we cannot know the digit right to the left after the decimal point. By convention, it's 0. Setting the entire mantissa to zero, we receive the following number: That's a 1 followed by 53 zeroes, 52 stored and 1 added due to the exponent. It represents 253, which marks the boundary (both negative and positive) between which we can accurately represent all integers. If we wanted to add one to 253, we would have to set the implicit zero (denoted by the x) to one, but that's impossible."}, {"id": 49134565, "score": 12, "vote": 0, "content": "<p>If you need to convert a string float to an int you can use this method.</p>\n<p>Example: <code>'38.0'</code> to <code>38</code></p>\n<p>In order to convert this to an int you can cast it as a float then an int. This will also work for float strings or integer strings.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; int(float('38.0'))\n38\n&gt;&gt;&gt; int(float('38'))\n38\n</code></pre>\n<p><strong>Note</strong>: This will strip any numbers after the decimal.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; int(float('38.2'))\n38\n</code></pre>\n", "abstract": "If you need to convert a string float to an int you can use this method. Example: '38.0' to 38 In order to convert this to an int you can cast it as a float then an int. This will also work for float strings or integer strings. Note: This will strip any numbers after the decimal."}, {"id": 3387714, "score": 9, "vote": 0, "content": "<p><code>math.floor</code> will always return an integer number and thus <code>int(math.floor(some_float))</code> will never introduce rounding errors.</p>\n<p>The rounding error might already be introduced in <code>math.floor(some_large_float)</code>, though, or even when storing a large number in a float in the first place. (Large numbers may lose precision when stored in floats.)</p>\n", "abstract": "math.floor will always return an integer number and thus int(math.floor(some_float)) will never introduce rounding errors. The rounding error might already be introduced in math.floor(some_large_float), though, or even when storing a large number in a float in the first place. (Large numbers may lose precision when stored in floats.)"}, {"id": 36505607, "score": 2, "vote": 0, "content": "<p>Another code sample to convert a real/float to an integer using variables.\n\"vel\" is a real/float number and converted to the next highest INTEGER, \"newvel\".</p>\n<pre><code class=\"python\">import arcpy.math, os, sys, arcpy.da\n.\n.\nwith arcpy.da.SearchCursor(densifybkp,[floseg,vel,Length]) as cursor:\n for row in cursor:\n    curvel = float(row[1])\n    newvel = int(math.ceil(curvel))\n</code></pre>\n", "abstract": "Another code sample to convert a real/float to an integer using variables.\n\"vel\" is a real/float number and converted to the next highest INTEGER, \"newvel\"."}, {"id": 52446800, "score": 2, "vote": 0, "content": "<p>Since you're asking for the 'safest' way, I'll provide another answer other than the top answer.</p>\n<p>An easy way to make sure you don't lose any precision is to check if the values would be equal after you convert them. </p>\n<pre><code class=\"python\">if int(some_value) == some_value:\n     some_value = int(some_value)\n</code></pre>\n<p>If the float is 1.0 for example,  1.0 is equal to 1. So the conversion to int will execute. And if the float is 1.1, int(1.1) equates to 1, and 1.1 != 1. So the value will remain a float and you won't lose any precision.</p>\n", "abstract": "Since you're asking for the 'safest' way, I'll provide another answer other than the top answer. An easy way to make sure you don't lose any precision is to check if the values would be equal after you convert them.  If the float is 1.0 for example,  1.0 is equal to 1. So the conversion to int will execute. And if the float is 1.1, int(1.1) equates to 1, and 1.1 != 1. So the value will remain a float and you won't lose any precision."}]}, {"link": "https://stackoverflow.com/questions/56227419/why-does-pythons-hash-of-infinity-have-the-digits-of-%cf%80", "question": {"id": "56227419", "title": "Why does Python&#39;s hash of infinity have the digits of \u03c0?", "content": "<p>The hash of infinity in Python has digits matching <a href=\"https://en.wikipedia.org/wiki/Pi\" rel=\"noreferrer\">pi</a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; inf = float('inf')\n&gt;&gt;&gt; hash(inf)\n314159\n&gt;&gt;&gt; int(math.pi*1e5)\n314159\n</code></pre>\n<p>Is that just a coincidence or is it intentional?</p>\n", "abstract": "The hash of infinity in Python has digits matching pi: Is that just a coincidence or is it intentional?"}, "answers": [{"id": 56227918, "score": 225, "vote": 0, "content": "<p>Summary: It's not a coincidence; <a href=\"https://github.com/python/cpython/blob/a5119e7d75c9729fc36c059d05f3d7132e7f6bb4/Include/pyhash.h#L29\" rel=\"noreferrer\"><code>_PyHASH_INF</code> is hardcoded as 314159</a> in the default CPython implementation of Python, and was picked as an arbitrary value (obviously from the digits of \u03c0) <a href=\"https://github.com/python/cpython/commit/39dce29365d287dc6b353b2a527dc11fe58dcfa6#diff-b1b488004963172ac81a4a8127ecfd23R560\" rel=\"noreferrer\">by Tim Peters in 2000</a>.</p>\n<hr/>\n<p>The value of <code>hash(float('inf'))</code> is one of the system-dependent parameters of the built-in hash function for numeric types, and <a href=\"https://docs.python.org/3/library/sys.html#sys.hash_info\" rel=\"noreferrer\">is also available</a> as <code>sys.hash_info.inf</code> in Python 3:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.hash_info\nsys.hash_info(width=64, modulus=2305843009213693951, inf=314159, nan=0, imag=1000003, algorithm='siphash24', hash_bits=64, seed_bits=128, cutoff=0)\n&gt;&gt;&gt; sys.hash_info.inf\n314159\n</code></pre>\n<p>(Same results <a href=\"https://tio.run/##NYwxCsAgDEV3T9FRh7r0QOKgGNAkaJacPpVit/fh/ccqjfC5WVnNYDBNuZYud5B7lkpzOJ6A4v8Z@fulbfUyCkoWIPQhHG8XYsurJcBKwewF\" rel=\"noreferrer\">with PyPy</a> too.)</p>\n<hr/>\n<p>In terms of code, <a href=\"https://docs.python.org/3/library/functions.html#hash\" rel=\"noreferrer\"><code>hash</code></a> is a built-in function. Calling it on a Python float object invokes the function whose pointer is given by the <a href=\"https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_hash\" rel=\"noreferrer\"><code>tp_hash</code> attribute</a> of the built-in float type (<code>PyTypeObject PyFloat_Type</code>), which <a href=\"https://github.com/python/cpython/blob/a5119e7d75c9729fc36c059d05f3d7132e7f6bb4/Objects/floatobject.c#L1910,L1924\" rel=\"noreferrer\">is</a> the <code>float_hash</code> function, <a href=\"https://github.com/python/cpython/blob/a5119e7d75c9729fc36c059d05f3d7132e7f6bb4/Objects/floatobject.c#L528,L532\" rel=\"noreferrer\">defined</a> as <code>return _Py_HashDouble(v-&gt;ob_fval)</code>, which in turn <a href=\"https://github.com/python/cpython/blob/a5119e7d75c9729fc36c059d05f3d7132e7f6bb4/Python/pyhash.c#L93-L94\" rel=\"noreferrer\">has</a></p>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">    if (Py_IS_INFINITY(v))\n        return v &gt; 0 ? _PyHASH_INF : -_PyHASH_INF;\n</code></pre>\n<p>where <code>_PyHASH_INF</code> is <a href=\"https://github.com/python/cpython/blob/a5119e7d75c9729fc36c059d05f3d7132e7f6bb4/Include/pyhash.h#L29\" rel=\"noreferrer\">defined as</a> 314159:</p>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">#define _PyHASH_INF 314159\n</code></pre>\n<hr/>\n<p>In terms of history, the first mention of <code>314159</code> in this context in the Python code (you can find this with <code>git bisect</code> or <code>git log -S 314159 -p</code>) was added by <a href=\"https://en.wikipedia.org/w/index.php?title=Tim_Peters_(software_engineer)&amp;oldid=886078303\" rel=\"noreferrer\">Tim Peters</a> in August 2000, in what is now  commit <a href=\"https://github.com/python/cpython/commit/39dce29365d287dc6b353b2a527dc11fe58dcfa6\" rel=\"noreferrer\">39dce293</a> in the <code>cpython</code> git repository.</p>\n<p>The commit message says:</p>\n<blockquote>\n<p>Fix for <a href=\"http://sourceforge.net/bugs/?func=detailbug&amp;bug_id=111866&amp;group_id=5470\" rel=\"noreferrer\">http://sourceforge.net/bugs/?func=detailbug&amp;bug_id=111866&amp;group_id=5470</a>.\n  This was a misleading bug -- the true \"bug\" was that <code>hash(x)</code> gave an error\n  return when <code>x</code> is an infinity.  Fixed that.  Added new <code>Py_IS_INFINITY</code> macro to\n  <code>pyport.h</code>.  Rearranged code to reduce growing duplication in hashing of float and\n  complex numbers, pushing Trent's earlier stab at that to a logical conclusion.\n  Fixed exceedingly rare bug where hashing of floats could return -1 even if there\n  wasn't an error (didn't waste time trying to construct a test case, it was simply\n  obvious from the code that it <em>could</em> happen).  Improved complex hash so that\n  <code>hash(complex(x, y))</code> doesn't systematically equal <code>hash(complex(y, x))</code> anymore.</p>\n</blockquote>\n<p>In particular, in this commit he ripped out the code of <code>static long float_hash(PyFloatObject *v)</code> in <code>Objects/floatobject.c</code> and made it just <code>return _Py_HashDouble(v-&gt;ob_fval);</code>, and in the definition of <code>long _Py_HashDouble(double v)</code> in <code>Objects/object.c</code> he added the lines:</p>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">        if (Py_IS_INFINITY(intpart))\n            /* can't convert to long int -- arbitrary */\n            v = v &lt; 0 ? -271828.0 : 314159.0;\n</code></pre>\n<p>So as mentioned, it was an arbitrary choice. Note that 271828 is formed from the first few decimal digits of <a href=\"https://en.wikipedia.org/wiki/e_(mathematical_constant)\" rel=\"noreferrer\">e</a>.</p>\n<p>Related later commits:</p>\n<ul>\n<li><p><a href=\"https://github.com/python/cpython/commit/f3eeca16cbadd7da5836ed781572343863b1a074\" rel=\"noreferrer\">By Mark Dickinson in Apr 2010</a> (<a href=\"https://github.com/python/cpython/commit/ac256ab2843dfb6c28af0227202df67664ed462e\" rel=\"noreferrer\">also</a>), making the <code>Decimal</code> type behave similarly</p></li>\n<li><p><a href=\"https://github.com/python/cpython/commit/5e0c2748fb2e16b3b0f33f0bb55f1aaa1272f887\" rel=\"noreferrer\">By Mark Dickinson in Apr 2010</a> (<a href=\"https://github.com/python/cpython/commit/5daab45158094e577b9791cda7d8a0f4e34f45cb\" rel=\"noreferrer\">also</a>), moving this check to the top and adding test cases</p></li>\n<li><p><a href=\"https://github.com/python/cpython/commit/dc787d2055a7b562b64ca91b8f1af6d49fa39f1c\" rel=\"noreferrer\">By Mark Dickinson in May 2010</a> as <a href=\"https://bugs.python.org/issue8188\" rel=\"noreferrer\">issue 8188</a>, completely rewriting the hash function to <a href=\"https://docs.python.org/3/library/stdtypes.html#hashing-of-numeric-types\" rel=\"noreferrer\">its current implementation</a>, but retaining this special case, giving the constant a name <code>_PyHASH_INF</code> (also removing the 271828 which is why in Python 3 <code>hash(float('-inf'))</code> returns <code>-314159</code> rather than <code>-271828</code> as it does in Python 2)</p></li>\n<li><p><a href=\"https://github.com/python/cpython/commit/e7dfe74ce39cad736da8e3a24fdc4cfb50c7c515\" rel=\"noreferrer\">By Raymond Hettinger in Jan 2011</a>, adding an explicit example in the \"What's new\" for Python 3.2 of <code>sys.hash_info</code> showing the above value. (See <a href=\"https://docs.python.org/3/whatsnew/3.2.html#decimal-and-fractions\" rel=\"noreferrer\">here</a>.)</p></li>\n<li><p><a href=\"https://github.com/python/cpython/commit/1919b7e72bc43315b32f38a6f5f01e8c717907f4\" rel=\"noreferrer\">By Stefan Krah in Mar 2012</a> modifying the Decimal module but keeping this hash.</p></li>\n<li><p><a href=\"https://github.com/python/cpython/commit/985ecdcfc29adfc36ce2339acf03f819ad414869\" rel=\"noreferrer\">By Christian Heimes in Nov 2013</a>, moved the definition of <code>_PyHASH_INF</code> from <code>Include/pyport.h</code> to <code>Include/pyhash.h</code> where it now lives.</p></li>\n</ul>\n", "abstract": "Summary: It's not a coincidence; _PyHASH_INF is hardcoded as 314159 in the default CPython implementation of Python, and was picked as an arbitrary value (obviously from the digits of \u03c0) by Tim Peters in 2000. The value of hash(float('inf')) is one of the system-dependent parameters of the built-in hash function for numeric types, and is also available as sys.hash_info.inf in Python 3: (Same results with PyPy too.) In terms of code, hash is a built-in function. Calling it on a Python float object invokes the function whose pointer is given by the tp_hash attribute of the built-in float type (PyTypeObject PyFloat_Type), which is the float_hash function, defined as return _Py_HashDouble(v->ob_fval), which in turn has where _PyHASH_INF is defined as 314159: In terms of history, the first mention of 314159 in this context in the Python code (you can find this with git bisect or git log -S 314159 -p) was added by Tim Peters in August 2000, in what is now  commit 39dce293 in the cpython git repository. The commit message says: Fix for http://sourceforge.net/bugs/?func=detailbug&bug_id=111866&group_id=5470.\n  This was a misleading bug -- the true \"bug\" was that hash(x) gave an error\n  return when x is an infinity.  Fixed that.  Added new Py_IS_INFINITY macro to\n  pyport.h.  Rearranged code to reduce growing duplication in hashing of float and\n  complex numbers, pushing Trent's earlier stab at that to a logical conclusion.\n  Fixed exceedingly rare bug where hashing of floats could return -1 even if there\n  wasn't an error (didn't waste time trying to construct a test case, it was simply\n  obvious from the code that it could happen).  Improved complex hash so that\n  hash(complex(x, y)) doesn't systematically equal hash(complex(y, x)) anymore. In particular, in this commit he ripped out the code of static long float_hash(PyFloatObject *v) in Objects/floatobject.c and made it just return _Py_HashDouble(v->ob_fval);, and in the definition of long _Py_HashDouble(double v) in Objects/object.c he added the lines: So as mentioned, it was an arbitrary choice. Note that 271828 is formed from the first few decimal digits of e. Related later commits: By Mark Dickinson in Apr 2010 (also), making the Decimal type behave similarly By Mark Dickinson in Apr 2010 (also), moving this check to the top and adding test cases By Mark Dickinson in May 2010 as issue 8188, completely rewriting the hash function to its current implementation, but retaining this special case, giving the constant a name _PyHASH_INF (also removing the 271828 which is why in Python 3 hash(float('-inf')) returns -314159 rather than -271828 as it does in Python 2) By Raymond Hettinger in Jan 2011, adding an explicit example in the \"What's new\" for Python 3.2 of sys.hash_info showing the above value. (See here.) By Stefan Krah in Mar 2012 modifying the Decimal module but keeping this hash. By Christian Heimes in Nov 2013, moved the definition of _PyHASH_INF from Include/pyport.h to Include/pyhash.h where it now lives."}, {"id": 56227651, "score": 49, "vote": 0, "content": "<p><code>_PyHASH_INF</code> is <a href=\"https://github.com/python/cpython/blob/35d5068928ab5485e5f28b60b1e33062bc2c46cc/Include/pyhash.h#L31\" rel=\"nofollow noreferrer\">defined as a constant</a> equal to <code>314159</code>.</p>\n<p>I can't find any discussion about this, or comments giving a reason.  I think it was chosen more or less arbitrarily.  I imagine that as long as they don't use the same meaningful value for other hashes, it shouldn't matter.</p>\n", "abstract": "_PyHASH_INF is defined as a constant equal to 314159. I can't find any discussion about this, or comments giving a reason.  I think it was chosen more or less arbitrarily.  I imagine that as long as they don't use the same meaningful value for other hashes, it shouldn't matter."}, {"id": 56242834, "score": 13, "vote": 0, "content": "<p>Indeed,</p>\n<pre><code class=\"python\">sys.hash_info.inf\n</code></pre>\n<p>returns <code>314159</code>. The value is not generated, it's built into the source code.\nIn fact,</p>\n<pre><code class=\"python\">hash(float('-inf'))\n</code></pre>\n<p>returns <code>-271828</code>, or approximately -e, in python 2 (<a href=\"https://docs.python.org/3/library/stdtypes.html#hashing-of-numeric-types\" rel=\"nofollow noreferrer\">it's -314159 now</a>).</p>\n<p>The fact that the two most famous irrational numbers of all time are used as the hash values makes it very unlikely to be a coincidence.</p>\n", "abstract": "Indeed, returns 314159. The value is not generated, it's built into the source code.\nIn fact, returns -271828, or approximately -e, in python 2 (it's -314159 now). The fact that the two most famous irrational numbers of all time are used as the hash values makes it very unlikely to be a coincidence."}]}, {"link": "https://stackoverflow.com/questions/33569668/numpy-max-vs-amax-vs-maximum", "question": {"id": "33569668", "title": "numpy max vs amax vs maximum", "content": "<p>numpy has three different functions which seem like they can be used for the same things --- except that <code>numpy.maximum</code> can <em>only</em> be used element-wise, while <code>numpy.max</code> and <code>numpy.amax</code> can be used on particular axes, or all elements.  Why is there more than just <code>numpy.max</code>?  Is there some subtlety to this in performance?</p>\n<p>(Similarly for <code>min</code> vs. <code>amin</code> vs. <code>minimum</code>)</p>\n", "abstract": "numpy has three different functions which seem like they can be used for the same things --- except that numpy.maximum can only be used element-wise, while numpy.max and numpy.amax can be used on particular axes, or all elements.  Why is there more than just numpy.max?  Is there some subtlety to this in performance? (Similarly for min vs. amin vs. minimum)"}, "answers": [{"id": 33569857, "score": 238, "vote": 0, "content": "<p><code>np.max</code> is just an alias for <code>np.amax</code>. This function only works on a <em>single</em> input array and finds the value of maximum element in that entire array (returning a scalar). Alternatively, it takes an <code>axis</code> argument and will find the maximum value along an axis of the input array (returning a new array).</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = np.array([[0, 1, 6],\n                  [2, 4, 1]])\n&gt;&gt;&gt; np.max(a)\n6\n&gt;&gt;&gt; np.max(a, axis=0) # max of each column\narray([2, 4, 6])\n</code></pre>\n<p>The default behaviour of <code>np.maximum</code> is to take <em>two</em> arrays and compute their element-wise maximum. Here, 'compatible' means that one array can be broadcast to the other. For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; b = np.array([3, 6, 1])\n&gt;&gt;&gt; c = np.array([4, 2, 9])\n&gt;&gt;&gt; np.maximum(b, c)\narray([4, 6, 9])\n</code></pre>\n<p>But <code>np.maximum</code> is also a <a href=\"http://docs.scipy.org/doc/numpy/reference/ufuncs.html\" rel=\"noreferrer\">universal function</a> which means that it has other features and methods which come in useful when working with multidimensional arrays. For example you can compute the cumulative maximum over an array (or a particular axis of the array):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d = np.array([2, 0, 3, -4, -2, 7, 9])\n&gt;&gt;&gt; np.maximum.accumulate(d)\narray([2, 2, 3, 3, 3, 7, 9])\n</code></pre>\n<p>This is not possible with <code>np.max</code>.</p>\n<p>You can make <code>np.maximum</code> imitate <code>np.max</code> to a certain extent when using <code>np.maximum.reduce</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; np.maximum.reduce(d)\n9\n&gt;&gt;&gt; np.max(d)\n9\n</code></pre>\n<p>Basic testing suggests the two approaches are comparable in performance; and they should be, as <a href=\"https://github.com/numpy/numpy/blob/v1.16.1/numpy/core/_methods.py#L16-L28\" rel=\"noreferrer\"><code>np.max()</code> actually calls <code>np.maximum.reduce</code></a> to do the computation.</p>\n", "abstract": "np.max is just an alias for np.amax. This function only works on a single input array and finds the value of maximum element in that entire array (returning a scalar). Alternatively, it takes an axis argument and will find the maximum value along an axis of the input array (returning a new array). The default behaviour of np.maximum is to take two arrays and compute their element-wise maximum. Here, 'compatible' means that one array can be broadcast to the other. For example: But np.maximum is also a universal function which means that it has other features and methods which come in useful when working with multidimensional arrays. For example you can compute the cumulative maximum over an array (or a particular axis of the array): This is not possible with np.max. You can make np.maximum imitate np.max to a certain extent when using np.maximum.reduce: Basic testing suggests the two approaches are comparable in performance; and they should be, as np.max() actually calls np.maximum.reduce to do the computation."}, {"id": 33569820, "score": 26, "vote": 0, "content": "<p>You've already stated why <code>np.maximum</code> is different - it returns an array that is the element-wise maximum between two arrays.</p>\n<p>As for <code>np.amax</code> and <code>np.max</code>: they both call the same function - <code>np.max</code> is just an alias for <code>np.amax</code>, and they compute the maximum of all elements in an array, or along an axis of an array.</p>\n<pre><code class=\"python\">In [1]: import numpy as np\n\nIn [2]: np.amax\nOut[2]: &lt;function numpy.core.fromnumeric.amax&gt;\n\nIn [3]: np.max\nOut[3]: &lt;function numpy.core.fromnumeric.amax&gt;\n</code></pre>\n", "abstract": "You've already stated why np.maximum is different - it returns an array that is the element-wise maximum between two arrays. As for np.amax and np.max: they both call the same function - np.max is just an alias for np.amax, and they compute the maximum of all elements in an array, or along an axis of an array."}, {"id": 53022516, "score": 13, "vote": 0, "content": "<p>For completeness, in Numpy there are four <em>maximum</em> related functions. They fall into two different categories: </p>\n<ul>\n<li><code>np.amax/np.max</code>, <code>np.nanmax</code>: for <strong>single array</strong> order statistics</li>\n<li>and <code>np.maximum</code>, <code>np.fmax</code>: for element-wise comparison of <strong>two arrays</strong></li>\n</ul>\n<hr/>\n<h3>I. <a href=\"https://docs.scipy.org/doc/numpy/reference/routines.statistics.html#order-statistics\" rel=\"noreferrer\">For <em>single array</em> order statistics</a></h3>\n<p>NaNs propagator <strong><code>np.amax/np.max</code></strong> and its NaN ignorant counterpart <strong><code>np.nanmax</code></strong>.</p>\n<ul>\n<li><p><code>np.max</code> is just an alias of <code>np.amax</code>, so they are considered as one function.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; np.max.__name__\n'amax'\n&gt;&gt;&gt; np.max is np.amax\nTrue\n</code></pre></li>\n<li><p><code>np.max</code> propagates NaNs while <code>np.nanmax</code> ignores NaNs.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; np.max([np.nan, 3.14, -1])\nnan\n&gt;&gt;&gt; np.nanmax([np.nan, 3.14, -1])\n3.14\n</code></pre></li>\n</ul>\n<h3>II. <a href=\"https://docs.scipy.org/doc/numpy/reference/routines.math.html#miscellaneous\" rel=\"noreferrer\">For element-wise comparison of <em>two arrays</em></a></h3>\n<p>NaNs propagator <strong><code>np.maximum</code></strong> and its NaNs ignorant counterpart <strong><code>np.fmax</code></strong>.</p>\n<ul>\n<li><p>Both functions require two arrays as the first two positional args to compare with.</p>\n<pre><code class=\"python\"># x1 and x2 must be the same shape or can be broadcast\nnp.maximum(x1, x2, /, ...);\nnp.fmax(x1, x2, /, ...)\n</code></pre></li>\n<li><p><code>np.maximum</code> propagates NaNs while <code>np.fmax</code> ignores NaNs.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; np.maximum([np.nan, 3.14, 0], [np.NINF, np.nan, 2.72])\narray([ nan,  nan, 2.72])\n&gt;&gt;&gt; np.fmax([np.nan, 3.14, 0], [np.NINF, np.nan, 2.72])\narray([-inf, 3.14, 2.72])\n</code></pre></li>\n<li><p>The element-wise functions are <a href=\"https://docs.scipy.org/doc/numpy/reference/ufuncs.html\" rel=\"noreferrer\"><code>np.ufunc</code>(<strong>Universal Function</strong>)</a>, which means they have some special properties that normal Numpy function don't have.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; type(np.maximum)\n&lt;class 'numpy.ufunc'&gt;\n&gt;&gt;&gt; type(np.fmax)\n&lt;class 'numpy.ufunc'&gt;\n&gt;&gt;&gt; #---------------#\n&gt;&gt;&gt; type(np.max)\n&lt;class 'function'&gt;\n&gt;&gt;&gt; type(np.nanmax)\n&lt;class 'function'&gt;\n</code></pre></li>\n</ul>\n<hr/>\n<p>And finally, the same rules apply to the four <em>minimum</em> related functions:</p>\n<ul>\n<li><code>np.amin/np.min</code>, <code>np.nanmin</code>; </li>\n<li>and <code>np.minimum</code>, <code>np.fmin</code>.</li>\n</ul>\n", "abstract": "For completeness, in Numpy there are four maximum related functions. They fall into two different categories:  NaNs propagator np.amax/np.max and its NaN ignorant counterpart np.nanmax. np.max is just an alias of np.amax, so they are considered as one function. np.max propagates NaNs while np.nanmax ignores NaNs. NaNs propagator np.maximum and its NaNs ignorant counterpart np.fmax. Both functions require two arrays as the first two positional args to compare with. np.maximum propagates NaNs while np.fmax ignores NaNs. The element-wise functions are np.ufunc(Universal Function), which means they have some special properties that normal Numpy function don't have. And finally, the same rules apply to the four minimum related functions:"}, {"id": 61357628, "score": 2, "vote": 0, "content": "<p><code>np.maximum</code> not only compares elementwise but also compares array elementwise with single value</p>\n<pre><code class=\"python\">&gt;&gt;&gt;np.maximum([23, 14, 16, 20, 25], 18)\narray([23, 18, 18, 20, 25])\n</code></pre>\n", "abstract": "np.maximum not only compares elementwise but also compares array elementwise with single value"}]}, {"link": "https://stackoverflow.com/questions/3410976/how-to-round-a-number-to-significant-figures-in-python", "question": {"id": "3410976", "title": "How to round a number to significant figures in Python", "content": "<p>I need to round a float to be displayed in a UI.  e.g, to one significant figure:</p>\n<pre><code class=\"python\">1234 -&gt; 1000\n\n0.12 -&gt; 0.1\n\n0.012 -&gt; 0.01\n\n0.062 -&gt; 0.06\n\n6253 -&gt; 6000\n\n1999 -&gt; 2000\n</code></pre>\n<p>Is there a nice way to do this using the Python library, or do I have to write it myself?</p>\n", "abstract": "I need to round a float to be displayed in a UI.  e.g, to one significant figure: Is there a nice way to do this using the Python library, or do I have to write it myself?"}, "answers": [{"id": 3411435, "score": 186, "vote": 0, "content": "<p>You can use negative numbers to round integers:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; round(1234, -3)\n1000.0\n</code></pre>\n<p>Thus if you need only most significant digit:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from math import log10, floor\n&gt;&gt;&gt; def round_to_1(x):\n...   return round(x, -int(floor(log10(abs(x)))))\n... \n&gt;&gt;&gt; round_to_1(0.0232)\n0.02\n&gt;&gt;&gt; round_to_1(1234243)\n1000000.0\n&gt;&gt;&gt; round_to_1(13)\n10.0\n&gt;&gt;&gt; round_to_1(4)\n4.0\n&gt;&gt;&gt; round_to_1(19)\n20.0\n</code></pre>\n<p>You'll probably have to take care of turning float to integer if it's bigger than 1.</p>\n", "abstract": "You can use negative numbers to round integers: Thus if you need only most significant digit: You'll probably have to take care of turning float to integer if it's bigger than 1."}, {"id": 3411731, "score": 126, "vote": 0, "content": "<p>%g in string formatting will format a float rounded to some number of significant figures.  It will sometimes use 'e' scientific notation, so convert the rounded string back to a float then through %s string formatting.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; '%s' % float('%.1g' % 1234)\n'1000'\n&gt;&gt;&gt; '%s' % float('%.1g' % 0.12)\n'0.1'\n&gt;&gt;&gt; '%s' % float('%.1g' % 0.012)\n'0.01'\n&gt;&gt;&gt; '%s' % float('%.1g' % 0.062)\n'0.06'\n&gt;&gt;&gt; '%s' % float('%.1g' % 6253)\n'6000.0'\n&gt;&gt;&gt; '%s' % float('%.1g' % 1999)\n'2000.0'\n</code></pre>\n", "abstract": "%g in string formatting will format a float rounded to some number of significant figures.  It will sometimes use 'e' scientific notation, so convert the rounded string back to a float then through %s string formatting."}, {"id": 3413529, "score": 68, "vote": 0, "content": "<p>If you want to have other than 1 significant decimal (otherwise the same as Evgeny):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from math import log10, floor\n&gt;&gt;&gt; def round_sig(x, sig=2):\n...   return round(x, sig-int(floor(log10(abs(x))))-1)\n... \n&gt;&gt;&gt; round_sig(0.0232)\n0.023\n&gt;&gt;&gt; round_sig(0.0232, 1)\n0.02\n&gt;&gt;&gt; round_sig(1234243, 3)\n1230000.0\n</code></pre>\n", "abstract": "If you want to have other than 1 significant decimal (otherwise the same as Evgeny):"}, {"id": 48812729, "score": 63, "vote": 0, "content": "<pre><code class=\"python\">f'{float(f\"{i:.1g}\"):g}'\n# Or with Python &lt;3.6,\n'{:g}'.format(float('{:.1g}'.format(i)))\n</code></pre>\n<p>This solution is different from all of the others because:</p>\n<ol>\n<li>it <strong>exactly</strong> solves the OP question</li>\n<li>it does <strong>not</strong> need any <strong>extra package</strong></li>\n<li>it does <strong>not</strong> need any user-defined <strong>auxiliary function</strong> or <strong>mathematical operation</strong></li>\n</ol>\n<p>For an arbitrary number <code>n</code> of significant figures, you can use:</p>\n<pre><code class=\"python\">print('{:g}'.format(float('{:.{p}g}'.format(i, p=n))))\n</code></pre>\n<p>Test:</p>\n<pre><code class=\"python\">a = [1234, 0.12, 0.012, 0.062, 6253, 1999, -3.14, 0., -48.01, 0.75]\nb = ['{:g}'.format(float('{:.1g}'.format(i))) for i in a]\n# b == ['1000', '0.1', '0.01', '0.06', '6000', '2000', '-3', '0', '-50', '0.8']\n</code></pre>\n<p><em>Note</em>: with this solution, it is not possible to adapt the number of significant figures dynamically from the input because there is no standard way to distinguish numbers with different numbers of trailing zeros (<code>3.14 == 3.1400</code>). If you need to do so, then non-standard functions like the ones provided in the <a href=\"https://github.com/BebeSparkelSparkel/to-precision\" rel=\"noreferrer\">to-precision</a> package are needed.</p>\n", "abstract": "This solution is different from all of the others because: For an arbitrary number n of significant figures, you can use: Test: Note: with this solution, it is not possible to adapt the number of significant figures dynamically from the input because there is no standard way to distinguish numbers with different numbers of trailing zeros (3.14 == 3.1400). If you need to do so, then non-standard functions like the ones provided in the to-precision package are needed."}, {"id": 56974893, "score": 13, "vote": 0, "content": "<p>To directly answer the question, here's my version using naming from the <a href=\"https://stat.ethz.ch/R-manual/R-devel/library/base/html/Round.html\" rel=\"noreferrer\">R function</a>:</p>\n<pre><code class=\"python\">import math\n\ndef signif(x, digits=6):\n    if x == 0 or not math.isfinite(x):\n        return x\n    digits -= math.ceil(math.log10(abs(x)))\n    return round(x, digits)\n</code></pre>\n<p>My main reason for posting this answer are the comments complaining that \"0.075\" rounds to 0.07 rather than 0.08.  This is due, as pointed out by \"Novice C\", to a combination of floating point arithmetic having both <a href=\"https://docs.python.org/3/tutorial/floatingpoint.html\" rel=\"noreferrer\">finite precision and a base-2 representation</a>.  The nearest number to 0.075 that can actually be represented is slightly smaller, hence rounding comes out differently than you might naively expect.</p>\n<p>Also note that this applies to any use of non-decimal floating point arithmetic, e.g. C and Java both have the same issue.</p>\n<p>To show in more detail, we ask Python to format the number in \"hex\" format:</p>\n<pre><code class=\"python\">0.075.hex()\n</code></pre>\n<p>which gives us: <code>0x1.3333333333333p-4</code>.  The reason for doing this is that the normal decimal representation often involves rounding and hence is not how the computer actually \"sees\" the number.  If you're not used to this format, a couple of useful references are the <a href=\"https://docs.python.org/3/library/stdtypes.html#float.hex\" rel=\"noreferrer\">Python docs</a> and the <a href=\"https://en.cppreference.com/w/c/language/floating_constant\" rel=\"noreferrer\">C standard</a>.  </p>\n<p>To show how these numbers work a bit, we can get back to our starting point by doing:</p>\n<pre><code class=\"python\">0x13333333333333 / 16**13 * 2**-4\n</code></pre>\n<p>which should should print out <code>0.075</code>.  <code>16**13</code> is because there are 13 hexadecimal digits after the decimal point, and <code>2**-4</code> is because hex exponents are base-2.</p>\n<p>Now we have some idea of how floats are represented we can use the <code>decimal</code> module to give us some more precision, showing us what's going on:</p>\n<pre><code class=\"python\">from decimal import Decimal\n\nDecimal(0x13333333333333) / 16**13 / 2**4\n</code></pre>\n<p>giving: <code>0.07499999999999999722444243844</code> and hopefully explaining why <code>round(0.075, 2)</code> evaluates to <code>0.07</code></p>\n", "abstract": "To directly answer the question, here's my version using naming from the R function: My main reason for posting this answer are the comments complaining that \"0.075\" rounds to 0.07 rather than 0.08.  This is due, as pointed out by \"Novice C\", to a combination of floating point arithmetic having both finite precision and a base-2 representation.  The nearest number to 0.075 that can actually be represented is slightly smaller, hence rounding comes out differently than you might naively expect. Also note that this applies to any use of non-decimal floating point arithmetic, e.g. C and Java both have the same issue. To show in more detail, we ask Python to format the number in \"hex\" format: which gives us: 0x1.3333333333333p-4.  The reason for doing this is that the normal decimal representation often involves rounding and hence is not how the computer actually \"sees\" the number.  If you're not used to this format, a couple of useful references are the Python docs and the C standard.   To show how these numbers work a bit, we can get back to our starting point by doing: which should should print out 0.075.  16**13 is because there are 13 hexadecimal digits after the decimal point, and 2**-4 is because hex exponents are base-2. Now we have some idea of how floats are represented we can use the decimal module to give us some more precision, showing us what's going on: giving: 0.07499999999999999722444243844 and hopefully explaining why round(0.075, 2) evaluates to 0.07"}, {"id": 44134235, "score": 12, "vote": 0, "content": "<p>I have created the package <a href=\"https://bitbucket.org/william_rusnack/to-precision\" rel=\"noreferrer\">to-precision</a> that does what you want. It allows you to give your numbers more or less significant figures.</p>\n<p>It also outputs standard, scientific, and engineering notation with a specified number of significant figures.</p>\n<p>In the accepted answer there is the line</p>\n<pre><code class=\"python\">&gt;&gt;&gt; round_to_1(1234243)\n1000000.0\n</code></pre>\n<p>That actually specifies 8 sig figs. For the number 1234243 my library only displays one significant figure:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from to_precision import to_precision\n&gt;&gt;&gt; to_precision(1234243, 1, 'std')\n'1000000'\n&gt;&gt;&gt; to_precision(1234243, 1, 'sci')\n'1e6'\n&gt;&gt;&gt; to_precision(1234243, 1, 'eng')\n'1e6'\n</code></pre>\n<p>It will also round the last significant figure and can automatically choose what notation to use if a notation isn't specified:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; to_precision(599, 2)\n'600'\n&gt;&gt;&gt; to_precision(1164, 2)\n'1.2e3'\n</code></pre>\n", "abstract": "I have created the package to-precision that does what you want. It allows you to give your numbers more or less significant figures. It also outputs standard, scientific, and engineering notation with a specified number of significant figures. In the accepted answer there is the line That actually specifies 8 sig figs. For the number 1234243 my library only displays one significant figure: It will also round the last significant figure and can automatically choose what notation to use if a notation isn't specified:"}, {"id": 9557559, "score": 5, "vote": 0, "content": "<p>To round an integer to 1 significant figure the basic idea is to convert it to a floating point with 1 digit before the point and round that, then convert it back to its original integer size.</p>\n<p>To do this we need to know the largest power of 10 less than the integer. We can use floor of the log 10 function for this. </p>\n<blockquote>\n<pre><code class=\"python\">from math import log10, floor\ndef round_int(i,places):\n    if i == 0:\n        return 0\n    isign = i/abs(i)\n    i = abs(i)\n    if i &lt; 1:\n        return 0\n    max10exp = floor(log10(i))\n    if max10exp+1 &lt; places:\n        return i\n    sig10pow = 10**(max10exp-places+1)\n    floated = i*1.0/sig10pow\n    defloated = round(floated)*sig10pow\n    return int(defloated*isign)\n</code></pre>\n</blockquote>\n", "abstract": "To round an integer to 1 significant figure the basic idea is to convert it to a floating point with 1 digit before the point and round that, then convert it back to its original integer size. To do this we need to know the largest power of 10 less than the integer. We can use floor of the log 10 function for this. "}, {"id": 38362362, "score": 5, "vote": 0, "content": "<pre><code class=\"python\">def round_to_n(x, n):\n    if not x: return 0\n    power = -int(math.floor(math.log10(abs(x)))) + (n - 1)\n    factor = (10 ** power)\n    return round(x * factor) / factor\n\nround_to_n(0.075, 1)      # 0.08\nround_to_n(0, 1)          # 0\nround_to_n(-1e15 - 1, 16) # 1000000000000001.0\n</code></pre>\n<p>Hopefully taking the best of all the answers above (minus being able to put it as a one line lambda ;)  ).  Haven't explored yet, feel free to edit this answer:</p>\n<pre><code class=\"python\">round_to_n(1e15 + 1, 11)  # 999999999999999.9\n</code></pre>\n", "abstract": "Hopefully taking the best of all the answers above (minus being able to put it as a one line lambda ;)  ).  Haven't explored yet, feel free to edit this answer:"}, {"id": 36240131, "score": 4, "vote": 0, "content": "<p>I modified indgar's solution to handle negative numbers and small numbers (including zero).</p>\n<pre><code class=\"python\">from math import log10, floor\ndef round_sig(x, sig=6, small_value=1.0e-9):\n    return round(x, sig - int(floor(log10(max(abs(x), abs(small_value))))) - 1)\n</code></pre>\n", "abstract": "I modified indgar's solution to handle negative numbers and small numbers (including zero)."}, {"id": 58490997, "score": 4, "vote": 0, "content": "<p>The posted answer was the best available when given, but it has a number of limitations and does not produce technically correct significant figures.</p>\n<p><a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.format_float_positional.html\" rel=\"nofollow noreferrer\">numpy.format_float_positional</a> supports the desired behaviour directly.  The following fragment returns the float <code>x</code> formatted to 4 significant figures, with scientific notation suppressed.</p>\n<pre><code class=\"python\">import numpy as np\nx=12345.6\nnp.format_float_positional(x, precision=4, unique=False, fractional=False, trim='k')\n&gt; 12340.\n</code></pre>\n", "abstract": "The posted answer was the best available when given, but it has a number of limitations and does not produce technically correct significant figures. numpy.format_float_positional supports the desired behaviour directly.  The following fragment returns the float x formatted to 4 significant figures, with scientific notation suppressed."}, {"id": 3411150, "score": 3, "vote": 0, "content": "<p>I can't think of anything that would be able to handle this out of the box. But it's fairly well handled for floating point numbers.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; round(1.2322, 2)\n1.23\n</code></pre>\n<p>Integers are trickier. They're not stored as base 10 in memory, so significant places isn't a natural thing to do. It's fairly trivial to implement once they're a string though.</p>\n<p>Or for integers:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def intround(n, sigfigs):\n...   n = str(n)\n...   return n[:sigfigs] + ('0' * (len(n)-(sigfigs)))\n\n&gt;&gt;&gt; intround(1234, 1)\n'1000'\n&gt;&gt;&gt; intround(1234, 2)\n</code></pre>\n<p>If you would like to create a function that handles any number, my preference would be to convert them both to strings and look for a decimal place to decide what to do:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def roundall1(n, sigfigs):\n...   n = str(n)\n...   try:\n...     sigfigs = n.index('.')\n...   except ValueError:\n...     pass\n...   return intround(n, sigfigs)\n</code></pre>\n<p>Another option is to check for type. This will be far less flexible, and will probably not play nicely with other numbers such as <code>Decimal</code> objects:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def roundall2(n, sigfigs):\n...   if type(n) is int: return intround(n, sigfigs)\n...   else: return round(n, sigfigs)\n</code></pre>\n", "abstract": "I can't think of anything that would be able to handle this out of the box. But it's fairly well handled for floating point numbers. Integers are trickier. They're not stored as base 10 in memory, so significant places isn't a natural thing to do. It's fairly trivial to implement once they're a string though. Or for integers: If you would like to create a function that handles any number, my preference would be to convert them both to strings and look for a decimal place to decide what to do: Another option is to check for type. This will be far less flexible, and will probably not play nicely with other numbers such as Decimal objects:"}, {"id": 49810920, "score": 3, "vote": 0, "content": "<p>If you want to round without involving strings, the link I found buried in the comments above:</p>\n<p><a href=\"http://code.activestate.com/lists/python-tutor/70739/\" rel=\"nofollow noreferrer\">http://code.activestate.com/lists/python-tutor/70739/</a></p>\n<p>strikes me as best.  Then when you print with any string formatting descriptors, you get a reasonable output, and you can use the numeric representation for other calculation purposes.</p>\n<p>The code at the link is a three liner: def, doc, and return.  It has a bug: you need to check for exploding logarithms.  That is easy.  Compare the input to <code>sys.float_info.min</code>.  The complete solution is:</p>\n<pre><code class=\"python\">import sys,math\n\ndef tidy(x, n):\n\"\"\"Return 'x' rounded to 'n' significant digits.\"\"\"\ny=abs(x)\nif y &lt;= sys.float_info.min: return 0.0\nreturn round( x, int( n-math.ceil(math.log10(y)) ) )\n</code></pre>\n<p>It works for any scalar numeric value, and n can be a <code>float</code> if you need to shift the response for some reason.  You can actually push the limit to:</p>\n<pre><code class=\"python\">sys.float_info.min*sys.float_info.epsilon\n</code></pre>\n<p>without provoking an error, if for some reason you are working with miniscule values.</p>\n", "abstract": "If you want to round without involving strings, the link I found buried in the comments above: http://code.activestate.com/lists/python-tutor/70739/ strikes me as best.  Then when you print with any string formatting descriptors, you get a reasonable output, and you can use the numeric representation for other calculation purposes. The code at the link is a three liner: def, doc, and return.  It has a bug: you need to check for exploding logarithms.  That is easy.  Compare the input to sys.float_info.min.  The complete solution is: It works for any scalar numeric value, and n can be a float if you need to shift the response for some reason.  You can actually push the limit to: without provoking an error, if for some reason you are working with miniscule values."}, {"id": 59118576, "score": 2, "vote": 0, "content": "<p>The <a href=\"https://pypi.org/project/sigfig/\" rel=\"nofollow noreferrer\">sigfig</a> package/library covers this.  After <a href=\"https://sigfig.readthedocs.io/en/latest/install.html\" rel=\"nofollow noreferrer\">installing</a> you can do the following:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from sigfig import round\n&gt;&gt;&gt; round(1234, 1)\n1000\n&gt;&gt;&gt; round(0.12, 1)\n0.1\n&gt;&gt;&gt; round(0.012, 1)\n0.01\n&gt;&gt;&gt; round(0.062, 1)\n0.06\n&gt;&gt;&gt; round(6253, 1)\n6000\n&gt;&gt;&gt; round(1999, 1)\n2000\n</code></pre>\n", "abstract": "The sigfig package/library covers this.  After installing you can do the following:"}, {"id": 48151416, "score": 1, "vote": 0, "content": "<p>Using python 2.6+ <a href=\"https://docs.python.org/2/library/string.html#format-string-syntax\" rel=\"nofollow noreferrer\">new-style formatting</a> (as %-style is deprecated):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; \"{0}\".format(float(\"{0:.1g}\".format(1216)))\n'1000.0'\n&gt;&gt;&gt; \"{0}\".format(float(\"{0:.1g}\".format(0.00356)))\n'0.004'\n</code></pre>\n<p>In python 2.7+ you can omit the leading <code>0</code>s.</p>\n", "abstract": "Using python 2.6+ new-style formatting (as %-style is deprecated): In python 2.7+ you can omit the leading 0s."}, {"id": 70395300, "score": 1, "vote": 0, "content": "<p>I adapted one of the answers. I like this:</p>\n<pre><code class=\"python\">def sigfiground(number:float, ndigits=3)-&gt;float:\n    return float(f\"{number:.{ndigits}g}\")\n</code></pre>\n<p>I use it when I still want a float (I do formatting elsewhere).</p>\n", "abstract": "I adapted one of the answers. I like this: I use it when I still want a float (I do formatting elsewhere)."}, {"id": 46474482, "score": 0, "vote": 0, "content": "<p>I ran into this as well but I needed control over the rounding type. Thus, I wrote a quick function (see code below) that can take value, rounding type, and desired significant digits into account.</p>\n<pre><code class=\"python\">import decimal\nfrom math import log10, floor\n\ndef myrounding(value , roundstyle='ROUND_HALF_UP',sig = 3):\n    roundstyles = [ 'ROUND_05UP','ROUND_DOWN','ROUND_HALF_DOWN','ROUND_HALF_UP','ROUND_CEILING','ROUND_FLOOR','ROUND_HALF_EVEN','ROUND_UP']\n\n    power =  -1 * floor(log10(abs(value)))\n    value = '{0:f}'.format(value) #format value to string to prevent float conversion issues\n    divided = Decimal(value) * (Decimal('10.0')**power) \n    roundto = Decimal('10.0')**(-sig+1)\n    if roundstyle not in roundstyles:\n        print('roundstyle must be in list:', roundstyles) ## Could thrown an exception here if you want.\n    return_val = decimal.Decimal(divided).quantize(roundto,rounding=roundstyle)*(decimal.Decimal(10.0)**-power)\n    nozero = ('{0:f}'.format(return_val)).rstrip('0').rstrip('.') # strips out trailing 0 and .\n    return decimal.Decimal(nozero)\n\n\nfor x in list(map(float, '-1.234 1.2345 0.03 -90.25 90.34543 9123.3 111'.split())):\n    print (x, 'rounded UP: ',myrounding(x,'ROUND_UP',3))\n    print (x, 'rounded normal: ',myrounding(x,sig=3))\n</code></pre>\n", "abstract": "I ran into this as well but I needed control over the rounding type. Thus, I wrote a quick function (see code below) that can take value, rounding type, and desired significant digits into account."}, {"id": 51419250, "score": 0, "vote": 0, "content": "<p>This function does a normal round if the number is bigger than 10**(-decimal_positions), otherwise adds more decimal until the number of meaningful decimal positions is reached:</p>\n<pre><code class=\"python\">def smart_round(x, decimal_positions):\n    dp = - int(math.log10(abs(x))) if x != 0.0 else int(0)\n    return round(float(x), decimal_positions + dp if dp &gt; 0 else decimal_positions)\n</code></pre>\n<p>Hope it helps.</p>\n", "abstract": "This function does a normal round if the number is bigger than 10**(-decimal_positions), otherwise adds more decimal until the number of meaningful decimal positions is reached: Hope it helps."}, {"id": 54833330, "score": 0, "vote": 0, "content": "<p><a href=\"https://stackoverflow.com/users/1391441/gabriel\">https://stackoverflow.com/users/1391441/gabriel</a>, does the following address your concern about rnd(.075, 1)?\nCaveat: returns value as a float</p>\n<pre><code class=\"python\">def round_to_n(x, n):\n    fmt = '{:1.' + str(n) + 'e}'    # gives 1.n figures\n    p = fmt.format(x).split('e')    # get mantissa and exponent\n                                    # round \"extra\" figure off mantissa\n    p[0] = str(round(float(p[0]) * 10**(n-1)) / 10**(n-1))\n    return float(p[0] + 'e' + p[1]) # convert str to float\n\n&gt;&gt;&gt; round_to_n(750, 2)\n750.0\n&gt;&gt;&gt; round_to_n(750, 1)\n800.0\n&gt;&gt;&gt; round_to_n(.0750, 2)\n0.075\n&gt;&gt;&gt; round_to_n(.0750, 1)\n0.08\n&gt;&gt;&gt; math.pi\n3.141592653589793\n&gt;&gt;&gt; round_to_n(math.pi, 7)\n3.141593\n</code></pre>\n", "abstract": "https://stackoverflow.com/users/1391441/gabriel, does the following address your concern about rnd(.075, 1)?\nCaveat: returns value as a float"}, {"id": 55182235, "score": 0, "vote": 0, "content": "<p>This returns a string, so that results without fractional parts, and small values which would otherwise appear in E notation are shown correctly:</p>\n<pre><code class=\"python\">def sigfig(x, num_sigfig):\n    num_decplace = num_sigfig - int(math.floor(math.log10(abs(x)))) - 1\n    return '%.*f' % (num_decplace, round(x, num_decplace))\n</code></pre>\n", "abstract": "This returns a string, so that results without fractional parts, and small values which would otherwise appear in E notation are shown correctly:"}, {"id": 57336891, "score": 0, "vote": 0, "content": "<p>Given a question so thoroughly answered why not add another</p>\n<p>This suits my aesthetic a little better, though many of the above are comparable</p>\n<pre><code class=\"python\">import numpy as np\n\nnumber=-456.789\nsignificantFigures=4\n\nroundingFactor=significantFigures - int(np.floor(np.log10(np.abs(number)))) - 1\nrounded=np.round(number, roundingFactor)\n\nstring=rounded.astype(str)\n\nprint(string)\n</code></pre>\n<p>This works for individual numbers and numpy arrays, and should function fine for negative numbers.</p>\n<p>There's one additional step we might add - np.round() returns a decimal number even if rounded is an integer (i.e. for significantFigures=2 we might expect to get back -460 but instead we get -460.0). We can add this step to correct for that:</p>\n<pre><code class=\"python\">if roundingFactor&lt;=0:\n    rounded=rounded.astype(int)\n</code></pre>\n<p>Unfortunately, this final step won't work for an array of numbers - I'll leave that to you dear reader to figure out if you need. </p>\n", "abstract": "Given a question so thoroughly answered why not add another This suits my aesthetic a little better, though many of the above are comparable This works for individual numbers and numpy arrays, and should function fine for negative numbers. There's one additional step we might add - np.round() returns a decimal number even if rounded is an integer (i.e. for significantFigures=2 we might expect to get back -460 but instead we get -460.0). We can add this step to correct for that: Unfortunately, this final step won't work for an array of numbers - I'll leave that to you dear reader to figure out if you need. "}, {"id": 60876419, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">import math\n\n  def sig_dig(x, n_sig_dig):\n      num_of_digits = len(str(x).replace(\".\", \"\"))\n      if n_sig_dig &gt;= num_of_digits:\n          return x\n      n = math.floor(math.log10(x) + 1 - n_sig_dig)\n      result = round(10 ** -n * x) * 10 ** n\n      return float(str(result)[: n_sig_dig + 1])\n\n\n    &gt;&gt;&gt; sig_dig(1234243, 3)\n    &gt;&gt;&gt; sig_dig(243.3576, 5)\n\n        1230.0\n        243.36\n</code></pre>\n", "abstract": ""}, {"id": 65328998, "score": 0, "vote": 0, "content": "<p>Most of these answers involve the math, decimal and/or numpy imports or output values as strings.  Here is a simple solution in base python that handles both large and small numbers and outputs a float:</p>\n<pre><code class=\"python\">def sig_fig_round(number, digits=3):\n    power = \"{:e}\".format(number).split('e')[1]\n    return round(number, -(int(power) - digits))\n</code></pre>\n", "abstract": "Most of these answers involve the math, decimal and/or numpy imports or output values as strings.  Here is a simple solution in base python that handles both large and small numbers and outputs a float:"}, {"id": 69059156, "score": 0, "vote": 0, "content": "<p>A simple variant using the standard decimal library</p>\n<pre><code class=\"python\">from decimal import Decimal\n\ndef to_significant_figures(v: float, n_figures: int) -&gt; str:\n    d = Decimal(v)\n    d = d.quantize(Decimal((0, (), d.adjusted() - n_figures + 1)))\n    return str(d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize())\n</code></pre>\n<p>Testing it</p>\n<pre><code class=\"python\">&gt;&gt;&gt; to_significant_figures(1.234567, 3)\n'1.23'\n&gt;&gt;&gt; to_significant_figures(1234567, 3)\n'1230000'\n&gt;&gt;&gt; to_significant_figures(1.23, 7)\n'1.23'\n&gt;&gt;&gt; to_significant_figures(123, 7)\n'123'\n</code></pre>\n", "abstract": "A simple variant using the standard decimal library Testing it"}, {"id": 70262507, "score": 0, "vote": 0, "content": "<p>This function takes both positive and negative numbers and does the proper significant digit rounding.</p>\n<pre><code class=\"python\">from math import floor\n\ndef significant_arithmetic_rounding(n, d):\n    '''\n    This function takes a floating point number and the no. of significant digit d, perform significant digits\n    arithmetic rounding and returns the floating point number after rounding\n    '''\n    if n == 0:\n        return 0\n    else:\n        # Checking whether the no. is negative or positive. If it is negative we will take the absolute value of it and proceed\n        neg_flag = 0\n        if n &lt; 0:\n            neg_flag = 1\n            n = abs(n)\n        \n        n1 = n   \n        # Counting the no. of digits to the left of the decimal point in the no.\n        ld = 0\n        while(n1 &gt;= 1):\n            n1 /= 10\n            ld += 1\n        \n        n1 = n\n        # Counting the no. of zeros to the right of the decimal point and before the first significant digit in the no.\n        z = 0\n        if ld == 0:\n            while(n1 &lt;= 0.1):\n                n1 *= 10\n                z += 1\n        \n        n1 = n\n        # No. of digits to be considered after decimal for rounding\n        rd = (d - ld) + z\n        n1 *= 10**rd\n    \n        # Increase by 0.5 and take the floor value for rounding\n        n1 = floor(n1+0.5)\n        # Placing the decimal point at proper position\n        n1 /= 10 ** rd\n        # If the original number is negative then make it negative\n        if neg_flag == 1:\n            n1 = 0 - n1\n\n        return n1\n</code></pre>\n<p>Testing:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; significant_arithmetic_rounding(1234, 3)\n1230.0\n&gt;&gt;&gt; significant_arithmetic_rounding(123.4, 3)\n123.0\n&gt;&gt;&gt; significant_arithmetic_rounding(0.0012345, 3)\n0.00123\n&gt;&gt;&gt; significant_arithmetic_rounding(-0.12345, 3)\n-0.123\n&gt;&gt;&gt; significant_arithmetic_rounding(-30.15345, 3)\n-30.2\n</code></pre>\n", "abstract": "This function takes both positive and negative numbers and does the proper significant digit rounding. Testing:"}, {"id": 71974021, "score": 0, "vote": 0, "content": "<p>Easier to know an answer works for your needs when it includes examples.  The following is built on previous solutions, but offers a more general function which can round to 1, 2, 3, 4, or any number of significant digits.</p>\n<pre><code class=\"python\">import math\n\n# Given x as float or decimal, returns as string a number rounded to \"sig\" significant digts\n# Return as string in order to control significant digits, could be a float or decimal \ndef round_sig(x, sig=2):\n  r = round(x, sig-int(math.floor(math.log10(abs(x))))-1)\n  floatsig = \"%.\" + str(sig) + \"g\"\n  return \"%d\"%r if abs(r) &gt;= 10**(sig-1) else '%s'%float(floatsig % r) \n\n&gt;&gt;&gt; a = [1234, 123.4, 12.34, 1.234, 0.1234, 0.01234, 0.25, 1999, -3.14, -48.01, 0.75]\n&gt;&gt;&gt; [print(i, \"-&gt;\", round_sig(i,1), round_sig(i), round_sig(i,3), round_sig(i,4)) for i in a]\n\n1234 -&gt; 1000 1200 1230 1234\n123.4 -&gt; 100 120 123 123.4\n12.34 -&gt; 10 12 12.3 12.34\n1.234 -&gt; 1 1.2 1.23 1.234\n0.1234 -&gt; 0.1 0.12 0.123 0.1234\n0.01234 -&gt; 0.01 0.012 0.0123 0.01234\n0.25 -&gt; 0.2 0.25 0.25 0.25\n1999 -&gt; 2000 2000 2000 1999\n-3.14 -&gt; -3 -3.1 -3.14 -3.14\n-48.01 -&gt; -50 -48 -48.0 -48.01\n0.75 -&gt; 0.8 0.75 0.75 0.75\n</code></pre>\n", "abstract": "Easier to know an answer works for your needs when it includes examples.  The following is built on previous solutions, but offers a more general function which can round to 1, 2, 3, 4, or any number of significant digits."}, {"id": 73756472, "score": 0, "vote": 0, "content": "<p>in very cases, the number of significant is depend on to the evaluated process, e.g. error. I wrote the some codes which returns a number according to it's error (or with some desired digits) and also in string form (which doesn't eliminate right side significant zeros)</p>\n<pre><code class=\"python\">import numpy as np\n\ndef Sig_Digit(x, *N,):\n    if abs(x) &lt; 1.0e-15:\n        return(1)\n    N = 1 if N ==() else N[0]\n    k = int(round(abs(N)-1))-int(np.floor(np.log10(abs(x))))\n    return(k);\n\ndef Sig_Format(x, *Error,):\n    if abs(x) &lt; 1.0e-15:\n        return('{}')\n    Error = 1 if Error ==() else abs(Error[0])\n    k = int(np.floor(np.log10(abs(x))))\n    z = x/10**k\n    k = -Sig_Digit(Error, 1)\n    m = 10**k\n    y = round(x*m)/m\n    if k &lt; 0:\n        k = abs(k)\n        if z &gt;= 9.5:\n            FMT = '{:'+'{}'.format(1+k)+'.'+'{}'.format(k-1)+'f}'\n        else:\n            FMT = '{:'+'{}'.format(2+k)+'.'+'{}'.format(k)+'f}'\n    elif k == 0:\n        if z &gt;= 9.5:\n            FMT = '{:'+'{}'.format(1+k)+'.0e}'\n        else:\n            FMT = '{:'+'{}'.format(2+k)+'.0f}'\n    else:\n        FMT = '{:'+'{}'.format(2+k)+'.'+'{}'.format(k)+'e}'\n    return(FMT)\n\ndef Sci_Format(x, *N):\n    if abs(x) &lt; 1.0e-15:\n        return('{}')\n    N = 1 if N ==() else N[0]\n    N = int(round(abs(N)-1))\n    y = abs(x)\n    k = int(np.floor(np.log10(y)))\n    z = x/10**k\n    k = k-N\n    m = 10**k\n    y = round(x/m)*m\n    if k &lt; 0:\n        k = abs(k)\n        if z &gt;= 9.5:\n            FMT = '{:'+'{}'.format(1+k)+'.'+'{}'.format(k-1)+'f}'\n        else:\n            FMT = '{:'+'{}'.format(2+k)+'.'+'{}'.format(k)+'f}'\n    elif k == 0:\n        if z &gt;= 9.5:\n            FMT = '{:'+'{}'.format(1+k)+'.0e}'\n        else:\n            FMT = '{:'+'{}'.format(2+k)+'.0f}'\n    else:\n        FMT = '{:'+'{}'.format(2+N)+'.'+'{}'.format(N)+'e}'\n    return(FMT)\n\ndef Significant(x, *Error):\n    N = 0 if Error ==() else Sig_Digit(abs(Error[0]), 1)\n    m = 10**N\n    y = round(x*m)/m\n    return(y)\n\ndef Scientific(x, *N):\n    m = 10**Sig_Digit(x, *N)\n    y = round(x*m)/m\n    return(y)\n\ndef Scientific_Str(x, *N,): \n    FMT = Sci_Format(x, *N)\n    return(FMT.format(x))\n\ndef Significant_Str(x, *Error,):    \n    FMT = Sig_Format(x, *Error)\n    return(FMT.format(x))\n</code></pre>\n<p>test code:</p>\n<pre><code class=\"python\">X = [19.03345607, 12.075, 360.108321344, 4325.007605343]\nError = [1.245, 0.1245, 0.0563, 0.01245, 0.001563, 0.0004603]\nfor x in X:\n    for error in Error:\n        print(x,'+/-',error, end='   \\t==&gt; ')\n        print(' (',Significant_Str(x, error), '+/-', Scientific_Str(error),')')\n\n  \n</code></pre>\n<p>print out:</p>\n<pre><code class=\"python\">19.03345607 +/- 1.245       ==&gt;  ( 19 +/-  1 )\n\n19.03345607 +/- 0.1245      ==&gt;  ( 19.0 +/- 0.1 )\n\n19.03345607 +/- 0.0563      ==&gt;  ( 19.03 +/- 0.06 )\n\n19.03345607 +/- 0.01245     ==&gt;  ( 19.03 +/- 0.01 )\n\n19.03345607 +/- 0.001563    ==&gt;  ( 19.033 +/- 0.002 )\n\n19.03345607 +/- 0.0004603       ==&gt;  ( 19.0335 +/- 0.0005 )\n\n12.075 +/- 1.245    ==&gt;  ( 12 +/-  1 )\n\n12.075 +/- 0.1245       ==&gt;  ( 12.1 +/- 0.1 )\n\n12.075 +/- 0.0563       ==&gt;  ( 12.07 +/- 0.06 )\n\n12.075 +/- 0.01245      ==&gt;  ( 12.07 +/- 0.01 )\n\n12.075 +/- 0.001563     ==&gt;  ( 12.075 +/- 0.002 )\n\n12.075 +/- 0.0004603    ==&gt;  ( 12.0750 +/- 0.0005 )\n\n360.108321344 +/- 1.245     ==&gt;  ( 360 +/-  1 )\n\n360.108321344 +/- 0.1245    ==&gt;  ( 360.1 +/- 0.1 )\n\n360.108321344 +/- 0.0563    ==&gt;  ( 360.11 +/- 0.06 )\n\n360.108321344 +/- 0.01245       ==&gt;  ( 360.11 +/- 0.01 )\n\n360.108321344 +/- 0.001563      ==&gt;  ( 360.108 +/- 0.002 )\n\n360.108321344 +/- 0.0004603     ==&gt;  ( 360.1083 +/- 0.0005 )\n\n4325.007605343 +/- 1.245    ==&gt;  ( 4325 +/-  1 )\n\n4325.007605343 +/- 0.1245       ==&gt;  ( 4325.0 +/- 0.1 )\n\n4325.007605343 +/- 0.0563       ==&gt;  ( 4325.01 +/- 0.06 )\n\n4325.007605343 +/- 0.01245      ==&gt;  ( 4325.01 +/- 0.01 )\n\n4325.007605343 +/- 0.001563     ==&gt;  ( 4325.008 +/- 0.002 )\n\n4325.007605343 +/- 0.0004603    ==&gt;  ( 4325.0076 +/- 0.0005 )\n</code></pre>\n", "abstract": "in very cases, the number of significant is depend on to the evaluated process, e.g. error. I wrote the some codes which returns a number according to it's error (or with some desired digits) and also in string form (which doesn't eliminate right side significant zeros) test code: print out:"}]}, {"link": "https://stackoverflow.com/questions/8582741/why-do-pythons-math-ceil-and-math-floor-operations-return-floats-instead-of", "question": {"id": "8582741", "title": "Why do Python&#39;s math.ceil() and math.floor() operations return floats instead of integers?", "content": "<p>Can someone explain this (straight from the <a href=\"http://docs.python.org/library/math.html#number-theoretic-and-representation-functions\" rel=\"noreferrer\">docs</a>- emphasis mine):</p>\n<blockquote>\n<p><strong>math.ceil(x)</strong> Return the ceiling of x <em>as a float</em>, the smallest <em>integer</em> value greater than or equal to x.</p>\n<p><strong>math.floor(x)</strong> Return the floor of x <em>as a float</em>, the largest <em>integer</em> value less than or equal to x.</p>\n</blockquote>\n<p>Why would <code>.ceil</code> and <code>.floor</code> return floats when they are by definition supposed to calculate integers?</p>\n<hr/>\n<p><strong>EDIT:</strong></p>\n<p>Well this got some very good arguments as to why they <em>should</em> return floats, and I was just getting used to the idea, when <a href=\"https://stackoverflow.com/a/8582845/165673\">@jcollado</a> pointed out that they in fact <em>do</em> return ints in Python 3...</p>\n", "abstract": "Can someone explain this (straight from the docs- emphasis mine): math.ceil(x) Return the ceiling of x as a float, the smallest integer value greater than or equal to x. math.floor(x) Return the floor of x as a float, the largest integer value less than or equal to x. Why would .ceil and .floor return floats when they are by definition supposed to calculate integers? EDIT: Well this got some very good arguments as to why they should return floats, and I was just getting used to the idea, when @jcollado pointed out that they in fact do return ints in Python 3..."}, "answers": [{"id": 8582845, "score": 111, "vote": 0, "content": "<p>As pointed out by other answers, in python they return floats probably because of historical reasons to prevent overflow problems. However, they return integers in python 3.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; type(math.floor(3.1))\n&lt;class 'int'&gt;\n&gt;&gt;&gt; type(math.ceil(3.1))\n&lt;class 'int'&gt;\n</code></pre>\n<p>You can find more information in <a href=\"http://www.python.org/dev/peps/pep-3141/#changes-to-operations-and-magic-methods\">PEP 3141</a>.</p>\n", "abstract": "As pointed out by other answers, in python they return floats probably because of historical reasons to prevent overflow problems. However, they return integers in python 3. You can find more information in PEP 3141."}, {"id": 8582794, "score": 106, "vote": 0, "content": "<p>The range of floating point numbers usually exceeds the range of integers. By returning a floating point value, the functions can return a sensible value for input values that lie outside the representable range of integers.</p>\n<p>Consider: If <code>floor()</code> returned an integer, what should <code>floor(1.0e30)</code> return?</p>\n<p>Now, while Python's integers are now arbitrary precision, it wasn't always this way. The standard library functions are thin wrappers around the equivalent C library functions.</p>\n", "abstract": "The range of floating point numbers usually exceeds the range of integers. By returning a floating point value, the functions can return a sensible value for input values that lie outside the representable range of integers. Consider: If floor() returned an integer, what should floor(1.0e30) return? Now, while Python's integers are now arbitrary precision, it wasn't always this way. The standard library functions are thin wrappers around the equivalent C library functions."}, {"id": 8582781, "score": 20, "vote": 0, "content": "<p>Because python's math library is a thin wrapper around the C math library which returns floats.</p>\n", "abstract": "Because python's math library is a thin wrapper around the C math library which returns floats."}, {"id": 8582849, "score": 18, "vote": 0, "content": "<p>The source of your confusion is evident in your comment:</p>\n<blockquote>\n<p>The whole point of ceil/floor operations is to convert floats to integers!</p>\n</blockquote>\n<p>The point of the ceil and floor operations is to round floating-point data to <em>integral values</em>.  Not to do a type conversion.  Users who need to get <em>integer</em> values can do an explicit conversion following the operation.</p>\n<p>Note that it would not be possible to implement a round to integral value as trivially if all you had available were a ceil or float operation that returned an integer.  You would need to first check that the input is within the representable integer range, then call the function; you would need to handle NaN and infinities in a separate code path.</p>\n<p>Additionally, you must have versions of ceil and floor which return floating-point numbers if you want to conform to <a href=\"https://en.wikipedia.org/wiki/IEEE_floating_point\" rel=\"noreferrer\">IEEE 754</a>.</p>\n", "abstract": "The source of your confusion is evident in your comment: The whole point of ceil/floor operations is to convert floats to integers! The point of the ceil and floor operations is to round floating-point data to integral values.  Not to do a type conversion.  Users who need to get integer values can do an explicit conversion following the operation. Note that it would not be possible to implement a round to integral value as trivially if all you had available were a ceil or float operation that returned an integer.  You would need to first check that the input is within the representable integer range, then call the function; you would need to handle NaN and infinities in a separate code path. Additionally, you must have versions of ceil and floor which return floating-point numbers if you want to conform to IEEE 754."}, {"id": 8582832, "score": 5, "vote": 0, "content": "<p>Before Python 2.4, an integer couldn't hold the full range of truncated real numbers.</p>\n<p><a href=\"http://docs.python.org/whatsnew/2.4.html#pep-237-unifying-long-integers-and-integers\" rel=\"noreferrer\">http://docs.python.org/whatsnew/2.4.html#pep-237-unifying-long-integers-and-integers</a></p>\n", "abstract": "Before Python 2.4, an integer couldn't hold the full range of truncated real numbers. http://docs.python.org/whatsnew/2.4.html#pep-237-unifying-long-integers-and-integers"}, {"id": 8582799, "score": 4, "vote": 0, "content": "<p>Because the range for floats is greater than that of integers -- returning an integer could overflow</p>\n", "abstract": "Because the range for floats is greater than that of integers -- returning an integer could overflow"}, {"id": 10970552, "score": 4, "vote": 0, "content": "<p>This is a very interesting question! As a float requires some bits to store the exponent (=<code>bits_for_exponent</code>) any floating point number greater than <code>2**(float_size - bits_for_exponent)</code> will always be an integral value! At the other extreme a float with a negative exponent will give one of <code>1</code>, <code>0</code> or <code>-1</code>. This makes the discussion of <b>integer range</b> versus <b>float range</b> moot because these functions will simply return the original number whenever the number is outside the range of the integer type.  The python functions are wrappers of the <code>C</code> function and so this is really a deficiency of the <code>C</code> functions where they should have returned an integer and forced the programer to do the range/<code>NaN</code>/<code>Inf</code> check before calling ceil/floor.</p>\n<p>Thus the logical answer is the only time these functions are useful they would return a value within integer range and so the fact they return a float is a <b>mistake</b> and you are very smart for realizing this!</p>\n", "abstract": "This is a very interesting question! As a float requires some bits to store the exponent (=bits_for_exponent) any floating point number greater than 2**(float_size - bits_for_exponent) will always be an integral value! At the other extreme a float with a negative exponent will give one of 1, 0 or -1. This makes the discussion of integer range versus float range moot because these functions will simply return the original number whenever the number is outside the range of the integer type.  The python functions are wrappers of the C function and so this is really a deficiency of the C functions where they should have returned an integer and forced the programer to do the range/NaN/Inf check before calling ceil/floor. Thus the logical answer is the only time these functions are useful they would return a value within integer range and so the fact they return a float is a mistake and you are very smart for realizing this!"}, {"id": 8582776, "score": 1, "vote": 0, "content": "<p>Maybe because other languages do this as well, so it is generally-accepted behavior. (For good reasons, as shown in the other answers)</p>\n", "abstract": "Maybe because other languages do this as well, so it is generally-accepted behavior. (For good reasons, as shown in the other answers)"}, {"id": 65496264, "score": 1, "vote": 0, "content": "<p>This totally caught me off guard recently.  This is because I've programmed in C since the 1970's and I'm only now learning the fine details of Python.  Like this curious behavior of math.floor().</p>\n<p>The math library of Python is how you access the C standard math library.  And the C standard math library is a collection of floating point numerical functions, like sin(), and cos(), sqrt().  The floor() function in the context of numerical calculations has ALWAYS returned a float. For 50 YEARS now. It's part of the standards for numerical computation. For those of us familiar with the math library of C, we don't understand it to be just \"math functions\". We understand it to be a collection of floating-point algorithms. It would be better named something like NFPAL - Numerical Floating Point Algorithms Libary. :)</p>\n<p>Those of us that understand the history instantly see the python math module as just a wrapper for the long-established C floating-point library. So we expect without a second thought, that math.floor() is the same function as the C standard library floor() which takes a float argument and returns a float value.</p>\n<p>The use of floor() as a numerical math concept goes back to 1798 per the Wikipedia page on the subject: <a href=\"https://en.wikipedia.org/wiki/Floor_and_ceiling_functions#Notation\" rel=\"nofollow noreferrer\">https://en.wikipedia.org/wiki/Floor_and_ceiling_functions#Notation</a></p>\n<p>It never has been a computer science covert floating-point to integer storage format function even though logically it's a similar concept.</p>\n<p>The floor() function in this context has always been a floating-point numerical calculation as all(most) the functions in the math library.  Floating-point goes beyond what integers can do.  They include the special values of +inf, -inf, and Nan (not a number) which are all well defined as to how they propagate through floating-point numerical calculations.  Floor() has always CORRECTLY preserved values like Nan and +inf and -inf in numerical calculations.  If Floor returns an int, it totally breaks the entire concept of what the numerical floor() function was meant to do. math.floor(float(\"nan\")) must return \"nan\" if it is to be a true floating-point numerical floor() function.</p>\n<p>When I recently saw a Python education video telling us to use:</p>\n<pre><code class=\"python\">i = math.floor(12.34/3)\n</code></pre>\n<p>to get an integer I laughed to myself at how clueless the instructor was.  But before writing a snarkish comment, I did some testing and to my shock, I found the numerical algorithms library in Python was returning an int.  And even stranger, what I thought was the obvious answer to getting an int from a divide, was to use:</p>\n<pre><code class=\"python\">i = 12.34 // 3\n</code></pre>\n<p>Why not use the built-in integer divide to get the integer you are looking for! From my C background, it was the obvious right answer. But low and behold, integer divide in Python returns a FLOAT in this case! Wow! What a strange upside-down world Python can be.</p>\n<p>A better answer in Python is that if you really NEED an int type, you should just be explicit and ask for int in python:</p>\n<pre><code class=\"python\">i = int(12.34/3)\n</code></pre>\n<p>Keeping in mind however that floor() rounds towards negative infinity and int() rounds towards zero so they give different answers for negative numbers. So if negative values are possible, you must use the function that gives the results you need for your application.</p>\n<p>Python however is a different beast for good reasons.  It's trying to address a different problem set than C.  The static typing of Python is great for fast prototyping and development, but it can create some very complex and hard to find bugs when code that was tested with one type of objects, like floats, fails in subtle and hard to find ways when passed an int argument.  And because of this, a lot of interesting choices were made for Python that put the need to minimize surprise errors above other historic norms.</p>\n<p>Changing the divide to always return a float (or some form of non int) was a move in the right direction for this.  And in this same light, it's logical to make // be a floor(a/b) function, and not an \"int divide\".</p>\n<p>Making float divide by zero a fatal error instead of returning float(\"inf\") is likewise wise because, in MOST python code, a divide by zero is not a numerical calculation but a programming bug where the math is wrong or there is an off by one error. It's more important for average Python code to catch that bug when it happens, instead of propagating a hidden error in the form of an \"inf\" which causes a blow-up miles away from the actual bug.</p>\n<p>And as long as the rest of the language is doing a good job of casting ints to floats when needed, such as in divide, or math.sqrt(), it's logical to have math.floor() return an int, because if it is needed as a float later, it will be converted correctly back to a float.  And if the programmer needed an int, well then the function gave them what they needed. math.floor(a/b) and a//b should act the same way, but the fact that they don't I guess is just a matter of history not yet adjusted for consistency. And maybe too hard to \"fix\" due to backward compatibility issues. And maybe not that important???</p>\n<p>In Python, if you want to write hard-core numerical algorithms, the correct answer is to use NumPy and SciPy, not the built-in Python math module.</p>\n<pre><code class=\"python\">import numpy as np\n\nnan = np.float64(0.0) / 0.0    # gives a warning and returns float64 nan\n\nnan = np.floor(nan)            # returns float64 nan\n</code></pre>\n<p>Python is different, for good reasons, and it takes a bit of time to understand it.  And we can see in this case, the OP, who didn't understand the history of the numerical floor() function, needed and expected it to return an int from their thinking about mathematical integers and reals. Now Python is doing what our mathematical (vs computer science) training implies. Which makes it more likely to do what a beginner expects it to do while still covering all the more complex needs of advanced numerical algorithms with NumPy and SciPy.  I'm constantly impressed with how Python has evolved, even if at times I'm totally caught off guard.</p>\n", "abstract": "This totally caught me off guard recently.  This is because I've programmed in C since the 1970's and I'm only now learning the fine details of Python.  Like this curious behavior of math.floor(). The math library of Python is how you access the C standard math library.  And the C standard math library is a collection of floating point numerical functions, like sin(), and cos(), sqrt().  The floor() function in the context of numerical calculations has ALWAYS returned a float. For 50 YEARS now. It's part of the standards for numerical computation. For those of us familiar with the math library of C, we don't understand it to be just \"math functions\". We understand it to be a collection of floating-point algorithms. It would be better named something like NFPAL - Numerical Floating Point Algorithms Libary. :) Those of us that understand the history instantly see the python math module as just a wrapper for the long-established C floating-point library. So we expect without a second thought, that math.floor() is the same function as the C standard library floor() which takes a float argument and returns a float value. The use of floor() as a numerical math concept goes back to 1798 per the Wikipedia page on the subject: https://en.wikipedia.org/wiki/Floor_and_ceiling_functions#Notation It never has been a computer science covert floating-point to integer storage format function even though logically it's a similar concept. The floor() function in this context has always been a floating-point numerical calculation as all(most) the functions in the math library.  Floating-point goes beyond what integers can do.  They include the special values of +inf, -inf, and Nan (not a number) which are all well defined as to how they propagate through floating-point numerical calculations.  Floor() has always CORRECTLY preserved values like Nan and +inf and -inf in numerical calculations.  If Floor returns an int, it totally breaks the entire concept of what the numerical floor() function was meant to do. math.floor(float(\"nan\")) must return \"nan\" if it is to be a true floating-point numerical floor() function. When I recently saw a Python education video telling us to use: to get an integer I laughed to myself at how clueless the instructor was.  But before writing a snarkish comment, I did some testing and to my shock, I found the numerical algorithms library in Python was returning an int.  And even stranger, what I thought was the obvious answer to getting an int from a divide, was to use: Why not use the built-in integer divide to get the integer you are looking for! From my C background, it was the obvious right answer. But low and behold, integer divide in Python returns a FLOAT in this case! Wow! What a strange upside-down world Python can be. A better answer in Python is that if you really NEED an int type, you should just be explicit and ask for int in python: Keeping in mind however that floor() rounds towards negative infinity and int() rounds towards zero so they give different answers for negative numbers. So if negative values are possible, you must use the function that gives the results you need for your application. Python however is a different beast for good reasons.  It's trying to address a different problem set than C.  The static typing of Python is great for fast prototyping and development, but it can create some very complex and hard to find bugs when code that was tested with one type of objects, like floats, fails in subtle and hard to find ways when passed an int argument.  And because of this, a lot of interesting choices were made for Python that put the need to minimize surprise errors above other historic norms. Changing the divide to always return a float (or some form of non int) was a move in the right direction for this.  And in this same light, it's logical to make // be a floor(a/b) function, and not an \"int divide\". Making float divide by zero a fatal error instead of returning float(\"inf\") is likewise wise because, in MOST python code, a divide by zero is not a numerical calculation but a programming bug where the math is wrong or there is an off by one error. It's more important for average Python code to catch that bug when it happens, instead of propagating a hidden error in the form of an \"inf\" which causes a blow-up miles away from the actual bug. And as long as the rest of the language is doing a good job of casting ints to floats when needed, such as in divide, or math.sqrt(), it's logical to have math.floor() return an int, because if it is needed as a float later, it will be converted correctly back to a float.  And if the programmer needed an int, well then the function gave them what they needed. math.floor(a/b) and a//b should act the same way, but the fact that they don't I guess is just a matter of history not yet adjusted for consistency. And maybe too hard to \"fix\" due to backward compatibility issues. And maybe not that important??? In Python, if you want to write hard-core numerical algorithms, the correct answer is to use NumPy and SciPy, not the built-in Python math module. Python is different, for good reasons, and it takes a bit of time to understand it.  And we can see in this case, the OP, who didn't understand the history of the numerical floor() function, needed and expected it to return an int from their thinking about mathematical integers and reals. Now Python is doing what our mathematical (vs computer science) training implies. Which makes it more likely to do what a beginner expects it to do while still covering all the more complex needs of advanced numerical algorithms with NumPy and SciPy.  I'm constantly impressed with how Python has evolved, even if at times I'm totally caught off guard."}]}, {"link": "https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere", "question": {"id": "9600801", "title": "Evenly distributing n points on a sphere", "content": "<p>I need an algorithm that can give me positions around a sphere for N points (less than 20, probably) that vaguely spreads them out. There's no need for \"perfection\", but I just need it so none of them are bunched together.</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/5408276/python-uniform-spherical-distribution\">This question</a> provided good code, but I couldn't find a way to make this uniform, as this seemed 100% randomized.</li>\n<li><a href=\"http://www.xsi-blog.com/archives/115\" rel=\"noreferrer\">This blog post</a> recommended had two ways allowing input of number of points on the sphere, but the <a href=\"http://sitemason.vanderbilt.edu/page/hmbADS\" rel=\"noreferrer\">Saff and Kuijlaars</a> algorithm is exactly in psuedocode I could transcribe, and the <a href=\"http://cgafaq.info/wiki/Evenly_distributed_points_on_sphere#Spirals\" rel=\"noreferrer\">code example</a> I found contained \"node[k]\", which I couldn't see explained and ruined that possibility. The second blog example was the Golden Section Spiral, which gave me strange, bunched up results, with no clear way to define a constant radius.</li>\n<li><a href=\"http://mathworld.wolfram.com/SpherePointPicking.html\" rel=\"noreferrer\">This algorithm</a> from <a href=\"https://stackoverflow.com/questions/1841014/uniform-random-monte-carlo-distribution-on-unit-sphere\">this question</a> seems like it could possibly work, but I can't piece together what's on that page into psuedocode or anything.</li>\n</ul>\n<p>A few other question threads I came across spoke of randomized uniform distribution, which adds a level of complexity I'm not concerned about. I apologize that this is such a silly question, but I wanted to show that I've truly looked hard and still come up short.</p>\n<p>So, what I'm looking for is simple pseudocode to evenly distribute N points around a unit sphere, that either returns in spherical or Cartesian coordinates. Even better if it can even distribute with a bit of randomization (think planets around a star, decently spread out, but with room for leeway).</p>\n", "abstract": "I need an algorithm that can give me positions around a sphere for N points (less than 20, probably) that vaguely spreads them out. There's no need for \"perfection\", but I just need it so none of them are bunched together. A few other question threads I came across spoke of randomized uniform distribution, which adds a level of complexity I'm not concerned about. I apologize that this is such a silly question, but I wanted to show that I've truly looked hard and still come up short. So, what I'm looking for is simple pseudocode to evenly distribute N points around a unit sphere, that either returns in spherical or Cartesian coordinates. Even better if it can even distribute with a bit of randomization (think planets around a star, decently spread out, but with room for leeway)."}, "answers": [{"id": 26127012, "score": 198, "vote": 0, "content": "<p><a href=\"https://arxiv.org/pdf/0912.4540.pdf\" rel=\"nofollow noreferrer\">The Fibonacci sphere algorithm</a> is great for this. It is fast and gives results that at a glance will easily fool the human eye. <a href=\"http://www.openprocessing.org/sketch/41142\" rel=\"nofollow noreferrer\">You can see an example done with processing</a> which will show the result over time as points are added. <a href=\"https://www.vertexshaderart.com/art/79HqSrQH4meL63aAo/revision/9c9YN5LwBQKLDa4Aa\" rel=\"nofollow noreferrer\">Here's another great interactive example</a> made by @gman. And here's a simple implementation in python.</p>\n<pre><code class=\"python\">import math\n\n\ndef fibonacci_sphere(samples=1000):\n\n    points = []\n    phi = math.pi * (3. - math.sqrt(5.))  # golden angle in radians\n\n    for i in range(samples):\n        y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n        radius = math.sqrt(1 - y * y)  # radius at y\n\n        theta = phi * i  # golden angle increment\n\n        x = math.cos(theta) * radius\n        z = math.sin(theta) * radius\n\n        points.append((x, y, z))\n\n    return points\n</code></pre>\n<p>1000 samples gives you this:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/NsCif.png\"/></p>\n", "abstract": "The Fibonacci sphere algorithm is great for this. It is fast and gives results that at a glance will easily fool the human eye. You can see an example done with processing which will show the result over time as points are added. Here's another great interactive example made by @gman. And here's a simple implementation in python. 1000 samples gives you this: "}, {"id": 44164075, "score": 177, "vote": 0, "content": "<h1>The golden spiral method</h1>\n<p>You said you couldn\u2019t get the golden spiral method to work and that\u2019s a shame because it\u2019s really, really good. I would like to give you a complete understanding of it so that maybe you can understand how to keep this away from being \u201cbunched up.\u201d</p>\n<p>So here\u2019s a fast, non-random way to create a lattice that is approximately correct; as discussed above, no lattice will be perfect, but this may be good enough. It is compared to other methods e.g. at <a href=\"https://bendwavy.org/pack/pack.htm\" rel=\"noreferrer\">BendWavy.org</a> but it just has a nice and pretty look as well as a guarantee about even spacing in the limit.</p>\n<h2>Primer: sunflower spirals on the unit disk</h2>\n<p>To understand this algorithm, I first invite you to look at the 2D sunflower spiral algorithm. This is based on the fact that the most irrational number is the golden ratio <code>(1 + sqrt(5))/2</code> and if one emits points by the approach \u201cstand at the center, turn a golden ratio of whole turns, then emit another point in that direction,\u201d one naturally constructs a spiral which, as you get to higher and higher numbers of points, nevertheless refuses to have well-defined \u2018bars\u2019 that the points line up on.<sup>(Note 1.)</sup></p>\n<p>The algorithm for even spacing on a disk is,</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from numpy import pi, cos, sin, sqrt, arange\nimport matplotlib.pyplot as pp\n\nnum_pts = 100\nindices = arange(0, num_pts, dtype=float) + 0.5\n\nr = sqrt(indices/num_pts)\ntheta = pi * (1 + 5**0.5) * indices\n\npp.scatter(r*cos(theta), r*sin(theta))\npp.show()\n</code></pre>\n<p>and it produces results that look like (n=100 and n=1000):</p>\n<p><a href=\"https://i.stack.imgur.com/U7Ut2.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/U7Ut2.png\"/></a></p>\n<h2>Spacing the points radially</h2>\n<p>The key strange thing is the formula <code>r = sqrt(indices / num_pts)</code>; how did I come to that one? <sup>(Note 2.)</sup></p>\n<p>Well, I am using the square root here because I want these to have even-area spacing around the disk. That is the same as saying that in the limit of large <em>N</em> I want a little region <em>R</em> \u2208 (<em>r</em>, <em>r</em> + d<em>r</em>), <em>\u0398</em> \u2208 (<em>\u03b8</em>, <em>\u03b8</em> + d<em>\u03b8</em>) to contain a number of points proportional to its area, which is <em>r</em> d<em>r</em> d<em>\u03b8</em>. Now if we pretend that we are talking about a random variable here, this has a straightforward interpretation as saying that the joint probability density for (<em>R</em>, <em>\u0398</em>) is just <em>c r</em> for some constant <em>c</em>. Normalization on the unit disk would then force <em>c</em> = 1/\u03c0.</p>\n<p>Now let me introduce a trick. It comes from probability theory where it\u2019s known as <a href=\"https://en.wikipedia.org/wiki/Inverse_transform_sampling\" rel=\"noreferrer\">sampling the inverse CDF</a>: suppose you wanted to <em>generate</em> a random variable with a probability density <em>f</em>(<em>z</em>) and you have a random variable <em>U</em> ~ Uniform(0, 1), just like comes out of <code>random()</code> in most programming languages. How do you do this?</p>\n<ol>\n<li>First, turn your density into a <a href=\"https://en.wikipedia.org/wiki/Cumulative_distribution_function\" rel=\"noreferrer\">cumulative distribution function</a> or CDF, which we will call <em>F</em>(<em>z</em>). A CDF, remember, increases monotonically from 0 to 1 with derivative <em>f</em>(<em>z</em>).</li>\n<li>Then calculate the CDF\u2019s inverse function <em>F</em><sup>-1</sup>(<em>z</em>).</li>\n<li>You will find that <em>Z</em> = <em>F</em><sup>-1</sup>(<em>U</em>) is distributed according to the target density. <sup>(Note 3).</sup></li>\n</ol>\n<p>Now the golden-ratio spiral trick spaces the points out in a nicely even pattern for <em>\u03b8</em> so let\u2019s integrate that out; for the unit disk we are left with <em>F</em>(<em>r</em>) = <em>r</em><sup>2</sup>. So the inverse function is <em>F</em><sup>-1</sup>(<em>u</em>) = <em>u</em><sup>1/2</sup>, and therefore we would generate random points on the disk in polar coordinates with <code>r = sqrt(random()); theta = 2 * pi * random()</code>.</p>\n<p>Now instead of <em>randomly</em> sampling this inverse function we\u2019re <em>uniformly</em> sampling it, and the nice thing about uniform sampling is that our results about how points are spread out in the limit of large <em>N</em> will behave as if we had randomly sampled it. This combination is the trick. Instead of <code>random()</code> we use <code>(arange(0, num_pts, dtype=float) + 0.5)/num_pts</code>, so that, say, if we want to sample 10 points they are <code>r = 0.05, 0.15, 0.25, ... 0.95</code>. We uniformly sample <em>r</em> to get equal-area spacing, and we use the sunflower increment to avoid awful \u201cbars\u201d of points in the output.</p>\n<h2>Now doing the sunflower on a sphere</h2>\n<p>The changes that we need to make to dot the sphere with points merely involve switching out the polar coordinates for spherical coordinates. The radial coordinate of course doesn't enter into this because we're on a unit sphere. To keep things a little more consistent here, even though I was trained as a physicist I'll use mathematicians' coordinates where 0 \u2264 <em>\u03c6</em> \u2264 \u03c0 is latitude coming down from the pole and 0 \u2264 <em>\u03b8</em> \u2264 2\u03c0 is longitude. So the difference from above is that we are basically replacing the variable <em>r</em> with <em>\u03c6</em>.</p>\n<p>Our area element, which was <em>r</em> d<em>r</em> d<em>\u03b8</em>, now becomes the not-much-more-complicated sin(<em>\u03c6</em>) d<em>\u03c6</em> d<em>\u03b8</em>. So our joint density for uniform spacing is sin(<em>\u03c6</em>)/4\u03c0. Integrating out <em>\u03b8</em>, we find <em>f</em>(<em>\u03c6</em>) = sin(<em>\u03c6</em>)/2, thus <em>F</em>(<em>\u03c6</em>) = (1 \u2212 cos(<em>\u03c6</em>))/2. Inverting this we can see that a uniform random variable would look like acos(1 - 2 <em>u</em>), but we sample uniformly instead of randomly, so we instead use <em>\u03c6</em><sub><em>k</em></sub> = acos(1 \u2212 2 (<em>k</em> + 0.5)/<em>N</em>). And the rest of the algorithm is just projecting this onto the x, y, and z coordinates:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from numpy import pi, cos, sin, arccos, arange\nimport mpl_toolkits.mplot3d\nimport matplotlib.pyplot as pp\n\nnum_pts = 1000\nindices = arange(0, num_pts, dtype=float) + 0.5\n\nphi = arccos(1 - 2*indices/num_pts)\ntheta = pi * (1 + 5**0.5) * indices\n\nx, y, z = cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi);\n\npp.figure().add_subplot(111, projection='3d').scatter(x, y, z);\npp.show()\n</code></pre>\n<p>Again for n=100 and n=1000 the results look like:\n<a href=\"https://i.stack.imgur.com/13o9v.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/13o9v.png\"/></a>\n<a href=\"https://i.stack.imgur.com/jml6W.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/jml6W.png\"/></a></p>\n<h1>Further research</h1>\n<p>I wanted to give a shout out to Martin Roberts\u2019s blog. Note that above I created an offset of my indices by adding 0.5 to each index. This was just visually appealing to me, but <a href=\"http://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/#more-3069\" rel=\"noreferrer\">it turns out that the choice of offset matters a lot</a> and is not constant over the interval and can mean getting as much as 8% better accuracy in packing if chosen correctly. There should also be a way to get <a href=\"http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\" rel=\"noreferrer\">his R<sub>2</sub> sequence</a> to cover a sphere and it would be interesting to see if this also produced a nice even covering, perhaps as-is but perhaps needing to be, say, taken from only a half of the unit square cut diagonally or so and stretched around to get a circle.</p>\n<h1>Notes</h1>\n<ol>\n<li><p>Those \u201cbars\u201d are formed by rational approximations to a number, and the best rational approximations to a number come from its continued fraction expression, <code>z + 1/(n_1 + 1/(n_2 + 1/(n_3 + ...)))</code> where <code>z</code> is an integer and <code>n_1, n_2, n_3, ...</code> is either a finite or infinite sequence of positive integers:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def continued_fraction(r):\n    while r != 0:\n        n = floor(r)\n        yield n\n        r = 1/(r - n)\n</code></pre>\n<p>Since the fraction part <code>1/(...)</code> is always between zero and one, a large integer in the continued fraction allows for a particularly good rational approximation: \u201cone divided by something between 100 and 101\u201d is better than \u201cone divided by something between 1 and 2.\u201d The most irrational number is therefore the one which is <code>1 + 1/(1 + 1/(1 + ...))</code> and has no particularly good rational approximations; one can solve <em>\u03c6</em> = 1 + 1/<em>\u03c6</em> by multiplying through by <em>\u03c6</em> to get the formula for the golden ratio.</p>\n</li>\n<li><p>For folks who are not so familiar with NumPy -- all of the functions are \u201cvectorized,\u201d so that <code>sqrt(array)</code> is the same as what other languages might write <code>map(sqrt, array)</code>. So this is a component-by-component <code>sqrt</code> application. The same also holds for division by a scalar or addition with scalars -- those apply to all components in parallel.</p>\n</li>\n<li><p>The proof is simple once you know that this is the result. If you ask what's the probability that <em>z</em> &lt; <em>Z</em> &lt; <em>z</em> + d<em>z</em>, this is the same as asking what's the probability that <em>z</em> &lt; <em>F</em><sup>-1</sup>(<em>U</em>) &lt; <em>z</em> + d<em>z</em>, apply <em>F</em> to all three expressions noting that it is a monotonically increasing function, hence <em>F</em>(<em>z</em>) &lt; <em>U</em> &lt; <em>F</em>(<em>z</em> + d<em>z</em>), expand the right hand side out to find <em>F</em>(<em>z</em>) + <em>f</em>(<em>z</em>) d<em>z</em>, and since <em>U</em> is uniform this probability is just <em>f</em>(<em>z</em>) d<em>z</em> as promised.</p>\n</li>\n</ol>\n", "abstract": "You said you couldn\u2019t get the golden spiral method to work and that\u2019s a shame because it\u2019s really, really good. I would like to give you a complete understanding of it so that maybe you can understand how to keep this away from being \u201cbunched up.\u201d So here\u2019s a fast, non-random way to create a lattice that is approximately correct; as discussed above, no lattice will be perfect, but this may be good enough. It is compared to other methods e.g. at BendWavy.org but it just has a nice and pretty look as well as a guarantee about even spacing in the limit. To understand this algorithm, I first invite you to look at the 2D sunflower spiral algorithm. This is based on the fact that the most irrational number is the golden ratio (1 + sqrt(5))/2 and if one emits points by the approach \u201cstand at the center, turn a golden ratio of whole turns, then emit another point in that direction,\u201d one naturally constructs a spiral which, as you get to higher and higher numbers of points, nevertheless refuses to have well-defined \u2018bars\u2019 that the points line up on.(Note 1.) The algorithm for even spacing on a disk is, and it produces results that look like (n=100 and n=1000):  The key strange thing is the formula r = sqrt(indices / num_pts); how did I come to that one? (Note 2.) Well, I am using the square root here because I want these to have even-area spacing around the disk. That is the same as saying that in the limit of large N I want a little region R \u2208 (r, r + dr), \u0398 \u2208 (\u03b8, \u03b8 + d\u03b8) to contain a number of points proportional to its area, which is r dr d\u03b8. Now if we pretend that we are talking about a random variable here, this has a straightforward interpretation as saying that the joint probability density for (R, \u0398) is just c r for some constant c. Normalization on the unit disk would then force c = 1/\u03c0. Now let me introduce a trick. It comes from probability theory where it\u2019s known as sampling the inverse CDF: suppose you wanted to generate a random variable with a probability density f(z) and you have a random variable U ~ Uniform(0, 1), just like comes out of random() in most programming languages. How do you do this? Now the golden-ratio spiral trick spaces the points out in a nicely even pattern for \u03b8 so let\u2019s integrate that out; for the unit disk we are left with F(r) = r2. So the inverse function is F-1(u) = u1/2, and therefore we would generate random points on the disk in polar coordinates with r = sqrt(random()); theta = 2 * pi * random(). Now instead of randomly sampling this inverse function we\u2019re uniformly sampling it, and the nice thing about uniform sampling is that our results about how points are spread out in the limit of large N will behave as if we had randomly sampled it. This combination is the trick. Instead of random() we use (arange(0, num_pts, dtype=float) + 0.5)/num_pts, so that, say, if we want to sample 10 points they are r = 0.05, 0.15, 0.25, ... 0.95. We uniformly sample r to get equal-area spacing, and we use the sunflower increment to avoid awful \u201cbars\u201d of points in the output. The changes that we need to make to dot the sphere with points merely involve switching out the polar coordinates for spherical coordinates. The radial coordinate of course doesn't enter into this because we're on a unit sphere. To keep things a little more consistent here, even though I was trained as a physicist I'll use mathematicians' coordinates where 0 \u2264 \u03c6 \u2264 \u03c0 is latitude coming down from the pole and 0 \u2264 \u03b8 \u2264 2\u03c0 is longitude. So the difference from above is that we are basically replacing the variable r with \u03c6. Our area element, which was r dr d\u03b8, now becomes the not-much-more-complicated sin(\u03c6) d\u03c6 d\u03b8. So our joint density for uniform spacing is sin(\u03c6)/4\u03c0. Integrating out \u03b8, we find f(\u03c6) = sin(\u03c6)/2, thus F(\u03c6) = (1 \u2212 cos(\u03c6))/2. Inverting this we can see that a uniform random variable would look like acos(1 - 2 u), but we sample uniformly instead of randomly, so we instead use \u03c6k = acos(1 \u2212 2 (k + 0.5)/N). And the rest of the algorithm is just projecting this onto the x, y, and z coordinates: Again for n=100 and n=1000 the results look like:\n\n I wanted to give a shout out to Martin Roberts\u2019s blog. Note that above I created an offset of my indices by adding 0.5 to each index. This was just visually appealing to me, but it turns out that the choice of offset matters a lot and is not constant over the interval and can mean getting as much as 8% better accuracy in packing if chosen correctly. There should also be a way to get his R2 sequence to cover a sphere and it would be interesting to see if this also produced a nice even covering, perhaps as-is but perhaps needing to be, say, taken from only a half of the unit square cut diagonally or so and stretched around to get a circle. Those \u201cbars\u201d are formed by rational approximations to a number, and the best rational approximations to a number come from its continued fraction expression, z + 1/(n_1 + 1/(n_2 + 1/(n_3 + ...))) where z is an integer and n_1, n_2, n_3, ... is either a finite or infinite sequence of positive integers: Since the fraction part 1/(...) is always between zero and one, a large integer in the continued fraction allows for a particularly good rational approximation: \u201cone divided by something between 100 and 101\u201d is better than \u201cone divided by something between 1 and 2.\u201d The most irrational number is therefore the one which is 1 + 1/(1 + 1/(1 + ...)) and has no particularly good rational approximations; one can solve \u03c6 = 1 + 1/\u03c6 by multiplying through by \u03c6 to get the formula for the golden ratio. For folks who are not so familiar with NumPy -- all of the functions are \u201cvectorized,\u201d so that sqrt(array) is the same as what other languages might write map(sqrt, array). So this is a component-by-component sqrt application. The same also holds for division by a scalar or addition with scalars -- those apply to all components in parallel. The proof is simple once you know that this is the result. If you ask what's the probability that z < Z < z + dz, this is the same as asking what's the probability that z < F-1(U) < z + dz, apply F to all three expressions noting that it is a monotonically increasing function, hence F(z) < U < F(z + dz), expand the right hand side out to find F(z) + f(z) dz, and since U is uniform this probability is just f(z) dz as promised."}, {"id": 9606368, "score": 88, "vote": 0, "content": "<p>This is known as packing points on a sphere, and there is no (known) general, perfect solution.  However, there are plenty of imperfect solutions.  The three most popular seem to be:</p>\n<ol>\n<li><strong>Create a simulation</strong>.  Treat each point as an electron constrained to a sphere, then run a simulation for a certain number of steps.  The electrons' repulsion will naturally tend the system to a more stable state, where the points are about as far away from each other as they can get.</li>\n<li><strong>Hypercube rejection</strong>.  This fancy-sounding method is actually really simple:  you uniformly choose points <em>(much more than <code>n</code> of them)</em> inside of the cube surrounding the sphere, then reject the points outside of the sphere.  Treat the remaining points as vectors, and normalize them.  These are your \"samples\" - choose <code>n</code> of them using some method (randomly, greedy, etc).</li>\n<li><strong>Spiral approximations</strong>.  You trace a spiral around a sphere, and evenly-distribute the points around the spiral.  Because of the mathematics involved, these are more complicated to understand than the simulation, but much faster (and probably involving less code).  The most popular seems to be by <a href=\"http://www.math.vanderbilt.edu/saffeb/texts/161.pdf\" rel=\"noreferrer\">Saff, et al</a>.</li>\n</ol>\n<p>A <em>lot</em> more information about this problem can be found <a href=\"http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere\" rel=\"noreferrer\">here</a></p>\n", "abstract": "This is known as packing points on a sphere, and there is no (known) general, perfect solution.  However, there are plenty of imperfect solutions.  The three most popular seem to be: A lot more information about this problem can be found here"}, {"id": 9601334, "score": 15, "vote": 0, "content": "<p>In <a href=\"https://web.archive.org/web/20120107030109/http://cgafaq.info/wiki/Evenly_distributed_points_on_sphere#Spirals\" rel=\"noreferrer\">this example code</a> <code>node[k]</code> is just the kth node. You are generating an array N points and <code>node[k]</code> is the kth (from 0 to N-1). If that is all that is confusing you, hopefully you can use that now.</p>\n<p>(in other words, <code>k</code> is an array of size N that is defined before the code fragment starts, and which contains a list of the points).</p>\n<p><em>Alternatively</em>, building on the other answer here (and using Python):</p>\n<pre><code class=\"python\">&gt; cat ll.py\nfrom math import asin\nnx = 4; ny = 5\nfor x in range(nx):\n    lon = 360 * ((x+0.5) / nx)\n    for y in range(ny):                                                         \n        midpt = (y+0.5) / ny                                                    \n        lat = 180 * asin(2*((y+0.5)/ny-0.5))                                    \n        print lon,lat                                                           \n&gt; python2.7 ll.py                                                      \n45.0 -166.91313924                                                              \n45.0 -74.0730322921                                                             \n45.0 0.0                                                                        \n45.0 74.0730322921                                                              \n45.0 166.91313924                                                               \n135.0 -166.91313924                                                             \n135.0 -74.0730322921                                                            \n135.0 0.0                                                                       \n135.0 74.0730322921                                                             \n135.0 166.91313924                                                              \n225.0 -166.91313924                                                             \n225.0 -74.0730322921                                                            \n225.0 0.0                                                                       \n225.0 74.0730322921                                                             \n225.0 166.91313924\n315.0 -166.91313924\n315.0 -74.0730322921\n315.0 0.0\n315.0 74.0730322921\n315.0 166.91313924\n</code></pre>\n<p>If you plot that, you'll see that the vertical spacing is larger near the poles so that each point is situated in about the same total <em>area</em> of space (near the poles there's less space \"horizontally\", so it gives more \"vertically\").</p>\n<p>This isn't the same as all points having about the same distance to their neighbours (which is what I think your links are talking about), but it may be sufficient for what you want and improves on simply making a uniform lat/lon grid.</p>\n", "abstract": "In this example code node[k] is just the kth node. You are generating an array N points and node[k] is the kth (from 0 to N-1). If that is all that is confusing you, hopefully you can use that now. (in other words, k is an array of size N that is defined before the code fragment starts, and which contains a list of the points). Alternatively, building on the other answer here (and using Python): If you plot that, you'll see that the vertical spacing is larger near the poles so that each point is situated in about the same total area of space (near the poles there's less space \"horizontally\", so it gives more \"vertically\"). This isn't the same as all points having about the same distance to their neighbours (which is what I think your links are talking about), but it may be sufficient for what you want and improves on simply making a uniform lat/lon grid."}, {"id": 29663633, "score": 12, "vote": 0, "content": "<p>What you are looking for is called a <em>spherical covering</em>. The spherical covering problem is very hard and solutions are unknown except for small numbers of points. One thing that is known for sure is that given n points on a sphere, there always exist two points of distance <code>d = (4-csc^2(\\pi n/6(n-2)))^(1/2)</code> or closer.</p>\n<p>If you want a probabilistic method for generating points uniformly distributed on a sphere, it's easy: generate points in space uniformly by Gaussian distribution (it's built into Java, not hard to find the code for other languages). So in 3-dimensional space, you need something like </p>\n<pre><code class=\"python\">Random r = new Random();\ndouble[] p = { r.nextGaussian(), r.nextGaussian(), r.nextGaussian() };\n</code></pre>\n<p>Then project the point onto the sphere by normalizing its distance from the origin </p>\n<pre><code class=\"python\">double norm = Math.sqrt( (p[0])^2 + (p[1])^2 + (p[2])^2 ); \ndouble[] sphereRandomPoint = { p[0]/norm, p[1]/norm, p[2]/norm };\n</code></pre>\n<p>The Gaussian distribution in n dimensions is spherically symmetric so the projection onto the sphere is uniform.</p>\n<p>Of course, there's no guarantee that the distance between any two points in a collection of uniformly generated points will be bounded below, so you can use rejection to enforce any such conditions that you might have: probably it's best to generate the whole collection and then reject the whole collection if necessary. (Or use \"early rejection\" to reject the whole collection you've generated so far; just don't keep some points and drop others.) You can use the formula for <code>d</code> given above, minus some slack, to determine the min distance between points below which you will reject a set of points. You'll have to calculate n choose 2 distances, and the probability of rejection will depend on the slack; it's hard to say how, so run a simulation to get a feel for the relevant statistics.</p>\n", "abstract": "What you are looking for is called a spherical covering. The spherical covering problem is very hard and solutions are unknown except for small numbers of points. One thing that is known for sure is that given n points on a sphere, there always exist two points of distance d = (4-csc^2(\\pi n/6(n-2)))^(1/2) or closer. If you want a probabilistic method for generating points uniformly distributed on a sphere, it's easy: generate points in space uniformly by Gaussian distribution (it's built into Java, not hard to find the code for other languages). So in 3-dimensional space, you need something like  Then project the point onto the sphere by normalizing its distance from the origin  The Gaussian distribution in n dimensions is spherically symmetric so the projection onto the sphere is uniform. Of course, there's no guarantee that the distance between any two points in a collection of uniformly generated points will be bounded below, so you can use rejection to enforce any such conditions that you might have: probably it's best to generate the whole collection and then reject the whole collection if necessary. (Or use \"early rejection\" to reject the whole collection you've generated so far; just don't keep some points and drop others.) You can use the formula for d given above, minus some slack, to determine the min distance between points below which you will reject a set of points. You'll have to calculate n choose 2 distances, and the probability of rejection will depend on the slack; it's hard to say how, so run a simulation to get a feel for the relevant statistics."}, {"id": 16128461, "score": 7, "vote": 0, "content": "<p>This answer is based on the same 'theory'  that is outlined well by <a href=\"https://stackoverflow.com/a/9606368/155631\">this answer</a></p>\n<p>I'm adding this answer as: <br/>\n-- None of the other options fit the 'uniformity' need 'spot-on' (or not obviously-clearly so).  (Noting to get the planet like distribution looking behavior particurally wanted in the original ask, you just reject from the finite list of the k uniformly created points at random (random wrt the index count  in the k items back).) <br/>\n--The closest other impl forced you to decide the 'N' by 'angular axis', vs. just 'one value of N' across both angular axis values ( which at low counts of N is very tricky  to know what may, or may not matter  (e.g. you want '5' points -- have fun ) )  <br/>\n--Furthermore, it's very hard to 'grok' how to differentiate between the other options without any imagery, so here's what this option looks like (below), and the ready-to-run implementation that goes with it. <br/></p>\n<p><strong>with N at 20:</strong> <br/></p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/3mBdL.jpg\"/>\n<br/>\n<strong>and then N at 80:</strong>\n<img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/XSJqn.jpg\"/></p>\n<p><br/></p>\n<p>here's the ready-to-run python3 code, where the emulation is that same source: \" <a href=\"http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere\" rel=\"nofollow noreferrer\">http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere</a> \" found by others.  ( The plotting I've included, that fires when run as 'main,' is taken from: <a href=\"http://www.scipy.org/Cookbook/Matplotlib/mplot3D\" rel=\"nofollow noreferrer\">http://www.scipy.org/Cookbook/Matplotlib/mplot3D</a> )</p>\n<pre><code class=\"python\">from math import cos, sin, pi, sqrt\n\ndef GetPointsEquiAngularlyDistancedOnSphere(numberOfPoints=45):\n    \"\"\" each point you get will be of form 'x, y, z'; in cartesian coordinates\n        eg. the 'l2 distance' from the origion [0., 0., 0.] for each point will be 1.0 \n        ------------\n        converted from:  http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere ) \n    \"\"\"\n    dlong = pi*(3.0-sqrt(5.0))  # ~2.39996323 \n    dz   =  2.0/numberOfPoints\n    long =  0.0\n    z    =  1.0 - dz/2.0\n    ptsOnSphere =[]\n    for k in range( 0, numberOfPoints): \n        r    = sqrt(1.0-z*z)\n        ptNew = (cos(long)*r, sin(long)*r, z)\n        ptsOnSphere.append( ptNew )\n        z    = z - dz\n        long = long + dlong\n    return ptsOnSphere\n\nif __name__ == '__main__':                \n    ptsOnSphere = GetPointsEquiAngularlyDistancedOnSphere( 80)    \n\n    #toggle True/False to print them\n    if( True ):    \n        for pt in ptsOnSphere:  print( pt)\n\n    #toggle True/False to plot them\n    if(True):\n        from numpy import *\n        import pylab as p\n        import mpl_toolkits.mplot3d.axes3d as p3\n\n        fig=p.figure()\n        ax = p3.Axes3D(fig)\n\n        x_s=[];y_s=[]; z_s=[]\n\n        for pt in ptsOnSphere:\n            x_s.append( pt[0]); y_s.append( pt[1]); z_s.append( pt[2])\n\n        ax.scatter3D( array( x_s), array( y_s), array( z_s) )                \n        ax.set_xlabel('X'); ax.set_ylabel('Y'); ax.set_zlabel('Z')\n        p.show()\n        #end\n</code></pre>\n<p>tested at low counts (N in 2, 5, 7, 13, etc) and seems to work 'nice'</p>\n", "abstract": "This answer is based on the same 'theory'  that is outlined well by this answer I'm adding this answer as: \n-- None of the other options fit the 'uniformity' need 'spot-on' (or not obviously-clearly so).  (Noting to get the planet like distribution looking behavior particurally wanted in the original ask, you just reject from the finite list of the k uniformly created points at random (random wrt the index count  in the k items back).) \n--The closest other impl forced you to decide the 'N' by 'angular axis', vs. just 'one value of N' across both angular axis values ( which at low counts of N is very tricky  to know what may, or may not matter  (e.g. you want '5' points -- have fun ) )  \n--Furthermore, it's very hard to 'grok' how to differentiate between the other options without any imagery, so here's what this option looks like (below), and the ready-to-run implementation that goes with it.  with N at 20:  \n\nand then N at 80:\n  here's the ready-to-run python3 code, where the emulation is that same source: \" http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere \" found by others.  ( The plotting I've included, that fires when run as 'main,' is taken from: http://www.scipy.org/Cookbook/Matplotlib/mplot3D ) tested at low counts (N in 2, 5, 7, 13, etc) and seems to work 'nice'"}, {"id": 20852006, "score": 7, "vote": 0, "content": "<p>Try:</p>\n<pre><code class=\"python\">function sphere ( N:float,k:int):Vector3 {\n    var inc =  Mathf.PI  * (3 - Mathf.Sqrt(5));\n    var off = 2 / N;\n    var y = k * off - 1 + (off / 2);\n    var r = Mathf.Sqrt(1 - y*y);\n    var phi = k * inc;\n    return Vector3((Mathf.Cos(phi)*r), y, Mathf.Sin(phi)*r); \n};\n</code></pre>\n<p>The above function should run in loop with N loop total and k loop current iteration.</p>\n<p>It is based on a sunflower seeds pattern, except the sunflower seeds are curved around into a half dome, and again into a sphere.</p>\n<p>Here is a picture, except I put the camera half way inside the sphere so it looks 2d instead of 3d because the camera is same distance from all points.\n<a href=\"http://3.bp.blogspot.com/-9lbPHLccQHA/USXf88_bvVI/AAAAAAAAADY/j7qhQsSZsA8/s640/sphere.jpg\" rel=\"noreferrer\">http://3.bp.blogspot.com/-9lbPHLccQHA/USXf88_bvVI/AAAAAAAAADY/j7qhQsSZsA8/s640/sphere.jpg</a></p>\n", "abstract": "Try: The above function should run in loop with N loop total and k loop current iteration. It is based on a sunflower seeds pattern, except the sunflower seeds are curved around into a half dome, and again into a sphere. Here is a picture, except I put the camera half way inside the sphere so it looks 2d instead of 3d because the camera is same distance from all points.\nhttp://3.bp.blogspot.com/-9lbPHLccQHA/USXf88_bvVI/AAAAAAAAADY/j7qhQsSZsA8/s640/sphere.jpg"}, {"id": 44599165, "score": 4, "vote": 0, "content": "<p>Healpix solves a closely related problem (pixelating the sphere with equal area pixels):</p>\n<p><a href=\"http://healpix.sourceforge.net/\" rel=\"nofollow noreferrer\">http://healpix.sourceforge.net/</a></p>\n<p>It's probably overkill, but maybe after looking at it you'll realize some of it's other nice properties are interesting to you. It's way more than just a function that outputs a point cloud.</p>\n<p>I landed here trying to find it again; the name \"healpix\" doesn't exactly evoke spheres... </p>\n", "abstract": "Healpix solves a closely related problem (pixelating the sphere with equal area pixels): http://healpix.sourceforge.net/ It's probably overkill, but maybe after looking at it you'll realize some of it's other nice properties are interesting to you. It's way more than just a function that outputs a point cloud. I landed here trying to find it again; the name \"healpix\" doesn't exactly evoke spheres... "}, {"id": 9602404, "score": 2, "vote": 0, "content": "<p><strong>edit:</strong> This does not answer the question the OP meant to ask, leaving it here in case people find it useful somehow.</p>\n<p>We use the multiplication rule of probability, combined with infinitessimals. This results in 2 lines of code to achieve your desired result:</p>\n<pre><code class=\"python\">longitude: \u03c6 = uniform([0,2pi))\nazimuth:   \u03b8 = -arcsin(1 - 2*uniform([0,1]))\n</code></pre>\n<p>(defined in the following coordinate system:)</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/EHHKM.png\"/></p>\n<p>Your language typically has a uniform random number primitive. For example in python you can use <code>random.random()</code> to return a number in the range <code>[0,1)</code>. You can multiply this number by k to get a random number in the range <code>[0,k)</code>. Thus in python, <code>uniform([0,2pi))</code> would mean <code>random.random()*2*math.pi</code>.</p>\n<hr/>\n<p><strong>Proof</strong></p>\n<p>Now we can't assign \u03b8 uniformly, otherwise we'd get clumping at the poles. We wish to assign probabilities proportional to the surface area of the spherical wedge (the \u03b8 in this diagram is actually \u03c6):</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/4OHbn.gif\"/></p>\n<p>An angular displacement d\u03c6 at the equator will result in a displacement of d\u03c6*r. What will that displacement be at an arbitrary azimuth \u03b8? Well, the radius from the z-axis is <code>r*sin(\u03b8)</code>, so the arclength of that \"latitude\" intersecting the wedge is <code>d\u03c6 * r*sin(\u03b8)</code>. Thus we calculate the <a href=\"http://en.wikipedia.org/wiki/Cumulative_distribution_function\" rel=\"nofollow noreferrer\">cumulative distribution</a> of the area to sample from it, by integrating the area of the slice from the south pole to the north pole.</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/AZGuq.gif\"/> (where stuff=<code>d\u03c6*r</code>)</p>\n<p>We will now attempt to get the inverse of the CDF to sample from it: <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/Inverse_transform_sampling</a></p>\n<p>First we normalize by dividing our almost-CDF by its maximum value. This has the side-effect of cancelling out the d\u03c6 and r.</p>\n<pre><code class=\"python\">azimuthalCDF: cumProb = (sin(\u03b8)+1)/2 from -pi/2 to pi/2\n\ninverseCDF: \u03b8 = -sin^(-1)(1 - 2*cumProb)\n</code></pre>\n<p>Thus:</p>\n<pre><code class=\"python\">let x by a random float in range [0,1]\n\u03b8 = -arcsin(1-2*x)\n</code></pre>\n", "abstract": "edit: This does not answer the question the OP meant to ask, leaving it here in case people find it useful somehow. We use the multiplication rule of probability, combined with infinitessimals. This results in 2 lines of code to achieve your desired result: (defined in the following coordinate system:)  Your language typically has a uniform random number primitive. For example in python you can use random.random() to return a number in the range [0,1). You can multiply this number by k to get a random number in the range [0,k). Thus in python, uniform([0,2pi)) would mean random.random()*2*math.pi. Proof Now we can't assign \u03b8 uniformly, otherwise we'd get clumping at the poles. We wish to assign probabilities proportional to the surface area of the spherical wedge (the \u03b8 in this diagram is actually \u03c6):  An angular displacement d\u03c6 at the equator will result in a displacement of d\u03c6*r. What will that displacement be at an arbitrary azimuth \u03b8? Well, the radius from the z-axis is r*sin(\u03b8), so the arclength of that \"latitude\" intersecting the wedge is d\u03c6 * r*sin(\u03b8). Thus we calculate the cumulative distribution of the area to sample from it, by integrating the area of the slice from the south pole to the north pole.  (where stuff=d\u03c6*r) We will now attempt to get the inverse of the CDF to sample from it: http://en.wikipedia.org/wiki/Inverse_transform_sampling First we normalize by dividing our almost-CDF by its maximum value. This has the side-effect of cancelling out the d\u03c6 and r. Thus:"}, {"id": 9601168, "score": 1, "vote": 0, "content": "<p>Take the two largest factors of your <code>N</code>, if <code>N==20</code> then the two largest factors are <code>{5,4}</code>, or, more generally <code>{a,b}</code>.  Calculate </p>\n<pre><code class=\"python\">dlat  = 180/(a+1)\ndlong = 360/(b+1})\n</code></pre>\n<p>Put your first point at <code>{90-dlat/2,(dlong/2)-180}</code>, your second at <code>{90-dlat/2,(3*dlong/2)-180}</code>, your 3rd at <code>{90-dlat/2,(5*dlong/2)-180}</code>, until you've tripped round the world once, by which time you've got to about <code>{75,150}</code> when you go next to <code>{90-3*dlat/2,(dlong/2)-180}</code>.</p>\n<p>Obviously I'm working this in degrees on the surface of the spherical earth, with the usual conventions for translating +/- to N/S or E/W.  And obviously this gives you a completely non-random distribution, but it is uniform and the points are not bunched together.</p>\n<p>To add some degree of randomness, you could generate 2 normally-distributed (with mean 0 and std dev of {dlat/3, dlong/3} as appropriate) and add them to your uniformly distributed points.</p>\n", "abstract": "Take the two largest factors of your N, if N==20 then the two largest factors are {5,4}, or, more generally {a,b}.  Calculate  Put your first point at {90-dlat/2,(dlong/2)-180}, your second at {90-dlat/2,(3*dlong/2)-180}, your 3rd at {90-dlat/2,(5*dlong/2)-180}, until you've tripped round the world once, by which time you've got to about {75,150} when you go next to {90-3*dlat/2,(dlong/2)-180}. Obviously I'm working this in degrees on the surface of the spherical earth, with the usual conventions for translating +/- to N/S or E/W.  And obviously this gives you a completely non-random distribution, but it is uniform and the points are not bunched together. To add some degree of randomness, you could generate 2 normally-distributed (with mean 0 and std dev of {dlat/3, dlong/3} as appropriate) and add them to your uniformly distributed points."}, {"id": 9601408, "score": 1, "vote": 0, "content": "<p>with small numbers of points you could run a simulation:</p>\n<pre><code class=\"python\">from random import random,randint\nr = 10\nn = 20\nbest_closest_d = 0\nbest_points = []\npoints = [(r,0,0) for i in range(n)]\nfor simulation in range(10000):\n    x = random()*r\n    y = random()*r\n    z = r-(x**2+y**2)**0.5\n    if randint(0,1):\n        x = -x\n    if randint(0,1):\n        y = -y\n    if randint(0,1):\n        z = -z\n    closest_dist = (2*r)**2\n    closest_index = None\n    for i in range(n):\n        for j in range(n):\n            if i==j:\n                continue\n            p1,p2 = points[i],points[j]\n            x1,y1,z1 = p1\n            x2,y2,z2 = p2\n            d = (x1-x2)**2+(y1-y2)**2+(z1-z2)**2\n            if d &lt; closest_dist:\n                closest_dist = d\n                closest_index = i\n    if simulation % 100 == 0:\n        print simulation,closest_dist\n    if closest_dist &gt; best_closest_d:\n        best_closest_d = closest_dist\n        best_points = points[:]\n    points[closest_index]=(x,y,z)\n\n\nprint best_points\n&gt;&gt;&gt; best_points\n[(9.921692138442777, -9.930808529773849, 4.037839326088124),\n (5.141893371460546, 1.7274947332807744, -4.575674650522637),\n (-4.917695758662436, -1.090127967097737, -4.9629263893193745),\n (3.6164803265540666, 7.004158551438312, -2.1172868271109184),\n (-9.550655088997003, -9.580386054762917, 3.5277052594769422),\n (-0.062238110294250415, 6.803105171979587, 3.1966101417463655),\n (-9.600996012203195, 9.488067284474834, -3.498242301168819),\n (-8.601522086624803, 4.519484132245867, -0.2834204048792728),\n (-1.1198210500791472, -2.2916581379035694, 7.44937337008726),\n (7.981831370440529, 8.539378431788634, 1.6889099589074377),\n (0.513546008372332, -2.974333486904779, -6.981657873262494),\n (-4.13615438946178, -6.707488383678717, 2.1197605651446807),\n (2.2859494919024326, -8.14336582650039, 1.5418694699275672),\n (-7.241410895247996, 9.907335206038226, 2.271647103735541),\n (-9.433349952523232, -7.999106443463781, -2.3682575660694347),\n (3.704772125650199, 1.0526567864085812, 6.148581714099761),\n (-3.5710511242327048, 5.512552040316693, -3.4318468250897647),\n (-7.483466337225052, -1.506434920354559, 2.36641535124918),\n (7.73363824231576, -8.460241422163824, -1.4623228616326003),\n (10, 0, 0)]\n</code></pre>\n", "abstract": "with small numbers of points you could run a simulation:"}, {"id": 21949236, "score": 1, "vote": 0, "content": "<p>OR... to place 20 points, compute the centers of the icosahedronal faces. For 12 points, find the vertices of the icosahedron. For 30 points, the mid point of the edges of the icosahedron. you can do the same thing with the tetrahedron, cube, dodecahedron and octahedrons: one set of points is on the vertices, another on the center of the face and another on the center of the edges. They cannot be mixed, however.</p>\n", "abstract": "OR... to place 20 points, compute the centers of the icosahedronal faces. For 12 points, find the vertices of the icosahedron. For 30 points, the mid point of the edges of the icosahedron. you can do the same thing with the tetrahedron, cube, dodecahedron and octahedrons: one set of points is on the vertices, another on the center of the face and another on the center of the edges. They cannot be mixed, however."}, {"id": 66257432, "score": 1, "vote": 0, "content": "<p>Based on fnord's answer, here is a Unity3D version with added ranges :</p>\n<p>Code :</p>\n<pre class=\"lang-cs prettyprint-override\"><code class=\"python\">// golden angle in radians\nstatic float Phi = Mathf.PI * ( 3f - Mathf.Sqrt( 5f ) );\nstatic float Pi2 = Mathf.PI * 2;\n\npublic static Vector3 Point( float radius , int index , int total , float min = 0f, float max = 1f , float angleStartDeg = 0f, float angleRangeDeg = 360 )\n{\n    // y goes from min (-) to max (+)\n    var y = ( ( index / ( total - 1f ) ) * ( max - min ) + min ) * 2f - 1f;\n\n    // golden angle increment\n    var theta = Phi * index ; \n        \n    if( angleStartDeg != 0 || angleRangeDeg != 360 )\n    {\n        theta = ( theta % ( Pi2 ) ) ;\n        theta = theta &lt; 0 ? theta + Pi2 : theta ;\n            \n        var a1 = angleStartDeg * Mathf.Deg2Rad;\n        var a2 = angleRangeDeg * Mathf.Deg2Rad;\n            \n        theta = theta * a2 / Pi2 + a1;\n    }\n\n    // https://stackoverflow.com/a/26127012/2496170\n    \n    // radius at y\n    var rY = Mathf.Sqrt( 1 - y * y ); \n    \n    var x = Mathf.Cos( theta ) * rY;\n    var z = Mathf.Sin( theta ) * rY;\n\n    return  new Vector3( x, y, z ) * radius;\n}\n</code></pre>\n<p>Gist : <a href=\"https://gist.github.com/nukadelic/7449f0872f708065bc1afeb19df666f7/edit\" rel=\"nofollow noreferrer\">https://gist.github.com/nukadelic/7449f0872f708065bc1afeb19df666f7/edit</a></p>\n<p>Preview:</p>\n<p><a href=\"https://i.imgur.com/HtMeCtq.mp4\" rel=\"nofollow noreferrer\"><img alt=\"MP4\" src=\"https://i.imgur.com/mmEjYwc.png\"/></a></p>\n", "abstract": "Based on fnord's answer, here is a Unity3D version with added ranges : Code : Gist : https://gist.github.com/nukadelic/7449f0872f708065bc1afeb19df666f7/edit Preview: "}, {"id": 12588704, "score": 0, "vote": 0, "content": "<pre><code class=\"python\"># create uniform spiral grid\nnumOfPoints = varargin[0]\nvxyz = zeros((numOfPoints,3),dtype=float)\nsq0 = 0.00033333333**2\nsq2 = 0.9999998**2\nsumsq = 2*sq0 + sq2\nvxyz[numOfPoints -1] = array([(sqrt(sq0/sumsq)), \n                              (sqrt(sq0/sumsq)), \n                              (-sqrt(sq2/sumsq))])\nvxyz[0] = -vxyz[numOfPoints -1] \nphi2 = sqrt(5)*0.5 + 2.5\nrootCnt = sqrt(numOfPoints)\nprevLongitude = 0\nfor index in arange(1, (numOfPoints -1), 1, dtype=float):\n  zInc = (2*index)/(numOfPoints) -1\n  radius = sqrt(1-zInc**2)\n\n  longitude = phi2/(rootCnt*radius)\n  longitude = longitude + prevLongitude\n  while (longitude &gt; 2*pi): \n    longitude = longitude - 2*pi\n\n  prevLongitude = longitude\n  if (longitude &gt; pi):\n    longitude = longitude - 2*pi\n\n  latitude = arccos(zInc) - pi/2\n  vxyz[index] = array([ (cos(latitude) * cos(longitude)) ,\n                        (cos(latitude) * sin(longitude)), \n                        sin(latitude)])\n</code></pre>\n", "abstract": ""}, {"id": 63002668, "score": 0, "vote": 0, "content": "<p>@robert king It's a really nice solution but has some sloppy bugs in it.    I know it helped me a lot though, so never mind the sloppiness.  :)\nHere is a cleaned up version....</p>\n<pre><code class=\"python\">from math import pi, asin, sin, degrees\nhalfpi, twopi = .5 * pi, 2 * pi\nsphere_area = lambda R=1.0: 4 * pi * R ** 2\n\nlat_dist = lambda lat, R=1.0: R*(1-sin(lat))\n\n#A = 2*pi*R^2(1-sin(lat))\ndef sphere_latarea(lat, R=1.0):\n    if -halfpi &gt; lat or lat &gt; halfpi:\n        raise ValueError(\"lat must be between -halfpi and halfpi\")\n    return 2 * pi * R ** 2 * (1-sin(lat))\n\nsphere_lonarea = lambda lon, R=1.0: \\\n        4 * pi * R ** 2 * lon / twopi\n\n#A = 2*pi*R^2 |sin(lat1)-sin(lat2)| |lon1-lon2|/360\n#    = (pi/180)R^2 |sin(lat1)-sin(lat2)| |lon1-lon2|\nsphere_rectarea = lambda lat0, lat1, lon0, lon1, R=1.0: \\\n        (sphere_latarea(lat0, R)-sphere_latarea(lat1, R)) * (lon1-lon0) / twopi\n\n\ndef test_sphere(n_lats=10, n_lons=19, radius=540.0):\n    total_area = 0.0\n    for i_lons in range(n_lons):\n        lon0 = twopi * float(i_lons) / n_lons\n        lon1 = twopi * float(i_lons+1) / n_lons\n        for i_lats in range(n_lats):\n            lat0 = asin(2 * float(i_lats) / n_lats - 1)\n            lat1 = asin(2 * float(i_lats+1)/n_lats - 1)\n            area = sphere_rectarea(lat0, lat1, lon0, lon1, radius)\n            print(\"{:} {:}: {:9.4f} to  {:9.4f}, {:9.4f} to  {:9.4f} =&gt; area {:10.4f}\"\n                    .format(i_lats, i_lons\n                    , degrees(lat0), degrees(lat1)\n                    , degrees(lon0), degrees(lon1)\n                    , area))\n            total_area += area\n    print(\"total_area = {:10.4f} (difference of {:10.4f})\"\n            .format(total_area, abs(total_area) - sphere_area(radius)))\n\ntest_sphere()\n</code></pre>\n", "abstract": "@robert king It's a really nice solution but has some sloppy bugs in it.    I know it helped me a lot though, so never mind the sloppiness.  :)\nHere is a cleaned up version...."}, {"id": 74080162, "score": 0, "vote": 0, "content": "<p>Here is a simple algorithm that is applicable to n-dimensions:</p>\n<pre><code class=\"python\">/**\n * Populate points on the surface of a unit radius n-dimensional hypersphere.\n * The points are evenly spaced relative to a random starting point.\n * \n * @param dims The number of dimensions in the hypersphere.\n * @param numPoints The number of points to populate.\n * @param points The points to populate. The shape is points[numPoints][dims].\n */\nprivate void populateHypersphere(int dims, int numPoints, double[][] points) {\n    \n    if (dims &lt;= 0)\n        throw new IllegalArgumentException(\"dims must be &gt; 0\");\n    \n    if (numPoints &lt;= 0)\n        throw new IllegalArgumentException(\"num points must be &gt; 0\");\n    \n    final double TWOPI = 2 * Math.PI;\n    \n    final double DELTA = TWOPI / numPoints;\n    \n    ThreadLocalRandom rng = ThreadLocalRandom.current();\n\n    // in each dimension generate a series of evenly spaced points\n    //   where the values vary from -1.0 to 1.0\n    \n    // insert some randomness if needed. this can be set to 0 if desired.\n    // or move it inside outer for loop below and each axis will have\n    // a different random start angle.\n    \n    double BASE_ANGLE = rng.nextDouble(TWOPI);\n\n    for (int d = 0; d &lt; dims; d++) {\n        \n        for (int p = 0; p &lt; numPoints; p++) {\n            \n            points[p][d] = Math.cos(BASE_ANGLE + p*DELTA);\n        }\n    }\n\n    // now scale the points into unit vectors\n    \n    for (int p = 0; p &lt; numPoints; p++) {\n        \n        double norm = 0;\n        \n        for (int d = 0; d &lt; dims; d++) {\n            \n            norm += points[p][d] * points[p][d];\n        }\n\n        norm = Math.sqrt(norm);\n        \n        if (norm == 0) {\n            norm = 1;\n        }\n\n        for (int d = 0; d &lt; dims; d++) {\n            \n            points[p][d] /= norm;\n        }\n    }\n    \n    // At this point you can scale and translate the sphere\n    // points into your coordinates of choice. For instance:\n    //   newCoords = (newScale * each vector) + newOrigin \n}\n</code></pre>\n", "abstract": "Here is a simple algorithm that is applicable to n-dimensions:"}, {"id": 14149595, "score": -1, "vote": 0, "content": "<p>This works and it's deadly simple. As many points as you want:</p>\n<pre><code class=\"python\">    private function moveTweets():void {\n\n\n        var newScale:Number=Scale(meshes.length,50,500,6,2);\n        trace(\"new scale:\"+newScale);\n\n\n        var l:Number=this.meshes.length;\n        var tweetMeshInstance:TweetMesh;\n        var destx:Number;\n        var desty:Number;\n        var destz:Number;\n        for (var i:Number=0;i&lt;this.meshes.length;i++){\n\n            tweetMeshInstance=meshes[i];\n\n            var phi:Number = Math.acos( -1 + ( 2 * i ) / l );\n            var theta:Number = Math.sqrt( l * Math.PI ) * phi;\n\n            tweetMeshInstance.origX = (sphereRadius+5) * Math.cos( theta ) * Math.sin( phi );\n            tweetMeshInstance.origY= (sphereRadius+5) * Math.sin( theta ) * Math.sin( phi );\n            tweetMeshInstance.origZ = (sphereRadius+5) * Math.cos( phi );\n\n            destx=sphereRadius * Math.cos( theta ) * Math.sin( phi );\n            desty=sphereRadius * Math.sin( theta ) * Math.sin( phi );\n            destz=sphereRadius * Math.cos( phi );\n\n            tweetMeshInstance.lookAt(new Vector3D());\n\n\n            TweenMax.to(tweetMeshInstance, 1, {scaleX:newScale,scaleY:newScale,x:destx,y:desty,z:destz,onUpdate:onLookAtTween, onUpdateParams:[tweetMeshInstance]});\n\n        }\n\n    }\n    private function onLookAtTween(theMesh:TweetMesh):void {\n        theMesh.lookAt(new Vector3D());\n    }\n</code></pre>\n", "abstract": "This works and it's deadly simple. As many points as you want:"}]}, {"link": "https://stackoverflow.com/questions/2371436/evaluating-a-mathematical-expression-in-a-string", "question": {"id": "2371436", "title": "Evaluating a mathematical expression in a string", "content": "<pre><code class=\"python\">stringExp = \"2^4\"\nintVal = int(stringExp)      # Expected value: 16\n</code></pre>\n<p>This returns the following error:</p>\n<pre><code class=\"python\">Traceback (most recent call last):  \nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: invalid literal for int()\nwith base 10: '2^4'\n</code></pre>\n<p>I know that <code>eval</code> can work around this, but isn't there a better and - more importantly - safer method to evaluate a mathematical expression that is being stored in a string?</p>\n", "abstract": "This returns the following error: I know that eval can work around this, but isn't there a better and - more importantly - safer method to evaluate a mathematical expression that is being stored in a string?"}, "answers": [{"id": 9558001, "score": 236, "vote": 0, "content": "<h2><code>eval</code> is evil</h2>\n<pre><code class=\"python\">eval(\"__import__('os').remove('important file')\") # arbitrary commands\neval(\"9**9**9**9**9**9**9**9\", {'__builtins__': None}) # CPU, memory\n</code></pre>\n<p>Note: even if you use set <code>__builtins__</code> to <code>None</code> it still might be possible to break out using introspection:</p>\n<pre><code class=\"python\">eval('(1).__class__.__bases__[0].__subclasses__()', {'__builtins__': None})\n</code></pre>\n<h2>Evaluate arithmetic expression using <code>ast</code></h2>\n<pre><code class=\"python\">import ast\nimport operator as op\n\n# supported operators\noperators = {ast.Add: op.add, ast.Sub: op.sub, ast.Mult: op.mul,\n             ast.Div: op.truediv, ast.Pow: op.pow, ast.BitXor: op.xor,\n             ast.USub: op.neg}\n\ndef eval_expr(expr):\n    \"\"\"\n    &gt;&gt;&gt; eval_expr('2^6')\n    4\n    &gt;&gt;&gt; eval_expr('2**6')\n    64\n    &gt;&gt;&gt; eval_expr('1 + 2*3**(4^5) / (6 + -7)')\n    -5.0\n    \"\"\"\n    return eval_(ast.parse(expr, mode='eval').body)\n\ndef eval_(node):\n    if isinstance(node, ast.Num): # &lt;number&gt;\n        return node.n\n    elif isinstance(node, ast.BinOp): # &lt;left&gt; &lt;operator&gt; &lt;right&gt;\n        return operators[type(node.op)](eval_(node.left), eval_(node.right))\n    elif isinstance(node, ast.UnaryOp): # &lt;operator&gt; &lt;operand&gt; e.g., -1\n        return operators[type(node.op)](eval_(node.operand))\n    else:\n        raise TypeError(node)\n</code></pre>\n<p>You can easily limit allowed range for each operation or any intermediate result, e.g., to limit input arguments for <code>a**b</code>:</p>\n<pre><code class=\"python\">def power(a, b):\n    if any(abs(n) &gt; 100 for n in [a, b]):\n        raise ValueError((a,b))\n    return op.pow(a, b)\noperators[ast.Pow] = power\n</code></pre>\n<p>Or to limit magnitude of intermediate results:</p>\n<pre><code class=\"python\">import functools\n\ndef limit(max_=None):\n    \"\"\"Return decorator that limits allowed returned values.\"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            ret = func(*args, **kwargs)\n            try:\n                mag = abs(ret)\n            except TypeError:\n                pass # not applicable\n            else:\n                if mag &gt; max_:\n                    raise ValueError(ret)\n            return ret\n        return wrapper\n    return decorator\n\neval_ = limit(max_=10**100)(eval_)\n</code></pre>\n<h3>Example</h3>\n<pre><code class=\"python\">&gt;&gt;&gt; evil = \"__import__('os').remove('important file')\"\n&gt;&gt;&gt; eval_expr(evil) #doctest:+IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nTypeError:\n&gt;&gt;&gt; eval_expr(\"9**9\")\n387420489\n&gt;&gt;&gt; eval_expr(\"9**9**9**9**9**9**9**9\") #doctest:+IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nValueError:\n</code></pre>\n", "abstract": "Note: even if you use set __builtins__ to None it still might be possible to break out using introspection: You can easily limit allowed range for each operation or any intermediate result, e.g., to limit input arguments for a**b: Or to limit magnitude of intermediate results:"}, {"id": 2371789, "score": 130, "vote": 0, "content": "<p><a href=\"https://github.com/pyparsing/pyparsing\" rel=\"noreferrer\">Pyparsing</a> can be used to parse mathematical expressions. In particular, <a href=\"https://github.com/pyparsing/pyparsing/blob/master/examples/fourFn.py\" rel=\"noreferrer\">fourFn.py</a>\nshows how to parse basic arithmetic expressions. Below, I've rewrapped fourFn into a numeric parser class for easier reuse. </p>\n<pre><code class=\"python\">from __future__ import division\nfrom pyparsing import (Literal, CaselessLiteral, Word, Combine, Group, Optional,\n                       ZeroOrMore, Forward, nums, alphas, oneOf)\nimport math\nimport operator\n\n__author__ = 'Paul McGuire'\n__version__ = '$Revision: 0.0 $'\n__date__ = '$Date: 2009-03-20 $'\n__source__ = '''http://pyparsing.wikispaces.com/file/view/fourFn.py\nhttp://pyparsing.wikispaces.com/message/view/home/15549426\n'''\n__note__ = '''\nAll I've done is rewrap Paul McGuire's fourFn.py as a class, so I can use it\nmore easily in other places.\n'''\n\n\nclass NumericStringParser(object):\n    '''\n    Most of this code comes from the fourFn.py pyparsing example\n\n    '''\n\n    def pushFirst(self, strg, loc, toks):\n        self.exprStack.append(toks[0])\n\n    def pushUMinus(self, strg, loc, toks):\n        if toks and toks[0] == '-':\n            self.exprStack.append('unary -')\n\n    def __init__(self):\n        \"\"\"\n        expop   :: '^'\n        multop  :: '*' | '/'\n        addop   :: '+' | '-'\n        integer :: ['+' | '-'] '0'..'9'+\n        atom    :: PI | E | real | fn '(' expr ')' | '(' expr ')'\n        factor  :: atom [ expop factor ]*\n        term    :: factor [ multop factor ]*\n        expr    :: term [ addop term ]*\n        \"\"\"\n        point = Literal(\".\")\n        e = CaselessLiteral(\"E\")\n        fnumber = Combine(Word(\"+-\" + nums, nums) +\n                          Optional(point + Optional(Word(nums))) +\n                          Optional(e + Word(\"+-\" + nums, nums)))\n        ident = Word(alphas, alphas + nums + \"_$\")\n        plus = Literal(\"+\")\n        minus = Literal(\"-\")\n        mult = Literal(\"*\")\n        div = Literal(\"/\")\n        lpar = Literal(\"(\").suppress()\n        rpar = Literal(\")\").suppress()\n        addop = plus | minus\n        multop = mult | div\n        expop = Literal(\"^\")\n        pi = CaselessLiteral(\"PI\")\n        expr = Forward()\n        atom = ((Optional(oneOf(\"- +\")) +\n                 (ident + lpar + expr + rpar | pi | e | fnumber).setParseAction(self.pushFirst))\n                | Optional(oneOf(\"- +\")) + Group(lpar + expr + rpar)\n                ).setParseAction(self.pushUMinus)\n        # by defining exponentiation as \"atom [ ^ factor ]...\" instead of\n        # \"atom [ ^ atom ]...\", we get right-to-left exponents, instead of left-to-right\n        # that is, 2^3^2 = 2^(3^2), not (2^3)^2.\n        factor = Forward()\n        factor &lt;&lt; atom + \\\n            ZeroOrMore((expop + factor).setParseAction(self.pushFirst))\n        term = factor + \\\n            ZeroOrMore((multop + factor).setParseAction(self.pushFirst))\n        expr &lt;&lt; term + \\\n            ZeroOrMore((addop + term).setParseAction(self.pushFirst))\n        # addop_term = ( addop + term ).setParseAction( self.pushFirst )\n        # general_term = term + ZeroOrMore( addop_term ) | OneOrMore( addop_term)\n        # expr &lt;&lt;  general_term\n        self.bnf = expr\n        # map operator symbols to corresponding arithmetic operations\n        epsilon = 1e-12\n        self.opn = {\"+\": operator.add,\n                    \"-\": operator.sub,\n                    \"*\": operator.mul,\n                    \"/\": operator.truediv,\n                    \"^\": operator.pow}\n        self.fn = {\"sin\": math.sin,\n                   \"cos\": math.cos,\n                   \"tan\": math.tan,\n                   \"exp\": math.exp,\n                   \"abs\": abs,\n                   \"trunc\": lambda a: int(a),\n                   \"round\": round,\n                   \"sgn\": lambda a: abs(a) &gt; epsilon and cmp(a, 0) or 0}\n\n    def evaluateStack(self, s):\n        op = s.pop()\n        if op == 'unary -':\n            return -self.evaluateStack(s)\n        if op in \"+-*/^\":\n            op2 = self.evaluateStack(s)\n            op1 = self.evaluateStack(s)\n            return self.opn[op](op1, op2)\n        elif op == \"PI\":\n            return math.pi  # 3.1415926535\n        elif op == \"E\":\n            return math.e  # 2.718281828\n        elif op in self.fn:\n            return self.fn[op](self.evaluateStack(s))\n        elif op[0].isalpha():\n            return 0\n        else:\n            return float(op)\n\n    def eval(self, num_string, parseAll=True):\n        self.exprStack = []\n        results = self.bnf.parseString(num_string, parseAll)\n        val = self.evaluateStack(self.exprStack[:])\n        return val\n</code></pre>\n<p>You can use it like this</p>\n<pre><code class=\"python\">nsp = NumericStringParser()\nresult = nsp.eval('2^4')\nprint(result)\n# 16.0\n\nresult = nsp.eval('exp(2^4)')\nprint(result)\n# 8886110.520507872\n</code></pre>\n", "abstract": "Pyparsing can be used to parse mathematical expressions. In particular, fourFn.py\nshows how to parse basic arithmetic expressions. Below, I've rewrapped fourFn into a numeric parser class for easier reuse.  You can use it like this"}, {"id": 18096137, "score": 14, "vote": 0, "content": "<p>Some safer alternatives to <code>eval()</code> and <a href=\"http://docs.sympy.org/latest/modules/core.html#module-sympy.core.sympify\" rel=\"noreferrer\"><code>sympy.sympify().evalf()</code></a><sup>*</sup>:</p>\n<ul>\n<li><a href=\"http://newville.github.io/asteval/\" rel=\"noreferrer\">asteval</a> </li>\n<li><a href=\"https://github.com/pydata/numexpr\" rel=\"noreferrer\">numexpr</a></li>\n</ul>\n<p><sup>*</sup>SymPy <a href=\"http://docs.sympy.org/latest/modules/core.html#module-sympy.core.sympify\" rel=\"noreferrer\"><code>sympify</code></a> is also unsafe according to the following warning from the documentation.</p>\n<blockquote>\n<p><strong>Warning:</strong> Note that this function uses <code>eval</code>, and thus shouldn\u2019t be used on unsanitized input.</p>\n</blockquote>\n", "abstract": "Some safer alternatives to eval() and sympy.sympify().evalf()*: *SymPy sympify is also unsafe according to the following warning from the documentation. Warning: Note that this function uses eval, and thus shouldn\u2019t be used on unsanitized input."}, {"id": 25437733, "score": 11, "vote": 0, "content": "<p>Okay, so the problem with eval is that it can escape its sandbox too easily, even if you get rid of <code>__builtins__</code>.  All the methods for escaping the sandbox come down to using <code>getattr</code> or <code>object.__getattribute__</code> (via the <code>.</code> operator) to obtain a reference to some dangerous object via some allowed object (<code>''.__class__.__bases__[0].__subclasses__</code> or similar).  <code>getattr</code> is eliminated by setting <code>__builtins__</code> to <code>None</code>.  <code>object.__getattribute__</code> is the difficult one, since it cannot simply be removed, both because <code>object</code> is immutable and because removing it would break everything.  However, <code>__getattribute__</code> is only accessible via the <code>.</code> operator, so purging that from your input is sufficient to ensure eval cannot escape its sandbox.<br/>\nIn processing formulas, the only valid use of a decimal is when it is preceded or followed by <code>[0-9]</code>, so we just remove all other instances of <code>.</code>.</p>\n<pre><code class=\"python\">import re\ninp = re.sub(r\"\\.(?![0-9])\",\"\", inp)\nval = eval(inp, {'__builtins__':None})\n</code></pre>\n<p>Note that while python normally treats <code>1 + 1.</code> as <code>1 + 1.0</code>, this will remove the trailing <code>.</code> and leave you with <code>1 + 1</code>.  You could add <code>)</code>,<code></code>, and <code>EOF</code> to the list of things allowed to follow <code>.</code>, but why bother?</p>\n", "abstract": "Okay, so the problem with eval is that it can escape its sandbox too easily, even if you get rid of __builtins__.  All the methods for escaping the sandbox come down to using getattr or object.__getattribute__ (via the . operator) to obtain a reference to some dangerous object via some allowed object (''.__class__.__bases__[0].__subclasses__ or similar).  getattr is eliminated by setting __builtins__ to None.  object.__getattribute__ is the difficult one, since it cannot simply be removed, both because object is immutable and because removing it would break everything.  However, __getattribute__ is only accessible via the . operator, so purging that from your input is sufficient to ensure eval cannot escape its sandbox.\nIn processing formulas, the only valid use of a decimal is when it is preceded or followed by [0-9], so we just remove all other instances of .. Note that while python normally treats 1 + 1. as 1 + 1.0, this will remove the trailing . and leave you with 1 + 1.  You could add ),, and EOF to the list of things allowed to follow ., but why bother?"}, {"id": 30516254, "score": 9, "vote": 0, "content": "<p>You can use the ast module and write a NodeVisitor that verifies that the type of each node is part of a whitelist.</p>\n<pre><code class=\"python\">import ast, math\n\nlocals =  {key: value for (key,value) in vars(math).items() if key[0] != '_'}\nlocals.update({\"abs\": abs, \"complex\": complex, \"min\": min, \"max\": max, \"pow\": pow, \"round\": round})\n\nclass Visitor(ast.NodeVisitor):\n    def visit(self, node):\n       if not isinstance(node, self.whitelist):\n           raise ValueError(node)\n       return super().visit(node)\n\n    whitelist = (ast.Module, ast.Expr, ast.Load, ast.Expression, ast.Add, ast.Sub, ast.UnaryOp, ast.Num, ast.BinOp,\n            ast.Mult, ast.Div, ast.Pow, ast.BitOr, ast.BitAnd, ast.BitXor, ast.USub, ast.UAdd, ast.FloorDiv, ast.Mod,\n            ast.LShift, ast.RShift, ast.Invert, ast.Call, ast.Name)\n\ndef evaluate(expr, locals = {}):\n    if any(elem in expr for elem in '\\n#') : raise ValueError(expr)\n    try:\n        node = ast.parse(expr.strip(), mode='eval')\n        Visitor().visit(node)\n        return eval(compile(node, \"&lt;string&gt;\", \"eval\"), {'__builtins__': None}, locals)\n    except Exception: raise ValueError(expr)\n</code></pre>\n<p>Because it works via a whitelist rather than a blacklist, it is safe. The only functions and variables it can access are those you explicitly give it access to. I populated a dict with math-related functions so you can easily provide access to those if you want, but you have to explicitly use it.</p>\n<p>If the string attempts to call functions that haven't been provided, or invoke any methods, an exception will be raised, and it will not be executed.</p>\n<p>Because this uses Python's built in parser and evaluator, it also inherits Python's precedence and promotion rules as well.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; evaluate(\"7 + 9 * (2 &lt;&lt; 2)\")\n79\n&gt;&gt;&gt; evaluate(\"6 // 2 + 0.0\")\n3.0\n</code></pre>\n<p>The above code has only been tested on Python 3.</p>\n<p>If desired, you can add a timeout decorator on this function.</p>\n", "abstract": "You can use the ast module and write a NodeVisitor that verifies that the type of each node is part of a whitelist. Because it works via a whitelist rather than a blacklist, it is safe. The only functions and variables it can access are those you explicitly give it access to. I populated a dict with math-related functions so you can easily provide access to those if you want, but you have to explicitly use it. If the string attempts to call functions that haven't been provided, or invoke any methods, an exception will be raised, and it will not be executed. Because this uses Python's built in parser and evaluator, it also inherits Python's precedence and promotion rules as well. The above code has only been tested on Python 3. If desired, you can add a timeout decorator on this function."}, {"id": 35930111, "score": 9, "vote": 0, "content": "<p>The reason <code>eval</code> and <code>exec</code> are so dangerous is that the default <code>compile</code> function will generate bytecode for any valid python expression, and the default <code>eval</code> or <code>exec</code> will execute any valid python bytecode.  All the answers to date have focused on restricting the bytecode that can be generated (by sanitizing input) or building your own domain-specific-language using the AST.  </p>\n<p>Instead, you can easily create a simple <code>eval</code> function that is incapable of doing anything nefarious and can easily have runtime checks on memory or time used.  Of course, if it is simple math, than there is a shortcut.</p>\n<pre><code class=\"python\">c = compile(stringExp, 'userinput', 'eval')\nif c.co_code[0]==b'd' and c.co_code[3]==b'S':\n    return c.co_consts[ord(c.co_code[1])+ord(c.co_code[2])*256]\n</code></pre>\n<p>The way this works is simple, any constant mathematic expression is safely evaluated during compilation and stored as a constant.  The code object returned by compile consists of <code>d</code>, which is the bytecode for <code>LOAD_CONST</code>, followed by the number of the constant to load (usually the last one in the list), followed by <code>S</code>, which is the bytecode for <code>RETURN_VALUE</code>.  If this shortcut doesn't work, it means that the user input isn't a constant expression (contains a variable or function call or similar).  </p>\n<p>This also opens the door to some more sophisticated input formats.  For example:</p>\n<pre><code class=\"python\">stringExp = \"1 + cos(2)\"\n</code></pre>\n<p>This requires actually evaluating the bytecode, which is still quite simple.  Python bytecode is a stack oriented language, so everything is a simple matter of <code>TOS=stack.pop(); op(TOS); stack.put(TOS)</code> or similar.  The key is to only implement the opcodes that are safe (loading/storing values, math operations, returning values) and not unsafe ones (attribute lookup).  If you want the user to be able to call functions (the whole reason not to use the shortcut above), simple make your implementation of <code>CALL_FUNCTION</code> only allow functions in a 'safe' list.</p>\n<pre><code class=\"python\">from dis import opmap\nfrom Queue import LifoQueue\nfrom math import sin,cos\nimport operator\n\nglobs = {'sin':sin, 'cos':cos}\nsafe = globs.values()\n\nstack = LifoQueue()\n\nclass BINARY(object):\n    def __init__(self, operator):\n        self.op=operator\n    def __call__(self, context):\n        stack.put(self.op(stack.get(),stack.get()))\n\nclass UNARY(object):\n    def __init__(self, operator):\n        self.op=operator\n    def __call__(self, context):\n        stack.put(self.op(stack.get()))\n\n\ndef CALL_FUNCTION(context, arg):\n    argc = arg[0]+arg[1]*256\n    args = [stack.get() for i in range(argc)]\n    func = stack.get()\n    if func not in safe:\n        raise TypeError(\"Function %r now allowed\"%func)\n    stack.put(func(*args))\n\ndef LOAD_CONST(context, arg):\n    cons = arg[0]+arg[1]*256\n    stack.put(context['code'].co_consts[cons])\n\ndef LOAD_NAME(context, arg):\n    name_num = arg[0]+arg[1]*256\n    name = context['code'].co_names[name_num]\n    if name in context['locals']:\n        stack.put(context['locals'][name])\n    else:\n        stack.put(context['globals'][name])\n\ndef RETURN_VALUE(context):\n    return stack.get()\n\nopfuncs = {\n    opmap['BINARY_ADD']: BINARY(operator.add),\n    opmap['UNARY_INVERT']: UNARY(operator.invert),\n    opmap['CALL_FUNCTION']: CALL_FUNCTION,\n    opmap['LOAD_CONST']: LOAD_CONST,\n    opmap['LOAD_NAME']: LOAD_NAME\n    opmap['RETURN_VALUE']: RETURN_VALUE,\n}\n\ndef VMeval(c):\n    context = dict(locals={}, globals=globs, code=c)\n    bci = iter(c.co_code)\n    for bytecode in bci:\n        func = opfuncs[ord(bytecode)]\n        if func.func_code.co_argcount==1:\n            ret = func(context)\n        else:\n            args = ord(bci.next()), ord(bci.next())\n            ret = func(context, args)\n        if ret:\n            return ret\n\ndef evaluate(expr):\n    return VMeval(compile(expr, 'userinput', 'eval'))\n</code></pre>\n<p>Obviously, the real version of this would be a bit longer (there are 119 opcodes, 24 of which are math related).  Adding <code>STORE_FAST</code> and a couple others would allow for input like <code>'x=5;return x+x</code> or similar, trivially easily.  It can even be used to execute user-created functions, so long as the user created functions are themselves executed via VMeval (don't make them callable!!! or they could get used as a callback somewhere).  Handling loops requires support for the <code>goto</code> bytecodes, which means changing from a <code>for</code> iterator to <code>while</code> and maintaining a pointer to the current instruction, but isn't too hard.  For resistance to DOS, the main loop should check how much time has passed since the start of the calculation, and certain operators should deny input over some reasonable limit (<code>BINARY_POWER</code> being the most obvious).</p>\n<p>While this approach is somewhat longer than a simple grammar parser for simple expressions (see above about just grabbing the compiled constant), it extends easily to more complicated input, and doesn't require dealing with grammar (<code>compile</code> take anything arbitrarily complicated and reduces it to a sequence of simple instructions).</p>\n", "abstract": "The reason eval and exec are so dangerous is that the default compile function will generate bytecode for any valid python expression, and the default eval or exec will execute any valid python bytecode.  All the answers to date have focused on restricting the bytecode that can be generated (by sanitizing input) or building your own domain-specific-language using the AST.   Instead, you can easily create a simple eval function that is incapable of doing anything nefarious and can easily have runtime checks on memory or time used.  Of course, if it is simple math, than there is a shortcut. The way this works is simple, any constant mathematic expression is safely evaluated during compilation and stored as a constant.  The code object returned by compile consists of d, which is the bytecode for LOAD_CONST, followed by the number of the constant to load (usually the last one in the list), followed by S, which is the bytecode for RETURN_VALUE.  If this shortcut doesn't work, it means that the user input isn't a constant expression (contains a variable or function call or similar).   This also opens the door to some more sophisticated input formats.  For example: This requires actually evaluating the bytecode, which is still quite simple.  Python bytecode is a stack oriented language, so everything is a simple matter of TOS=stack.pop(); op(TOS); stack.put(TOS) or similar.  The key is to only implement the opcodes that are safe (loading/storing values, math operations, returning values) and not unsafe ones (attribute lookup).  If you want the user to be able to call functions (the whole reason not to use the shortcut above), simple make your implementation of CALL_FUNCTION only allow functions in a 'safe' list. Obviously, the real version of this would be a bit longer (there are 119 opcodes, 24 of which are math related).  Adding STORE_FAST and a couple others would allow for input like 'x=5;return x+x or similar, trivially easily.  It can even be used to execute user-created functions, so long as the user created functions are themselves executed via VMeval (don't make them callable!!! or they could get used as a callback somewhere).  Handling loops requires support for the goto bytecodes, which means changing from a for iterator to while and maintaining a pointer to the current instruction, but isn't too hard.  For resistance to DOS, the main loop should check how much time has passed since the start of the calculation, and certain operators should deny input over some reasonable limit (BINARY_POWER being the most obvious). While this approach is somewhat longer than a simple grammar parser for simple expressions (see above about just grabbing the compiled constant), it extends easily to more complicated input, and doesn't require dealing with grammar (compile take anything arbitrarily complicated and reduces it to a sequence of simple instructions)."}, {"id": 2371543, "score": 6, "vote": 0, "content": "<p>I think I would use <code>eval()</code>, but would first check to make sure the string is a valid mathematical expression, as opposed to something malicious.  You could use a regex for the validation.</p>\n<p><code>eval()</code> also takes additional arguments which you can use to restrict the namespace it operates in for greater security.</p>\n", "abstract": "I think I would use eval(), but would first check to make sure the string is a valid mathematical expression, as opposed to something malicious.  You could use a regex for the validation. eval() also takes additional arguments which you can use to restrict the namespace it operates in for greater security."}, {"id": 9556473, "score": 4, "vote": 0, "content": "<p>This is a massively late reply, but I think useful for future reference. Rather than write your own math parser (although the pyparsing example above is great) you could use SymPy. I don't have a lot of experience with it, but it contains a much more powerful math engine than anyone is likely to write for a specific application and the basic expression evaluation is very easy:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import sympy\n&gt;&gt;&gt; x, y, z = sympy.symbols('x y z')\n&gt;&gt;&gt; sympy.sympify(\"x**3 + sin(y)\").evalf(subs={x:1, y:-3})\n0.858879991940133\n</code></pre>\n<p>Very cool indeed! A <code>from sympy import *</code> brings in a lot more function support, such as trig functions, special functions, etc., but I've avoided that here to show what's coming from where.</p>\n", "abstract": "This is a massively late reply, but I think useful for future reference. Rather than write your own math parser (although the pyparsing example above is great) you could use SymPy. I don't have a lot of experience with it, but it contains a much more powerful math engine than anyone is likely to write for a specific application and the basic expression evaluation is very easy: Very cool indeed! A from sympy import * brings in a lot more function support, such as trig functions, special functions, etc., but I've avoided that here to show what's coming from where."}, {"id": 65945969, "score": 4, "vote": 0, "content": "<p>Based on <a href=\"https://stackoverflow.com/a/35930111/624066\">Perkins' amazing approach</a>, I've updated and improved his \"shortcut\" for simple algebraic expressions (no functions or variables). Now it works on Python 3.6+ and avoids some pitfalls:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import re\n\n# Kept outside simple_eval() just for performance\n_re_simple_eval = re.compile(rb'd([\\x00-\\xFF]+)S\\x00')\n\ndef simple_eval(expr):\n    try:\n        c = compile(expr, 'userinput', 'eval')\n    except SyntaxError:\n        raise ValueError(f\"Malformed expression: {expr}\")\n    m = _re_simple_eval.fullmatch(c.co_code)\n    if not m:\n        raise ValueError(f\"Not a simple algebraic expression: {expr}\")\n    try:\n        return c.co_consts[int.from_bytes(m.group(1), sys.byteorder)]\n    except IndexError:\n        raise ValueError(f\"Expression not evaluated as constant: {expr}\")\n</code></pre>\n<p>Testing, using some of the examples in other answers:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">for expr, res in (\n    ('2^4',                         6      ),\n    ('2**4',                       16      ),\n    ('1 + 2*3**(4^5) / (6 + -7)',  -5.0    ),\n    ('7 + 9 * (2 &lt;&lt; 2)',           79      ),\n    ('6 // 2 + 0.0',                3.0    ),\n    ('2+3',                         5      ),\n    ('6+4/2*2',                    10.0    ),\n    ('3+2.45/8',                    3.30625),\n    ('3**3*3/3+3',                 30.0    ),\n):\n    result = simple_eval(expr)\n    ok = (result == res and type(result) == type(res))\n    print(\"{} {} = {}\".format(\"OK!\" if ok else \"FAIL!\", expr, result))\n</code></pre>\n<pre><code class=\"python\">OK! 2^4 = 6\nOK! 2**4 = 16\nOK! 1 + 2*3**(4^5) / (6 + -7) = -5.0\nOK! 7 + 9 * (2 &lt;&lt; 2) = 79\nOK! 6 // 2 + 0.0 = 3.0\nOK! 2+3 = 5\nOK! 6+4/2*2 = 10.0\nOK! 3+2.45/8 = 3.30625\nOK! 3**3*3/3+3 = 30.0\n</code></pre>\n<p>Testing bad input:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">for expr in (\n    'foo bar',\n    'print(\"hi\")',\n    '2*x',\n    'lambda: 10',\n    '2**1234',\n):\n    try:\n        result = simple_eval(expr)\n    except ValueError as e:\n        print(e)\n        continue\n    print(\"OK!\")  # will never happen\n</code></pre>\n<pre><code class=\"python\">Malformed expression: foo bar\nNot a simple algebraic expression: print(\"hi\")\nExpression not evaluated as constant: 2*x\nExpression not evaluated as constant: lambda: 10\nExpression not evaluated as constant: 2**1234\n</code></pre>\n", "abstract": "Based on Perkins' amazing approach, I've updated and improved his \"shortcut\" for simple algebraic expressions (no functions or variables). Now it works on Python 3.6+ and avoids some pitfalls: Testing, using some of the examples in other answers: Testing bad input:"}, {"id": 41188356, "score": 3, "vote": 0, "content": "<p><em>[I know this is an old question, but it is worth pointing out new useful solutions as they pop up]</em></p>\n<p>Since python3.6, this capability is now <strong>built into the language</strong>, coined <strong>\"f-strings\"</strong>.</p>\n<p><strong>See: <a href=\"https://www.python.org/dev/peps/pep-0498/\" rel=\"nofollow noreferrer\">PEP 498 -- Literal String Interpolation</a></strong></p>\n<p>For example (note the <strong><code>f</code></strong> prefix):</p>\n<pre><code class=\"python\">f'{2**4}'\n=&gt; '16'\n</code></pre>\n", "abstract": "[I know this is an old question, but it is worth pointing out new useful solutions as they pop up] Since python3.6, this capability is now built into the language, coined \"f-strings\". See: PEP 498 -- Literal String Interpolation For example (note the f prefix):"}, {"id": 2372145, "score": 2, "vote": 0, "content": "<p>Use <code>eval</code> in a clean namespace:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; ns = {'__builtins__': None}\n&gt;&gt;&gt; eval('2 ** 4', ns)\n16\n</code></pre>\n<p>The clean namespace should prevent injection. For instance:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; eval('__builtins__.__import__(\"os\").system(\"echo got through\")', ns)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'NoneType' object has no attribute '__import__'\n</code></pre>\n<p>Otherwise you would get:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; eval('__builtins__.__import__(\"os\").system(\"echo got through\")')\ngot through\n0\n</code></pre>\n<p>You might want to give access to the math module:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; ns = vars(math).copy()\n&gt;&gt;&gt; ns['__builtins__'] = None\n&gt;&gt;&gt; eval('cos(pi/3)', ns)\n0.50000000000000011\n</code></pre>\n", "abstract": "Use eval in a clean namespace: The clean namespace should prevent injection. For instance: Otherwise you would get: You might want to give access to the math module:"}, {"id": 55485414, "score": 0, "vote": 0, "content": "<p>Here's my solution to the problem without using eval. Works with Python2 and Python3. It doesn't work with negative numbers.</p>\n<pre><code class=\"python\">$ python -m pytest test.py\n</code></pre>\n<p>test.py</p>\n<pre><code class=\"python\">from solution import Solutions\n\nclass SolutionsTestCase(unittest.TestCase):\n    def setUp(self):\n        self.solutions = Solutions()\n\n    def test_evaluate(self):\n        expressions = [\n            '2+3=5',\n            '6+4/2*2=10',\n            '3+2.45/8=3.30625',\n            '3**3*3/3+3=30',\n            '2^4=6'\n        ]\n        results = [x.split('=')[1] for x in expressions]\n        for e in range(len(expressions)):\n            if '.' in results[e]:\n                results[e] = float(results[e])\n            else:\n                results[e] = int(results[e])\n            self.assertEqual(\n                results[e],\n                self.solutions.evaluate(expressions[e])\n            )\n</code></pre>\n<p>solution.py</p>\n<pre><code class=\"python\">class Solutions(object):\n    def evaluate(self, exp):\n        def format(res):\n            if '.' in res:\n                try:\n                    res = float(res)\n                except ValueError:\n                    pass\n            else:\n                try:\n                    res = int(res)\n                except ValueError:\n                    pass\n            return res\n        def splitter(item, op):\n            mul = item.split(op)\n            if len(mul) == 2:\n                for x in ['^', '*', '/', '+', '-']:\n                    if x in mul[0]:\n                        mul = [mul[0].split(x)[1], mul[1]]\n                    if x in mul[1]:\n                        mul = [mul[0], mul[1].split(x)[0]]\n            elif len(mul) &gt; 2:\n                pass\n            else:\n                pass\n            for x in range(len(mul)):\n                mul[x] = format(mul[x])\n            return mul\n        exp = exp.replace(' ', '')\n        if '=' in exp:\n            res = exp.split('=')[1]\n            res = format(res)\n            exp = exp.replace('=%s' % res, '')\n        while '^' in exp:\n            if '^' in exp:\n                itm = splitter(exp, '^')\n                res = itm[0] ^ itm[1]\n                exp = exp.replace('%s^%s' % (str(itm[0]), str(itm[1])), str(res))\n        while '**' in exp:\n            if '**' in exp:\n                itm = splitter(exp, '**')\n                res = itm[0] ** itm[1]\n                exp = exp.replace('%s**%s' % (str(itm[0]), str(itm[1])), str(res))\n        while '/' in exp:\n            if '/' in exp:\n                itm = splitter(exp, '/')\n                res = itm[0] / itm[1]\n                exp = exp.replace('%s/%s' % (str(itm[0]), str(itm[1])), str(res))\n        while '*' in exp:\n            if '*' in exp:\n                itm = splitter(exp, '*')\n                res = itm[0] * itm[1]\n                exp = exp.replace('%s*%s' % (str(itm[0]), str(itm[1])), str(res))\n        while '+' in exp:\n            if '+' in exp:\n                itm = splitter(exp, '+')\n                res = itm[0] + itm[1]\n                exp = exp.replace('%s+%s' % (str(itm[0]), str(itm[1])), str(res))\n        while '-' in exp:\n            if '-' in exp:\n                itm = splitter(exp, '-')\n                res = itm[0] - itm[1]\n                exp = exp.replace('%s-%s' % (str(itm[0]), str(itm[1])), str(res))\n\n        return format(exp)\n</code></pre>\n", "abstract": "Here's my solution to the problem without using eval. Works with Python2 and Python3. It doesn't work with negative numbers. test.py solution.py"}, {"id": 67491514, "score": 0, "vote": 0, "content": "<p>Using lark parser library <a href=\"https://stackoverflow.com/posts/67491514/edit\">https://stackoverflow.com/posts/67491514/edit</a></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from operator import add, sub, mul, truediv, neg, pow\nfrom lark import Lark, Transformer, v_args\n\ncalc_grammar = f\"\"\"\n    ?start: sum\n    ?sum: product\n        | sum \"+\" product   -&gt; {add.__name__}\n        | sum \"-\" product   -&gt; {sub.__name__}\n    ?product: power\n        | product \"*\" power  -&gt; {mul.__name__}\n        | product \"/\" power  -&gt; {truediv.__name__}\n    ?power: atom\n        | power \"^\" atom -&gt; {pow.__name__}\n    ?atom: NUMBER           -&gt; number\n         | \"-\" atom         -&gt; {neg.__name__}\n         | \"(\" sum \")\"\n\n    %import common.NUMBER\n    %import common.WS_INLINE\n\n    %ignore WS_INLINE\n\"\"\"\n\n\n@v_args(inline=True)\nclass CalculateTree(Transformer):\n    add = add\n    sub = sub\n    neg = neg\n    mul = mul\n    truediv = truediv\n    pow = pow\n    number = float\n\n\ncalc_parser = Lark(calc_grammar, parser=\"lalr\", transformer=CalculateTree())\ncalc = calc_parser.parse\n\n\ndef eval_expr(expression: str) -&gt; float:\n    return calc(expression)\n\n\nprint(eval_expr(\"2^4\"))\nprint(eval_expr(\"-1*2^4\"))\nprint(eval_expr(\"-2^3 + 1\"))\nprint(eval_expr(\"2**4\"))  # Error\n\n</code></pre>\n", "abstract": "Using lark parser library https://stackoverflow.com/posts/67491514/edit"}, {"id": 70814858, "score": 0, "vote": 0, "content": "<p>I came here looking for a mathematic expression parser as well. Reading through some of the answers and looking up libraries, I came across <a href=\"https://pypi.org/project/py-expression/\" rel=\"nofollow noreferrer\">py-expression</a> which I am now using. It basically handles a lot of operators and formula constructs, but if you're missing something you can easily add new operators/functions to it.</p>\n<p>The basic syntax is:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from py_expression.core import Exp\nexp = Exp()\n\nparsed_formula = exp.parse('a+4')\n\nresult = exp.eval(parsed_formula, {\"a\":2})\n</code></pre>\n<p>The only issue that I've had with it so far is that it doesn't come with built-in mathematical constants nor a mechanism to add them in. I just proposed a solution to that however: <a href=\"https://github.com/FlavioLionelRita/py-expression/issues/7\" rel=\"nofollow noreferrer\">https://github.com/FlavioLionelRita/py-expression/issues/7</a></p>\n", "abstract": "I came here looking for a mathematic expression parser as well. Reading through some of the answers and looking up libraries, I came across py-expression which I am now using. It basically handles a lot of operators and formula constructs, but if you're missing something you can easily add new operators/functions to it. The basic syntax is: The only issue that I've had with it so far is that it doesn't come with built-in mathematical constants nor a mechanism to add them in. I just proposed a solution to that however: https://github.com/FlavioLionelRita/py-expression/issues/7"}]}, {"link": "https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect", "question": {"id": "3838329", "title": "How can I check if two segments intersect?", "content": "<p>How can I check if 2 segments intersect?</p>\n<p>I've the following data:</p>\n<pre><code class=\"python\">Segment1 [ {x1,y1}, {x2,y2} ]\nSegment2 [ {x1,y1}, {x2,y2} ] \n</code></pre>\n<p>I need to write a small algorithm in Python to detect if the 2 lines are intersecting.</p>\n<p><br/><img alt=\"alt text\" src=\"https://i.stack.imgur.com/AlB0e.png\"/></p>\n", "abstract": "How can I check if 2 segments intersect? I've the following data: I need to write a small algorithm in Python to detect if the 2 lines are intersecting. "}, "answers": [{"id": 9997374, "score": 131, "vote": 0, "content": "<p>User @i_4_got points to <a href=\"http://www.bryceboe.com/2006/10/23/line-segment-intersection-algorithm/\">this page</a> with a very efficent solution in Python. I reproduce it here for convenience (since it would have made me happy to have it here):</p>\n<pre><code class=\"python\">def ccw(A,B,C):\n    return (C.y-A.y) * (B.x-A.x) &gt; (B.y-A.y) * (C.x-A.x)\n\n# Return true if line segments AB and CD intersect\ndef intersect(A,B,C,D):\n    return ccw(A,C,D) != ccw(B,C,D) and ccw(A,B,C) != ccw(A,B,D)\n</code></pre>\n", "abstract": "User @i_4_got points to this page with a very efficent solution in Python. I reproduce it here for convenience (since it would have made me happy to have it here):"}, {"id": 3838357, "score": 88, "vote": 0, "content": "<p>The equation of a line is:</p>\n<pre><code class=\"python\">f(x) = A*x + b = y\n</code></pre>\n<p>For a segment, it is exactly the same, except that x is included on an interval I.</p>\n<p>If you have two segments, defined as follow:</p>\n<pre><code class=\"python\">Segment1 = {(X1, Y1), (X2, Y2)}\nSegment2 = {(X3, Y3), (X4, Y4)}\n</code></pre>\n<p>The abcisse Xa of the potential point of intersection (Xa,Ya) must be contained in both interval I1 and I2, defined as follow :</p>\n<pre><code class=\"python\">I1 = [min(X1,X2), max(X1,X2)]\nI2 = [min(X3,X4), max(X3,X4)]\n</code></pre>\n<p>And we could say that Xa is included into :</p>\n<pre><code class=\"python\">Ia = [max( min(X1,X2), min(X3,X4) ),\n      min( max(X1,X2), max(X3,X4) )]\n</code></pre>\n<p>Now, we need to check that this interval Ia exists :</p>\n<pre><code class=\"python\">if (max(X1,X2) &lt; min(X3,X4)):\n    return False  # There is no mutual abcisses\n</code></pre>\n<p>So, we have two line formula, and a mutual interval. Your line formulas are:</p>\n<pre><code class=\"python\">f1(x) = A1*x + b1 = y\nf2(x) = A2*x + b2 = y\n</code></pre>\n<p>As we got two points by segment, we are able to determine A1, A2, b1 and b2:</p>\n<pre><code class=\"python\">A1 = (Y1-Y2)/(X1-X2)  # Pay attention to not dividing by zero\nA2 = (Y3-Y4)/(X3-X4)  # Pay attention to not dividing by zero\nb1 = Y1-A1*X1 = Y2-A1*X2\nb2 = Y3-A2*X3 = Y4-A2*X4\n</code></pre>\n<p>If the segments are parallel, then A1 == A2 :</p>\n<pre><code class=\"python\">if (A1 == A2):\n    return False  # Parallel segments\n</code></pre>\n<p>A point (Xa,Ya) standing on both line must verify both formulas f1 and f2:</p>\n<pre><code class=\"python\">Ya = A1 * Xa + b1\nYa = A2 * Xa + b2\nA1 * Xa + b1 = A2 * Xa + b2\nXa = (b2 - b1) / (A1 - A2)   # Once again, pay attention to not dividing by zero\n</code></pre>\n<p>The last thing to do is check that Xa is included into Ia:</p>\n<pre><code class=\"python\">if ( (Xa &lt; max( min(X1,X2), min(X3,X4) )) or\n     (Xa &gt; min( max(X1,X2), max(X3,X4) )) ):\n    return False  # intersection is out of bound\nelse:\n    return True\n</code></pre>\n<p>In addition to this, you may check at startup that two of the four provided points are not equals to avoid all that testing.</p>\n", "abstract": "The equation of a line is: For a segment, it is exactly the same, except that x is included on an interval I. If you have two segments, defined as follow: The abcisse Xa of the potential point of intersection (Xa,Ya) must be contained in both interval I1 and I2, defined as follow : And we could say that Xa is included into : Now, we need to check that this interval Ia exists : So, we have two line formula, and a mutual interval. Your line formulas are: As we got two points by segment, we are able to determine A1, A2, b1 and b2: If the segments are parallel, then A1 == A2 : A point (Xa,Ya) standing on both line must verify both formulas f1 and f2: The last thing to do is check that Xa is included into Ia: In addition to this, you may check at startup that two of the four provided points are not equals to avoid all that testing."}, {"id": 3842240, "score": 39, "vote": 0, "content": "<p>You don't have to compute exactly <strong>where</strong> does the segments intersect, but only understand <strong>whether</strong> they intersect at all. This will simplify the solution.</p>\n<p>The idea is to treat one segment as the \"anchor\" and separate the second segment into 2 points.<br/>\nNow, you will have to find the relative position of each point to the \"anchored\" segment (OnLeft, OnRight or Collinear).<br/>\nAfter doing so for both points, check that one of the points is OnLeft and the other is OnRight (or perhaps include Collinear position, if you wish to include <em>improper</em> intersections as well).</p>\n<p>You must then repeat the process with the roles of anchor and separated segments.</p>\n<p>An intersection exists if, and only if, one of the points is OnLeft and the other is OnRight. See <a href=\"http://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\" rel=\"noreferrer\">this link</a> for a more detailed explanation with example images for each possible case.</p>\n<p>Implementing such method will be much easier than actually implementing a method that finds the intersection point (given the many corner cases which you will have to handle as well).</p>\n<p><strong>Update</strong></p>\n<p>The following functions should illustrate the idea (source: <a href=\"https://rads.stackoverflow.com/amzn/click/com/0521649765\" rel=\"nofollow noreferrer\">Computational Geometry in C</a>).<br/>\n<em>Remark:</em> This sample assumes the usage of integers. If you're using some floating-point representation instead (which could obviously complicate things), then you should determine some epsilon value to indicate \"equality\" (mostly for the <code>IsCollinear</code> evaluation).</p>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">// points \"a\" and \"b\" forms the anchored segment.\n// point \"c\" is the evaluated point\nbool IsOnLeft(Point a, Point b, Point c)\n{\n     return Area2(a, b, c) &gt; 0;\n}\n\nbool IsOnRight(Point a, Point b, Point c)\n{\n     return Area2(a, b, c) &lt; 0;\n}\n\nbool IsCollinear(Point a, Point b, Point c)\n{\n     return Area2(a, b, c) == 0;\n}\n\n// calculates the triangle's size (formed by the \"anchor\" segment and additional point)\nint Area2(Point a, Point b, Point c)\n{\n     return (b.X - a.X) * (c.Y - a.Y) -\n            (c.X - a.X) * (b.Y - a.Y);\n}\n</code></pre>\n<p>Of course, when using these functions, one must remember to check that each segment lies \"between\" the other segment (since these are finite segments, and not infinite lines).  </p>\n<p>Also, using these functions you can understand whether you've got a <em>proper</em> or <em>improper</em> intersection.</p>\n<ul>\n<li><strong>Proper</strong>: There are no collinear points. The segments crosses each\nother \"from side to side\".</li>\n<li><strong>Improper</strong>: One segment only \"touches\" the other (at least one of\nthe points is collinear to the\nanchored segment).</li>\n</ul>\n", "abstract": "You don't have to compute exactly where does the segments intersect, but only understand whether they intersect at all. This will simplify the solution. The idea is to treat one segment as the \"anchor\" and separate the second segment into 2 points.\nNow, you will have to find the relative position of each point to the \"anchored\" segment (OnLeft, OnRight or Collinear).\nAfter doing so for both points, check that one of the points is OnLeft and the other is OnRight (or perhaps include Collinear position, if you wish to include improper intersections as well). You must then repeat the process with the roles of anchor and separated segments. An intersection exists if, and only if, one of the points is OnLeft and the other is OnRight. See this link for a more detailed explanation with example images for each possible case. Implementing such method will be much easier than actually implementing a method that finds the intersection point (given the many corner cases which you will have to handle as well). Update The following functions should illustrate the idea (source: Computational Geometry in C).\nRemark: This sample assumes the usage of integers. If you're using some floating-point representation instead (which could obviously complicate things), then you should determine some epsilon value to indicate \"equality\" (mostly for the IsCollinear evaluation). Of course, when using these functions, one must remember to check that each segment lies \"between\" the other segment (since these are finite segments, and not infinite lines).   Also, using these functions you can understand whether you've got a proper or improper intersection."}, {"id": 3842157, "score": 17, "vote": 0, "content": "<p>Suppose the two segments have endpoints A,B and C,D. The numerically robust way to determine intersection is to check the sign of the four determinants:</p>\n<pre><code class=\"python\">| Ax-Cx  Bx-Cx |    | Ax-Dx  Bx-Dx |\n| Ay-Cy  By-Cy |    | Ay-Dy  By-Dy |\n\n| Cx-Ax  Dx-Ax |    | Cx-Bx  Dx-Bx |\n| Cy-Ay  Dy-Ay |    | Cy-By  Dy-By |\n</code></pre>\n<p>For intersection, each determinant on the left must have the opposite sign of the one to the right, but there need not be any relationship between the two lines. You are basically checking each point of a segment against the other segment to make sure they lie on opposite sides of the line defined by the other segment.</p>\n<p>See here: <a href=\"http://www.cs.cmu.edu/~quake/robust.html\" rel=\"noreferrer\">http://www.cs.cmu.edu/~quake/robust.html</a></p>\n", "abstract": "Suppose the two segments have endpoints A,B and C,D. The numerically robust way to determine intersection is to check the sign of the four determinants: For intersection, each determinant on the left must have the opposite sign of the one to the right, but there need not be any relationship between the two lines. You are basically checking each point of a segment against the other segment to make sure they lie on opposite sides of the line defined by the other segment. See here: http://www.cs.cmu.edu/~quake/robust.html"}, {"id": 57075989, "score": 16, "vote": 0, "content": "<p>Checking if line segments intersect is very easy with <a href=\"https://shapely.readthedocs.io/en/latest/manual.html\" rel=\"noreferrer\">Shapely</a> library using <a href=\"https://shapely.readthedocs.io/en/latest/manual.html#object.intersects\" rel=\"noreferrer\"><code>intersects</code></a> method:</p>\n<pre><code class=\"python\">from shapely.geometry import LineString\n\nline = LineString([(0, 0), (1, 1)])\nother = LineString([(0, 1), (1, 0)])\nprint(line.intersects(other))\n# True\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/H39ag.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/H39ag.png\"/></a></p>\n<pre><code class=\"python\">line = LineString([(0, 0), (1, 1)])\nother = LineString([(0, 1), (1, 2)])\nprint(line.intersects(other))\n# False\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/WJYvQ.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/WJYvQ.png\"/></a></p>\n", "abstract": "Checking if line segments intersect is very easy with Shapely library using intersects method:  "}, {"id": 62625458, "score": 15, "vote": 0, "content": "<p>Here's a solution using dot products:</p>\n<pre><code class=\"python\"># assumes line segments are stored in the format [(x0,y0),(x1,y1)]\ndef intersects(s0,s1):\n    dx0 = s0[1][0]-s0[0][0]\n    dx1 = s1[1][0]-s1[0][0]\n    dy0 = s0[1][1]-s0[0][1]\n    dy1 = s1[1][1]-s1[0][1]\n    p0 = dy1*(s1[1][0]-s0[0][0]) - dx1*(s1[1][1]-s0[0][1])\n    p1 = dy1*(s1[1][0]-s0[1][0]) - dx1*(s1[1][1]-s0[1][1])\n    p2 = dy0*(s0[1][0]-s1[0][0]) - dx0*(s0[1][1]-s1[0][1])\n    p3 = dy0*(s0[1][0]-s1[1][0]) - dx0*(s0[1][1]-s1[1][1])\n    return (p0*p1&lt;=0) &amp; (p2*p3&lt;=0)\n</code></pre>\n<p>Here's a visualization in Desmos: <a href=\"https://www.desmos.com/calculator/0wr2rfkjbk\" rel=\"noreferrer\">Line Segment Intersection</a></p>\n", "abstract": "Here's a solution using dot products: Here's a visualization in Desmos: Line Segment Intersection"}, {"id": 18524383, "score": 7, "vote": 0, "content": "<p>Based on <a href=\"https://stackoverflow.com/users/2164233/liran\">Liran's</a> and <a href=\"https://stackoverflow.com/users/167531/grumdrig\">Grumdrig's</a> excellent answers here is a complete Python code to verify if <strong>closed</strong> segments do intersect. Works for collinear segments, segments parallel to axis Y, degenerate segments (devil is in details). Assumes integer coordinates. Floating point coordinates require a modification to points equality test.</p>\n<pre><code class=\"python\">def side(a,b,c):\n    \"\"\" Returns a position of the point c relative to the line going through a and b\n        Points a, b are expected to be different\n    \"\"\"\n    d = (c[1]-a[1])*(b[0]-a[0]) - (b[1]-a[1])*(c[0]-a[0])\n    return 1 if d &gt; 0 else (-1 if d &lt; 0 else 0)\n\ndef is_point_in_closed_segment(a, b, c):\n    \"\"\" Returns True if c is inside closed segment, False otherwise.\n        a, b, c are expected to be collinear\n    \"\"\"\n    if a[0] &lt; b[0]:\n        return a[0] &lt;= c[0] and c[0] &lt;= b[0]\n    if b[0] &lt; a[0]:\n        return b[0] &lt;= c[0] and c[0] &lt;= a[0]\n\n    if a[1] &lt; b[1]:\n        return a[1] &lt;= c[1] and c[1] &lt;= b[1]\n    if b[1] &lt; a[1]:\n        return b[1] &lt;= c[1] and c[1] &lt;= a[1]\n\n    return a[0] == c[0] and a[1] == c[1]\n\n#\ndef closed_segment_intersect(a,b,c,d):\n    \"\"\" Verifies if closed segments a, b, c, d do intersect.\n    \"\"\"\n    if a == b:\n        return a == c or a == d\n    if c == d:\n        return c == a or c == b\n\n    s1 = side(a,b,c)\n    s2 = side(a,b,d)\n\n    # All points are collinear\n    if s1 == 0 and s2 == 0:\n        return \\\n            is_point_in_closed_segment(a, b, c) or is_point_in_closed_segment(a, b, d) or \\\n            is_point_in_closed_segment(c, d, a) or is_point_in_closed_segment(c, d, b)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    s1 = side(c,d,a)\n    s2 = side(c,d,b)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    return True\n</code></pre>\n", "abstract": "Based on Liran's and Grumdrig's excellent answers here is a complete Python code to verify if closed segments do intersect. Works for collinear segments, segments parallel to axis Y, degenerate segments (devil is in details). Assumes integer coordinates. Floating point coordinates require a modification to points equality test."}, {"id": 55598451, "score": 6, "vote": 0, "content": "<p>This is my way of checking for line crossing and where the intersection occurs.  Lets use x1 through x4 and y1 through y4</p>\n<pre><code class=\"python\">Segment1 = ((X1, Y1), (X2, Y2))\nSegment2 = ((X3, Y3), (X4, Y4))\n</code></pre>\n<p>Then we need some vectors to represent them</p>\n<pre><code class=\"python\">dx1 = X2 - X1\ndx2 = X4 - X3\ndy1 = Y2 - Y1\ndy2 = Y4 - Y3\n</code></pre>\n<p>Now we look at the determinant</p>\n<pre><code class=\"python\">det = dx1 * dy2 - dx2 * dy1\n</code></pre>\n<p>If the determinant is 0.0, then the line segments are parallel.  This could mean they overlap.  If they overlap just at endpoints, then there is one intersection solution.  Otherwise there will be infinite solutions.  With infinitely many solutions, what do say is your point of intersection?  So it's an interesting special case.  If you know ahead of time that the lines can't overlap then you can just check if <code>det == 0.0</code> and if so just say they don't intersect and be done.  Otherwise, lets continue on</p>\n<pre><code class=\"python\">dx3 = X1 - X3\ndy3 = Y1 - Y3\n\ndet1 = dx1 * dy3 - dx3 * dy1\ndet2 = dx2 * dy3 - dx3 * dy2\n</code></pre>\n<p>Now, if det, det1 and det2 are all zero, then your lines are co-linear and could overlap.  If det is zero but either det1 or det2 are not, then they are not co-linear, but are parallel, so there is no intersection.  So what's left now if det is zero is a 1D problem instead of 2D.  We will need to check one of two ways, depending if dx1 is zero or not (so we can avoid division by zero).  If dx1 is zero then just do the same logic with y values rather than x below.</p>\n<pre><code class=\"python\">s = X3 / dx1\nt = X4 / dx1\n</code></pre>\n<p>This computes two scalers, such that if we scale the vector (dx1, dy1) by s we get point (x3, y3), and by t we get (x4, y4).  So if either s or t is between 0.0 and 1.0, then point 3 or 4 lies on our first line.  Negative would mean the point is behind the start of our vector, while &gt; 1.0 means it is further ahead of the end of our vector.  0.0 means it is at (x1, y1) and 1.0 means it is at (x2, y2).  If both s and t are &lt; 0.0 or both are &gt; 1.0, then they don't intersect.  And that handles the parallel lines special case.</p>\n<p>Now, if <code>det != 0.0</code> then</p>\n<pre><code class=\"python\">s = det1 / det\nt = det2 / det\nif s &lt; 0.0 or s &gt; 1.0 or t &lt; 0.0 or t &gt; 1.0:\n    return false  # no intersect\n</code></pre>\n<p>This is similar to what we were doing above really.  Now if we pass the above test, then our line segments intersect, and we can calculate the intersection quite easily like so:</p>\n<pre><code class=\"python\">Ix = X1 + t * dx1\nIy = Y1 + t * dy1\n</code></pre>\n<p>If you want to dig deeper into what the math is doing, look into Cramer's Rule.</p>\n<p>Edit: I've fixed two errors that were present so it should be correct now.  I've learned enough python now to write actual code for this now.  It works except for some special cases, though it does handle some special cases correctly.  Special cases get really hard to deal with and I've spend enough time on it and want to move on.  If someone requires better then they have a good starting point at least to try and improve it.</p>\n<pre><code class=\"python\">import math\n\ndef line_intersection(line1, line2):\n    x1, x2, x3, x4 = line1[0][0], line1[1][0], line2[0][0], line2[1][0]\n    y1, y2, y3, y4 = line1[0][1], line1[1][1], line2[0][1], line2[1][1]\n\n    dx1 = x2 - x1\n    dx2 = x4 - x3\n    dy1 = y2 - y1\n    dy2 = y4 - y3\n    dx3 = x1 - x3\n    dy3 = y1 - y3\n\n    det = dx1 * dy2 - dx2 * dy1\n    det1 = dx1 * dy3 - dx3 * dy1\n    det2 = dx2 * dy3 - dx3 * dy2\n\n    if det == 0.0:  # lines are parallel\n        if det1 != 0.0 or det2 != 0.0:  # lines are not co-linear\n            return None  # so no solution\n\n        if dx1:\n            if x1 &lt; x3 &lt; x2 or x1 &gt; x3 &gt; x2:\n                return math.inf  # infinitely many solutions\n        else:\n            if y1 &lt; y3 &lt; y2 or y1 &gt; y3 &gt; y2:\n                return math.inf  # infinitely many solutions\n\n        if line1[0] == line2[0] or line1[1] == line2[0]:\n            return line2[0]\n        elif line1[0] == line2[1] or line1[1] == line2[1]:\n            return line2[1]\n\n        return None  # no intersection\n\n    s = det1 / det\n    t = det2 / det\n\n    if 0.0 &lt; s &lt; 1.0 and 0.0 &lt; t &lt; 1.0:\n        return x1 + t * dx1, y1 + t * dy1\n\nprint(\"one intersection\")\nprint(line_intersection(((0.0,0.0), (6.0,6.0)),((0.0,9.0), (9.0,0.0))))\nprint(line_intersection(((-2, -2), (2, 2)), ((2, -2), (-2, 2))))\nprint(line_intersection(((0.5, 0.5), (1.5, 0.5)), ((1.0, 0.0), (1.0, 2.0))))\nprint(line_intersection(((0, -1), (0, 0)), ((0, 0), (0, 1))))\nprint(line_intersection(((-1, 0), (0, 0)), ((0, 0), (1, 0))))\n\nprint()\nprint(\"no intersection\")\nprint(line_intersection(((-1, -1), (0, 0)), ((2, -4), (2, 4))))\nprint(line_intersection(((0.0,0.0), (0.0,9.0)),((9.0,0.0), (9.0,99.0))))\nprint(line_intersection(((0, 0), (1, 1)), ((1, 0), (2, 1))))\nprint(line_intersection(((-1, 1), (0, 1)), ((0, 0), (1, 0))))\nprint(line_intersection(((1, -1), (1, 0)), ((0, 0), (0, -1))))\n\nprint()\nprint(\"infinite intersection\")\nprint(line_intersection(((-1, -1), (1, 1)), ((0, 0), (2, 2))))\nprint(line_intersection(((-1, 0), (1, 0)), ((0, 0), (2, 0))))\nprint(line_intersection(((0, -1), (0, 1)), ((0, 0), (0, 2))))\nprint(line_intersection(((-1, 0), (0, 0)), ((0, 0), (-1, 0))))\nprint(line_intersection(((1, 0), (0, 0)), ((0, 0), (1, 0))))\n</code></pre>\n", "abstract": "This is my way of checking for line crossing and where the intersection occurs.  Lets use x1 through x4 and y1 through y4 Then we need some vectors to represent them Now we look at the determinant If the determinant is 0.0, then the line segments are parallel.  This could mean they overlap.  If they overlap just at endpoints, then there is one intersection solution.  Otherwise there will be infinite solutions.  With infinitely many solutions, what do say is your point of intersection?  So it's an interesting special case.  If you know ahead of time that the lines can't overlap then you can just check if det == 0.0 and if so just say they don't intersect and be done.  Otherwise, lets continue on Now, if det, det1 and det2 are all zero, then your lines are co-linear and could overlap.  If det is zero but either det1 or det2 are not, then they are not co-linear, but are parallel, so there is no intersection.  So what's left now if det is zero is a 1D problem instead of 2D.  We will need to check one of two ways, depending if dx1 is zero or not (so we can avoid division by zero).  If dx1 is zero then just do the same logic with y values rather than x below. This computes two scalers, such that if we scale the vector (dx1, dy1) by s we get point (x3, y3), and by t we get (x4, y4).  So if either s or t is between 0.0 and 1.0, then point 3 or 4 lies on our first line.  Negative would mean the point is behind the start of our vector, while > 1.0 means it is further ahead of the end of our vector.  0.0 means it is at (x1, y1) and 1.0 means it is at (x2, y2).  If both s and t are < 0.0 or both are > 1.0, then they don't intersect.  And that handles the parallel lines special case. Now, if det != 0.0 then This is similar to what we were doing above really.  Now if we pass the above test, then our line segments intersect, and we can calculate the intersection quite easily like so: If you want to dig deeper into what the math is doing, look into Cramer's Rule. Edit: I've fixed two errors that were present so it should be correct now.  I've learned enough python now to write actual code for this now.  It works except for some special cases, though it does handle some special cases correctly.  Special cases get really hard to deal with and I've spend enough time on it and want to move on.  If someone requires better then they have a good starting point at least to try and improve it."}, {"id": 47080549, "score": 5, "vote": 0, "content": "<p>Here is another python code to check whether closed segments intersect. It is the rewritten version of the C++ code in <a href=\"http://www.cdn.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\" rel=\"noreferrer\">http://www.cdn.geeksforgeeks.org/check-if-two-given-line-segments-intersect/</a>. This implementation covers all special cases (e.g. all points colinear).</p>\n<pre><code class=\"python\">def on_segment(p, q, r):\n    '''Given three colinear points p, q, r, the function checks if \n    point q lies on line segment \"pr\"\n    '''\n    if (q[0] &lt;= max(p[0], r[0]) and q[0] &gt;= min(p[0], r[0]) and\n        q[1] &lt;= max(p[1], r[1]) and q[1] &gt;= min(p[1], r[1])):\n        return True\n    return False\n\ndef orientation(p, q, r):\n    '''Find orientation of ordered triplet (p, q, r).\n    The function returns following values\n    0 --&gt; p, q and r are colinear\n    1 --&gt; Clockwise\n    2 --&gt; Counterclockwise\n    '''\n\n    val = ((q[1] - p[1]) * (r[0] - q[0]) - \n            (q[0] - p[0]) * (r[1] - q[1]))\n    if val == 0:\n        return 0  # colinear\n    elif val &gt; 0:\n        return 1   # clockwise\n    else:\n        return 2  # counter-clockwise\n\ndef do_intersect(p1, q1, p2, q2):\n    '''Main function to check whether the closed line segments p1 - q1 and p2 \n       - q2 intersect'''\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if (o1 != o2 and o3 != o4):\n        return True\n\n    # Special Cases\n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 and on_segment(p1, p2, q1)):\n        return True\n\n    # p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 and on_segment(p1, q2, q1)):\n        return True\n\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 and on_segment(p2, p1, q2)):\n        return True\n\n    # p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 and on_segment(p2, q1, q2)):\n        return True\n\n    return False # Doesn't fall in any of the above cases\n</code></pre>\n<p>Below is a test function to verify that it works.</p>\n<pre><code class=\"python\">import matplotlib.pyplot as plt\n\ndef test_intersect_func():\n    p1 = (1, 1)\n    q1 = (10, 1)\n    p2 = (1, 2)\n    q2 = (10, 2)\n    fig, ax = plt.subplots()\n    ax.plot([p1[0], q1[0]], [p1[1], q1[1]], 'x-')\n    ax.plot([p2[0], q2[0]], [p2[1], q2[1]], 'x-')\n    print(do_intersect(p1, q1, p2, q2))\n\n    p1 = (10, 0)\n    q1 = (0, 10)\n    p2 = (0, 0)\n    q2 = (10, 10)\n    fig, ax = plt.subplots()\n    ax.plot([p1[0], q1[0]], [p1[1], q1[1]], 'x-')\n    ax.plot([p2[0], q2[0]], [p2[1], q2[1]], 'x-')\n    print(do_intersect(p1, q1, p2, q2))\n\n    p1 = (-5, -5)\n    q1 = (0, 0)\n    p2 = (1, 1)\n    q2 = (10, 10)\n    fig, ax = plt.subplots()\n    ax.plot([p1[0], q1[0]], [p1[1], q1[1]], 'x-')\n    ax.plot([p2[0], q2[0]], [p2[1], q2[1]], 'x-')\n    print(do_intersect(p1, q1, p2, q2))\n\n    p1 = (0, 0)\n    q1 = (1, 1)\n    p2 = (1, 1)\n    q2 = (10, 10)\n    fig, ax = plt.subplots()\n    ax.plot([p1[0], q1[0]], [p1[1], q1[1]], 'x-')\n    ax.plot([p2[0], q2[0]], [p2[1], q2[1]], 'x-')\n    print(do_intersect(p1, q1, p2, q2))\n</code></pre>\n", "abstract": "Here is another python code to check whether closed segments intersect. It is the rewritten version of the C++ code in http://www.cdn.geeksforgeeks.org/check-if-two-given-line-segments-intersect/. This implementation covers all special cases (e.g. all points colinear). Below is a test function to verify that it works."}, {"id": 3840235, "score": 4, "vote": 0, "content": "<p>You have two line segments. Define one segment by endpoints A &amp; B and the second segment by endpoints C &amp; D. There is a nice trick to show that they must intersect, WITHIN the bounds of the segments. (Note that the lines themselves may intersect beyond the bounds of the segments, so you must be careful. Good code will also watch for parallel lines.)</p>\n<p>The trick is to test that points A and B must line on opposite sides of line CD, AND that points C and D must lie on opposite sides of line AB.</p>\n<p>Since this is homework, I won't give you an explicit solution. But a simple test to see which side of a line a point falls on, is to use a dot product. Thus, for a given line CD, compute the normal vector to that line (I'll call it N_C.) Now, simply test the signs of these two results:</p>\n<pre><code class=\"python\">dot(A-C,N_C)\n</code></pre>\n<p>and</p>\n<pre><code class=\"python\">dot(B-C,N_C)\n</code></pre>\n<p>If those results have opposite signs, then A and B are opposite sides of line CD. Now do the same test for the other line, AB. It has normal vector N_A. Compare the signs of</p>\n<pre><code class=\"python\">dot(C-A,N_A)\n</code></pre>\n<p>and</p>\n<pre><code class=\"python\">dot(D-A,N_A)\n</code></pre>\n<p>I'll leave it to you to figure out how to compute a normal vector. (In 2-d, that is trivial, but will your code worry about whether A and B are distinct points? Likewise, are C and D distinct?)</p>\n<p>You still need to worry about line segments that lie along the same infinite line, or if one point actually falls on the other line segment itself. Good code will cater to every possible problem.</p>\n", "abstract": "You have two line segments. Define one segment by endpoints A & B and the second segment by endpoints C & D. There is a nice trick to show that they must intersect, WITHIN the bounds of the segments. (Note that the lines themselves may intersect beyond the bounds of the segments, so you must be careful. Good code will also watch for parallel lines.) The trick is to test that points A and B must line on opposite sides of line CD, AND that points C and D must lie on opposite sides of line AB. Since this is homework, I won't give you an explicit solution. But a simple test to see which side of a line a point falls on, is to use a dot product. Thus, for a given line CD, compute the normal vector to that line (I'll call it N_C.) Now, simply test the signs of these two results: and If those results have opposite signs, then A and B are opposite sides of line CD. Now do the same test for the other line, AB. It has normal vector N_A. Compare the signs of and I'll leave it to you to figure out how to compute a normal vector. (In 2-d, that is trivial, but will your code worry about whether A and B are distinct points? Likewise, are C and D distinct?) You still need to worry about line segments that lie along the same infinite line, or if one point actually falls on the other line segment itself. Good code will cater to every possible problem."}, {"id": 17198094, "score": 3, "vote": 0, "content": "<p>Here is C code to check if two points are on the opposite sides of the line segment. Using this code you can check if two segments intersect as well.</p>\n<pre><code class=\"python\">// true if points p1, p2 lie on the opposite sides of segment s1--s2\nbool oppositeSide (Point2f s1, Point2f s2, Point2f p1, Point2f p2) {\n\n//calculate normal to the segment\nPoint2f vec = s1-s2;\nPoint2f normal(vec.y, -vec.x); // no need to normalize\n\n// vectors to the points\nPoint2f v1 = p1-s1;\nPoint2f v2 = p2-s1;\n\n// compare signs of the projections of v1, v2 onto the normal\nfloat proj1 = v1.dot(normal);\nfloat proj2 = v2.dot(normal);\nif (proj1==0 || proj2==0)\n        cout&lt;&lt;\"collinear points\"&lt;&lt;endl;\n\nreturn(SIGN(proj1) != SIGN(proj2));\n</code></pre>\n<p>}</p>\n", "abstract": "Here is C code to check if two points are on the opposite sides of the line segment. Using this code you can check if two segments intersect as well. }"}, {"id": 61699051, "score": 2, "vote": 0, "content": "<p>The answer by <a href=\"https://stackoverflow.com/users/7851470/georgy\">Georgy</a> is the cleanest to implement, by far.   Had to chase this down, since the brycboe example, while simple as well, had issues with colinearity.</p>\n<p>Code for testing:</p>\n<pre><code class=\"python\">#!/usr/bin/python\n#\n# Notes on intersection:\n#\n# https://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/\n#\n# https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\n\nfrom shapely.geometry import LineString\n\nclass Point:\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n\ndef ccw(A,B,C):\n    return (C.y-A.y)*(B.x-A.x) &gt; (B.y-A.y)*(C.x-A.x)\n\ndef intersect(A,B,C,D):\n    return ccw(A,C,D) != ccw(B,C,D) and ccw(A,B,C) != ccw(A,B,D)\n\n\ndef ShapelyIntersect(A,B,C,D):\n    return LineString([(A.x,A.y),(B.x,B.y)]).intersects(LineString([(C.x,C.y),(D.x,D.y)]))\n\n\na = Point(0,0)\nb = Point(0,1)\nc = Point(1,1)\nd = Point(1,0)\n\n'''\nTest points:\n\nb(0,1)   c(1,1)\n\n\n\n\na(0,0)   d(1,0)\n'''\n\n# F\nprint(intersect(a,b,c,d))\n\n# T\nprint(intersect(a,c,b,d))\nprint(intersect(b,d,a,c))\nprint(intersect(d,b,a,c))\n\n# F\nprint(intersect(a,d,b,c))\n\n# same end point cases:\nprint(\"same end points\")\n# F - not intersected\nprint(intersect(a,b,a,d))\n# T - This shows as intersected\nprint(intersect(b,a,a,d))\n# F - this does not\nprint(intersect(b,a,d,a))\n# F - this does not\nprint(intersect(a,b,d,a))\n\nprint(\"same end points, using shapely\")\n# T\nprint(ShapelyIntersect(a,b,a,d))\n# T\nprint(ShapelyIntersect(b,a,a,d))\n# T\nprint(ShapelyIntersect(b,a,d,a))\n# T\nprint(ShapelyIntersect(a,b,d,a))\n</code></pre>\n", "abstract": "The answer by Georgy is the cleanest to implement, by far.   Had to chase this down, since the brycboe example, while simple as well, had issues with colinearity. Code for testing:"}, {"id": 4151282, "score": 1, "vote": 0, "content": "<p>for segments AB and CD, find the slope of CD</p>\n<pre><code class=\"python\">slope=(Dy-Cy)/(Dx-Cx)\n</code></pre>\n<p>extend CD over A and B, and take the distance to CD going straight up</p>\n<pre><code class=\"python\">dist1=slope*(Cx-Ax)+Ay-Cy\ndist2=slope*(Dx-Ax)+Ay-Dy\n</code></pre>\n<p>check if they are on opposite sides</p>\n<pre><code class=\"python\">return dist1*dist2&lt;0\n</code></pre>\n", "abstract": "for segments AB and CD, find the slope of CD extend CD over A and B, and take the distance to CD going straight up check if they are on opposite sides"}, {"id": 40921580, "score": 1, "vote": 0, "content": "<p>Since you do not mention that you want to find the intersection point of the line, the problem becomes simpler to solve. If you need the intersection point, then the answer by <a href=\"https://stackoverflow.com/a/3838357/2864624\">OMG_peanuts</a> is a faster approach. However, if you just want to find whether the lines intersect or not, you can do so by using the line equation (ax + by + c = 0). The approach is as follows:</p>\n<ol>\n<li><p>Let's start with two line segments: segment 1 and segment 2. </p>\n<pre><code class=\"python\">segment1 = [[x1,y1], [x2,y2]]\nsegment2 = [[x3,y3], [x4,y4]]\n</code></pre></li>\n<li><p>Check if the two line segments are non zero length line and distinct segments. </p></li>\n<li><p>From hereon, I assume that the two segments are non-zero length and distinct. For each line segment, compute the slope of the line and then obtain the equation of a line in the form of ax + by + c = 0. Now, compute the value of f = ax + by + c for the two points of the other line segment (repeat this for the other line segment as well).</p>\n<pre><code class=\"python\">a2 = (y3-y4)/(x3-x4);\nb1 = -1;\nb2 = -1;\nc1 = y1 - a1*x1;\nc2 = y3 - a2*x3;\n// using the sign function from numpy\nf1_1 = sign(a1*x3 + b1*y3 + c1);\nf1_2 = sign(a1*x4 + b1*y4 + c1);\nf2_1 = sign(a2*x1 + b2*y1 + c2);\nf2_2 = sign(a2*x2 + b2*y2 + c2);\n</code></pre></li>\n<li><p>Now all that is left is the different cases. If f = 0 for any point, then the two lines touch at a point. If f1_1 and f1_2 are equal or f2_1 and f2_2 are equal, then the lines do not intersect. If f1_1 and f1_2 are unequal <strong>and</strong> f2_1 and f2_2 are unequal, then the line segments intersect. Depending on whether you want to consider the lines which touch as \"intersecting\" or not, you can adapt your conditions. </p></li>\n</ol>\n", "abstract": "Since you do not mention that you want to find the intersection point of the line, the problem becomes simpler to solve. If you need the intersection point, then the answer by OMG_peanuts is a faster approach. However, if you just want to find whether the lines intersect or not, you can do so by using the line equation (ax + by + c = 0). The approach is as follows: Let's start with two line segments: segment 1 and segment 2.  Check if the two line segments are non zero length line and distinct segments.  From hereon, I assume that the two segments are non-zero length and distinct. For each line segment, compute the slope of the line and then obtain the equation of a line in the form of ax + by + c = 0. Now, compute the value of f = ax + by + c for the two points of the other line segment (repeat this for the other line segment as well). Now all that is left is the different cases. If f = 0 for any point, then the two lines touch at a point. If f1_1 and f1_2 are equal or f2_1 and f2_2 are equal, then the lines do not intersect. If f1_1 and f1_2 are unequal and f2_1 and f2_2 are unequal, then the line segments intersect. Depending on whether you want to consider the lines which touch as \"intersecting\" or not, you can adapt your conditions. "}, {"id": 47328346, "score": 1, "vote": 0, "content": "<p>We can also solve this utilizing vectors. </p>\n<p>Let's define the segments as <code>[start, end]</code>. Given two such segments <code>[A, B]</code> and <code>[C, D]</code> that both have non-zero length, we can choose one of the endpoints to be used as a reference point so that we get three vectors:</p>\n<pre><code class=\"python\">x = 0\ny = 1\np = A-C = [C[x]-A[x], C[y]-A[y]]\nq = B-A = [B[x]-A[x], B[y]-A[y]]\nr = D-C = [D[x]-C[x], D[y]-C[y]]\n</code></pre>\n<p>From there, we can look for an intersection by calculating t and u in <code>p + t*r = u*q</code>. After playing around with the equation a little, we get:</p>\n<pre><code class=\"python\">t = (q[y]*p[x] - q[x]*p[y])/(q[x]*r[y] - q[y]*r[x])\nu = (p[x] + t*r[x])/q[x]\n</code></pre>\n<p>Thus, the function is:</p>\n<pre><code class=\"python\">def intersects(a, b):\n    p = [b[0][0]-a[0][0], b[0][1]-a[0][1]]\n    q = [a[1][0]-a[0][0], a[1][1]-a[0][1]]\n    r = [b[1][0]-b[0][0], b[1][1]-b[0][1]]\n\n    t = (q[1]*p[0] - q[0]*p[1])/(q[0]*r[1] - q[1]*r[0]) \\\n        if (q[0]*r[1] - q[1]*r[0]) != 0 \\\n        else (q[1]*p[0] - q[0]*p[1])\n    u = (p[0] + t*r[0])/q[0] \\\n        if q[0] != 0 \\\n        else (p[1] + t*r[1])/q[1]\n\n    return t &gt;= 0 and t &lt;= 1 and u &gt;= 0 and u &lt;= 1\n</code></pre>\n", "abstract": "We can also solve this utilizing vectors.  Let's define the segments as [start, end]. Given two such segments [A, B] and [C, D] that both have non-zero length, we can choose one of the endpoints to be used as a reference point so that we get three vectors: From there, we can look for an intersection by calculating t and u in p + t*r = u*q. After playing around with the equation a little, we get: Thus, the function is:"}, {"id": 60038103, "score": 1, "vote": 0, "content": "<p>One of the solutions above worked so well I decided to write a complete demonstration program using wxPython. You should be able to run this program like this: python \"<em>your file name</em>\"</p>\n<pre><code class=\"python\"># Click on the window to draw a line.\n# The program will tell you if this and the other line intersect.\n\nimport wx\n\nclass Point:\n    def __init__(self, newX, newY):\n        self.x = newX\n        self.y = newY\n\napp = wx.App()\nframe = wx.Frame(None, wx.ID_ANY, \"Main\")\np1 = Point(90,200)\np2 = Point(150,80)\nmp = Point(0,0) # mouse point\nhighestX = 0\n\n\ndef ccw(A,B,C):\n    return (C.y-A.y) * (B.x-A.x) &gt; (B.y-A.y) * (C.x-A.x)\n\n# Return true if line segments AB and CD intersect\ndef intersect(A,B,C,D):\n    return ccw(A,C,D) != ccw(B,C,D) and ccw(A,B,C) != ccw(A,B,D)\n\ndef is_intersection(p1, p2, p3, p4):\n    return intersect(p1, p2, p3, p4)\n\ndef drawIntersection(pc):\n    mp2 = Point(highestX, mp.y)\n    if is_intersection(p1, p2, mp, mp2):\n        pc.DrawText(\"intersection\", 10, 10)\n    else:\n        pc.DrawText(\"no intersection\", 10, 10)\n\ndef do_paint(evt):\n    pc = wx.PaintDC(frame)\n    pc.DrawLine(p1.x, p1.y, p2.x, p2.y)\n    pc.DrawLine(mp.x, mp.y, highestX, mp.y)\n    drawIntersection(pc)\n\ndef do_left_mouse(evt):\n    global mp, highestX\n    point = evt.GetPosition()\n    mp = Point(point[0], point[1])\n    highestX = frame.Size[0]\n    frame.Refresh()\n\nframe.Bind(wx.EVT_PAINT, do_paint)\nframe.Bind(wx.EVT_LEFT_DOWN, do_left_mouse)\nframe.Show()\napp.MainLoop()\n</code></pre>\n", "abstract": "One of the solutions above worked so well I decided to write a complete demonstration program using wxPython. You should be able to run this program like this: python \"your file name\""}, {"id": 63603253, "score": 1, "vote": 0, "content": "<p>Using <strong>OMG_Peanuts</strong> solution, I translated to SQL.\n(HANA Scalar Function)</p>\n<p>Thanks OMG_Peanuts, it works great.\nI am using round earth, but distances are small, so I figure its okay.</p>\n<pre><code class=\"python\">FUNCTION GA_INTERSECT\" ( IN LAT_A1 DOUBLE,\n         IN LONG_A1 DOUBLE,\n         IN LAT_A2 DOUBLE,\n         IN LONG_A2 DOUBLE,\n         IN LAT_B1 DOUBLE,\n         IN LONG_B1 DOUBLE,\n         IN LAT_B2 DOUBLE,\n         IN LONG_B2 DOUBLE) \n    \nRETURNS RET_DOESINTERSECT DOUBLE\n    LANGUAGE SQLSCRIPT\n    SQL SECURITY INVOKER AS\nBEGIN\n\n    DECLARE MA DOUBLE;\n    DECLARE MB DOUBLE;\n    DECLARE BA DOUBLE;\n    DECLARE BB DOUBLE;\n    DECLARE XA DOUBLE;\n    DECLARE MAX_MIN_X DOUBLE;\n    DECLARE MIN_MAX_X DOUBLE;\n    DECLARE DOESINTERSECT INTEGER;\n    \n    SELECT 1 INTO DOESINTERSECT FROM DUMMY;\n    \n    IF LAT_A2-LAT_A1 != 0 AND LAT_B2-LAT_B1 != 0 THEN\n        SELECT (LONG_A2 - LONG_A1)/(LAT_A2 - LAT_A1) INTO MA FROM DUMMY; \n        SELECT (LONG_B2 - LONG_B1)/(LAT_B2 - LAT_B1) INTO MB FROM DUMMY;\n        IF MA = MB THEN\n            SELECT 0 INTO DOESINTERSECT FROM DUMMY;\n        END IF;\n    END IF;\n    \n    SELECT LONG_A1-MA*LAT_A1 INTO BA FROM DUMMY;\n    SELECT LONG_B1-MB*LAT_B1 INTO BB FROM DUMMY;\n    SELECT (BB - BA) / (MA - MB) INTO XA FROM DUMMY;\n    \n    -- Max of Mins\n    IF LAT_A1 &lt; LAT_A2 THEN         -- MIN(LAT_A1, LAT_A2) = LAT_A1\n        IF LAT_B1 &lt; LAT_B2 THEN        -- MIN(LAT_B1, LAT_B2) = LAT_B1\n            IF LAT_A1 &gt; LAT_B1 THEN       -- MAX(LAT_A1, LAT_B1) = LAT_A1\n                SELECT LAT_A1 INTO MAX_MIN_X FROM DUMMY;\n            ELSE                          -- MAX(LAT_A1, LAT_B1) = LAT_B1\n                SELECT LAT_B1 INTO MAX_MIN_X FROM DUMMY;\n            END IF;\n        ELSEIF LAT_B2 &lt; LAT_B1 THEN   -- MIN(LAT_B1, LAT_B2) = LAT_B2\n            IF LAT_A1 &gt; LAT_B2 THEN       -- MAX(LAT_A1, LAT_B2) = LAT_A1\n                SELECT LAT_A1 INTO MAX_MIN_X FROM DUMMY;\n            ELSE                          -- MAX(LAT_A1, LAT_B2) = LAT_B2\n                SELECT LAT_B2 INTO MAX_MIN_X FROM DUMMY;\n            END IF;\n        END IF;\n    ELSEIF LAT_A2 &lt; LAT_A1 THEN     -- MIN(LAT_A1, LAT_A2) = LAT_A2\n        IF LAT_B1 &lt; LAT_B2 THEN        -- MIN(LAT_B1, LAT_B2) = LAT_B1\n            IF LAT_A2 &gt; LAT_B1 THEN       -- MAX(LAT_A2, LAT_B1) = LAT_A2\n                SELECT LAT_A2 INTO MAX_MIN_X FROM DUMMY;\n            ELSE                          -- MAX(LAT_A2, LAT_B1) = LAT_B1\n                SELECT LAT_B1 INTO MAX_MIN_X FROM DUMMY;\n            END IF;\n        ELSEIF LAT_B2 &lt; LAT_B1 THEN   -- MIN(LAT_B1, LAT_B2) = LAT_B2\n            IF LAT_A2 &gt; LAT_B2 THEN       -- MAX(LAT_A2, LAT_B2) = LAT_A2\n                SELECT LAT_A2 INTO MAX_MIN_X FROM DUMMY;\n            ELSE                          -- MAX(LAT_A2, LAT_B2) = LAT_B2\n                SELECT LAT_B2 INTO MAX_MIN_X FROM DUMMY;\n            END IF;\n        END IF;\n    END IF;\n    \n    -- Min of Max\n    IF LAT_A1 &gt; LAT_A2 THEN         -- MAX(LAT_A1, LAT_A2) = LAT_A1\n        IF LAT_B1 &gt; LAT_B2 THEN        -- MAX(LAT_B1, LAT_B2) = LAT_B1\n            IF LAT_A1 &lt; LAT_B1 THEN       -- MIN(LAT_A1, LAT_B1) = LAT_A1\n                SELECT LAT_A1 INTO MIN_MAX_X FROM DUMMY;\n            ELSE                          -- MIN(LAT_A1, LAT_B1) = LAT_B1\n                SELECT LAT_B1 INTO MIN_MAX_X FROM DUMMY;\n            END IF;\n        ELSEIF LAT_B2 &gt; LAT_B1 THEN   -- MAX(LAT_B1, LAT_B2) = LAT_B2\n            IF LAT_A1 &lt; LAT_B2 THEN       -- MIN(LAT_A1, LAT_B2) = LAT_A1\n                SELECT LAT_A1 INTO MIN_MAX_X FROM DUMMY;\n            ELSE                          -- MIN(LAT_A1, LAT_B2) = LAT_B2\n                SELECT LAT_B2 INTO MIN_MAX_X FROM DUMMY;\n            END IF;\n        END IF;\n    ELSEIF LAT_A2 &gt; LAT_A1 THEN     -- MAX(LAT_A1, LAT_A2) = LAT_A2\n        IF LAT_B1 &gt; LAT_B2 THEN        -- MAX(LAT_B1, LAT_B2) = LAT_B1\n            IF LAT_A2 &lt; LAT_B1 THEN       -- MIN(LAT_A2, LAT_B1) = LAT_A2\n                SELECT LAT_A2 INTO MIN_MAX_X FROM DUMMY;\n            ELSE                          -- MIN(LAT_A2, LAT_B1) = LAT_B1\n                SELECT LAT_B1 INTO MIN_MAX_X FROM DUMMY;\n            END IF;\n        ELSEIF LAT_B2 &gt; LAT_B1 THEN   -- MAX(LAT_B1, LAT_B2) = LAT_B2\n            IF LAT_A2 &lt; LAT_B2 THEN       -- MIN(LAT_A2, LAT_B2) = LAT_A2\n                SELECT LAT_A2 INTO MIN_MAX_X FROM DUMMY;\n            ELSE                          -- MIN(LAT_A2, LAT_B2) = LAT_B2\n                SELECT LAT_B2 INTO MIN_MAX_X FROM DUMMY;\n            END IF;\n        END IF;\n    END IF;\n        \n    \n    IF XA &lt; MAX_MIN_X OR\n       XA &gt; MIN_MAX_X THEN  \n       SELECT 0 INTO DOESINTERSECT FROM DUMMY;\n    END IF;\n    \n    RET_DOESINTERSECT := :DOESINTERSECT;\nEND;\n</code></pre>\n", "abstract": "Using OMG_Peanuts solution, I translated to SQL.\n(HANA Scalar Function) Thanks OMG_Peanuts, it works great.\nI am using round earth, but distances are small, so I figure its okay."}, {"id": 72147858, "score": 1, "vote": 0, "content": "<p>Digging up an old thread and modifying Grumdrig's code ...</p>\n<pre><code class=\"python\">template &lt;typename T&gt;\nstruct Point { \n  T x; \n  T y; \n  Point(T x_, T y_) : x(x_), y(y_) {};\n};\n\ntemplate &lt;typename T&gt;\ninline T CrossProduct(const Point&lt;T&gt;&amp; pt1, const Point&lt;T&gt;&amp; pt2, const Point&lt;T&gt;&amp; pt3) \n{\n  // nb: watch out for overflow\n  return ((pt2.x - pt1.x) * (pt3.y - pt2.y) - (pt2.y - pt1.y) * (pt3.x - pt2.x));\n}\n\ntemplate &lt;typename T&gt;\nbool SegmentsIntersect(const Point&lt;T&gt;&amp; a, const Point&lt;T&gt;&amp; b,\n  const Point&lt;T&gt;&amp; c, const Point&lt;T&gt;&amp; d)\n{\n  return\n    CrossProduct(a, c, d) * CrossProduct(b, c, d) &lt; 0 &amp;&amp;\n    CrossProduct(c, a, b) * CrossProduct(d, a, b) &lt; 0;\n}\n\nif (SegmentsIntersect(Point&lt;int&gt;(50, 0), Point&lt;int&gt;(50, 100), \n  Point&lt;int&gt;(0, 50), Point&lt;int&gt;(100, 50)))\n    std::cout &lt;&lt; \"it works!\" &lt;&lt; std::endl;\n</code></pre>\n", "abstract": "Digging up an old thread and modifying Grumdrig's code ..."}, {"id": 3838372, "score": 0, "vote": 0, "content": "<p>if your data define line you just have to prove that they are not parallel. To do this you can compute  </p>\n<pre><code class=\"python\">alpha = float(y2 - y1) / (x2 - x1).\n</code></pre>\n<p>If this coefficient is equal for both Line1 and Line2, it means the line are parallel. If not, it means they will intersect. </p>\n<p>If they are parallel you then have to prove that they are not the same. For that, you compute   </p>\n<pre><code class=\"python\">beta = y1 - alpha*x1\n</code></pre>\n<p>If beta is the same for Line1 and Line2,it means you line intersect as they are equal</p>\n<p>If they are segment, you still have to compute alpha and beta as described above for each Line. Then you have to check that (beta1 - beta2) / (alpha1 - alpha2) is greater than Min(x1_line1, x2_line1) and less than Max(x1_line1, x2_line1)</p>\n", "abstract": "if your data define line you just have to prove that they are not parallel. To do this you can compute   If this coefficient is equal for both Line1 and Line2, it means the line are parallel. If not, it means they will intersect.  If they are parallel you then have to prove that they are not the same. For that, you compute    If beta is the same for Line1 and Line2,it means you line intersect as they are equal If they are segment, you still have to compute alpha and beta as described above for each Line. Then you have to check that (beta1 - beta2) / (alpha1 - alpha2) is greater than Min(x1_line1, x2_line1) and less than Max(x1_line1, x2_line1)"}, {"id": 3839307, "score": 0, "vote": 0, "content": "<p>Calculate the intersection point of the lines laying on your segments (it means basically to solve a linear equation system), then check whether is it between the starting and ending points of your segments.</p>\n", "abstract": "Calculate the intersection point of the lines laying on your segments (it means basically to solve a linear equation system), then check whether is it between the starting and ending points of your segments."}, {"id": 3842262, "score": 0, "vote": 0, "content": "<p>This is what I've got for AS3, don't know much about python but the concept is there</p>\n<pre><code class=\"python\">    public function getIntersectingPointF($A:Point, $B:Point, $C:Point, $D:Point):Number {\n        var A:Point = $A.clone();\n        var B:Point = $B.clone();\n        var C:Point = $C.clone();\n        var D:Point = $D.clone();\n        var f_ab:Number = (D.x - C.x) * (A.y - C.y) - (D.y - C.y) * (A.x - C.x);\n\n        // are lines parallel\n        if (f_ab == 0) { return Infinity };\n\n        var f_cd:Number = (B.x - A.x) * (A.y - C.y) - (B.y - A.y) * (A.x - C.x);\n        var f_d:Number = (D.y - C.y) * (B.x - A.x) - (D.x - C.x) * (B.y - A.y);\n        var f1:Number = f_ab/f_d\n        var f2:Number = f_cd / f_d\n        if (f1 == Infinity || f1 &lt;= 0 || f1 &gt;= 1) { return Infinity };\n        if (f2 == Infinity || f2 &lt;= 0 || f2 &gt;= 1) { return Infinity };\n        return f1;\n    }\n\n    public function getIntersectingPoint($A:Point, $B:Point, $C:Point, $D:Point):Point\n    {\n        var f:Number = getIntersectingPointF($A, $B, $C, $D);\n        if (f == Infinity || f &lt;= 0 || f &gt;= 1) { return null };\n\n        var retPoint:Point = Point.interpolate($A, $B, 1 - f);\n        return retPoint.clone();\n    }\n</code></pre>\n", "abstract": "This is what I've got for AS3, don't know much about python but the concept is there"}, {"id": 47252592, "score": 0, "vote": 0, "content": "<p>I thought I'd contribute a nice Swift solution:</p>\n<pre><code class=\"python\">struct Pt {\n    var x: Double\n    var y: Double\n}\n\nstruct LineSegment {\n    var p1: Pt\n    var p2: Pt\n}\n\nfunc doLineSegmentsIntersect(ls1: LineSegment, ls2: LineSegment) -&gt; Bool {\n\n    if (ls1.p2.x-ls1.p1.x == 0) { //handle vertical segment1\n        if (ls2.p2.x-ls2.p1.x == 0) {\n            //both lines are vertical and parallel\n            return false\n        }\n\n        let x = ls1.p1.x\n\n        let slope2 = (ls2.p2.y-ls2.p1.y)/(ls2.p2.x-ls2.p1.x)\n        let c2 = ls2.p1.y-slope2*ls2.p1.x\n\n        let y = x*slope2+c2 // y intersection point\n\n        return (y &gt; ls1.p1.y &amp;&amp; x &lt; ls1.p2.y) || (y &gt; ls1.p2.y &amp;&amp; y &lt; ls1.p1.y) // check if y is between y1,y2 in segment1\n    }\n\n    if (ls2.p2.x-ls2.p1.x == 0) { //handle vertical segment2\n\n        let x = ls2.p1.x\n\n        let slope1 = (ls1.p2.y-ls1.p1.y)/(ls1.p2.x-ls1.p1.x)\n        let c1 = ls1.p1.y-slope1*ls1.p1.x\n\n        let y = x*slope1+c1 // y intersection point\n\n        return (y &gt; ls2.p1.y &amp;&amp; x &lt; ls2.p2.y) || (y &gt; ls2.p2.y &amp;&amp; y &lt; ls2.p1.y) // validate that y is between y1,y2 in segment2\n\n    }\n\n    let slope1 = (ls1.p2.y-ls1.p1.y)/(ls1.p2.x-ls1.p1.x)\n    let slope2 = (ls2.p2.y-ls2.p1.y)/(ls2.p2.x-ls2.p1.x)\n\n    if (slope1 == slope2) { //segments are parallel\n        return false\n    }\n\n    let c1 = ls1.p1.y-slope1*ls1.p1.x\n    let c2 = ls2.p1.y-slope2*ls2.p1.x\n\n    let x = (c2-c1)/(slope1-slope2)\n\n    return (((x &gt; ls1.p1.x &amp;&amp; x &lt; ls1.p2.x) || (x &gt; ls1.p2.x &amp;&amp; x &lt; ls1.p1.x)) &amp;&amp;\n        ((x &gt; ls2.p1.x &amp;&amp; x &lt; ls2.p2.x) || (x &gt; ls2.p2.x &amp;&amp; x &lt; ls2.p1.x)))\n    //validate that x is between x1,x2 in both segments\n\n}\n</code></pre>\n", "abstract": "I thought I'd contribute a nice Swift solution:"}, {"id": 16429239, "score": -1, "vote": 0, "content": "<p>Implemented in JAVA.  However It seems that it does not work for co-linear lines (aka line segments that exist within each other L1(0,0)(10,10) L2(1,1)(2,2)</p>\n<pre><code class=\"python\">public class TestCode\n{\n\n  public class Point\n  {\n    public double x = 0;\n    public double y = 0;\n    public Point(){}\n  }\n\n  public class Line\n  {\n    public Point p1, p2;\n    public Line( double x1, double y1, double x2, double y2) \n    {\n      p1 = new Point();\n      p2 = new Point();\n      p1.x = x1;\n      p1.y = y1;\n      p2.x = x2;\n      p2.y = y2;\n    }\n  }\n\n  //line segments\n  private static Line s1;\n  private static Line s2;\n\n  public TestCode()\n  {\n    s1 = new Line(0,0,0,10);\n    s2 = new Line(-1,0,0,10);\n  }\n\n  public TestCode(double x1, double y1, \n    double x2, double y2,\n    double x3, double y3,\n    double x4, double y4)\n  {\n    s1 = new Line(x1,y1, x2,y2);\n    s2 = new Line(x3,y3, x4,y4);\n  }\n\n  public static void main(String args[])\n  {\n     TestCode code  = null;\n////////////////////////////\n     code = new TestCode(0,0,0,10,\n                         0,1,0,5);\n     if( intersect(code) )\n     { System.out.println( \"OK COLINEAR: INTERSECTS\" ); }\n     else\n     { System.out.println( \"ERROR COLINEAR: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(0,0,0,10,\n                         0,1,0,10);\n     if( intersect(code) )\n     { System.out.println( \"OK COLINEAR: INTERSECTS\" ); }\n     else\n     { System.out.println( \"ERROR COLINEAR: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(0,0,10,0,\n                         5,0,15,0);\n     if( intersect(code) )\n     { System.out.println( \"OK COLINEAR: INTERSECTS\" ); }\n     else\n     { System.out.println( \"ERROR COLINEAR: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(0,0,10,0,\n                         0,0,15,0);\n     if( intersect(code) )\n     { System.out.println( \"OK COLINEAR: INTERSECTS\" ); }\n     else\n     { System.out.println( \"ERROR COLINEAR: DO NOT INTERSECT\" ); }\n\n////////////////////////////\n     code = new TestCode(0,0,10,10,\n                         1,1,5,5);\n     if( intersect(code) )\n     { System.out.println( \"OK COLINEAR: INTERSECTS\" ); }\n     else\n     { System.out.println( \"ERROR COLINEAR: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(0,0,0,10,\n                         -1,-1,0,10);\n     if( intersect(code) )\n     { System.out.println( \"OK SLOPE END: INTERSECTS\" ); }\n     else\n     { System.out.println( \"ERROR SLOPE END: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(-10,-10,10,10,\n                         -10,10,10,-10);\n     if( intersect(code) )\n     { System.out.println( \"OK SLOPE Intersect(0,0): INTERSECTS\" ); }\n     else\n     { System.out.println( \"ERROR SLOPE Intersect(0,0): DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(-10,-10,10,10,\n                         -3,-2,50,-2);\n     if( intersect(code) )\n     { System.out.println( \"OK SLOPE Line2 VERTIAL: INTERSECTS\" ); }\n     else\n     { System.out.println( \"ERROR SLOPE Line2 VERTICAL: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(-10,-10,10,10,\n                         50,-2,-3,-2);\n     if( intersect(code) )\n     { System.out.println( \"OK SLOPE Line2 (reversed) VERTIAL: INTERSECTS\" ); }\n     else\n     { System.out.println( \"ERROR SLOPE Line2 (reversed) VERTICAL: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(0,0,0,10,\n                         1,0,1,10);\n     if( intersect(code) )\n     { System.out.println( \"ERROR PARALLEL VERTICAL: INTERSECTS\" ); }\n     else\n     { System.out.println( \"OK PARALLEL VERTICAL: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(0,2,10,2,\n                         0,10,10,10);\n     if( intersect(code) )\n     { System.out.println( \"ERROR PARALLEL HORIZONTAL: INTERSECTS\" ); }\n     else\n     { System.out.println( \"OK PARALLEL HORIZONTAL: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(0,10,5,13.75,\n                         0,18.75,10,15);\n     if( intersect(code) )\n     { System.out.println( \"ERROR PARALLEL SLOPE=.75: INTERSECTS\" ); }\n     else\n     { System.out.println( \"OK PARALLEL SLOPE=.75: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(0,0,1,1,\n                         2,-1,2,10);\n     if( intersect(code) )\n     { System.out.println( \"ERROR SEPERATE SEGMENTS: INTERSECTS\" ); }\n     else\n     { System.out.println( \"OK SEPERATE SEGMENTS: DO NOT INTERSECT\" ); }\n////////////////////////////\n     code = new TestCode(0,0,1,1,\n                         -1,-10,-5,10);\n     if( intersect(code) )\n     { System.out.println( \"ERROR SEPERATE SEGMENTS 2: INTERSECTS\" ); }\n     else\n     { System.out.println( \"OK SEPERATE SEGMENTS 2: DO NOT INTERSECT\" ); }\n  }\n\n  public static boolean intersect( TestCode code )\n  {\n    return intersect( code.s1, code.s2);\n  }\n\n  public static boolean intersect( Line line1, Line line2 )\n  {\n    double i1min = Math.min(line1.p1.x, line1.p2.x);\n    double i1max = Math.max(line1.p1.x, line1.p2.x);\n    double i2min = Math.min(line2.p1.x, line2.p2.x);\n    double i2max = Math.max(line2.p1.x, line2.p2.x);\n\n    double iamax = Math.max(i1min, i2min);\n    double iamin = Math.min(i1max, i2max);\n\n    if( Math.max(line1.p1.x, line1.p2.x) &lt; Math.min(line2.p1.x, line2.p2.x) )\n      return false;\n\n    double m1 = (line1.p2.y - line1.p1.y) / (line1.p2.x - line1.p1.x );\n    double m2 = (line2.p2.y - line2.p1.y) / (line2.p2.x - line2.p1.x );\n\n    if( m1 == m2 )\n        return false;\n\n    //b1 = line1[0][1] - m1 * line1[0][0]\n    //b2 = line2[0][1] - m2 * line2[0][0]\n    double b1 = line1.p1.y - m1 * line1.p1.x;\n    double b2 = line2.p1.y - m2 * line2.p1.x;\n    double x1 = (b2 - b1) / (m1 - m2);\n    if( (x1 &lt; Math.max(i1min, i2min)) || (x1 &gt; Math.min(i1max, i2max)) )\n        return false;\n    return true;\n  }\n}\n</code></pre>\n<p>Output thus far is </p>\n<pre><code class=\"python\">ERROR COLINEAR: DO NOT INTERSECT\nERROR COLINEAR: DO NOT INTERSECT\nERROR COLINEAR: DO NOT INTERSECT\nERROR COLINEAR: DO NOT INTERSECT\nERROR COLINEAR: DO NOT INTERSECT\nOK SLOPE END: INTERSECTS\nOK SLOPE Intersect(0,0): INTERSECTS\nOK SLOPE Line2 VERTIAL: INTERSECTS\nOK SLOPE Line2 (reversed) VERTIAL: INTERSECTS\nOK PARALLEL VERTICAL: DO NOT INTERSECT\nOK PARALLEL HORIZONTAL: DO NOT INTERSECT\nOK PARALLEL SLOPE=.75: DO NOT INTERSECT\nOK SEPERATE SEGMENTS: DO NOT INTERSECT\nOK SEPERATE SEGMENTS 2: DO NOT INTERSECT\n</code></pre>\n", "abstract": "Implemented in JAVA.  However It seems that it does not work for co-linear lines (aka line segments that exist within each other L1(0,0)(10,10) L2(1,1)(2,2) Output thus far is "}, {"id": 10047298, "score": -2, "vote": 0, "content": "<p>Resolved but still why not with python... :)</p>\n<pre><code class=\"python\">def islineintersect(line1, line2):\n    i1 = [min(line1[0][0], line1[1][0]), max(line1[0][0], line1[1][0])]\n    i2 = [min(line2[0][0], line2[1][0]), max(line2[0][0], line2[1][0])]\n    ia = [max(i1[0], i2[0]), min(i1[1], i2[1])]\n    if max(line1[0][0], line1[1][0]) &lt; min(line2[0][0], line2[1][0]):\n        return False\n    m1 = (line1[1][1] - line1[0][1]) * 1. / (line1[1][0] - line1[0][0]) * 1.\n    m2 = (line2[1][1] - line2[0][1]) * 1. / (line2[1][0] - line2[0][0]) * 1.\n    if m1 == m2:\n        return False\n    b1 = line1[0][1] - m1 * line1[0][0]\n    b2 = line2[0][1] - m2 * line2[0][0]\n    x1 = (b2 - b1) / (m1 - m2)\n    if (x1 &lt; max(i1[0], i2[0])) or (x1 &gt; min(i1[1], i2[1])):\n        return False\n    return True\n</code></pre>\n<p>This:</p>\n<pre><code class=\"python\">print islineintersect([(15, 20), (100, 200)], [(210, 5), (23, 119)])\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">True\n</code></pre>\n<p>And this:</p>\n<pre><code class=\"python\">print islineintersect([(15, 20), (100, 200)], [(-1, -5), (-5, -5)])\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">False\n</code></pre>\n", "abstract": "Resolved but still why not with python... :) This: Output: And this: Output:"}]}, {"link": "https://stackoverflow.com/questions/9876290/how-do-i-compute-derivative-using-numpy", "question": {"id": "9876290", "title": "How do I compute derivative using Numpy?", "content": "<p>How do I calculate the derivative of a function, for example </p>\n<blockquote>\n<p>y = x<sup>2</sup>+1 </p>\n</blockquote>\n<p>using <code>numpy</code>?</p>\n<p>Let's say, I want the value of derivative at x = 5... </p>\n", "abstract": "How do I calculate the derivative of a function, for example  y = x2+1  using numpy? Let's say, I want the value of derivative at x = 5... "}, "answers": [{"id": 9877279, "score": 187, "vote": 0, "content": "<p>You have four options</p>\n<ol>\n<li><a href=\"http://en.wikipedia.org/wiki/Finite_differences\" rel=\"noreferrer\">Finite Differences</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Automatic_differentiation\" rel=\"noreferrer\">Automatic Derivatives</a> </li>\n<li><a href=\"http://en.wikipedia.org/wiki/Symbolic_differentiation\" rel=\"noreferrer\">Symbolic Differentiation</a></li>\n<li>Compute derivatives by hand.</li>\n</ol>\n<p>Finite differences require no external tools but are prone to numerical error and, if you're in a multivariate situation, can take a while. </p>\n<p>Symbolic differentiation is ideal if your problem is simple enough. Symbolic methods are getting quite robust these days. <a href=\"http://sympy.org/en/index.html\" rel=\"noreferrer\">SymPy</a> is an excellent project for this that integrates well with NumPy. Look at the autowrap or lambdify functions or check out <a href=\"http://ojensen.wordpress.com/\" rel=\"noreferrer\">Jensen's blogpost about a similar question</a>.</p>\n<p>Automatic derivatives are very cool, aren't prone to numeric errors, but do require some additional libraries (google for this, there are a few good options). This is the most robust but also the most sophisticated/difficult to set up choice.  If you're fine restricting yourself to <code>numpy</code> syntax then <a href=\"http://deeplearning.net/software/theano/\" rel=\"noreferrer\">Theano</a> might be a good choice.</p>\n<p>Here is an example using SymPy</p>\n<pre><code class=\"python\">In [1]: from sympy import *\nIn [2]: import numpy as np\nIn [3]: x = Symbol('x')\nIn [4]: y = x**2 + 1\nIn [5]: yprime = y.diff(x)\nIn [6]: yprime\nOut[6]: 2\u22c5x\n\nIn [7]: f = lambdify(x, yprime, 'numpy')\nIn [8]: f(np.ones(5))\nOut[8]: [ 2.  2.  2.  2.  2.]\n</code></pre>\n", "abstract": "You have four options Finite differences require no external tools but are prone to numerical error and, if you're in a multivariate situation, can take a while.  Symbolic differentiation is ideal if your problem is simple enough. Symbolic methods are getting quite robust these days. SymPy is an excellent project for this that integrates well with NumPy. Look at the autowrap or lambdify functions or check out Jensen's blogpost about a similar question. Automatic derivatives are very cool, aren't prone to numeric errors, but do require some additional libraries (google for this, there are a few good options). This is the most robust but also the most sophisticated/difficult to set up choice.  If you're fine restricting yourself to numpy syntax then Theano might be a good choice. Here is an example using SymPy"}, {"id": 26042315, "score": 70, "vote": 0, "content": "<p>The most straight-forward way I can think of is using <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.gradient.html\">numpy's gradient function</a>:</p>\n<pre><code class=\"python\">x = numpy.linspace(0,10,1000)\ndx = x[1]-x[0]\ny = x**2 + 1\ndydx = numpy.gradient(y, dx)\n</code></pre>\n<p>This way, dydx will be computed using central differences and will have the same length as y, unlike numpy.diff, which uses forward differences and will return (n-1) size vector.</p>\n", "abstract": "The most straight-forward way I can think of is using numpy's gradient function: This way, dydx will be computed using central differences and will have the same length as y, unlike numpy.diff, which uses forward differences and will return (n-1) size vector."}, {"id": 9876548, "score": 33, "vote": 0, "content": "<p>NumPy does not provide general functionality to compute derivatives.  It can handles the simple special case of polynomials however:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = numpy.poly1d([1, 0, 1])\n&gt;&gt;&gt; print p\n   2\n1 x + 1\n&gt;&gt;&gt; q = p.deriv()\n&gt;&gt;&gt; print q\n2 x\n&gt;&gt;&gt; q(5)\n10\n</code></pre>\n<p>If you want to compute the derivative numerically, you can get away with using central difference quotients for the vast majority of applications.  For the derivative in a single point, the formula would be something like</p>\n<pre><code class=\"python\">x = 5.0\neps = numpy.sqrt(numpy.finfo(float).eps) * (1.0 + x)\nprint (p(x + eps) - p(x - eps)) / (2.0 * eps * x)\n</code></pre>\n<p>if you have an array <code>x</code> of abscissae with a corresponding array <code>y</code> of function values, you can comput approximations of derivatives with</p>\n<pre><code class=\"python\">numpy.diff(y) / numpy.diff(x)\n</code></pre>\n", "abstract": "NumPy does not provide general functionality to compute derivatives.  It can handles the simple special case of polynomials however: If you want to compute the derivative numerically, you can get away with using central difference quotients for the vast majority of applications.  For the derivative in a single point, the formula would be something like if you have an array x of abscissae with a corresponding array y of function values, you can comput approximations of derivatives with"}, {"id": 44205536, "score": 20, "vote": 0, "content": "<p>Assuming you want to use <code>numpy</code>, you can numerically compute the derivative of a function at any point using the  <a href=\"https://en.wikipedia.org/wiki/Numerical_differentiation\" rel=\"noreferrer\">Rigorous definition</a>:</p>\n<pre><code class=\"python\">def d_fun(x):\n    h = 1e-5 #in theory h is an infinitesimal\n    return (fun(x+h)-fun(x))/h\n</code></pre>\n<p>You can also use the <a href=\"https://en.wikipedia.org/wiki/Symmetric_derivative\" rel=\"noreferrer\">Symmetric derivative</a> for better results:</p>\n<pre><code class=\"python\">def d_fun(x):\n    h = 1e-5\n    return (fun(x+h)-fun(x-h))/(2*h)\n</code></pre>\n<p>Using your example, the full code should look something like:</p>\n<pre><code class=\"python\">def fun(x):\n    return x**2 + 1\n\ndef d_fun(x):\n    h = 1e-5\n    return (fun(x+h)-fun(x-h))/(2*h)\n</code></pre>\n<p>Now, you can <strong>numerically</strong> find the derivative at <code>x=5</code>:</p>\n<pre><code class=\"python\">In [1]: d_fun(5)\nOut[1]: 9.999999999621423\n</code></pre>\n", "abstract": "Assuming you want to use numpy, you can numerically compute the derivative of a function at any point using the  Rigorous definition: You can also use the Symmetric derivative for better results: Using your example, the full code should look something like: Now, you can numerically find the derivative at x=5:"}, {"id": 33530090, "score": 10, "vote": 0, "content": "<p>I'll throw another method on the pile...</p>\n<p><code>scipy.interpolate</code>'s many interpolating splines are capable of providing derivatives.  So, using a linear spline (<code>k=1</code>), the derivative of the spline (using the <code>derivative()</code> method) should be equivalent to a forward difference.  I'm not entirely sure, but I believe using a cubic spline derivative would be similar to a centered difference derivative since it uses values from before and after to construct the cubic spline.</p>\n<pre><code class=\"python\">from scipy.interpolate import InterpolatedUnivariateSpline\n\n# Get a function that evaluates the linear spline at any x\nf = InterpolatedUnivariateSpline(x, y, k=1)\n\n# Get a function that evaluates the derivative of the linear spline at any x\ndfdx = f.derivative()\n\n# Evaluate the derivative dydx at each x location...\ndydx = dfdx(x)\n</code></pre>\n", "abstract": "I'll throw another method on the pile... scipy.interpolate's many interpolating splines are capable of providing derivatives.  So, using a linear spline (k=1), the derivative of the spline (using the derivative() method) should be equivalent to a forward difference.  I'm not entirely sure, but I believe using a cubic spline derivative would be similar to a centered difference derivative since it uses values from before and after to construct the cubic spline."}, {"id": 62533761, "score": 8, "vote": 0, "content": "<p>You can use <code>scipy</code>, which is pretty straight forward:</p>\n<p><a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.derivative.html\" rel=\"noreferrer\"><code>scipy.misc.derivative(func, x0, dx=1.0, n=1, args=(), order=3)</code></a></p>\n<blockquote>\n<p>Find the nth derivative of a function at a point.</p>\n</blockquote>\n<p>In your case:</p>\n<pre><code class=\"python\">from scipy.misc import derivative\n\ndef f(x):\n    return x**2 + 1\n\nderivative(f, 5, dx=1e-6)\n# 10.00000000139778\n</code></pre>\n", "abstract": "You can use scipy, which is pretty straight forward: scipy.misc.derivative(func, x0, dx=1.0, n=1, args=(), order=3) Find the nth derivative of a function at a point. In your case:"}, {"id": 51127265, "score": 7, "vote": 0, "content": "<p>To calculate gradients, the machine learning community uses Autograd:</p>\n<blockquote>\n<p>\"<a href=\"https://pypi.org/project/autograd/\" rel=\"noreferrer\">Efficiently computes derivatives of numpy code.</a>\"</p>\n</blockquote>\n<p>To install:</p>\n<pre><code class=\"python\">pip install autograd\n</code></pre>\n<p>Here is an example:</p>\n<pre><code class=\"python\">import autograd.numpy as np\nfrom autograd import grad\n\ndef fct(x):\n    y = x**2+1\n    return y\n\ngrad_fct = grad(fct)\nprint(grad_fct(1.0))\n</code></pre>\n<p>It can also compute gradients of complex functions, e.g. multivariate functions.</p>\n", "abstract": "To calculate gradients, the machine learning community uses Autograd: \"Efficiently computes derivatives of numpy code.\" To install: Here is an example: It can also compute gradients of complex functions, e.g. multivariate functions."}, {"id": 9876783, "score": 3, "vote": 0, "content": "<p>Depending on the level of precision you require you can work it out yourself, using the simple proof of differentiation:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; (((5 + 0.1) ** 2 + 1) - ((5) ** 2 + 1)) / 0.1\n10.09999999999998\n&gt;&gt;&gt; (((5 + 0.01) ** 2 + 1) - ((5) ** 2 + 1)) / 0.01\n10.009999999999764\n&gt;&gt;&gt; (((5 + 0.0000000001) ** 2 + 1) - ((5) ** 2 + 1)) / 0.0000000001\n10.00000082740371\n</code></pre>\n<p>we can't actually take the limit of the gradient, but its kinda fun.\nYou gotta watch out though because </p>\n<pre><code class=\"python\">&gt;&gt;&gt; (((5+0.0000000000000001)**2+1)-((5)**2+1))/0.0000000000000001\n0.0\n</code></pre>\n", "abstract": "Depending on the level of precision you require you can work it out yourself, using the simple proof of differentiation: we can't actually take the limit of the gradient, but its kinda fun.\nYou gotta watch out though because "}, {"id": 70949159, "score": 1, "vote": 0, "content": "<p>To compute the derivative of a numerical function, use this second order finite differences scheme as seen in:\n<a href=\"https://youtu.be/5QnToSn_oxk?t=1804\" rel=\"nofollow noreferrer\">https://youtu.be/5QnToSn_oxk?t=1804</a></p>\n<pre><code class=\"python\">dx = 0.01\nx = np.arange(-4, 4+dx, dx)\ny = np.sin(x)\nn = np.size(x)\n\nyp = np.zeros(n)\nyp[0] = (-3*y[0] + 4*y[1] - y[2]) / (2*dx)\nyp[n-1] = (3 * y[n-1] - 4*y[n-2] + y[n-3]) / (2*dx)\nfor j in range(1,n-1):\n    yp[j] = (y[j+1] - y[j-1]) / (2*dx)\n</code></pre>\n<p>Or if you want to use a higher order, use:\n<a href=\"https://youtu.be/5QnToSn_oxk?t=1374\" rel=\"nofollow noreferrer\">https://youtu.be/5QnToSn_oxk?t=1374</a></p>\n<p>All that comes from the Nathan Kutz' lectures of the course \"Beginning Scientific Computing\".</p>\n", "abstract": "To compute the derivative of a numerical function, use this second order finite differences scheme as seen in:\nhttps://youtu.be/5QnToSn_oxk?t=1804 Or if you want to use a higher order, use:\nhttps://youtu.be/5QnToSn_oxk?t=1374 All that comes from the Nathan Kutz' lectures of the course \"Beginning Scientific Computing\"."}]}, {"link": "https://stackoverflow.com/questions/2958684/why-does-the-division-get-rounded-to-an-integer", "question": {"id": "2958684", "title": "Why does the division get rounded to an integer?", "content": "<p>I was trying to normalize a set of numbers from -100 to 0 to a range of 10-100 and was having problems only to notice that even with no variables at all, this does not evaluate the way I would expect it to:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; (20-10) / (100-10)\n0\n</code></pre>\n<p>Float division doesn't work either:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; float((20-10) / (100-10))\n0.0\n</code></pre>\n<p>If either side of the division is cast to a float it will work:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; (20-10) / float((100-10))\n0.1111111111111111\n</code></pre>\n<p>Each side in the first example is evaluating as an int which means the final answer will be cast to an int. Since 0.111 is less than .5, it rounds to 0.  It is not transparent in my opinion, but I guess that's the way it is.</p>\n<p>What is the explanation?</p>\n", "abstract": "I was trying to normalize a set of numbers from -100 to 0 to a range of 10-100 and was having problems only to notice that even with no variables at all, this does not evaluate the way I would expect it to: Float division doesn't work either: If either side of the division is cast to a float it will work: Each side in the first example is evaluating as an int which means the final answer will be cast to an int. Since 0.111 is less than .5, it rounds to 0.  It is not transparent in my opinion, but I guess that's the way it is. What is the explanation?"}, "answers": [{"id": 2958717, "score": 247, "vote": 0, "content": "<p>You're using Python 2.x, where integer divisions will truncate instead of becoming a floating point number.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 1 / 2\n0\n</code></pre>\n<p>You should make one of them a <code>float</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; float(10 - 20) / (100 - 10)\n-0.1111111111111111\n</code></pre>\n<p>or <code>from __future__ import division</code>, which the forces <code>/</code> to adopt Python 3.x's behavior that always returns a float.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from __future__ import division\n&gt;&gt;&gt; (10 - 20) / (100 - 10)\n-0.1111111111111111\n</code></pre>\n", "abstract": "You're using Python 2.x, where integer divisions will truncate instead of becoming a floating point number. You should make one of them a float: or from __future__ import division, which the forces / to adopt Python 3.x's behavior that always returns a float."}, {"id": 2958712, "score": 21, "vote": 0, "content": "<p>You're <a href=\"http://docs.python.org/reference/expressions.html#binary-arithmetic-operations\" rel=\"noreferrer\">putting Integers in so Python is giving you an integer back</a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 10 / 90\n0\n</code></pre>\n<p>If if you cast this to a float afterwards the rounding will have already been done, in other words, 0 integer will always become 0 float.</p>\n<p>If you use floats on either side of the division then Python will give you the answer you expect.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 10 / 90.0\n0.1111111111111111\n</code></pre>\n<p>So in your case:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; float(20-10) / (100-10)\n0.1111111111111111\n&gt;&gt;&gt; (20-10) / float(100-10)\n0.1111111111111111\n</code></pre>\n", "abstract": "You're putting Integers in so Python is giving you an integer back: If if you cast this to a float afterwards the rounding will have already been done, in other words, 0 integer will always become 0 float. If you use floats on either side of the division then Python will give you the answer you expect. So in your case:"}, {"id": 31770642, "score": 12, "vote": 0, "content": "<p>In Python 2.7, the <code>/</code> operator is an integer division if inputs are integers:</p>\n<pre><code class=\"python\">&gt;&gt;&gt;20/15\n1\n\n&gt;&gt;&gt;20.0/15.0\n1.33333333333\n\n&gt;&gt;&gt;20.0/15\n1.33333333333\n</code></pre>\n<p>In Python 3.3, the <code>/</code> operator is a float division even if the inputs are integer.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 20/15\n1.33333333333\n\n&gt;&gt;&gt;20.0/15\n1.33333333333\n</code></pre>\n<p>For integer division in Python 3, we will use the <code>//</code> operator.</p>\n<p>The <code>//</code> operator is an integer division operator in both Python 2.7 and Python 3.3.</p>\n<p>In Python 2.7 and Python 3.3:</p>\n<pre><code class=\"python\">&gt;&gt;&gt;20//15\n1\n</code></pre>\n<p>Now, see the comparison</p>\n<pre><code class=\"python\">&gt;&gt;&gt;a = 7.0/4.0\n&gt;&gt;&gt;b = 7/4\n&gt;&gt;&gt;print a == b\n</code></pre>\n<p>For the above program, the output will be False in Python 2.7 and True in Python 3.3.</p>\n<p>In Python 2.7 a = 1.75 and b = 1.</p>\n<p>In Python 3.3 a = 1.75 and b = 1.75, just because <code>/</code> is a float division.</p>\n", "abstract": "In Python 2.7, the / operator is an integer division if inputs are integers: In Python 3.3, the / operator is a float division even if the inputs are integer. For integer division in Python 3, we will use the // operator. The // operator is an integer division operator in both Python 2.7 and Python 3.3. In Python 2.7 and Python 3.3: Now, see the comparison For the above program, the output will be False in Python 2.7 and True in Python 3.3. In Python 2.7 a = 1.75 and b = 1. In Python 3.3 a = 1.75 and b = 1.75, just because / is a float division."}, {"id": 2958705, "score": 11, "vote": 0, "content": "<p>You need to change it to a float BEFORE you do the division. That is:</p>\n<pre><code class=\"python\">float(20 - 10) / (100 - 10)\n</code></pre>\n", "abstract": "You need to change it to a float BEFORE you do the division. That is:"}, {"id": 27051142, "score": 8, "vote": 0, "content": "<p>It has to do with the version of python that you use. Basically it adopts the C behavior: if you divide two integers, the results will be rounded down to an integer. Also keep in mind that Python does the operations from left to right, which plays a role when you typecast.</p>\n<p>Example:\nSince this is a question that always pops in my head when I am doing arithmetic operations (should I convert to float and which number), an example from that aspect is presented:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = 1/2/3/4/5/4/3\n&gt;&gt;&gt; a\n0\n</code></pre>\n<p>When we divide integers, not surprisingly it gets lower rounded.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = 1/2/3/4/5/4/float(3)\n&gt;&gt;&gt; a\n0.0\n</code></pre>\n<p>If we typecast the last integer to float, we will still get zero, since by the time our number gets divided by the float has already become 0 because of the integer division.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = 1/2/3/float(4)/5/4/3\n&gt;&gt;&gt; a\n0.0\n</code></pre>\n<p>Same scenario as above but shifting the float typecast a little closer to the left side.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = float(1)/2/3/4/5/4/3\n&gt;&gt;&gt; a\n0.0006944444444444445\n</code></pre>\n<p>Finally, when we typecast the first integer to float, the result is the desired one, since beginning from the first division, i.e. the leftmost one, we use floats.</p>\n<p>Extra 1: If you are trying to answer that to improve arithmetic evaluation, you should check <a href=\"https://stackoverflow.com/questions/3264345\">this</a> </p>\n<p>Extra 2: Please be careful of the following scenario:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = float(1/2/3/4/5/4/3)\n&gt;&gt;&gt; a\n0.0\n</code></pre>\n", "abstract": "It has to do with the version of python that you use. Basically it adopts the C behavior: if you divide two integers, the results will be rounded down to an integer. Also keep in mind that Python does the operations from left to right, which plays a role when you typecast. Example:\nSince this is a question that always pops in my head when I am doing arithmetic operations (should I convert to float and which number), an example from that aspect is presented: When we divide integers, not surprisingly it gets lower rounded. If we typecast the last integer to float, we will still get zero, since by the time our number gets divided by the float has already become 0 because of the integer division. Same scenario as above but shifting the float typecast a little closer to the left side. Finally, when we typecast the first integer to float, the result is the desired one, since beginning from the first division, i.e. the leftmost one, we use floats. Extra 1: If you are trying to answer that to improve arithmetic evaluation, you should check this  Extra 2: Please be careful of the following scenario:"}, {"id": 25451810, "score": 4, "vote": 0, "content": "<p>Specifying a float by placing a '.' after the number will also cause it to default to float. </p>\n<pre><code class=\"python\">&gt;&gt;&gt; 1 / 2\n0\n\n&gt;&gt;&gt; 1. / 2.\n0.5\n</code></pre>\n", "abstract": "Specifying a float by placing a '.' after the number will also cause it to default to float. "}, {"id": 2958721, "score": 2, "vote": 0, "content": "<p>Make at least one of them float, then it will be float division, not integer:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; (20.0-10) / (100-10)\n0.1111111111111111\n</code></pre>\n<p>Casting the result to float is too late.</p>\n", "abstract": "Make at least one of them float, then it will be float division, not integer: Casting the result to float is too late."}, {"id": 51114456, "score": 1, "vote": 0, "content": "<p>In python <code>cv2</code> not updated the division calculation. so, you must include <code>from __future__ import division</code>  in first line of the program.</p>\n", "abstract": "In python cv2 not updated the division calculation. so, you must include from __future__ import division  in first line of the program."}, {"id": 2958708, "score": 0, "vote": 0, "content": "<p>Either way, it's integer division.  10/90 = 0.  In the second case, you're merely casting 0 to a float.</p>\n<p>Try casting one of the operands of \"/\" to be a float:</p>\n<pre><code class=\"python\">float(20-10) / (100-10)\n</code></pre>\n", "abstract": "Either way, it's integer division.  10/90 = 0.  In the second case, you're merely casting 0 to a float. Try casting one of the operands of \"/\" to be a float:"}, {"id": 2958709, "score": 0, "vote": 0, "content": "<p>You're casting to float after the division has already happened in your second example. Try this:</p>\n<pre><code class=\"python\">float(20-10) / float(100-10)\n</code></pre>\n", "abstract": "You're casting to float after the division has already happened in your second example. Try this:"}, {"id": 42381991, "score": 0, "vote": 0, "content": "<p>I'm somewhat surprised that no one has mentioned that the original poster might have liked <em>rational</em> numbers to result.  Should you be interested in this, the Python-based program <a href=\"http://sagecell.sagemath.org/?z=eJzTMDLQNTTQVNBX0DA0ADMBHa4DIQ==&amp;lang=sage\" rel=\"nofollow noreferrer\">Sage has your back</a>.  (Currently still based on Python 2.x, though 3.x is under way.)</p>\n<pre><code class=\"python\">sage: (20-10) / (100-10)\n1/9\n</code></pre>\n<p>This isn't a solution for everyone, because it does do some preparsing so these numbers aren't <code>int</code>s, but Sage <code>Integer</code> class elements.  Still, worth mentioning as a part of the Python ecosystem.</p>\n", "abstract": "I'm somewhat surprised that no one has mentioned that the original poster might have liked rational numbers to result.  Should you be interested in this, the Python-based program Sage has your back.  (Currently still based on Python 2.x, though 3.x is under way.) This isn't a solution for everyone, because it does do some preparsing so these numbers aren't ints, but Sage Integer class elements.  Still, worth mentioning as a part of the Python ecosystem."}, {"id": 46632230, "score": 0, "vote": 0, "content": "<p>Personally I preferred to insert a <code>1. *</code> at the very beginning. So the expression become something like this:</p>\n<pre><code class=\"python\">1. * (20-10) / (100-10)\n</code></pre>\n<p>As I always do a division for some formula like:</p>\n<pre><code class=\"python\">accuracy = 1. * (len(y_val) - sum(y_val)) / len(y_val)\n</code></pre>\n<p>so it is impossible to simply add a <code>.0</code> like <code>20.0</code>. And in my case, wrapping with a <code>float()</code> may lose a little bit readability.</p>\n", "abstract": "Personally I preferred to insert a 1. * at the very beginning. So the expression become something like this: As I always do a division for some formula like: so it is impossible to simply add a .0 like 20.0. And in my case, wrapping with a float() may lose a little bit readability."}, {"id": 71520178, "score": 0, "vote": 0, "content": "<p>In Python 3, the \u201c//\u201d operator works as a floor division for integer and float arguments. However, the operator / returns a float value if one of the arguments is a float (this is similar to C++)</p>\n<p>eg:</p>\n<pre><code class=\"python\"># A Python program to demonstrate the use of\n# \"//\" for integers\nprint (5//2)\nprint (-5//2)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">2\n-3\n\n\n\n# A Python program to demonstrate use of\n# \"/\" for floating point numbers\nprint (5.0/2)\nprint (-5.0/2)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">2.5\n-2.5\n</code></pre>\n<p>ref: <a href=\"https://www.geeksforgeeks.org/division-operator-in-python/\" rel=\"nofollow noreferrer\">https://www.geeksforgeeks.org/division-operator-in-python/</a></p>\n", "abstract": "In Python 3, the \u201c//\u201d operator works as a floor division for integer and float arguments. However, the operator / returns a float value if one of the arguments is a float (this is similar to C++) eg: Output: Output: ref: https://www.geeksforgeeks.org/division-operator-in-python/"}]}, {"link": "https://stackoverflow.com/questions/893657/how-do-i-calculate-r-squared-using-python-and-numpy", "question": {"id": "893657", "title": "How do I calculate r-squared using Python and Numpy?", "content": "<p>I'm using Python and Numpy to calculate a best fit polynomial of arbitrary degree.  I pass a list of x values, y values, and the degree of the polynomial I want to fit (linear, quadratic, etc.).</p>\n<p>This much works, but I also want to calculate r (coefficient of correlation) and r-squared(coefficient of determination).  I am comparing my results with Excel's best-fit trendline capability, and the r-squared value it calculates.  Using this, I know I am calculating r-squared correctly for linear best-fit (degree equals 1).  However, my function does not work for polynomials with degree greater than 1.</p>\n<p>Excel is able to do this.  How do I calculate r-squared for higher-order polynomials using Numpy?</p>\n<p>Here's my function:</p>\n<pre><code class=\"python\">import numpy\n\n# Polynomial Regression\ndef polyfit(x, y, degree):\n    results = {}\n\n    coeffs = numpy.polyfit(x, y, degree)\n     # Polynomial Coefficients\n    results['polynomial'] = coeffs.tolist()\n\n    correlation = numpy.corrcoef(x, y)[0,1]\n\n     # r\n    results['correlation'] = correlation\n     # r-squared\n    results['determination'] = correlation**2\n\n    return results\n</code></pre>\n", "abstract": "I'm using Python and Numpy to calculate a best fit polynomial of arbitrary degree.  I pass a list of x values, y values, and the degree of the polynomial I want to fit (linear, quadratic, etc.). This much works, but I also want to calculate r (coefficient of correlation) and r-squared(coefficient of determination).  I am comparing my results with Excel's best-fit trendline capability, and the r-squared value it calculates.  Using this, I know I am calculating r-squared correctly for linear best-fit (degree equals 1).  However, my function does not work for polynomials with degree greater than 1. Excel is able to do this.  How do I calculate r-squared for higher-order polynomials using Numpy? Here's my function:"}, "answers": [{"id": 1517401, "score": 178, "vote": 0, "content": "<p>A very late reply, but just in case someone needs a ready function for this:</p>\n<p><a href=\"http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html\" rel=\"noreferrer\">scipy.stats.linregress</a></p>\n<p>i.e.</p>\n<pre><code class=\"python\">slope, intercept, r_value, p_value, std_err = scipy.stats.linregress(x, y)\n</code></pre>\n<p>as in @Adam Marples's answer.</p>\n", "abstract": "A very late reply, but just in case someone needs a ready function for this: scipy.stats.linregress i.e. as in @Adam Marples's answer."}, {"id": 895063, "score": 77, "vote": 0, "content": "<p>From the <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html\" rel=\"noreferrer\">numpy.polyfit</a> documentation, it is fitting linear regression.  Specifically, numpy.polyfit with degree 'd' fits a linear regression with the mean function</p>\n<p>E(y|x) =  p_d * x**d + p_{d-1} * x **(d-1) + ... + p_1 * x + p_0</p>\n<p>So you just need to calculate the R-squared for that fit.  The wikipedia page on <a href=\"http://en.wikipedia.org/wiki/Linear_regression\" rel=\"noreferrer\">linear regression</a> gives full details.  You are interested in R^2 which you can calculate in a couple of ways, the easisest probably being</p>\n<pre><code class=\"python\">SST = Sum(i=1..n) (y_i - y_bar)^2\nSSReg = Sum(i=1..n) (y_ihat - y_bar)^2\nRsquared = SSReg/SST\n</code></pre>\n<p>Where I use 'y_bar' for the mean of the y's, and 'y_ihat' to be the fit value for each point.</p>\n<p>I'm not terribly familiar with numpy (I usually work in R), so there is probably a tidier way to calculate your R-squared, but the following should be correct</p>\n<pre><code class=\"python\">import numpy\n\n# Polynomial Regression\ndef polyfit(x, y, degree):\n    results = {}\n\n    coeffs = numpy.polyfit(x, y, degree)\n\n     # Polynomial Coefficients\n    results['polynomial'] = coeffs.tolist()\n\n    # r-squared\n    p = numpy.poly1d(coeffs)\n    # fit values, and mean\n    yhat = p(x)                         # or [p(z) for z in x]\n    ybar = numpy.sum(y)/len(y)          # or sum(y)/len(y)\n    ssreg = numpy.sum((yhat-ybar)**2)   # or sum([ (yihat - ybar)**2 for yihat in yhat])\n    sstot = numpy.sum((y - ybar)**2)    # or sum([ (yi - ybar)**2 for yi in y])\n    results['determination'] = ssreg / sstot\n\n    return results\n</code></pre>\n", "abstract": "From the numpy.polyfit documentation, it is fitting linear regression.  Specifically, numpy.polyfit with degree 'd' fits a linear regression with the mean function E(y|x) =  p_d * x**d + p_{d-1} * x **(d-1) + ... + p_1 * x + p_0 So you just need to calculate the R-squared for that fit.  The wikipedia page on linear regression gives full details.  You are interested in R^2 which you can calculate in a couple of ways, the easisest probably being Where I use 'y_bar' for the mean of the y's, and 'y_ihat' to be the fit value for each point. I'm not terribly familiar with numpy (I usually work in R), so there is probably a tidier way to calculate your R-squared, but the following should be correct"}, {"id": 30804603, "score": 77, "vote": 0, "content": "<p>From yanl (yet-another-library) <code>sklearn.metrics</code> has an <a href=\"http://scikit-learn.org/stable/modules/generated/sklearn.metrics.r2_score.html\" rel=\"noreferrer\"><code>r2_score</code></a> function;</p>\n<pre><code class=\"python\">from sklearn.metrics import r2_score\n\ncoefficient_of_dermination = r2_score(y, p(x))\n</code></pre>\n", "abstract": "From yanl (yet-another-library) sklearn.metrics has an r2_score function;"}, {"id": 13918150, "score": 31, "vote": 0, "content": "<p>I have been using this successfully, where x and y are array-like.</p>\n<p>Note: for linear regression only</p>\n<pre><code class=\"python\">def rsquared(x, y):\n    \"\"\" Return R^2 where x and y are array-like.\"\"\"\n\n    slope, intercept, r_value, p_value, std_err = scipy.stats.linregress(x, y)\n    return r_value**2\n</code></pre>\n", "abstract": "I have been using this successfully, where x and y are array-like. Note: for linear regression only"}, {"id": 34617603, "score": 28, "vote": 0, "content": "<p>I originally posted the benchmarks below with the purpose of recommending <code>numpy.corrcoef</code>, foolishly not realizing that the original question already uses <code>corrcoef</code> and was in fact asking about higher order polynomial fits.  I've added an actual solution to the polynomial r-squared question using statsmodels, and I've left the original benchmarks, which while off-topic, are potentially useful to someone.</p>\n<hr/>\n<p><code>statsmodels</code> has the capability to calculate the <code>r^2</code> of a polynomial fit directly, here are 2 methods...</p>\n<pre><code class=\"python\">import statsmodels.api as sm\nimport statsmodels.formula.api as smf\n\n# Construct the columns for the different powers of x\ndef get_r2_statsmodels(x, y, k=1):\n    xpoly = np.column_stack([x**i for i in range(k+1)])    \n    return sm.OLS(y, xpoly).fit().rsquared\n\n# Use the formula API and construct a formula describing the polynomial\ndef get_r2_statsmodels_formula(x, y, k=1):\n    formula = 'y ~ 1 + ' + ' + '.join('I(x**{})'.format(i) for i in range(1, k+1))\n    data = {'x': x, 'y': y}\n    return smf.ols(formula, data).fit().rsquared # or rsquared_adj\n</code></pre>\n<p>To further take advantage of <code>statsmodels</code>, one should also look at the fitted model summary, which can be printed or displayed as a rich HTML table in Jupyter/IPython notebook.  The results object provides access to many useful statistical metrics in addition to <code>rsquared</code>.</p>\n<pre><code class=\"python\">model = sm.OLS(y, xpoly)\nresults = model.fit()\nresults.summary()\n</code></pre>\n<hr/>\n<p>Below is my original Answer where I benchmarked various linear regression r^2 methods...</p>\n<p>The <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html\" rel=\"nofollow noreferrer\">corrcoef</a> function used in the Question calculates the correlation coefficient, <code>r</code>, only for a single linear regression, so it doesn't address the question of <code>r^2</code> for higher order polynomial fits.  However, for what it's worth, I've come to find that for linear regression, it is indeed the fastest and most direct method of calculating <code>r</code>.</p>\n<pre><code class=\"python\">def get_r2_numpy_corrcoef(x, y):\n    return np.corrcoef(x, y)[0, 1]**2\n</code></pre>\n<p>These were my timeit results from comparing a bunch of methods for 1000 random (x, y) points:</p>\n<ul>\n<li>Pure Python (direct <code>r</code> calculation)\n<ul>\n<li>1000 loops, best of 3: 1.59 ms per loop</li>\n</ul>\n</li>\n<li>Numpy polyfit (applicable to n-th degree polynomial fits)\n<ul>\n<li>1000 loops, best of 3: 326 \u00b5s per loop</li>\n</ul>\n</li>\n<li>Numpy Manual (direct <code>r</code> calculation)\n<ul>\n<li>10000 loops, best of 3: 62.1 \u00b5s per loop</li>\n</ul>\n</li>\n<li>Numpy corrcoef (direct <code>r</code> calculation)\n<ul>\n<li>10000 loops, best of 3: 56.6 \u00b5s per loop</li>\n</ul>\n</li>\n<li>Scipy (linear regression with <code>r</code> as an output)\n<ul>\n<li>1000 loops, best of 3: 676 \u00b5s per loop</li>\n</ul>\n</li>\n<li>Statsmodels (can do n-th degree polynomial and many other fits)\n<ul>\n<li>1000 loops, best of 3: 422 \u00b5s per loop</li>\n</ul>\n</li>\n</ul>\n<p>The corrcoef method narrowly beats calculating the r^2 \"manually\" using numpy methods. It is &gt;5X faster than the polyfit method and ~12X faster than the scipy.linregress.  Just to reinforce what numpy is doing for you, it's 28X faster than pure python.  I'm not well-versed in things like numba and pypy, so someone else would have to fill those gaps, but I think this is plenty convincing to me that <code>corrcoef</code> is the best tool for calculating <code>r</code> for a simple linear regression.</p>\n<p>Here's my benchmarking code.  I copy-pasted from a Jupyter Notebook (hard not to call it an IPython Notebook...), so I apologize if anything broke on the way. The %timeit magic command requires IPython.</p>\n<pre><code class=\"python\">import numpy as np\nfrom scipy import stats\nimport statsmodels.api as sm\nimport math\n\nn=1000\nx = np.random.rand(1000)*10\nx.sort()\ny = 10 * x + (5+np.random.randn(1000)*10-5)\n\nx_list = list(x)\ny_list = list(y)\n\ndef get_r2_numpy(x, y):\n    slope, intercept = np.polyfit(x, y, 1)\n    r_squared = 1 - (sum((y - (slope * x + intercept))**2) / ((len(y) - 1) * np.var(y, ddof=1)))\n    return r_squared\n    \ndef get_r2_scipy(x, y):\n    _, _, r_value, _, _ = stats.linregress(x, y)\n    return r_value**2\n    \ndef get_r2_statsmodels(x, y):\n    return sm.OLS(y, sm.add_constant(x)).fit().rsquared\n    \ndef get_r2_python(x_list, y_list):\n    n = len(x_list)\n    x_bar = sum(x_list)/n\n    y_bar = sum(y_list)/n\n    x_std = math.sqrt(sum([(xi-x_bar)**2 for xi in x_list])/(n-1))\n    y_std = math.sqrt(sum([(yi-y_bar)**2 for yi in y_list])/(n-1))\n    zx = [(xi-x_bar)/x_std for xi in x_list]\n    zy = [(yi-y_bar)/y_std for yi in y_list]\n    r = sum(zxi*zyi for zxi, zyi in zip(zx, zy))/(n-1)\n    return r**2\n    \ndef get_r2_numpy_manual(x, y):\n    zx = (x-np.mean(x))/np.std(x, ddof=1)\n    zy = (y-np.mean(y))/np.std(y, ddof=1)\n    r = np.sum(zx*zy)/(len(x)-1)\n    return r**2\n    \ndef get_r2_numpy_corrcoef(x, y):\n    return np.corrcoef(x, y)[0, 1]**2\n    \nprint('Python')\n%timeit get_r2_python(x_list, y_list)\nprint('Numpy polyfit')\n%timeit get_r2_numpy(x, y)\nprint('Numpy Manual')\n%timeit get_r2_numpy_manual(x, y)\nprint('Numpy corrcoef')\n%timeit get_r2_numpy_corrcoef(x, y)\nprint('Scipy')\n%timeit get_r2_scipy(x, y)\nprint('Statsmodels')\n%timeit get_r2_statsmodels(x, y)\n</code></pre>\n<p>7/28/21 Benchmark results. (Python 3.7, numpy 1.19, scipy 1.6, statsmodels 0.12)</p>\n<pre><code class=\"python\">Python\n2.41 ms \u00b1 180 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\nNumpy polyfit\n318 \u00b5s \u00b1 44.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\nNumpy Manual\n79.3 \u00b5s \u00b1 4.05 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\nNumpy corrcoef\n83.8 \u00b5s \u00b1 1.37 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\nScipy\n221 \u00b5s \u00b1 7.12 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\nStatsmodels\n375 \u00b5s \u00b1 3.63 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n</code></pre>\n", "abstract": "I originally posted the benchmarks below with the purpose of recommending numpy.corrcoef, foolishly not realizing that the original question already uses corrcoef and was in fact asking about higher order polynomial fits.  I've added an actual solution to the polynomial r-squared question using statsmodels, and I've left the original benchmarks, which while off-topic, are potentially useful to someone. statsmodels has the capability to calculate the r^2 of a polynomial fit directly, here are 2 methods... To further take advantage of statsmodels, one should also look at the fitted model summary, which can be printed or displayed as a rich HTML table in Jupyter/IPython notebook.  The results object provides access to many useful statistical metrics in addition to rsquared. Below is my original Answer where I benchmarked various linear regression r^2 methods... The corrcoef function used in the Question calculates the correlation coefficient, r, only for a single linear regression, so it doesn't address the question of r^2 for higher order polynomial fits.  However, for what it's worth, I've come to find that for linear regression, it is indeed the fastest and most direct method of calculating r. These were my timeit results from comparing a bunch of methods for 1000 random (x, y) points: The corrcoef method narrowly beats calculating the r^2 \"manually\" using numpy methods. It is >5X faster than the polyfit method and ~12X faster than the scipy.linregress.  Just to reinforce what numpy is doing for you, it's 28X faster than pure python.  I'm not well-versed in things like numba and pypy, so someone else would have to fill those gaps, but I think this is plenty convincing to me that corrcoef is the best tool for calculating r for a simple linear regression. Here's my benchmarking code.  I copy-pasted from a Jupyter Notebook (hard not to call it an IPython Notebook...), so I apologize if anything broke on the way. The %timeit magic command requires IPython. 7/28/21 Benchmark results. (Python 3.7, numpy 1.19, scipy 1.6, statsmodels 0.12)"}, {"id": 45538060, "score": 8, "vote": 0, "content": "<p>Here is a function to compute  the <em>weighted</em> r-squared with  Python and Numpy (most of the code comes from sklearn):</p>\n<pre><code class=\"python\">from __future__ import division \nimport numpy as np\n\ndef compute_r2_weighted(y_true, y_pred, weight):\n    sse = (weight * (y_true - y_pred) ** 2).sum(axis=0, dtype=np.float64)\n    tse = (weight * (y_true - np.average(\n        y_true, axis=0, weights=weight)) ** 2).sum(axis=0, dtype=np.float64)\n    r2_score = 1 - (sse / tse)\n    return r2_score, sse, tse\n</code></pre>\n<p>Example:</p>\n<pre><code class=\"python\">from __future__ import print_function, division \nimport sklearn.metrics \n\ndef compute_r2_weighted(y_true, y_pred, weight):\n    sse = (weight * (y_true - y_pred) ** 2).sum(axis=0, dtype=np.float64)\n    tse = (weight * (y_true - np.average(\n        y_true, axis=0, weights=weight)) ** 2).sum(axis=0, dtype=np.float64)\n    r2_score = 1 - (sse / tse)\n    return r2_score, sse, tse    \n\ndef compute_r2(y_true, y_predicted):\n    sse = sum((y_true - y_predicted)**2)\n    tse = (len(y_true) - 1) * np.var(y_true, ddof=1)\n    r2_score = 1 - (sse / tse)\n    return r2_score, sse, tse\n\ndef main():\n    '''\n    Demonstrate the use of compute_r2_weighted() and checks the results against sklearn\n    '''        \n    y_true = [3, -0.5, 2, 7]\n    y_pred = [2.5, 0.0, 2, 8]\n    weight = [1, 5, 1, 2]\n    r2_score = sklearn.metrics.r2_score(y_true, y_pred)\n    print('r2_score: {0}'.format(r2_score))  \n    r2_score,_,_ = compute_r2(np.array(y_true), np.array(y_pred))\n    print('r2_score: {0}'.format(r2_score))\n    r2_score = sklearn.metrics.r2_score(y_true, y_pred,weight)\n    print('r2_score weighted: {0}'.format(r2_score))\n    r2_score,_,_ = compute_r2_weighted(np.array(y_true), np.array(y_pred), np.array(weight))\n    print('r2_score weighted: {0}'.format(r2_score))\n\nif __name__ == \"__main__\":\n    main()\n    #cProfile.run('main()') # if you want to do some profiling\n</code></pre>\n<p>outputs:</p>\n<pre><code class=\"python\">r2_score: 0.9486081370449679\nr2_score: 0.9486081370449679\nr2_score weighted: 0.9573170731707317\nr2_score weighted: 0.9573170731707317\n</code></pre>\n<p>This corresponds to the <a href=\"http://web.maths.unsw.edu.au/~adelle/Garvan/Assays/GoodnessOfFit.html\" rel=\"noreferrer\">formula</a> (<a href=\"https://web.archive.org/web/20170817185657/http://web.maths.unsw.edu.au/~adelle/Garvan/Assays/GoodnessOfFit.html\" rel=\"noreferrer\">mirror</a>):</p>\n<p><a href=\"https://i.stack.imgur.com/8WDhJ.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/8WDhJ.png\"/></a></p>\n<p>with f_i is the predicted value from the fit, y_{av} is the mean of the observed data y_i is the observed data value. w_i is the weighting applied to each data point, usually w_i=1. SSE is the sum of squares due to error and SST is the total sum of squares.</p>\n<hr/>\n<p>If interested, the code in R: <a href=\"https://gist.github.com/dhimmel/588d64a73fa4fef02c8f\" rel=\"noreferrer\">https://gist.github.com/dhimmel/588d64a73fa4fef02c8f</a>  (<a href=\"https://web.archive.org/web/20170807154523/https://gist.github.com/dhimmel/588d64a73fa4fef02c8f\" rel=\"noreferrer\">mirror</a>)</p>\n", "abstract": "Here is a function to compute  the weighted r-squared with  Python and Numpy (most of the code comes from sklearn): Example: outputs: This corresponds to the formula (mirror):  with f_i is the predicted value from the fit, y_{av} is the mean of the observed data y_i is the observed data value. w_i is the weighting applied to each data point, usually w_i=1. SSE is the sum of squares due to error and SST is the total sum of squares. If interested, the code in R: https://gist.github.com/dhimmel/588d64a73fa4fef02c8f  (mirror)"}, {"id": 61548813, "score": 7, "vote": 0, "content": "<p>Here's a very simple python function to compute R^2 from the actual and predicted values assuming y and y_hat are pandas series:</p>\n<pre><code class=\"python\">def r_squared(y, y_hat):\n    y_bar = y.mean()\n    ss_tot = ((y-y_bar)**2).sum()\n    ss_res = ((y-y_hat)**2).sum()\n    return 1 - (ss_res/ss_tot)\n</code></pre>\n", "abstract": "Here's a very simple python function to compute R^2 from the actual and predicted values assuming y and y_hat are pandas series:"}, {"id": 893923, "score": 6, "vote": 0, "content": "<p>R-squared is a statistic that only applies to linear regression.</p>\n<p>Essentially, it measures how much variation in your data can be explained by the linear regression.</p>\n<p>So, you calculate the \"Total Sum of Squares\", which is the total squared deviation of each of your outcome variables from their mean. . .</p>\n<p><img alt=\"formula1\" src=\"https://chart.googleapis.com/chart?cht=tx&amp;chl=%5Csum_%7Bi%7D(y_%7Bi%7D%20-%20y_%7Bbar%7D)%5E2\"/></p>\n<p>where y_bar is the mean of the y's.</p>\n<p>Then, you calculate the \"regression sum of squares\", which is how much your FITTED values differ from the mean</p>\n<p><img alt=\"formula2\" src=\"https://chart.googleapis.com/chart?cht=tx&amp;chl=%5Csum_%7Bi%7D(yhat_%7Bi%7D%20-%20y_%7Bbar%7D)%5E2\"/></p>\n<p>and find the ratio of those two.</p>\n<p>Now, all you would have to do for a polynomial fit is plug in the y_hat's from that model, but it's not accurate to call that r-squared.</p>\n<p><a href=\"http://ask.metafilter.com/65278/Statistics-tell-me-about-rsquare-for-nonlinear-models\" rel=\"nofollow noreferrer\">Here</a> is a link I found that speaks to it a little.</p>\n", "abstract": "R-squared is a statistic that only applies to linear regression. Essentially, it measures how much variation in your data can be explained by the linear regression. So, you calculate the \"Total Sum of Squares\", which is the total squared deviation of each of your outcome variables from their mean. . .  where y_bar is the mean of the y's. Then, you calculate the \"regression sum of squares\", which is how much your FITTED values differ from the mean  and find the ratio of those two. Now, all you would have to do for a polynomial fit is plug in the y_hat's from that model, but it's not accurate to call that r-squared. Here is a link I found that speaks to it a little."}, {"id": 1326331, "score": 5, "vote": 0, "content": "<p>The wikipedia article on <a href=\"http://en.wikipedia.org/wiki/Coefficient_of_determination\" rel=\"noreferrer\">r-squareds</a> suggests that it may be used for general model fitting rather than just linear regression.</p>\n", "abstract": "The wikipedia article on r-squareds suggests that it may be used for general model fitting rather than just linear regression."}, {"id": 62678163, "score": 1, "vote": 0, "content": "<p><strong>You can execute this code directly, this will find you the polynomial, and will find you the R-value</strong> you can put a comment down below if you need more explanation.</p>\n<pre><code class=\"python\">from scipy.stats import linregress\nimport numpy as np\n\nx = np.array([1,2,3,4,5,6])\ny = np.array([2,3,5,6,7,8])\n\np3 = np.polyfit(x,y,3) # 3rd degree polynomial, you can change it to any degree you want\nxp = np.linspace(1,6,6)  # 6 means the length of the line\npoly_arr = np.polyval(p3,xp)\n\npoly_list = [round(num, 3) for num in list(poly_arr)]\nslope, intercept, r_value, p_value, std_err = linregress(x, poly_list)\nprint(r_value**2)\n</code></pre>\n", "abstract": "You can execute this code directly, this will find you the polynomial, and will find you the R-value you can put a comment down below if you need more explanation."}, {"id": 68877530, "score": 1, "vote": 0, "content": "<p>Using the numpy module (tested in python3):</p>\n<pre><code class=\"python\">import numpy as np\ndef linear_regression(x, y): \n    coefs = np.polynomial.polynomial.polyfit(x, y, 1)\n    ffit = np.poly1d(coefs)\n    m = ffit[0]\n    b = ffit[1] \n    eq = 'y = {}x + {}'.format(round(m, 3), round(b, 3))\n    rsquared = np.corrcoef(x, y)[0, 1]**2\n    return rsquared, eq, m, b\n\nrsquared, eq, m, b = linear_regression(x,y)\nprint(rsquared, m, b)\nprint(eq)\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<pre><code class=\"python\">0.013378252355751777 0.1316331351105754 0.7928782850418713 \ny = 0.132x + 0.793\n</code></pre>\n</blockquote>\n<p>Note: r\u00b2 \u2260 R\u00b2 <br/>\nr\u00b2 is called the \"Coefficient of Determination\"<br/>\nR\u00b2 is the square of the Pearson Coefficient</p>\n<p>R\u00b2, officially conflated as r\u00b2, is probably the one you want, as it's a least-square fit, which is better than the simple fraction of sums that r\u00b2 is. Numpy is not afraid to call it \"corrcoef\", which presupposes Pearson is the de-facto correlation coefficient.</p>\n", "abstract": "Using the numpy module (tested in python3): Output: Note: r\u00b2 \u2260 R\u00b2 \nr\u00b2 is called the \"Coefficient of Determination\"\nR\u00b2 is the square of the Pearson Coefficient R\u00b2, officially conflated as r\u00b2, is probably the one you want, as it's a least-square fit, which is better than the simple fraction of sums that r\u00b2 is. Numpy is not afraid to call it \"corrcoef\", which presupposes Pearson is the de-facto correlation coefficient."}, {"id": 58886462, "score": 0, "vote": 0, "content": "<p>From scipy.stats.linregress source. They use the average sum of squares method.</p>\n<pre><code class=\"python\">import numpy as np\n\nx = np.array(x)\ny = np.array(y)\n\n# average sum of squares:\nssxm, ssxym, ssyxm, ssym = np.cov(x, y, bias=1).flat\n\nr_num = ssxym\nr_den = np.sqrt(ssxm * ssym)\nr = r_num / r_den\n\nif r_den == 0.0:\n    r = 0.0\nelse:\n    r = r_num / r_den\n\n    if r &gt; 1.0:\n        r = 1.0\n    elif r &lt; -1.0:\n        r = -1.0\n</code></pre>\n", "abstract": "From scipy.stats.linregress source. They use the average sum of squares method."}]}, {"link": "https://stackoverflow.com/questions/643699/how-can-i-use-numpy-correlate-to-do-autocorrelation", "question": {"id": "643699", "title": "How can I use numpy.correlate to do autocorrelation?", "content": "<p>I need to do auto-correlation of a set of numbers, which as I understand it is just the correlation of the set with itself. </p>\n<p>I've tried it using numpy's correlate function, but I don't believe the result, as it almost always gives a vector where the first number is <em>not</em> the largest, as it ought to be.</p>\n<p>So, this question is really two questions:</p>\n<ol>\n<li>What exactly is <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.correlate.html\" rel=\"noreferrer\"><code>numpy.correlate</code></a> doing?</li>\n<li>How can I use it (or something else) to do auto-correlation?</li>\n</ol>\n", "abstract": "I need to do auto-correlation of a set of numbers, which as I understand it is just the correlation of the set with itself.  I've tried it using numpy's correlate function, but I don't believe the result, as it almost always gives a vector where the first number is not the largest, as it ought to be. So, this question is really two questions:"}, "answers": [{"id": 676302, "score": 142, "vote": 0, "content": "<p>To answer your first question, <code>numpy.correlate(a, v, mode)</code> is performing the convolution of <code>a</code> with the reverse of <code>v</code> and giving the results clipped by the specified mode. The <a href=\"http://mathworld.wolfram.com/Convolution.html\" rel=\"noreferrer\">definition of convolution</a>, C(t)=\u2211 <sub>-\u221e &lt; i &lt; \u221e </sub> a<sub>i</sub>v<sub>t+i</sub> where -\u221e &lt; t &lt; \u221e, allows for results from -\u221e to \u221e, but you obviously can't store an infinitely long array. So it has to be clipped, and that is where the mode comes in. There are 3 different modes: full, same, &amp; valid: </p>\n<ul>\n<li>\"full\" mode returns results for every <code>t</code> where both <code>a</code> and <code>v</code> have some overlap. </li>\n<li>\"same\" mode returns a result with the same length as the shortest vector (<code>a</code> or <code>v</code>). </li>\n<li>\"valid\" mode returns results only when <code>a</code> and <code>v</code> completely overlap each other. The <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.convolve.html\" rel=\"noreferrer\">documentation</a> for <code>numpy.convolve</code> gives more detail on the modes.</li>\n</ul>\n<p>For your second question, I think <code>numpy.correlate</code> <em>is</em> giving you the autocorrelation, it is just giving you a little more as well. The autocorrelation is used to find how similar a signal, or function, is to itself at a certain time difference. At a time difference of 0, the auto-correlation should be the highest because the signal is identical to itself, so you expected that the first element in the autocorrelation result array would be the greatest. However, the correlation is not starting at a time difference of 0. It starts at a negative time difference, closes to 0, and then goes positive. That is, you were expecting:  </p>\n<p>autocorrelation(a) = \u2211 <sub>-\u221e &lt; i &lt; \u221e </sub> a<sub>i</sub>v<sub>t+i</sub> where 0 &lt;= t &lt; \u221e  </p>\n<p>But what you got was:  </p>\n<p>autocorrelation(a) = \u2211 <sub>-\u221e &lt; i &lt; \u221e </sub> a<sub>i</sub>v<sub>t+i</sub> where -\u221e &lt; t &lt; \u221e</p>\n<p>What you need to do is take the last half of your correlation result, and that should be the autocorrelation you are looking for. A simple python function to do that would be:</p>\n<pre><code class=\"python\">def autocorr(x):\n    result = numpy.correlate(x, x, mode='full')\n    return result[result.size/2:]\n</code></pre>\n<p>You will, of course, need error checking to make sure that <code>x</code> is actually a 1-d array. Also, this explanation probably isn't the most mathematically rigorous. I've been throwing around infinities because the definition of convolution uses them, but that doesn't necessarily apply for autocorrelation. So, the theoretical portion of this explanation may be slightly wonky, but hopefully the practical results are helpful. <a href=\"http://mathworld.wolfram.com/Autocorrelation.html\" rel=\"noreferrer\">These</a> <a href=\"http://en.wikipedia.org/wiki/Autocorrelation\" rel=\"noreferrer\">pages</a> on autocorrelation are pretty helpful, and can give you a much better theoretical background if you don't mind wading through the notation and heavy concepts.</p>\n", "abstract": "To answer your first question, numpy.correlate(a, v, mode) is performing the convolution of a with the reverse of v and giving the results clipped by the specified mode. The definition of convolution, C(t)=\u2211 -\u221e < i < \u221e  aivt+i where -\u221e < t < \u221e, allows for results from -\u221e to \u221e, but you obviously can't store an infinitely long array. So it has to be clipped, and that is where the mode comes in. There are 3 different modes: full, same, & valid:  For your second question, I think numpy.correlate is giving you the autocorrelation, it is just giving you a little more as well. The autocorrelation is used to find how similar a signal, or function, is to itself at a certain time difference. At a time difference of 0, the auto-correlation should be the highest because the signal is identical to itself, so you expected that the first element in the autocorrelation result array would be the greatest. However, the correlation is not starting at a time difference of 0. It starts at a negative time difference, closes to 0, and then goes positive. That is, you were expecting:   autocorrelation(a) = \u2211 -\u221e < i < \u221e  aivt+i where 0 <= t < \u221e   But what you got was:   autocorrelation(a) = \u2211 -\u221e < i < \u221e  aivt+i where -\u221e < t < \u221e What you need to do is take the last half of your correlation result, and that should be the autocorrelation you are looking for. A simple python function to do that would be: You will, of course, need error checking to make sure that x is actually a 1-d array. Also, this explanation probably isn't the most mathematically rigorous. I've been throwing around infinities because the definition of convolution uses them, but that doesn't necessarily apply for autocorrelation. So, the theoretical portion of this explanation may be slightly wonky, but hopefully the practical results are helpful. These pages on autocorrelation are pretty helpful, and can give you a much better theoretical background if you don't mind wading through the notation and heavy concepts."}, {"id": 7981132, "score": 35, "vote": 0, "content": "<p>Auto-correlation comes in two versions: statistical and convolution. They both do the same, except for a little detail: The statistical version is normalized to be on the interval [-1,1]. Here is an example of how you do the statistical one:</p>\n<pre><code class=\"python\">def acf(x, length=20):\n    return numpy.array([1]+[numpy.corrcoef(x[:-i], x[i:])[0,1]  \\\n        for i in range(1, length)])\n</code></pre>\n", "abstract": "Auto-correlation comes in two versions: statistical and convolution. They both do the same, except for a little detail: The statistical version is normalized to be on the interval [-1,1]. Here is an example of how you do the statistical one:"}, {"id": 51168178, "score": 29, "vote": 0, "content": "<p>I think there are 2 things that add confusion to this topic:</p>\n<ol>\n<li>statistical v.s. signal processing definition: as others have pointed out, in statistics we normalize auto-correlation into [-1,1]. </li>\n<li>partial v.s. non-partial mean/variance: when the timeseries shifts at a lag&gt;0, their overlap size will always &lt; original length. Do we use the mean and std of the original (non-partial), or always compute a new mean and std using the ever changing overlap (partial) makes a difference. (There's probably a formal term for this, but I'm gonna use \"partial\" for now).</li>\n</ol>\n<p>I've created 5 functions that compute auto-correlation of a 1d array, with partial v.s. non-partial distinctions. Some use formula from statistics, some use correlate in the signal processing sense, which can also be done via FFT. But all results are auto-correlations in the <strong>statistics</strong> definition, so they illustrate how they are linked to each other. Code below:</p>\n<pre><code class=\"python\">import numpy\nimport matplotlib.pyplot as plt\n\ndef autocorr1(x,lags):\n    '''numpy.corrcoef, partial'''\n\n    corr=[1. if l==0 else numpy.corrcoef(x[l:],x[:-l])[0][1] for l in lags]\n    return numpy.array(corr)\n\ndef autocorr2(x,lags):\n    '''manualy compute, non partial'''\n\n    mean=numpy.mean(x)\n    var=numpy.var(x)\n    xp=x-mean\n    corr=[1. if l==0 else numpy.sum(xp[l:]*xp[:-l])/len(x)/var for l in lags]\n\n    return numpy.array(corr)\n\ndef autocorr3(x,lags):\n    '''fft, pad 0s, non partial'''\n\n    n=len(x)\n    # pad 0s to 2n-1\n    ext_size=2*n-1\n    # nearest power of 2\n    fsize=2**numpy.ceil(numpy.log2(ext_size)).astype('int')\n\n    xp=x-numpy.mean(x)\n    var=numpy.var(x)\n\n    # do fft and ifft\n    cf=numpy.fft.fft(xp,fsize)\n    sf=cf.conjugate()*cf\n    corr=numpy.fft.ifft(sf).real\n    corr=corr/var/n\n\n    return corr[:len(lags)]\n\ndef autocorr4(x,lags):\n    '''fft, don't pad 0s, non partial'''\n    mean=x.mean()\n    var=numpy.var(x)\n    xp=x-mean\n\n    cf=numpy.fft.fft(xp)\n    sf=cf.conjugate()*cf\n    corr=numpy.fft.ifft(sf).real/var/len(x)\n\n    return corr[:len(lags)]\n\ndef autocorr5(x,lags):\n    '''numpy.correlate, non partial'''\n    mean=x.mean()\n    var=numpy.var(x)\n    xp=x-mean\n    corr=numpy.correlate(xp,xp,'full')[len(x)-1:]/var/len(x)\n\n    return corr[:len(lags)]\n\n\nif __name__=='__main__':\n\n    y=[28,28,26,19,16,24,26,24,24,29,29,27,31,26,38,23,13,14,28,19,19,\\\n            17,22,2,4,5,7,8,14,14,23]\n    y=numpy.array(y).astype('float')\n\n    lags=range(15)\n    fig,ax=plt.subplots()\n\n    for funcii, labelii in zip([autocorr1, autocorr2, autocorr3, autocorr4,\n        autocorr5], ['np.corrcoef, partial', 'manual, non-partial',\n            'fft, pad 0s, non-partial', 'fft, no padding, non-partial',\n            'np.correlate, non-partial']):\n\n        cii=funcii(y,lags)\n        print(labelii)\n        print(cii)\n        ax.plot(lags,cii,label=labelii)\n\n    ax.set_xlabel('lag')\n    ax.set_ylabel('correlation coefficient')\n    ax.legend()\n    plt.show()\n</code></pre>\n<p>Here is the output figure:</p>\n<p><a href=\"https://i.stack.imgur.com/cXdbN.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/cXdbN.png\"/></a></p>\n<p>We don't see all 5 lines because 3 of them overlap (at the purple). The overlaps are all non-partial auto-correlations. This is because computations from the signal processing methods (<code>np.correlate</code>, FFT) don't compute a different mean/std for each overlap.</p>\n<p>Also note that the <code>fft, no padding, non-partial</code> (red line) result is different, because it didn't pad the timeseries with 0s before doing FFT, so it's circular FFT. I can't explain in detail why, that's what I learned from elsewhere.</p>\n", "abstract": "I think there are 2 things that add confusion to this topic: I've created 5 functions that compute auto-correlation of a 1d array, with partial v.s. non-partial distinctions. Some use formula from statistics, some use correlate in the signal processing sense, which can also be done via FFT. But all results are auto-correlations in the statistics definition, so they illustrate how they are linked to each other. Code below: Here is the output figure:  We don't see all 5 lines because 3 of them overlap (at the purple). The overlaps are all non-partial auto-correlations. This is because computations from the signal processing methods (np.correlate, FFT) don't compute a different mean/std for each overlap. Also note that the fft, no padding, non-partial (red line) result is different, because it didn't pad the timeseries with 0s before doing FFT, so it's circular FFT. I can't explain in detail why, that's what I learned from elsewhere."}, {"id": 21863139, "score": 26, "vote": 0, "content": "<p>Use the <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html\" rel=\"noreferrer\"><code>numpy.corrcoef</code></a> function instead of <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.correlate.html\" rel=\"noreferrer\"><code>numpy.correlate</code></a> to calculate the statistical correlation for a lag of t:</p>\n<pre><code class=\"python\">def autocorr(x, t=1):\n    return numpy.corrcoef(numpy.array([x[:-t], x[t:]]))\n</code></pre>\n", "abstract": "Use the numpy.corrcoef function instead of numpy.correlate to calculate the statistical correlation for a lag of t:"}, {"id": 17090200, "score": 12, "vote": 0, "content": "<p>As I just ran into the same problem, I would like to share a few lines of code with you. In fact there are several rather similar posts about autocorrelation in stackoverflow by now. If you define the autocorrelation as <code>a(x, L) = sum(k=0,N-L-1)((xk-xbar)*(x(k+L)-xbar))/sum(k=0,N-1)((xk-xbar)**2)</code> [this is the definition given in IDL's a_correlate function and it agrees with what I see in answer 2 of question <a href=\"https://stackoverflow.com/questions/12269834/is-there-any-numpy-autocorrellation-function-with-standardized-output\">#12269834</a>], then the following seems to give the correct results:</p>\n<pre><code class=\"python\">import numpy as np\nimport matplotlib.pyplot as plt\n\n# generate some data\nx = np.arange(0.,6.12,0.01)\ny = np.sin(x)\n# y = np.random.uniform(size=300)\nyunbiased = y-np.mean(y)\nynorm = np.sum(yunbiased**2)\nacor = np.correlate(yunbiased, yunbiased, \"same\")/ynorm\n# use only second half\nacor = acor[len(acor)/2:]\n\nplt.plot(acor)\nplt.show()\n</code></pre>\n<p>As you see I have tested this with a sin curve and a uniform random distribution, and both results look like I would expect them. Note that I used <code>mode=\"same\"</code> instead of <code>mode=\"full\"</code> as the others did. </p>\n", "abstract": "As I just ran into the same problem, I would like to share a few lines of code with you. In fact there are several rather similar posts about autocorrelation in stackoverflow by now. If you define the autocorrelation as a(x, L) = sum(k=0,N-L-1)((xk-xbar)*(x(k+L)-xbar))/sum(k=0,N-1)((xk-xbar)**2) [this is the definition given in IDL's a_correlate function and it agrees with what I see in answer 2 of question #12269834], then the following seems to give the correct results: As you see I have tested this with a sin curve and a uniform random distribution, and both results look like I would expect them. Note that I used mode=\"same\" instead of mode=\"full\" as the others did. "}, {"id": 40154897, "score": 12, "vote": 0, "content": "<p>Your question 1 has been already extensively discussed in several excellent answers here.</p>\n<p>I thought to share with you a few lines of code that allow you to compute the autocorrelation of a signal based only on the mathematical properties of the autocorrelation. That is, the autocorrelation may be computed in the following way:</p>\n<ol>\n<li><p>subtract the mean from the signal and obtain an unbiased signal</p></li>\n<li><p>compute the Fourier transform of the unbiased signal</p></li>\n<li><p>compute the power spectral density of the signal, by taking the square norm of each value of the Fourier transform of the unbiased signal</p></li>\n<li><p>compute the inverse Fourier transform of the power spectral density</p></li>\n<li><p>normalize the inverse Fourier transform of the power spectral density by the sum of the squares of the unbiased signal, and take only half of the resulting vector</p></li>\n</ol>\n<p>The code to do this is the following:</p>\n<pre><code class=\"python\">def autocorrelation (x) :\n    \"\"\"\n    Compute the autocorrelation of the signal, based on the properties of the\n    power spectral density of the signal.\n    \"\"\"\n    xp = x-np.mean(x)\n    f = np.fft.fft(xp)\n    p = np.array([np.real(v)**2+np.imag(v)**2 for v in f])\n    pi = np.fft.ifft(p)\n    return np.real(pi)[:x.size/2]/np.sum(xp**2)\n</code></pre>\n", "abstract": "Your question 1 has been already extensively discussed in several excellent answers here. I thought to share with you a few lines of code that allow you to compute the autocorrelation of a signal based only on the mathematical properties of the autocorrelation. That is, the autocorrelation may be computed in the following way: subtract the mean from the signal and obtain an unbiased signal compute the Fourier transform of the unbiased signal compute the power spectral density of the signal, by taking the square norm of each value of the Fourier transform of the unbiased signal compute the inverse Fourier transform of the power spectral density normalize the inverse Fourier transform of the power spectral density by the sum of the squares of the unbiased signal, and take only half of the resulting vector The code to do this is the following:"}, {"id": 55836584, "score": 9, "vote": 0, "content": "<p>An alternative to numpy.correlate is available in <a href=\"https://www.statsmodels.org/stable/generated/statsmodels.tsa.stattools.acf.html\" rel=\"noreferrer\">statsmodels.tsa.stattools.acf()</a>. This yields a continuously decreasing autocorrelation function like the one described by OP. Implementing it is fairly simple:</p>\n<pre><code class=\"python\">from statsmodels.tsa import stattools\n# x = 1-D array\n# Yield normalized autocorrelation function of number lags\nautocorr = stattools.acf( x )\n\n# Get autocorrelation coefficient at lag = 1\nautocorr_coeff = autocorr[1]\n</code></pre>\n<p>The default behavior is to stop at 40 nlags, but this can be adjusted with the <code>nlag=</code> option for your specific application. There is a citation at the bottom of the page for the <a href=\"https://www.jstor.org/stable/25049287?seq=1#metadata_info_tab_contents\" rel=\"noreferrer\">statistics behind the function</a>.</p>\n", "abstract": "An alternative to numpy.correlate is available in statsmodels.tsa.stattools.acf(). This yields a continuously decreasing autocorrelation function like the one described by OP. Implementing it is fairly simple: The default behavior is to stop at 40 nlags, but this can be adjusted with the nlag= option for your specific application. There is a citation at the bottom of the page for the statistics behind the function."}, {"id": 49800402, "score": 3, "vote": 0, "content": "<p>I'm a computational biologist, and when I had to compute the auto/cross-correlations between couples of time series of stochastic processes I realized that <code>np.correlate</code> was not doing the job I needed.</p>\n<p>Indeed, what seems to be missing from <code>np.correlate</code> is the <strong><em>averaging over all the possible couples of time points</em></strong> at distance \ud835\udf0f.</p>\n<p>Here is how I defined a function doing what I needed:</p>\n<pre><code class=\"python\">def autocross(x, y):\n    c = np.correlate(x, y, \"same\")\n    v = [c[i]/( len(x)-abs( i - (len(x)/2)  ) ) for i in range(len(c))]\n    return v\n</code></pre>\n<p>It seems to me none of the previous answers cover this instance of auto/cross-correlation: hope this answer may be useful to somebody working on stochastic processes like me.</p>\n", "abstract": "I'm a computational biologist, and when I had to compute the auto/cross-correlations between couples of time series of stochastic processes I realized that np.correlate was not doing the job I needed. Indeed, what seems to be missing from np.correlate is the averaging over all the possible couples of time points at distance \ud835\udf0f. Here is how I defined a function doing what I needed: It seems to me none of the previous answers cover this instance of auto/cross-correlation: hope this answer may be useful to somebody working on stochastic processes like me."}, {"id": 51479886, "score": 2, "vote": 0, "content": "<p>A simple solution without pandas:</p>\n<pre><code class=\"python\">import numpy as np\n\ndef auto_corrcoef(x):\n   return np.corrcoef(x[1:-1], x[2:])[0,1]\n</code></pre>\n", "abstract": "A simple solution without pandas:"}, {"id": 34408787, "score": 1, "vote": 0, "content": "<p>I use talib.CORREL for autocorrelation like this, I suspect you could do the same with other packages:</p>\n<pre><code class=\"python\">def autocorrelate(x, period):\n\n    # x is a deep indicator array \n    # period of sample and slices of comparison\n\n    # oldest data (period of input array) may be nan; remove it\n    x = x[-np.count_nonzero(~np.isnan(x)):]\n    # subtract mean to normalize indicator\n    x -= np.mean(x)\n    # isolate the recent sample to be autocorrelated\n    sample = x[-period:]\n    # create slices of indicator data\n    correls = []\n    for n in range((len(x)-1), period, -1):\n        alpha = period + n\n        slices = (x[-alpha:])[:period]\n        # compare each slice to the recent sample\n        correls.append(ta.CORREL(slices, sample, period)[-1])\n    # fill in zeros for sample overlap period of recent correlations    \n    for n in range(period,0,-1):\n        correls.append(0)\n    # oldest data (autocorrelation period) will be nan; remove it\n    correls = np.array(correls[-np.count_nonzero(~np.isnan(correls)):])      \n\n    return correls\n\n# CORRELATION OF BEST FIT\n# the highest value correlation    \nmax_value = np.max(correls)\n# index of the best correlation\nmax_index = np.argmax(correls)\n</code></pre>\n", "abstract": "I use talib.CORREL for autocorrelation like this, I suspect you could do the same with other packages:"}, {"id": 52361803, "score": 1, "vote": 0, "content": "<p>Using Fourier transformation and the convolution theorem </p>\n<p>The time complexicity is   <strong>N*log(N)</strong> </p>\n<pre><code class=\"python\">def autocorr1(x):\n    r2=np.fft.ifft(np.abs(np.fft.fft(x))**2).real\n    return r2[:len(x)//2]\n</code></pre>\n<p>Here is a normalized and unbiased version, it is also   <strong>N*log(N)</strong> </p>\n<pre><code class=\"python\">def autocorr2(x):\n    r2=np.fft.ifft(np.abs(np.fft.fft(x))**2).real\n    c=(r2/x.shape-np.mean(x)**2)/np.std(x)**2\n    return c[:len(x)//2]\n</code></pre>\n<p>The method provided by A. Levy works, but I tested it in my PC, its time complexicity seems to be <strong>N*N</strong></p>\n<pre><code class=\"python\">def autocorr(x):\n    result = numpy.correlate(x, x, mode='full')\n    return result[result.size/2:]\n</code></pre>\n", "abstract": "Using Fourier transformation and the convolution theorem  The time complexicity is   N*log(N)  Here is a normalized and unbiased version, it is also   N*log(N)  The method provided by A. Levy works, but I tested it in my PC, its time complexicity seems to be N*N"}, {"id": 28268013, "score": 0, "vote": 0, "content": "<p>I think the real answer to the OP's question is succinctly contained in this excerpt from the Numpy.correlate documentation:</p>\n<pre><code class=\"python\">mode : {'valid', 'same', 'full'}, optional\n    Refer to the `convolve` docstring.  Note that the default\n    is `valid`, unlike `convolve`, which uses `full`.\n</code></pre>\n<p>This implies that, when used with no 'mode' definition, the Numpy.correlate function will return a scalar, when given the same vector for its two input arguments (i.e. - when used to perform autocorrelation).</p>\n", "abstract": "I think the real answer to the OP's question is succinctly contained in this excerpt from the Numpy.correlate documentation: This implies that, when used with no 'mode' definition, the Numpy.correlate function will return a scalar, when given the same vector for its two input arguments (i.e. - when used to perform autocorrelation)."}, {"id": 52702583, "score": 0, "vote": 0, "content": "<p>Plot the statistical autocorrelation given a pandas datatime Series of returns:</p>\n<pre><code class=\"python\">import matplotlib.pyplot as plt\n\ndef plot_autocorr(returns, lags):\n    autocorrelation = []\n    for lag in range(lags+1):\n        corr_lag = returns.corr(returns.shift(-lag)) \n        autocorrelation.append(corr_lag)\n    plt.plot(range(lags+1), autocorrelation, '--o')\n    plt.xticks(range(lags+1))\n    return np.array(autocorrelation)\n</code></pre>\n", "abstract": "Plot the statistical autocorrelation given a pandas datatime Series of returns:"}, {"id": 73026983, "score": 0, "vote": 0, "content": "<p>To implement IDL's <a href=\"https://www.l3harrisgeospatial.com/docs/a_correlate.html\" rel=\"nofollow noreferrer\">a_correlate</a> function with numpy, you need to run <code>np.correlate</code> with <code>mode=\"full\"</code> and add <code>n-1</code> to the <code>lag</code> array.</p>\n<pre><code class=\"python\">def a_correlate(y, lag):\n    y = np.asarray(y)\n    lag = np.asarray(lag)\n    n = len(y)\n    yunbiased = y - np.mean(y)\n    ynorm = np.sum(yunbiased**2)\n    r = np.correlate(yunbiased, yunbiased, \"full\") / ynorm\n    return r[lag + (n - 1)]\n</code></pre>\n<p>Example (based on the example in the IDL documentation page linked above):</p>\n<pre><code class=\"python\"># Define an n-element sample population:\nX = np.array([3.73, 3.67, 3.77, 3.83, 4.67, 5.87, 6.70, 6.97, 6.40, 5.57])\n# Compute the autocorrelation of X for LAG = -3, 0, 1, 3, 4, 8:\nlag = [-3, 0, 1, 3, 4, 8]\nresult = a_correlate(X, lag)\nprint(result)\n# prints: [ 0.01461851  1.          0.81087925  0.01461851 -0.32527914 -0.15168379]\n</code></pre>\n", "abstract": "To implement IDL's a_correlate function with numpy, you need to run np.correlate with mode=\"full\" and add n-1 to the lag array. Example (based on the example in the IDL documentation page linked above):"}]}, {"link": "https://stackoverflow.com/questions/171765/what-is-the-best-way-to-get-all-the-divisors-of-a-number", "question": {"id": "171765", "title": "What is the best way to get all the divisors of a number?", "content": "<p>Here's the very dumb way:</p>\n<pre><code class=\"python\">def divisorGenerator(n):\n    for i in xrange(1,n/2+1):\n        if n%i == 0: yield i\n    yield n\n</code></pre>\n<p>The result I'd like to get is similar to this one, but I'd like a smarter algorithm (this one it's too much slow and dumb :-)</p>\n<p>I can find prime factors and their multiplicity fast enough. \nI've an generator that generates factor in this way:</p>\n<p>(factor1, multiplicity1)<br/>\n(factor2, multiplicity2)<br/>\n(factor3, multiplicity3)<br/>\nand so on...</p>\n<p>i.e. the output of </p>\n<pre><code class=\"python\">for i in factorGenerator(100):\n    print i\n</code></pre>\n<p>is:</p>\n<pre><code class=\"python\">(2, 2)\n(5, 2)\n</code></pre>\n<p>I don't know how much is this useful for what I want to do (I coded it for other problems), anyway I'd like a smarter way to make</p>\n<pre><code class=\"python\">for i in divisorGen(100):\n    print i\n</code></pre>\n<p>output this:</p>\n<pre><code class=\"python\">1\n2\n4\n5\n10\n20\n25\n50\n100\n</code></pre>\n<hr/>\n<p><strong>UPDATE:</strong> Many thanks to Greg Hewgill and his \"smart way\" :)\nCalculating all divisors of 100000000 took 0.01s with his way against the 39s that the dumb way took on my machine, very cool :D</p>\n<p><strong>UPDATE 2:</strong> Stop saying this is a duplicate of <a href=\"https://stackoverflow.com/questions/110344/algorithm-to-calculate-the-number-of-divisors-of-a-given-number\">this</a> post. Calculating the number of divisor of a given number doesn't need to calculate all the divisors. It's a different problem, if you think it's not then look for \"Divisor function\" on wikipedia. Read the questions and the answer before posting, if you do not understand what is the topic just don't add not useful and already given answers.</p>\n", "abstract": "Here's the very dumb way: The result I'd like to get is similar to this one, but I'd like a smarter algorithm (this one it's too much slow and dumb :-) I can find prime factors and their multiplicity fast enough. \nI've an generator that generates factor in this way: (factor1, multiplicity1)\n(factor2, multiplicity2)\n(factor3, multiplicity3)\nand so on... i.e. the output of  is: I don't know how much is this useful for what I want to do (I coded it for other problems), anyway I'd like a smarter way to make output this: UPDATE: Many thanks to Greg Hewgill and his \"smart way\" :)\nCalculating all divisors of 100000000 took 0.01s with his way against the 39s that the dumb way took on my machine, very cool :D UPDATE 2: Stop saying this is a duplicate of this post. Calculating the number of divisor of a given number doesn't need to calculate all the divisors. It's a different problem, if you think it's not then look for \"Divisor function\" on wikipedia. Read the questions and the answer before posting, if you do not understand what is the topic just don't add not useful and already given answers."}, "answers": [{"id": 171784, "score": 82, "vote": 0, "content": "<p>Given your <code>factorGenerator</code> function, here is a <code>divisorGen</code> that should work:</p>\n<pre><code class=\"python\">def divisorGen(n):\n    factors = list(factorGenerator(n))\n    nfactors = len(factors)\n    f = [0] * nfactors\n    while True:\n        yield reduce(lambda x, y: x*y, [factors[x][0]**f[x] for x in range(nfactors)], 1)\n        i = 0\n        while True:\n            f[i] += 1\n            if f[i] &lt;= factors[i][1]:\n                break\n            f[i] = 0\n            i += 1\n            if i &gt;= nfactors:\n                return\n</code></pre>\n<p>The overall efficiency of this algorithm will depend entirely on the efficiency of the <code>factorGenerator</code>.</p>\n", "abstract": "Given your factorGenerator function, here is a divisorGen that should work: The overall efficiency of this algorithm will depend entirely on the efficiency of the factorGenerator."}, {"id": 171779, "score": 41, "vote": 0, "content": "<p>To expand on what Shimi has said, you should only be running your loop from 1 to the square root of n. Then to find the pair, do <code>n / i</code>, and this will cover the whole problem space.</p>\n<p>As was also noted, this is a NP, or 'difficult' problem. Exhaustive search, the way you are doing it, is about as good as it gets for guaranteed answers. This fact is used by encryption algorithms and the like to help secure them. If someone were to solve this problem, most if not all of our current 'secure' communication would be rendered insecure.</p>\n<p>Python code:</p>\n<pre><code class=\"python\">import math\n\ndef divisorGenerator(n):\n    large_divisors = []\n    for i in xrange(1, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            yield i\n            if i*i != n:\n                large_divisors.append(n / i)\n    for divisor in reversed(large_divisors):\n        yield divisor\n\nprint list(divisorGenerator(100))\n</code></pre>\n<p>Which should output a list like:</p>\n<pre>\n[1, 2, 4, 5, 10, 20, 25, 50, 100]\n</pre>\n", "abstract": "To expand on what Shimi has said, you should only be running your loop from 1 to the square root of n. Then to find the pair, do n / i, and this will cover the whole problem space. As was also noted, this is a NP, or 'difficult' problem. Exhaustive search, the way you are doing it, is about as good as it gets for guaranteed answers. This fact is used by encryption algorithms and the like to help secure them. If someone were to solve this problem, most if not all of our current 'secure' communication would be rendered insecure. Python code: Which should output a list like:"}, {"id": 36700288, "score": 28, "vote": 0, "content": "<p>I think you can stop at <code>math.sqrt(n)</code> instead of n/2. </p>\n<p>I will give you example so that you can understand it easily. Now the <code>sqrt(28)</code> is <code>5.29</code> so <code>ceil(5.29)</code> will be 6. So I if I will stop at 6 then I will can get all the divisors. How?</p>\n<p>First see the code and then see image:</p>\n<pre><code class=\"python\">import math\ndef divisors(n):\n    divs = [1]\n    for i in xrange(2,int(math.sqrt(n))+1):\n        if n%i == 0:\n            divs.extend([i,n/i])\n    divs.extend([n])\n    return list(set(divs))\n</code></pre>\n<p>Now, See the image below:</p>\n<p>Lets say I have already added <code>1</code> to my divisors list and I start with <code>i=2</code> so</p>\n<p><a href=\"https://i.stack.imgur.com/jsBas.jpg\" rel=\"noreferrer\"><img alt=\"Divisors of a 28\" src=\"https://i.stack.imgur.com/jsBas.jpg\"/></a></p>\n<p>So at the end of all the iterations as I have added the quotient and the divisor to my list all the divisors of 28 are populated. </p>\n<p>Source: <a href=\"http://www.wikihow.com/Determine-the-Number-of-Divisors-of-an-Integer\" rel=\"noreferrer\">How to determine the divisors of a number</a></p>\n", "abstract": "I think you can stop at math.sqrt(n) instead of n/2.  I will give you example so that you can understand it easily. Now the sqrt(28) is 5.29 so ceil(5.29) will be 6. So I if I will stop at 6 then I will can get all the divisors. How? First see the code and then see image: Now, See the image below: Lets say I have already added 1 to my divisors list and I start with i=2 so  So at the end of all the iterations as I have added the quotient and the divisor to my list all the divisors of 28 are populated.  Source: How to determine the divisors of a number"}, {"id": 37058745, "score": 23, "vote": 0, "content": "<p>Although there are already many solutions to this, I really have to post this :)</p>\n<p>This one is:</p>\n<ul>\n<li>readable </li>\n<li>short</li>\n<li>self contained, copy &amp; paste ready</li>\n<li>quick (in cases with a lot of prime factors and divisors, &gt; 10 times faster than the accepted solution)</li>\n<li>python3, python2 and pypy compliant</li>\n</ul>\n<p>Code:</p>\n<pre><code class=\"python\">def divisors(n):\n    # get factors and their counts\n    factors = {}\n    nn = n\n    i = 2\n    while i*i &lt;= nn:\n        while nn % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            nn //= i\n        i += 1\n    if nn &gt; 1:\n        factors[nn] = factors.get(nn, 0) + 1\n\n    primes = list(factors.keys())\n\n    # generates factors from primes[k:] subset\n    def generate(k):\n        if k == len(primes):\n            yield 1\n        else:\n            rest = generate(k+1)\n            prime = primes[k]\n            for factor in rest:\n                prime_to_i = 1\n                # prime_to_i iterates prime**i values, i being all possible exponents\n                for _ in range(factors[prime] + 1):\n                    yield factor * prime_to_i\n                    prime_to_i *= prime\n\n    # in python3, `yield from generate(0)` would also work\n    for factor in generate(0):\n        yield factor\n</code></pre>\n", "abstract": "Although there are already many solutions to this, I really have to post this :) This one is: Code:"}, {"id": 54047215, "score": 12, "vote": 0, "content": "<p>An illustrative Pythonic one-liner:</p>\n<pre><code class=\"python\">from itertools import chain\nfrom math import sqrt\n\ndef divisors(n):\n    return set(chain.from_iterable((i,n//i) for i in range(1,int(sqrt(n))+1) if n%i == 0))\n</code></pre>\n<p>But better yet, just use sympy:</p>\n<pre><code class=\"python\">from sympy import divisors\n</code></pre>\n", "abstract": "An illustrative Pythonic one-liner: But better yet, just use sympy:"}, {"id": 371129, "score": 8, "vote": 0, "content": "<p>I like Greg solution, but I wish it was more python like.\nI feel it would be faster and more readable; \nso after some time of coding I came out with this.</p>\n<p>The first two functions are needed to make the cartesian product of lists. \nAnd can be reused whnever this problem arises. \nBy the way, I had to program this myself, if anyone knows of a standard solution for this problem, please feel free to contact me.</p>\n<p>\"Factorgenerator\" now returns a dictionary. And then the dictionary is fed into \"divisors\", who uses it to generate first a list of lists, where each list is the list of the factors of the form p^n with p prime.\nThen we make the cartesian product of those lists, and we finally use Greg' solution to generate the divisor.\nWe sort them, and return them.</p>\n<p>I tested it and it seem to be a bit faster than the previous version. I tested it as part of a bigger program, so I can't really say how much is it faster though.</p>\n<p>Pietro Speroni (pietrosperoni dot it)</p>\n<pre><code class=\"python\">from math import sqrt\n\n\n##############################################################\n### cartesian product of lists ##################################\n##############################################################\n\ndef appendEs2Sequences(sequences,es):\n    result=[]\n    if not sequences:\n        for e in es:\n            result.append([e])\n    else:\n        for e in es:\n            result+=[seq+[e] for seq in sequences]\n    return result\n\n\ndef cartesianproduct(lists):\n    \"\"\"\n    given a list of lists,\n    returns all the possible combinations taking one element from each list\n    The list does not have to be of equal length\n    \"\"\"\n    return reduce(appendEs2Sequences,lists,[])\n\n##############################################################\n### prime factors of a natural ##################################\n##############################################################\n\ndef primefactors(n):\n    '''lists prime factors, from greatest to smallest'''  \n    i = 2\n    while i&lt;=sqrt(n):\n        if n%i==0:\n            l = primefactors(n/i)\n            l.append(i)\n            return l\n        i+=1\n    return [n]      # n is prime\n\n\n##############################################################\n### factorization of a natural ##################################\n##############################################################\n\ndef factorGenerator(n):\n    p = primefactors(n)\n    factors={}\n    for p1 in p:\n        try:\n            factors[p1]+=1\n        except KeyError:\n            factors[p1]=1\n    return factors\n\ndef divisors(n):\n    factors = factorGenerator(n)\n    divisors=[]\n    listexponents=[map(lambda x:k**x,range(0,factors[k]+1)) for k in factors.keys()]\n    listfactors=cartesianproduct(listexponents)\n    for f in listfactors:\n        divisors.append(reduce(lambda x, y: x*y, f, 1))\n    divisors.sort()\n    return divisors\n\n\n\nprint divisors(60668796879)\n</code></pre>\n<p>P.S. \nit is the first time I am posting to stackoverflow. \nI am looking forward for any feedback.</p>\n", "abstract": "I like Greg solution, but I wish it was more python like.\nI feel it would be faster and more readable; \nso after some time of coding I came out with this. The first two functions are needed to make the cartesian product of lists. \nAnd can be reused whnever this problem arises. \nBy the way, I had to program this myself, if anyone knows of a standard solution for this problem, please feel free to contact me. \"Factorgenerator\" now returns a dictionary. And then the dictionary is fed into \"divisors\", who uses it to generate first a list of lists, where each list is the list of the factors of the form p^n with p prime.\nThen we make the cartesian product of those lists, and we finally use Greg' solution to generate the divisor.\nWe sort them, and return them. I tested it and it seem to be a bit faster than the previous version. I tested it as part of a bigger program, so I can't really say how much is it faster though. Pietro Speroni (pietrosperoni dot it) P.S. \nit is the first time I am posting to stackoverflow. \nI am looking forward for any feedback."}, {"id": 46637377, "score": 6, "vote": 0, "content": "<p>Here is a smart and fast way to do it for numbers up to and around 10**16 in pure Python 3.6,</p>\n<pre><code class=\"python\">from itertools import compress\n\ndef primes(n):\n    \"\"\" Returns  a list of primes &lt; n for n &gt; 2 \"\"\"\n    sieve = bytearray([True]) * (n//2)\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i//2]:\n            sieve[i*i//2::i] = bytearray((n-i*i-1)//(2*i)+1)\n    return [2,*compress(range(3,n,2), sieve[1:])]\n\ndef factorization(n):\n    \"\"\" Returns a list of the prime factorization of n \"\"\"\n    pf = []\n    for p in primeslist:\n      if p*p &gt; n : break\n      count = 0\n      while not n % p:\n        n //= p\n        count += 1\n      if count &gt; 0: pf.append((p, count))\n    if n &gt; 1: pf.append((n, 1))\n    return pf\n\ndef divisors(n):\n    \"\"\" Returns an unsorted list of the divisors of n \"\"\"\n    divs = [1]\n    for p, e in factorization(n):\n        divs += [x*p**k for k in range(1,e+1) for x in divs]\n    return divs\n\nn = 600851475143\nprimeslist = primes(int(n**0.5)+1) \nprint(divisors(n))\n</code></pre>\n", "abstract": "Here is a smart and fast way to do it for numbers up to and around 10**16 in pure Python 3.6,"}, {"id": 63416316, "score": 3, "vote": 0, "content": "<p>If your PC has tons of memory, a brute single line can be fast enough with numpy:</p>\n<pre><code class=\"python\">N = 10000000; tst = np.arange(1, N); tst[np.mod(N, tst) == 0]\nOut: \narray([      1,       2,       4,       5,       8,      10,      16,\n            20,      25,      32,      40,      50,      64,      80,\n           100,     125,     128,     160,     200,     250,     320,\n           400,     500,     625,     640,     800,    1000,    1250,\n          1600,    2000,    2500,    3125,    3200,    4000,    5000,\n          6250,    8000,   10000,   12500,   15625,   16000,   20000,\n         25000,   31250,   40000,   50000,   62500,   78125,   80000,\n        100000,  125000,  156250,  200000,  250000,  312500,  400000,\n        500000,  625000, 1000000, 1250000, 2000000, 2500000, 5000000])\n</code></pre>\n<p>Takes less than 1s on my slow PC.</p>\n", "abstract": "If your PC has tons of memory, a brute single line can be fast enough with numpy: Takes less than 1s on my slow PC."}, {"id": 15025068, "score": 2, "vote": 0, "content": "<p>Adapted from <a href=\"https://codereview.stackexchange.com/a/23015/8431\">CodeReview</a>, here is a variant which works with <code>num=1</code> !</p>\n<pre><code class=\"python\">from itertools import product\nimport operator\n\ndef prod(ls):\n   return reduce(operator.mul, ls, 1)\n\ndef powered(factors, powers):\n   return prod(f**p for (f,p) in zip(factors, powers))\n\n\ndef divisors(num) :\n\n   pf = dict(prime_factors(num))\n   primes = pf.keys()\n   #For each prime, possible exponents\n   exponents = [range(i+1) for i in pf.values()]\n   return (powered(primes,es) for es in product(*exponents))\n</code></pre>\n", "abstract": "Adapted from CodeReview, here is a variant which works with num=1 !"}, {"id": 36070582, "score": 2, "vote": 0, "content": "<p>Old question, but here is my take:</p>\n<pre><code class=\"python\">def divs(n, m):\n    if m == 1: return [1]\n    if n % m == 0: return [m] + divs(n, m - 1)\n    return divs(n, m - 1)\n</code></pre>\n<p>You can proxy with:</p>\n<pre><code class=\"python\">def divisorGenerator(n):\n    for x in reversed(divs(n, n)):\n        yield x\n</code></pre>\n<p>NOTE: For languages that support, this could be tail recursive.</p>\n", "abstract": "Old question, but here is my take: You can proxy with: NOTE: For languages that support, this could be tail recursive."}, {"id": 18366032, "score": 0, "vote": 0, "content": "<p>Assuming that the <code>factors</code> function returns the factors of <em>n</em> (for instance, <code>factors(60)</code> returns the list [2, 2, 3, 5]), here is a function to compute the divisors of <em>n</em>:</p>\n<pre><code class=\"python\">function divisors(n)\n    divs := [1]\n    for fact in factors(n)\n        temp := []\n        for div in divs\n            if fact * div not in divs\n                append fact * div to temp\n        divs := divs + temp\n    return divs\n</code></pre>\n", "abstract": "Assuming that the factors function returns the factors of n (for instance, factors(60) returns the list [2, 2, 3, 5]), here is a function to compute the divisors of n:"}, {"id": 23983542, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">return [x for x in range(n+1) if n/x==int(n/x)]\n</code></pre>\n", "abstract": ""}, {"id": 31340346, "score": 0, "vote": 0, "content": "<p>Here's my solution. It seems to be dumb but works well...and I was trying to find all proper divisors so the loop started from i = 2. </p>\n<pre><code class=\"python\">import math as m \n\ndef findfac(n):\n    faclist = [1]\n    for i in range(2, int(m.sqrt(n) + 2)):\n        if n%i == 0:\n            if i not in faclist:\n                faclist.append(i)\n                if n/i not in faclist:\n                    faclist.append(n/i)\n    return facts\n</code></pre>\n", "abstract": "Here's my solution. It seems to be dumb but works well...and I was trying to find all proper divisors so the loop started from i = 2. "}, {"id": 49888733, "score": 0, "vote": 0, "content": "<p>If you only care about using list comprehensions and nothing else matters to you!</p>\n<pre><code class=\"python\">from itertools import combinations\nfrom functools import reduce\n\ndef get_devisors(n):\n    f = [f for f,e in list(factorGenerator(n)) for i in range(e)]\n    fc = [x for l in range(len(f)+1) for x in combinations(f, l)]\n    devisors = [1 if c==() else reduce((lambda x, y: x * y), c) for c in set(fc)]\n    return sorted(devisors)\n</code></pre>\n", "abstract": "If you only care about using list comprehensions and nothing else matters to you!"}, {"id": 63450265, "score": 0, "vote": 0, "content": "<p>My solution via generator function is:</p>\n<pre><code class=\"python\">def divisor(num):\n    for x in range(1, num + 1):\n        if num % x == 0:\n            yield x\n    while True:\n        yield None\n</code></pre>\n", "abstract": "My solution via generator function is:"}, {"id": 67455769, "score": 0, "vote": 0, "content": "<p>Try to calculate square root a given number and then loop range(1,square_root+1).</p>\n<pre><code class=\"python\">number = int(input(\"Enter a Number: \"))\nsquare_root = round(number ** (1.0 / 2))\nprint(square_root)\ndivisor_list = []\nfor i in range(1,square_root+1):\n    if number % i == 0: # Check if mod return 0 if yes then append i and number/i in the list\n        divisor_list.append(i)\n        divisor_list.append(int(number/i))\n\nprint(divisor_list)\n</code></pre>\n", "abstract": "Try to calculate square root a given number and then loop range(1,square_root+1)."}, {"id": 69464666, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">def divisorGen(n): v = n last = [] for i in range(1, v+1) : if n % i == 0 : last.append(i)\n</code></pre>\n", "abstract": ""}, {"id": 70406267, "score": 0, "vote": 0, "content": "<p>I don\u00b4t understand why there are so many complicated solutions to this problem.</p>\n<p>Here is my take on it:</p>\n<pre><code class=\"python\">def divisors(n):\n  lis =[1]\n  s = math.ceil(math.sqrt(n))\n  for g in range(s,1, -1):\n     if n % g == 0:\n        lis.append(g)\n        lis.append(int(n / g))\n  return (set(lis))\n</code></pre>\n", "abstract": "I don\u00b4t understand why there are so many complicated solutions to this problem. Here is my take on it:"}]}, {"link": "https://stackoverflow.com/questions/9595135/why-does-python-give-the-wrong-answer-for-square-root-what-is-integer-divisio", "question": {"id": "9595135", "title": "Why does Python give the &quot;wrong&quot; answer for square root? What is integer division in Python 2?", "content": "<pre><code class=\"python\">x = 16\n\nsqrt = x**(.5)  #returns 4\nsqrt = x**(1/2) #returns 1\n</code></pre>\n<p>I know I can <code>import math</code> and use <code>sqrt</code>, but I'm looking for an answer to the above. What is integer division in Python 2? This behavior is fixed in Python 3.</p>\n", "abstract": "I know I can import math and use sqrt, but I'm looking for an answer to the above. What is integer division in Python 2? This behavior is fixed in Python 3."}, "answers": [{"id": 9595150, "score": 277, "vote": 0, "content": "<p>In Python 2, <code>sqrt=x**(1/2)</code> does integer division. <code>1/2 == 0</code>.</p>\n<p>So x<sup>(1/2)</sup> equals x<sup>(0)</sup>, which is 1.</p>\n<p>It's not wrong, it's the right answer to a different question.</p>\n<p>If you want to calculate the square root without an import of the math module, you'll need to use <code>x**(1.0/2)</code> or <code>x**(1/2.)</code>.  One of the integers needs to be a floating number.</p>\n<p>Note: this is not the case in Python 3, where <code>1/2</code> would be <code>0.5</code> and <code>1//2</code> would instead be integer division.</p>\n", "abstract": "In Python 2, sqrt=x**(1/2) does integer division. 1/2 == 0. So x(1/2) equals x(0), which is 1. It's not wrong, it's the right answer to a different question. If you want to calculate the square root without an import of the math module, you'll need to use x**(1.0/2) or x**(1/2.).  One of the integers needs to be a floating number. Note: this is not the case in Python 3, where 1/2 would be 0.5 and 1//2 would instead be integer division."}, {"id": 9595161, "score": 133, "vote": 0, "content": "<p>You have to write: <code>sqrt = x**(1/2.0)</code>, otherwise an integer division is performed and the expression <code>1/2</code> returns <code>0</code>.</p>\n<p>This behavior is \"normal\" in Python 2.x, whereas in Python 3.x <code>1/2</code> evaluates to <code>0.5</code>. If you want your Python 2.x code to behave like 3.x w.r.t. division write <code>from __future__ import division</code> - then <code>1/2</code> will evaluate to <code>0.5</code> and for backwards compatibility, <code>1//2</code> will evaluate to <code>0</code>.</p>\n<p>And for the record, the preferred way to calculate a square root is this:</p>\n<pre><code class=\"python\">import math\nmath.sqrt(x)\n</code></pre>\n", "abstract": "You have to write: sqrt = x**(1/2.0), otherwise an integer division is performed and the expression 1/2 returns 0. This behavior is \"normal\" in Python 2.x, whereas in Python 3.x 1/2 evaluates to 0.5. If you want your Python 2.x code to behave like 3.x w.r.t. division write from __future__ import division - then 1/2 will evaluate to 0.5 and for backwards compatibility, 1//2 will evaluate to 0. And for the record, the preferred way to calculate a square root is this:"}, {"id": 9595153, "score": 14, "vote": 0, "content": "<p><code>/</code> performs an integer division in Python 2:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 1/2\n0\n</code></pre>\n<p>If one of the numbers is a float, it works as expected:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 1.0/2\n0.5\n&gt;&gt;&gt; 16**(1.0/2)\n4.0\n</code></pre>\n", "abstract": "/ performs an integer division in Python 2: If one of the numbers is a float, it works as expected:"}, {"id": 9595162, "score": 7, "vote": 0, "content": "<p>What you're seeing is integer division. To get floating point division by default, </p>\n<pre><code class=\"python\">from __future__ import division\n</code></pre>\n<p>Or, you could convert 1 or 2 of 1/2 into a floating point value.</p>\n<pre><code class=\"python\">sqrt = x**(1.0/2)\n</code></pre>\n", "abstract": "What you're seeing is integer division. To get floating point division by default,  Or, you could convert 1 or 2 of 1/2 into a floating point value."}, {"id": 49684309, "score": 0, "vote": 0, "content": "<p>Perhaps a simple way to remember: add a dot after the numerator (or denominator)</p>\n<pre><code class=\"python\">16 ** (1. / 2)   # 4\n289 ** (1. / 2)  # 17\n27 ** (1. / 3)   # 3\n</code></pre>\n", "abstract": "Perhaps a simple way to remember: add a dot after the numerator (or denominator)"}]}, {"link": "https://stackoverflow.com/questions/39402795/how-to-pad-a-string-with-leading-zeros-in-python-3", "question": {"id": "39402795", "title": "How to pad a string with leading zeros in Python 3", "content": "<p>I'm trying to make <code>length = 001</code> in Python 3 but whenever I try to print it out it truncates the value without the leading zeros (<code>length = 1</code>). How would I stop this happening without having to cast <code>length</code> to a string before printing it out?</p>\n", "abstract": "I'm trying to make length = 001 in Python 3 but whenever I try to print it out it truncates the value without the leading zeros (length = 1). How would I stop this happening without having to cast length to a string before printing it out?"}, "answers": [{"id": 39402910, "score": 179, "vote": 0, "content": "<p>Make use of the <code>zfill()</code> helper method to left-pad any string, integer or float with zeros; it's valid for both <a href=\"https://docs.python.org/2/library/string.html#string.zfill\" rel=\"noreferrer\">Python 2.x</a> and <a href=\"https://docs.python.org/3.0/library/stdtypes.html#str.zfill\" rel=\"noreferrer\">Python 3.x</a>.</p>\n<p>It important to note that Python 2 is <a href=\"https://www.python.org/doc/sunset-python-2/\" rel=\"noreferrer\">no longer supported</a>.</p>\n<p><em>Sample usage:</em></p>\n<pre><code class=\"python\">print(str(1).zfill(3))\n# Expected output: 001\n</code></pre>\n<p><em>Description:</em></p>\n<p>When applied to a value, <code>zfill()</code> returns a value left-padded with zeros when the length of the initial <em>string</em> value less than that of the applied <em>width</em> value, otherwise, the initial <em>string</em> value as is.</p>\n<p><em>Syntax:</em></p>\n<pre><code class=\"python\">str(string).zfill(width)\n# Where string represents a string, an integer or a float, and\n# width, the desired length to left-pad.\n</code></pre>\n", "abstract": "Make use of the zfill() helper method to left-pad any string, integer or float with zeros; it's valid for both Python 2.x and Python 3.x. It important to note that Python 2 is no longer supported. Sample usage: Description: When applied to a value, zfill() returns a value left-padded with zeros when the length of the initial string value less than that of the applied width value, otherwise, the initial string value as is. Syntax:"}, {"id": 51837162, "score": 126, "vote": 0, "content": "<p>Since python 3.6 you can use fstring :</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; length = 1\n&gt;&gt;&gt; print(f'length = {length:03}')\nlength = 001\n</code></pre>\n", "abstract": "Since python 3.6 you can use fstring :"}, {"id": 57348617, "score": 32, "vote": 0, "content": "<p>There are many ways to achieve this but the easiest way in Python 3.6+, in my opinion, is this:</p>\n<pre><code class=\"python\">print(f\"{1:03}\")\n</code></pre>\n", "abstract": "There are many ways to achieve this but the easiest way in Python 3.6+, in my opinion, is this:"}, {"id": 39402853, "score": 13, "vote": 0, "content": "<p>Python integers don't have an inherent length or number of significant digits. If you want them to print a specific way, you need to convert them to a string. There are several ways you can do so that let you specify things like padding characters and minimum lengths.</p>\n<p>To pad with zeros to a minimum of three characters, try:</p>\n<pre><code class=\"python\">length = 1\nprint(format(length, '03'))\n</code></pre>\n", "abstract": "Python integers don't have an inherent length or number of significant digits. If you want them to print a specific way, you need to convert them to a string. There are several ways you can do so that let you specify things like padding characters and minimum lengths. To pad with zeros to a minimum of three characters, try:"}, {"id": 57791237, "score": -7, "vote": 0, "content": "<p>I suggest this ugly method but it works:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">length = 1\nlenghtafterpadding = 3\nnewlength = '0' * (lenghtafterpadding - len(str(length))) + str(length)\n</code></pre>\n<p>I came here to find a lighter solution than this one!</p>\n", "abstract": "I suggest this ugly method but it works: I came here to find a lighter solution than this one!"}]}, {"link": "https://stackoverflow.com/questions/328107/how-can-you-determine-a-point-is-between-two-other-points-on-a-line-segment", "question": {"id": "328107", "title": "How can you determine a point is between two other points on a line segment?", "content": "<p>Let's say you have a two dimensional plane with 2 points (called a and b) on it represented by an x integer and a y integer for each point.</p>\n<p>How can you determine if another point c is on the line segment defined by a and b?</p>\n<p>I use python most, but examples in any language would be helpful.</p>\n", "abstract": "Let's say you have a two dimensional plane with 2 points (called a and b) on it represented by an x integer and a y integer for each point. How can you determine if another point c is on the line segment defined by a and b? I use python most, but examples in any language would be helpful."}, "answers": [{"id": 328122, "score": 149, "vote": 0, "content": "<p>Check if the <strong>cross product</strong> of (b-a) and (c-a) is 0, as tells Darius Bacon, tells you if the points a, b and c are aligned.</p>\n<p>But, as you want to know if c is between a and b, you also have to check that the <strong>dot product</strong> of (b-a) and (c-a) is <em>positive</em> and is <em>less</em> than the square of the distance between a and b.</p>\n<p>In non-optimized pseudocode:</p>\n<pre><code class=\"python\">def isBetween(a, b, c):\n    crossproduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y)\n\n    # compare versus epsilon for floating point values, or != 0 if using integers\n    if abs(crossproduct) &gt; epsilon:\n        return False\n\n    dotproduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y)*(b.y - a.y)\n    if dotproduct &lt; 0:\n        return False\n\n    squaredlengthba = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y)\n    if dotproduct &gt; squaredlengthba:\n        return False\n\n    return True\n</code></pre>\n", "abstract": "Check if the cross product of (b-a) and (c-a) is 0, as tells Darius Bacon, tells you if the points a, b and c are aligned. But, as you want to know if c is between a and b, you also have to check that the dot product of (b-a) and (c-a) is positive and is less than the square of the distance between a and b. In non-optimized pseudocode:"}, {"id": 328193, "score": 65, "vote": 0, "content": "<p>Here's how I'd do it:</p>\n<pre><code class=\"python\">def distance(a,b):\n    return sqrt((a.x - b.x)**2 + (a.y - b.y)**2)\n\ndef is_between(a,c,b):\n    return distance(a,c) + distance(c,b) == distance(a,b)\n</code></pre>\n", "abstract": "Here's how I'd do it:"}, {"id": 328110, "score": 39, "vote": 0, "content": "<p>Check if the cross product of <code>b-a</code> and <code>c-a</code> is<code>0</code>: that means all the points are collinear. If they are, check if <code>c</code>'s coordinates are between <code>a</code>'s and <code>b</code>'s. Use either the x or the y coordinates, as long as <code>a</code> and <code>b</code> are separate on that axis (or they're the same on both).</p>\n<pre><code class=\"python\">def is_on(a, b, c):\n    \"Return true iff point c intersects the line segment from a to b.\"\n    # (or the degenerate case that all 3 points are coincident)\n    return (collinear(a, b, c)\n            and (within(a.x, c.x, b.x) if a.x != b.x else \n                 within(a.y, c.y, b.y)))\n\ndef collinear(a, b, c):\n    \"Return true iff a, b, and c all lie on the same line.\"\n    return (b.x - a.x) * (c.y - a.y) == (c.x - a.x) * (b.y - a.y)\n\ndef within(p, q, r):\n    \"Return true iff q is between p and r (inclusive).\"\n    return p &lt;= q &lt;= r or r &lt;= q &lt;= p\n</code></pre>\n<p>This answer used to be a mess of three updates. The worthwhile info from them: Brian Hayes's <a href=\"http://bit-player.org/bph-publications/BeautifulCode-2007-Hayes.pdf\" rel=\"nofollow noreferrer\">chapter</a> in <em>Beautiful Code</em> covers the design space for a collinearity-test function -- useful background. <a href=\"https://stackoverflow.com/questions/328107/how-can-you-determine-a-point-is-between-two-other-points-on-a-line-segment#328337\">Vincent's answer</a> helped to improve this one. And it was Hayes who suggested testing only one of the x or the y coordinates; originally the code had <code>and</code> in place of <code>if a.x != b.x else</code>.</p>\n<p>(This is coded for exact arithmetic with integers or rationals; if you pass in floating-point numbers instead, there will be problems with round-off errors. I'm not even sure what's a good way to define betweenness of 2-d points in float coordinates.)</p>\n", "abstract": "Check if the cross product of b-a and c-a is0: that means all the points are collinear. If they are, check if c's coordinates are between a's and b's. Use either the x or the y coordinates, as long as a and b are separate on that axis (or they're the same on both). This answer used to be a mess of three updates. The worthwhile info from them: Brian Hayes's chapter in Beautiful Code covers the design space for a collinearity-test function -- useful background. Vincent's answer helped to improve this one. And it was Hayes who suggested testing only one of the x or the y coordinates; originally the code had and in place of if a.x != b.x else. (This is coded for exact arithmetic with integers or rationals; if you pass in floating-point numbers instead, there will be problems with round-off errors. I'm not even sure what's a good way to define betweenness of 2-d points in float coordinates.)"}, {"id": 328142, "score": 9, "vote": 0, "content": "<p>Here's another approach:  </p>\n<ul>\n<li>Lets assume the two points be A (x1,y1) and B (x2,y2)</li>\n<li>The equation of the line passing through those points is (x-x1)/(y-y1)=(x2-x1)/(y2-y1) .. (just making equating the slopes)</li>\n</ul>\n<p>Point C (x3,y3) will lie between A &amp; B if:</p>\n<ul>\n<li>x3,y3 satisfies the above equation.</li>\n<li>x3 lies between x1 &amp; x2 and y3 lies between y1 &amp; y2 (trivial check)</li>\n</ul>\n", "abstract": "Here's another approach:   Point C (x3,y3) will lie between A & B if:"}, {"id": 328337, "score": 7, "vote": 0, "content": "<p>The length of the segment is not important, thus using a square root is not required and should be avoided since we could lose some precision.</p>\n<pre><code class=\"python\">class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def is_between(self, c):\n        # Check if slope of a to c is the same as a to b ;\n        # that is, when moving from a.x to c.x, c.y must be proportionally\n        # increased than it takes to get from a.x to b.x .\n\n        # Then, c.x must be between a.x and b.x, and c.y must be between a.y and b.y.\n        # =&gt; c is after a and before b, or the opposite\n        # that is, the absolute value of cmp(a, b) + cmp(b, c) is either 0 ( 1 + -1 )\n        #    or 1 ( c == a or c == b)\n\n        a, b = self.a, self.b             \n\n        return ((b.x - a.x) * (c.y - a.y) == (c.x - a.x) * (b.y - a.y) and \n                abs(cmp(a.x, c.x) + cmp(b.x, c.x)) &lt;= 1 and\n                abs(cmp(a.y, c.y) + cmp(b.y, c.y)) &lt;= 1)\n</code></pre>\n<p>Some random example of usage :</p>\n<pre><code class=\"python\">a = Point(0,0)\nb = Point(50,100)\nc = Point(25,50)\nd = Point(0,8)\n\nprint Segment(a,b).is_between(c)\nprint Segment(a,b).is_between(d)\n</code></pre>\n", "abstract": "The length of the segment is not important, thus using a square root is not required and should be avoided since we could lose some precision. Some random example of usage :"}, {"id": 29301940, "score": 5, "vote": 0, "content": "<p>You can use the wedge and dot product:</p>\n<pre><code class=\"python\">def dot(v,w): return v.x*w.x + v.y*w.y\ndef wedge(v,w): return v.x*w.y - v.y*w.x\n\ndef is_between(a,b,c):\n   v = a - b\n   w = b - c\n   return wedge(v,w) == 0 and dot(v,w) &gt; 0\n</code></pre>\n", "abstract": "You can use the wedge and dot product:"}, {"id": 328154, "score": 4, "vote": 0, "content": "<p>Using a more geometric approach, calculate the following distances:</p>\n<pre><code class=\"python\">ab = sqrt((a.x-b.x)**2 + (a.y-b.y)**2)\nac = sqrt((a.x-c.x)**2 + (a.y-c.y)**2)\nbc = sqrt((b.x-c.x)**2 + (b.y-c.y)**2)\n</code></pre>\n<p>and test whether <strong>ac+bc</strong> equals <strong>ab</strong>:</p>\n<pre><code class=\"python\">is_on_segment = abs(ac + bc - ab) &lt; EPSILON\n</code></pre>\n<p>That's because there are three possibilities:</p>\n<ul>\n<li>The 3 points form a triangle =&gt; <strong>ac+bc &gt; ab</strong></li>\n<li>They are collinear and <strong>c</strong> is outside the <strong>ab</strong> segment =&gt; <strong>ac+bc &gt; ab</strong></li>\n<li>They are collinear and <strong>c</strong> is inside the <strong>ab</strong> segment =&gt; <strong>ac+bc = ab</strong></li>\n</ul>\n", "abstract": "Using a more geometric approach, calculate the following distances: and test whether ac+bc equals ab: That's because there are three possibilities:"}, {"id": 13323946, "score": 4, "vote": 0, "content": "<p>Here's a different way to go about it, with code given in C++. Given two points, l1 and l2 it's trivial to express the line segment between them as</p>\n<pre><code class=\"python\">l1 + A(l2 - l1)\n</code></pre>\n<p>where 0 &lt;= A &lt;= 1. This is known as the vector representation of a line if you're interested any more beyond just using it for this problem. We can split out the x and y components of this, giving:</p>\n<pre><code class=\"python\">x = l1.x + A(l2.x - l1.x)\ny = l1.y + A(l2.y - l1.y)\n</code></pre>\n<p>Take a point (x, y) and substitute its x and y components into these two expressions to solve for A. The point is on the line if the solutions for A in both expressions are equal and 0 &lt;= A &lt;= 1. Because solving for A requires division, there's special cases that need handling to stop division by zero when the line segment is horizontal or vertical. The final solution is as follows:</p>\n<pre><code class=\"python\">// Vec2 is a simple x/y struct - it could very well be named Point for this use\n\nbool isBetween(double a, double b, double c) {\n    // return if c is between a and b\n    double larger = (a &gt;= b) ? a : b;\n    double smaller = (a != larger) ? a : b;\n\n    return c &lt;= larger &amp;&amp; c &gt;= smaller;\n}\n\nbool pointOnLine(Vec2&lt;double&gt; p, Vec2&lt;double&gt; l1, Vec2&lt;double&gt; l2) {\n    if(l2.x - l1.x == 0) return isBetween(l1.y, l2.y, p.y); // vertical line\n    if(l2.y - l1.y == 0) return isBetween(l1.x, l2.x, p.x); // horizontal line\n\n    double Ax = (p.x - l1.x) / (l2.x - l1.x);\n    double Ay = (p.y - l1.y) / (l2.y - l1.y);\n\n    // We want Ax == Ay, so check if the difference is very small (floating\n    // point comparison is fun!)\n\n    return fabs(Ax - Ay) &lt; 0.000001 &amp;&amp; Ax &gt;= 0.0 &amp;&amp; Ax &lt;= 1.0;\n}\n</code></pre>\n", "abstract": "Here's a different way to go about it, with code given in C++. Given two points, l1 and l2 it's trivial to express the line segment between them as where 0 <= A <= 1. This is known as the vector representation of a line if you're interested any more beyond just using it for this problem. We can split out the x and y components of this, giving: Take a point (x, y) and substitute its x and y components into these two expressions to solve for A. The point is on the line if the solutions for A in both expressions are equal and 0 <= A <= 1. Because solving for A requires division, there's special cases that need handling to stop division by zero when the line segment is horizontal or vertical. The final solution is as follows:"}, {"id": 328126, "score": 2, "vote": 0, "content": "<p>The scalar product between (c-a) and (b-a) must be equal to the product of their lengths (this means that the vectors (c-a) and (b-a) are aligned and with the same direction). Moreover, the length of (c-a) must be less than or equal to that of (b-a). Pseudocode:</p>\n<pre><code class=\"python\"># epsilon = small constant\n\ndef isBetween(a, b, c):\n    lengthca2  = (c.x - a.x)*(c.x - a.x) + (c.y - a.y)*(c.y - a.y)\n    lengthba2  = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y)\n    if lengthca2 &gt; lengthba2: return False\n    dotproduct = (c.x - a.x)*(b.x - a.x) + (c.y - a.y)*(b.y - a.y)\n    if dotproduct &lt; 0.0: return False\n    if abs(dotproduct*dotproduct - lengthca2*lengthba2) &gt; epsilon: return False \n    return True\n</code></pre>\n", "abstract": "The scalar product between (c-a) and (b-a) must be equal to the product of their lengths (this means that the vectors (c-a) and (b-a) are aligned and with the same direction). Moreover, the length of (c-a) must be less than or equal to that of (b-a). Pseudocode:"}, {"id": 11588038, "score": 2, "vote": 0, "content": "<p>I needed this for javascript for use in an html5 canvas for detecting if the users cursor was over or near a certain line. So I modified the answer given by Darius Bacon into coffeescript:</p>\n<pre><code class=\"python\">is_on = (a,b,c) -&gt;\n    # \"Return true if point c intersects the line segment from a to b.\"\n    # (or the degenerate case that all 3 points are coincident)\n    return (collinear(a,b,c) and withincheck(a,b,c))\n\nwithincheck = (a,b,c) -&gt;\n    if a[0] != b[0]\n        within(a[0],c[0],b[0]) \n    else \n        within(a[1],c[1],b[1])\n\ncollinear = (a,b,c) -&gt;\n    # \"Return true if a, b, and c all lie on the same line.\"\n    ((b[0]-a[0])*(c[1]-a[1]) &lt; (c[0]-a[0])*(b[1]-a[1]) + 1000) and ((b[0]-a[0])*(c[1]-a[1]) &gt; (c[0]-a[0])*(b[1]-a[1]) - 1000)\n\nwithin = (p,q,r) -&gt;\n    # \"Return true if q is between p and r (inclusive).\"\n    p &lt;= q &lt;= r or r &lt;= q &lt;= p\n</code></pre>\n", "abstract": "I needed this for javascript for use in an html5 canvas for detecting if the users cursor was over or near a certain line. So I modified the answer given by Darius Bacon into coffeescript:"}, {"id": 328268, "score": 1, "vote": 0, "content": "<p>Here's how I did it at school. I forgot why it is not a good idea.</p>\n<p>EDIT: </p>\n<p>@Darius Bacon: <a href=\"https://stackoverflow.com/questions/328107/how-can-you-determine-a-point-is-between-two-other-points-on-a-line-segment#328110\">cites a \"Beautiful Code\" book</a> which contains an explanation why the belowed code is not a good idea.</p>\n<pre><code class=\"python\">#!/usr/bin/env python\nfrom __future__ import division\n\nepsilon = 1e-6\n\nclass Point:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n\nclass LineSegment:\n    \"\"\"\n    &gt;&gt;&gt; ls = LineSegment(Point(0,0), Point(2,4))\n    &gt;&gt;&gt; Point(1, 2) in ls\n    True\n    &gt;&gt;&gt; Point(.5, 1) in ls\n    True\n    &gt;&gt;&gt; Point(.5, 1.1) in ls\n    False\n    &gt;&gt;&gt; Point(-1, -2) in ls\n    False\n    &gt;&gt;&gt; Point(.1, 0.20000001) in ls\n    True\n    &gt;&gt;&gt; Point(.1, 0.2001) in ls\n    False\n    &gt;&gt;&gt; ls = LineSegment(Point(1, 1), Point(3, 5))\n    &gt;&gt;&gt; Point(2, 3) in ls\n    True\n    &gt;&gt;&gt; Point(1.5, 2) in ls\n    True\n    &gt;&gt;&gt; Point(0, -1) in ls\n    False\n    &gt;&gt;&gt; ls = LineSegment(Point(1, 2), Point(1, 10))\n    &gt;&gt;&gt; Point(1, 6) in ls\n    True\n    &gt;&gt;&gt; Point(1, 1) in ls\n    False\n    &gt;&gt;&gt; Point(2, 6) in ls \n    False\n    &gt;&gt;&gt; ls = LineSegment(Point(-1, 10), Point(5, 10))\n    &gt;&gt;&gt; Point(3, 10) in ls\n    True\n    &gt;&gt;&gt; Point(6, 10) in ls\n    False\n    &gt;&gt;&gt; Point(5, 10) in ls\n    True\n    &gt;&gt;&gt; Point(3, 11) in ls\n    False\n    \"\"\"\n    def __init__(self, a, b):\n        if a.x &gt; b.x:\n            a, b = b, a\n        (self.x0, self.y0, self.x1, self.y1) = (a.x, a.y, b.x, b.y)\n        self.slope = (self.y1 - self.y0) / (self.x1 - self.x0) if self.x1 != self.x0 else None\n\n    def __contains__(self, c):\n        return (self.x0 &lt;= c.x &lt;= self.x1 and\n                min(self.y0, self.y1) &lt;= c.y &lt;= max(self.y0, self.y1) and\n                (not self.slope or -epsilon &lt; (c.y - self.y(c.x)) &lt; epsilon))\n\n    def y(self, x):        \n        return self.slope * (x - self.x0) + self.y0\n\nif __name__ == '__main__':\n    import  doctest\n    doctest.testmod()\n</code></pre>\n", "abstract": "Here's how I did it at school. I forgot why it is not a good idea. EDIT:  @Darius Bacon: cites a \"Beautiful Code\" book which contains an explanation why the belowed code is not a good idea."}, {"id": 328647, "score": 1, "vote": 0, "content": "<p>Ok, lots of mentions of linear algebra (cross product of vectors) and this works in a real (ie continuous or floating point) space but the question specifically stated that the two points were expressed as <strong>integers</strong> and thus a cross product is not the correct solution although it can give an approximate solution.</p>\n<p>The correct solution is to use <a href=\"http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm\" rel=\"nofollow noreferrer\">Bresenham's Line Algorithm</a> between the two points and to see if the third point is one of the points on the line.  If the points are sufficiently distant that calculating the algorithm is non-performant (and it'd have to be really large for that to be the case) I'm sure you could dig around and find optimisations.</p>\n", "abstract": "Ok, lots of mentions of linear algebra (cross product of vectors) and this works in a real (ie continuous or floating point) space but the question specifically stated that the two points were expressed as integers and thus a cross product is not the correct solution although it can give an approximate solution. The correct solution is to use Bresenham's Line Algorithm between the two points and to see if the third point is one of the points on the line.  If the points are sufficiently distant that calculating the algorithm is non-performant (and it'd have to be really large for that to be the case) I'm sure you could dig around and find optimisations."}, {"id": 7913523, "score": 1, "vote": 0, "content": "<p>Any point on the line segment (<strong>a</strong>, <strong>b</strong>) (where <strong>a</strong> and <strong>b</strong> are vectors) can be expressed as a <em>linear combination</em> of the two vectors <strong>a</strong> and <strong>b</strong>:</p>\n<p>In other words, if <strong>c</strong> lies on the line segment (<strong>a</strong>, <strong>b</strong>):</p>\n<pre><code class=\"python\">c = ma + (1 - m)b, where 0 &lt;= m &lt;= 1\n</code></pre>\n<p>Solving for <em>m</em>, we get:</p>\n<pre><code class=\"python\">m = (c.x - b.x)/(a.x - b.x) = (c.y - b.y)/(a.y - b.y)\n</code></pre>\n<p>So, our test becomes (in Python):</p>\n<pre><code class=\"python\">def is_on(a, b, c):\n    \"\"\"Is c on the line segment ab?\"\"\"\n\n    def _is_zero( val ):\n        return -epsilon &lt; val &lt; epsilon\n\n    x1 = a.x - b.x\n    x2 = c.x - b.x\n    y1 = a.y - b.y\n    y2 = c.y - b.y\n\n    if _is_zero(x1) and _is_zero(y1):\n        # a and b are the same point:\n        # so check that c is the same as a and b\n        return _is_zero(x2) and _is_zero(y2)\n\n    if _is_zero(x1):\n        # a and b are on same vertical line\n        m2 = y2 * 1.0 / y1\n        return _is_zero(x2) and 0 &lt;= m2 &lt;= 1\n    elif _is_zero(y1):\n        # a and b are on same horizontal line\n        m1 = x2 * 1.0 / x1\n        return _is_zero(y2) and 0 &lt;= m1 &lt;= 1\n    else:\n        m1 = x2 * 1.0 / x1\n        if m1 &lt; 0 or m1 &gt; 1:\n            return False\n        m2 = y2 * 1.0 / y1\n        return _is_zero(m2 - m1)\n</code></pre>\n", "abstract": "Any point on the line segment (a, b) (where a and b are vectors) can be expressed as a linear combination of the two vectors a and b: In other words, if c lies on the line segment (a, b): Solving for m, we get: So, our test becomes (in Python):"}, {"id": 9224700, "score": 1, "vote": 0, "content": "<p>c#\nFrom <a href=\"http://www.faqs.org/faqs/graphics/algorithms-faq/\" rel=\"nofollow\">http://www.faqs.org/faqs/graphics/algorithms-faq/</a>\n-&gt; Subject 1.02: How do I find the distance from a point to a line?</p>\n<pre><code class=\"python\">Boolean Contains(PointF from, PointF to, PointF pt, double epsilon)\n        {\n\n            double segmentLengthSqr = (to.X - from.X) * (to.X - from.X) + (to.Y - from.Y) * (to.Y - from.Y);\n            double r = ((pt.X - from.X) * (to.X - from.X) + (pt.Y - from.Y) * (to.Y - from.Y)) / segmentLengthSqr;\n            if(r&lt;0 || r&gt;1) return false;\n            double sl = ((from.Y - pt.Y) * (to.X - from.X) - (from.X - pt.X) * (to.Y - from.Y)) / System.Math.Sqrt(segmentLengthSqr);\n            return -epsilon &lt;= sl &amp;&amp; sl &lt;= epsilon;\n        }\n</code></pre>\n", "abstract": "c#\nFrom http://www.faqs.org/faqs/graphics/algorithms-faq/\n-> Subject 1.02: How do I find the distance from a point to a line?"}, {"id": 19633299, "score": 1, "vote": 0, "content": "<p>Here is some Java code that worked for me:</p>\n<pre><code class=\"python\">boolean liesOnSegment(Coordinate a, Coordinate b, Coordinate c) {\n        \n    double dotProduct = (c.x - a.x) * (c.x - b.x) + (c.y - a.y) * (c.y - b.y);\n    return (dotProduct &lt; 0);\n}\n</code></pre>\n", "abstract": "Here is some Java code that worked for me:"}, {"id": 21453970, "score": 1, "vote": 0, "content": "<p>An answer in C# using a Vector2D class</p>\n<pre><code class=\"python\">public static bool IsOnSegment(this Segment2D @this, Point2D c, double tolerance)\n{\n     var distanceSquared = tolerance*tolerance;\n     // Start of segment to test point vector\n     var v = new Vector2D( @this.P0, c ).To3D();\n     // Segment vector\n     var s = new Vector2D( @this.P0, @this.P1 ).To3D();\n     // Dot product of s\n     var ss = s*s;\n     // k is the scalar we multiply s by to get the projection of c onto s\n     // where we assume s is an infinte line\n     var k = v*s/ss;\n     // Convert our tolerance to the units of the scalar quanity k\n     var kd = tolerance / Math.Sqrt( ss );\n     // Check that the projection is within the bounds\n     if (k &lt;= -kd || k &gt;= (1+kd))\n     {\n        return false;\n     }\n     // Find the projection point\n     var p = k*s;\n     // Find the vector between test point and it's projection\n     var vp = (v - p);\n     // Check the distance is within tolerance.\n     return vp * vp &lt; distanceSquared;\n}\n</code></pre>\n<p>Note that</p>\n<pre><code class=\"python\">s * s\n</code></pre>\n<p>is the dot product of the segment vector via operator overloading in C#</p>\n<p>The key is taking advantage of the projection of the point onto the infinite line and observing that the scalar quantity of the projection tells us trivially if the projection is on the segment or not. We can adjust the bounds of the scalar quantity to use a fuzzy tolerance.</p>\n<p>If the projection is within bounds we just test if the distance from the point to the projection is within bounds.</p>\n<p>The benefit over the cross product approach is that the tolerance has a meaningful value.</p>\n", "abstract": "An answer in C# using a Vector2D class Note that is the dot product of the segment vector via operator overloading in C# The key is taking advantage of the projection of the point onto the infinite line and observing that the scalar quantity of the projection tells us trivially if the projection is on the segment or not. We can adjust the bounds of the scalar quantity to use a fuzzy tolerance. If the projection is within bounds we just test if the distance from the point to the projection is within bounds. The benefit over the cross product approach is that the tolerance has a meaningful value."}, {"id": 56850069, "score": 1, "vote": 0, "content": "<p>C# version of Jules' answer:</p>\n<pre><code class=\"python\">public static double CalcDistanceBetween2Points(double x1, double y1, double x2, double y2)\n{\n    return Math.Sqrt(Math.Pow (x1-x2, 2) + Math.Pow (y1-y2, 2));\n}\n\npublic static bool PointLinesOnLine (double x, double y, double x1, double y1, double x2, double y2, double allowedDistanceDifference)\n{\n    double dist1 = CalcDistanceBetween2Points(x, y, x1, y1);\n    double dist2 = CalcDistanceBetween2Points(x, y, x2, y2);\n    double dist3 = CalcDistanceBetween2Points(x1, y1, x2, y2);\n    return Math.Abs(dist3 - (dist1 + dist2)) &lt;= allowedDistanceDifference;\n}\n</code></pre>\n", "abstract": "C# version of Jules' answer:"}, {"id": 72285835, "score": 1, "vote": 0, "content": "<p>You could also use the very convenient <code>scikit-spatial</code> <a href=\"https://scikit-spatial.readthedocs.io/en/stable/index.html#\" rel=\"nofollow noreferrer\">library</a>.</p>\n<p>For instance, you could create a <code>Line</code> object defined by the two points <code>a</code> and <code>b</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; point_a = [0, 0]\n&gt;&gt;&gt; point_b = [1, 0]\n\n&gt;&gt;&gt; line = Line.from_points(point_a, point_b)\n</code></pre>\n<p>then you can use the <code>side_point</code> method of the <code>Line</code> class to check whether point <code>c</code> lies on <code>line</code> or not.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; line.side_point([0.5, 0])\n0\n</code></pre>\n<p>If the output is <code>0</code>, then point <code>c</code> lies on <code>line</code>.</p>\n", "abstract": "You could also use the very convenient scikit-spatial library. For instance, you could create a Line object defined by the two points a and b: then you can use the side_point method of the Line class to check whether point c lies on line or not. If the output is 0, then point c lies on line."}, {"id": 329347, "score": 0, "vote": 0, "content": "<p>how about just ensuring that the slope is the same and the point is between the others?</p>\n<p>given points (x1, y1) and (x2, y2) ( with x2 &gt; x1)\nand candidate point (a,b)</p>\n<p>if  (b-y1) / (a-x1) = (y2-y2) / (x2-x1)  And x1 &lt; a &lt; x2 </p>\n<p>Then (a,b) must be on line between (x1,y1) and (x2, y2)</p>\n", "abstract": "how about just ensuring that the slope is the same and the point is between the others? given points (x1, y1) and (x2, y2) ( with x2 > x1)\nand candidate point (a,b) if  (b-y1) / (a-x1) = (y2-y2) / (x2-x1)  And x1 < a < x2  Then (a,b) must be on line between (x1,y1) and (x2, y2)"}, {"id": 46822167, "score": 0, "vote": 0, "content": "<p>Here is my solution with C# in Unity.</p>\n<pre><code class=\"python\">private bool _isPointOnLine( Vector2 ptLineStart, Vector2 ptLineEnd, Vector2 ptPoint )\n{\n    bool bRes = false;\n    if((Mathf.Approximately(ptPoint.x, ptLineStart.x) || Mathf.Approximately(ptPoint.x, ptLineEnd.x)))\n    {\n        if(ptPoint.y &gt; ptLineStart.y &amp;&amp; ptPoint.y &lt; ptLineEnd.y)\n        {\n            bRes = true;\n        }\n    }\n    else if((Mathf.Approximately(ptPoint.y, ptLineStart.y) || Mathf.Approximately(ptPoint.y, ptLineEnd.y)))\n    {\n        if(ptPoint.x &gt; ptLineStart.x &amp;&amp; ptPoint.x &lt; ptLineEnd.x)\n        {\n            bRes = true;\n        }\n    }\n    return bRes;\n}\n</code></pre>\n", "abstract": "Here is my solution with C# in Unity."}, {"id": 63343210, "score": 0, "vote": 0, "content": "<p>You can do it by solving the line equation for that line segment with the point coordinates you will know whether that point is on the line and then checking the bounds of the segment to know whether it is inside or outside of it. You can apply some threshold because well it is somewhere in space mostl likely defined by a floating point value and you must not hit the exact one.\nExample in php</p>\n<pre><code class=\"python\">function getLineDefinition($p1=array(0,0), $p2=array(0,0)){\n    \n    $k = ($p1[1]-$p2[1])/($p1[0]-$p2[0]);\n    $q = $p1[1]-$k*$p1[0];\n    \n    return array($k, $q);\n    \n}\n\nfunction isPointOnLineSegment($line=array(array(0,0),array(0,0)), $pt=array(0,0)){\n    \n    // GET THE LINE DEFINITION y = k.x + q AS array(k, q) \n    $def = getLineDefinition($line[0], $line[1]);\n    \n    // use the line definition to find y for the x of your point\n    $y = $def[0]*$pt[0]+$def[1];\n\n    $yMin = min($line[0][1], $line[1][1]);\n    $yMax = max($line[0][1], $line[1][1]);\n\n    // exclude y values that are outside this segments bounds\n    if($y&gt;$yMax || $y&lt;$yMin) return false;\n    \n    // calculate the difference of your points y value from the reference value calculated from lines definition \n    // in ideal cases this would equal 0 but we are dealing with floating point values so we need some threshold value not to lose results\n    // this is up to you to fine tune\n    $diff = abs($pt[1]-$y);\n    \n    $thr = 0.000001;\n    \n    return $diff&lt;=$thr;\n    \n}\n</code></pre>\n", "abstract": "You can do it by solving the line equation for that line segment with the point coordinates you will know whether that point is on the line and then checking the bounds of the segment to know whether it is inside or outside of it. You can apply some threshold because well it is somewhere in space mostl likely defined by a floating point value and you must not hit the exact one.\nExample in php"}]}, {"link": "https://stackoverflow.com/questions/2489435/check-if-a-number-is-a-perfect-square", "question": {"id": "2489435", "title": "Check if a number is a perfect square", "content": "<p>How could I check if a number is a perfect square?</p>\n<p>Speed is of no concern, for now, just working.</p>\n", "abstract": "How could I check if a number is a perfect square? Speed is of no concern, for now, just working."}, "answers": [{"id": 2489519, "score": 129, "vote": 0, "content": "<p>The problem with relying on any floating point computation (<code>math.sqrt(x)</code>, or <code>x**0.5</code>) is that you can't really be sure it's exact (for sufficiently large integers <code>x</code>, it won't be, and might even overflow). Fortunately (if one's in no hurry;-) there are many pure integer approaches, such as the following...:</p>\n<pre><code class=\"python\">def is_square(apositiveint):\n  x = apositiveint // 2\n  seen = set([x])\n  while x * x != apositiveint:\n    x = (x + (apositiveint // x)) // 2\n    if x in seen: return False\n    seen.add(x)\n  return True\n\nfor i in range(110, 130):\n   print i, is_square(i)\n</code></pre>\n<p>Hint: it's based on the \"Babylonian algorithm\" for square root, see <a href=\"http://en.wikipedia.org/wiki/Methods_of_computing_square_roots\" rel=\"noreferrer\">wikipedia</a>.  It <em>does</em> work for any positive number for which you have enough memory for the computation to proceed to completion;-).</p>\n<p><strong>Edit</strong>: let's see an example...</p>\n<pre><code class=\"python\">x = 12345678987654321234567 ** 2\n\nfor i in range(x, x+2):\n   print i, is_square(i)\n</code></pre>\n<p>this prints, as desired (and in a reasonable amount of time, too;-):</p>\n<pre><code class=\"python\">152415789666209426002111556165263283035677489 True\n152415789666209426002111556165263283035677490 False\n</code></pre>\n<p>Please, before you propose solutions based on floating point intermediate results, make sure they work correctly on this simple example -- it's not <strong>that</strong> hard (you just need a few extra checks in case the sqrt computed is a little off), just takes a bit of care.</p>\n<p>And then try with <code>x**7</code> and find clever way to work around the problem you'll get,</p>\n<pre><code class=\"python\">OverflowError: long int too large to convert to float\n</code></pre>\n<p>you'll have to get more and more clever as the numbers keep growing, of course.</p>\n<p>If I <em>was</em> in a hurry, of course, I'd use <a href=\"http://www.gmpy.org/\" rel=\"noreferrer\">gmpy</a> -- but then, I'm clearly biased;-).</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import gmpy\n&gt;&gt;&gt; gmpy.is_square(x**7)\n1\n&gt;&gt;&gt; gmpy.is_square(x**7 + 1)\n0\n</code></pre>\n<p>Yeah, I know, that's just so easy it feels like cheating (a bit the way I feel towards Python in general;-) -- no cleverness at all, just perfect directness and simplicity (and, in the case of gmpy, sheer speed;-)...</p>\n", "abstract": "The problem with relying on any floating point computation (math.sqrt(x), or x**0.5) is that you can't really be sure it's exact (for sufficiently large integers x, it won't be, and might even overflow). Fortunately (if one's in no hurry;-) there are many pure integer approaches, such as the following...: Hint: it's based on the \"Babylonian algorithm\" for square root, see wikipedia.  It does work for any positive number for which you have enough memory for the computation to proceed to completion;-). Edit: let's see an example... this prints, as desired (and in a reasonable amount of time, too;-): Please, before you propose solutions based on floating point intermediate results, make sure they work correctly on this simple example -- it's not that hard (you just need a few extra checks in case the sqrt computed is a little off), just takes a bit of care. And then try with x**7 and find clever way to work around the problem you'll get, you'll have to get more and more clever as the numbers keep growing, of course. If I was in a hurry, of course, I'd use gmpy -- but then, I'm clearly biased;-). Yeah, I know, that's just so easy it feels like cheating (a bit the way I feel towards Python in general;-) -- no cleverness at all, just perfect directness and simplicity (and, in the case of gmpy, sheer speed;-)..."}, {"id": 2489540, "score": 58, "vote": 0, "content": "<p>Use Newton's method to quickly zero in on the nearest integer square root, then square it and see if it's your number. See <a href=\"https://en.wikipedia.org/wiki/Integer_square_root\" rel=\"noreferrer\">isqrt</a>.</p>\n<p>Python \u2265 3.8 has <a href=\"https://docs.python.org/3.8/library/math.html#module-math\" rel=\"noreferrer\"><code>math.isqrt</code></a>. If using an older version of Python, look for the \"<code>def isqrt(n)</code>\" implementation <a href=\"https://github.com/python/cpython/blob/master/Modules/mathmodule.c\" rel=\"noreferrer\">here</a>.</p>\n<pre><code class=\"python\">import math\n\ndef is_square(i: int) -&gt; bool:\n    return i == math.isqrt(i) ** 2\n</code></pre>\n", "abstract": "Use Newton's method to quickly zero in on the nearest integer square root, then square it and see if it's your number. See isqrt. Python \u2265 3.8 has math.isqrt. If using an older version of Python, look for the \"def isqrt(n)\" implementation here."}, {"id": 2489580, "score": 20, "vote": 0, "content": "<p>Since you can never depend on exact comparisons when dealing with floating point computations (such as these ways of calculating the square root), a less error-prone implementation would be</p>\n<pre><code class=\"python\">import math\n\ndef is_square(integer):\n    root = math.sqrt(integer)\n    return integer == int(root + 0.5) ** 2\n</code></pre>\n<p>Imagine <code>integer</code> is <code>9</code>. <code>math.sqrt(9)</code> could be <code>3.0</code>, but it could also be something like <code>2.99999</code> or <code>3.00001</code>, so squaring the result right off isn't reliable. Knowing that <code>int</code> takes the floor value, increasing the float value by <code>0.5</code> first means we'll get the value we're looking for if we're in a range where <code>float</code> still has a fine enough resolution to represent numbers near the one for which we are looking.</p>\n", "abstract": "Since you can never depend on exact comparisons when dealing with floating point computations (such as these ways of calculating the square root), a less error-prone implementation would be Imagine integer is 9. math.sqrt(9) could be 3.0, but it could also be something like 2.99999 or 3.00001, so squaring the result right off isn't reliable. Knowing that int takes the floor value, increasing the float value by 0.5 first means we'll get the value we're looking for if we're in a range where float still has a fine enough resolution to represent numbers near the one for which we are looking."}, {"id": 45724520, "score": 20, "vote": 0, "content": "<p>If youre interested, I have a pure-math response to a similar question at <a href=\"https://math.stackexchange.com/questions/131330/detecting-perfect-squares-faster-than-by-extracting-square-root/712818#712818\" title=\"Detecting perfect squares faster than by extracting square root\">math stackexchange, \"Detecting perfect squares faster than by extracting square root\"</a>.</p>\n<p>My own implementation of isSquare(n) may not be the best, but I like it. Took me several months of study in math theory, digital computation and python programming, comparing myself to other contributors, etc., to really click with this method. I like its simplicity and efficiency though. I havent seen better. Tell me what you think.</p>\n<pre><code class=\"python\">def isSquare(n):\n    ## Trivial checks\n    if type(n) != int:  ## integer\n        return False\n    if n &lt; 0:      ## positivity\n        return False\n    if n == 0:      ## 0 pass\n        return True\n\n    ## Reduction by powers of 4 with bit-logic\n    while n&amp;3 == 0:    \n        n=n&gt;&gt;2\n\n    ## Simple bit-logic test. All perfect squares, in binary,\n    ## end in 001, when powers of 4 are factored out.\n    if n&amp;7 != 1:\n        return False\n\n    if n==1:\n        return True  ## is power of 4, or even power of 2\n\n\n    ## Simple modulo equivalency test\n    c = n%10\n    if c in {3, 7}:\n        return False  ## Not 1,4,5,6,9 in mod 10\n    if n % 7 in {3, 5, 6}:\n        return False  ## Not 1,2,4 mod 7\n    if n % 9 in {2,3,5,6,8}:\n        return False  \n    if n % 13 in {2,5,6,7,8,11}:\n        return False  \n\n    ## Other patterns\n    if c == 5:  ## if it ends in a 5\n        if (n//10)%10 != 2:\n            return False    ## then it must end in 25\n        if (n//100)%10 not in {0,2,6}: \n            return False    ## and in 025, 225, or 625\n        if (n//100)%10 == 6:\n            if (n//1000)%10 not in {0,5}:\n                return False    ## that is, 0625 or 5625\n    else:\n        if (n//10)%4 != 0:\n            return False    ## (4k)*10 + (1,9)\n\n\n    ## Babylonian Algorithm. Finding the integer square root.\n    ## Root extraction.\n    s = (len(str(n))-1) // 2\n    x = (10**s) * 4\n\n    A = {x, n}\n    while x * x != n:\n        x = (x + (n // x)) &gt;&gt; 1\n        if x in A:\n            return False\n        A.add(x)\n    return True\n</code></pre>\n<p>Pretty straight forward. First it checks that we have an integer, and a positive one at that. Otherwise there is no point.   It lets 0 slip through as True (necessary or else next block is infinite loop).</p>\n<p>The next block of code systematically removes powers of 4 in a very fast sub-algorithm using bit shift and bit logic operations.  We ultimately are not finding the isSquare of our original n but of a k&lt;n that has been scaled down by powers of 4, if possible. This reduces the size of the number we are working with and really speeds up the Babylonian method, but also makes other checks faster too.</p>\n<p>The third block of code performs a simple Boolean bit-logic test.  The least significant three digits, in binary, of any perfect square are 001. Always. Save for leading zeros resulting from powers of 4, anyway, which has already been accounted for.  If it fails the test, you immediately know it isnt a square. If it passes, you cant be sure.</p>\n<p>Also, if we end up with a 1 for a test value then the test number was originally a power of 4, including perhaps 1 itself.</p>\n<p>Like the third block, the fourth tests the ones-place value in decimal using simple modulus operator, and tends to catch values that slip through the previous test. Also a mod 7, mod 8, mod 9, and mod 13 test.</p>\n<p>The fifth block of code checks for some of the well-known perfect square patterns. Numbers ending in 1 or 9 are preceded by a multiple of four. And numbers ending in 5 must end in 5625, 0625, 225, or 025. I had included others but realized they were redundant or never actually used.</p>\n<p>Lastly, the sixth block of code resembles very much what the top answerer - Alex Martelli - answer is.  Basically finds the square root using the ancient Babylonian algorithm, but restricting it to integer values while ignoring floating point. Done both for speed and extending the magnitudes of values that are testable. I used sets instead of lists because it takes far less time, I used bit shifts instead of division by two, and I smartly chose an initial start value much more efficiently.</p>\n<p>By the way, I did test Alex Martelli's recommended test number, as well as a few numbers many orders magnitude larger, such as:</p>\n<pre><code class=\"python\">x=1000199838770766116385386300483414671297203029840113913153824086810909168246772838680374612768821282446322068401699727842499994541063844393713189701844134801239504543830737724442006577672181059194558045164589783791764790043104263404683317158624270845302200548606715007310112016456397357027095564872551184907513312382763025454118825703090010401842892088063527451562032322039937924274426211671442740679624285180817682659081248396873230975882215128049713559849427311798959652681930663843994067353808298002406164092996533923220683447265882968239141724624870704231013642255563984374257471112743917655991279898690480703935007493906644744151022265929975993911186879561257100479593516979735117799410600147341193819147290056586421994333004992422258618475766549646258761885662783430625 ** 2\nfor i in range(x, x+2):\n    print(i, isSquare(i))\n</code></pre>\n<p>printed the following results:</p>\n<pre><code class=\"python\">1000399717477066534083185452789672211951514938424998708930175541558932213310056978758103599452364409903384901149641614494249195605016959576235097480592396214296565598519295693079257885246632306201885850365687426564365813280963724310434494316592041592681626416195491751015907716210235352495422858432792668507052756279908951163972960239286719854867504108121432187033786444937064356645218196398775923710931242852937602515835035177768967470757847368349565128635934683294155947532322786360581473152034468071184081729335560769488880138928479829695277968766082973795720937033019047838250608170693879209655321034310764422462828792636246742456408134706264621790736361118589122797268261542115823201538743148116654378511916000714911467547209475246784887830649309238110794938892491396597873160778553131774466638923135932135417900066903068192088883207721545109720968467560224268563643820599665232314256575428214983451466488658896488012211237139254674708538347237589290497713613898546363590044902791724541048198769085430459186735166233549186115282574626012296888817453914112423361525305960060329430234696000121420787598967383958525670258016851764034555105019265380321048686563527396844220047826436035333266263375049097675787975100014823583097518824871586828195368306649956481108708929669583308777347960115138098217676704862934389659753628861667169905594181756523762369645897154232744410732552956489694024357481100742138381514396851789639339362228442689184910464071202445106084939268067445115601375050153663645294106475257440167535462278022649865332161044187890625 True\n1000399717477066534083185452789672211951514938424998708930175541558932213310056978758103599452364409903384901149641614494249195605016959576235097480592396214296565598519295693079257885246632306201885850365687426564365813280963724310434494316592041592681626416195491751015907716210235352495422858432792668507052756279908951163972960239286719854867504108121432187033786444937064356645218196398775923710931242852937602515835035177768967470757847368349565128635934683294155947532322786360581473152034468071184081729335560769488880138928479829695277968766082973795720937033019047838250608170693879209655321034310764422462828792636246742456408134706264621790736361118589122797268261542115823201538743148116654378511916000714911467547209475246784887830649309238110794938892491396597873160778553131774466638923135932135417900066903068192088883207721545109720968467560224268563643820599665232314256575428214983451466488658896488012211237139254674708538347237589290497713613898546363590044902791724541048198769085430459186735166233549186115282574626012296888817453914112423361525305960060329430234696000121420787598967383958525670258016851764034555105019265380321048686563527396844220047826436035333266263375049097675787975100014823583097518824871586828195368306649956481108708929669583308777347960115138098217676704862934389659753628861667169905594181756523762369645897154232744410732552956489694024357481100742138381514396851789639339362228442689184910464071202445106084939268067445115601375050153663645294106475257440167535462278022649865332161044187890626 False\n</code></pre>\n<p>And it did this in 0.33 seconds.</p>\n<p>In my opinion, my algorithm works the same as Alex Martelli's, with all the benefits thereof, but has the added benefit highly efficient simple-test rejections that save a lot of time, not to mention the reduction in size of test numbers by powers of 4, which improves speed, efficiency, accuracy and the size of numbers that are testable. Probably especially true in non-Python implementations.</p>\n<p>Roughly 99% of all integers are rejected as non-Square before Babylonian root extraction is even implemented, and in 2/3 the time it would take the Babylonian to reject the integer. And though these tests dont speed up the process that significantly, the reduction in all test numbers to an odd by dividing out all powers of 4 <em>really</em> accelerates the Babylonian test.</p>\n<p>I did a time comparison test.  I tested all integers from 1 to 10 Million in succession.  Using just the Babylonian method by itself (with my specially tailored initial guess) it took my Surface 3 an average of 165 seconds (with 100% accuracy). Using just the logical tests in my algorithm (excluding the Babylonian), it took 127 seconds, it rejected 99% of all integers as non-Square without mistakenly rejecting any perfect squares. Of those integers that passed, only 3% were perfect Squares (a much higher density).  Using the full algorithm above that employs both the logical tests and the Babylonian root extraction, we have 100% accuracy, and test completion in only 14 seconds.  The first 100 Million integers takes roughly 2 minutes 45 seconds to test.</p>\n<p>EDIT: I have been able to bring down the time further. I can now test the integers 0 to 100 Million in 1 minute 40 seconds.  A lot of time is wasted checking the data type and the positivity.  Eliminate the very first two checks and I cut the experiment down by a minute.  One must assume the user is smart enough to know that negatives and floats are not perfect squares.</p>\n", "abstract": "If youre interested, I have a pure-math response to a similar question at math stackexchange, \"Detecting perfect squares faster than by extracting square root\". My own implementation of isSquare(n) may not be the best, but I like it. Took me several months of study in math theory, digital computation and python programming, comparing myself to other contributors, etc., to really click with this method. I like its simplicity and efficiency though. I havent seen better. Tell me what you think. Pretty straight forward. First it checks that we have an integer, and a positive one at that. Otherwise there is no point.   It lets 0 slip through as True (necessary or else next block is infinite loop). The next block of code systematically removes powers of 4 in a very fast sub-algorithm using bit shift and bit logic operations.  We ultimately are not finding the isSquare of our original n but of a k<n that has been scaled down by powers of 4, if possible. This reduces the size of the number we are working with and really speeds up the Babylonian method, but also makes other checks faster too. The third block of code performs a simple Boolean bit-logic test.  The least significant three digits, in binary, of any perfect square are 001. Always. Save for leading zeros resulting from powers of 4, anyway, which has already been accounted for.  If it fails the test, you immediately know it isnt a square. If it passes, you cant be sure. Also, if we end up with a 1 for a test value then the test number was originally a power of 4, including perhaps 1 itself. Like the third block, the fourth tests the ones-place value in decimal using simple modulus operator, and tends to catch values that slip through the previous test. Also a mod 7, mod 8, mod 9, and mod 13 test. The fifth block of code checks for some of the well-known perfect square patterns. Numbers ending in 1 or 9 are preceded by a multiple of four. And numbers ending in 5 must end in 5625, 0625, 225, or 025. I had included others but realized they were redundant or never actually used. Lastly, the sixth block of code resembles very much what the top answerer - Alex Martelli - answer is.  Basically finds the square root using the ancient Babylonian algorithm, but restricting it to integer values while ignoring floating point. Done both for speed and extending the magnitudes of values that are testable. I used sets instead of lists because it takes far less time, I used bit shifts instead of division by two, and I smartly chose an initial start value much more efficiently. By the way, I did test Alex Martelli's recommended test number, as well as a few numbers many orders magnitude larger, such as: printed the following results: And it did this in 0.33 seconds. In my opinion, my algorithm works the same as Alex Martelli's, with all the benefits thereof, but has the added benefit highly efficient simple-test rejections that save a lot of time, not to mention the reduction in size of test numbers by powers of 4, which improves speed, efficiency, accuracy and the size of numbers that are testable. Probably especially true in non-Python implementations. Roughly 99% of all integers are rejected as non-Square before Babylonian root extraction is even implemented, and in 2/3 the time it would take the Babylonian to reject the integer. And though these tests dont speed up the process that significantly, the reduction in all test numbers to an odd by dividing out all powers of 4 really accelerates the Babylonian test. I did a time comparison test.  I tested all integers from 1 to 10 Million in succession.  Using just the Babylonian method by itself (with my specially tailored initial guess) it took my Surface 3 an average of 165 seconds (with 100% accuracy). Using just the logical tests in my algorithm (excluding the Babylonian), it took 127 seconds, it rejected 99% of all integers as non-Square without mistakenly rejecting any perfect squares. Of those integers that passed, only 3% were perfect Squares (a much higher density).  Using the full algorithm above that employs both the logical tests and the Babylonian root extraction, we have 100% accuracy, and test completion in only 14 seconds.  The first 100 Million integers takes roughly 2 minutes 45 seconds to test. EDIT: I have been able to bring down the time further. I can now test the integers 0 to 100 Million in 1 minute 40 seconds.  A lot of time is wasted checking the data type and the positivity.  Eliminate the very first two checks and I cut the experiment down by a minute.  One must assume the user is smart enough to know that negatives and floats are not perfect squares."}, {"id": 37565406, "score": 12, "vote": 0, "content": "<pre><code class=\"python\">import math\n\ndef is_square(n):\n    sqrt = math.sqrt(n)\n    return (sqrt - int(sqrt)) == 0\n</code></pre>\n<p>A perfect square is a number that can be expressed as the product of two equal integers. <code>math.sqrt(number)</code> return a <code>float</code>. <code>int(math.sqrt(number))</code> casts the outcome to <code>int</code>.</p>\n<p>If the square root is an integer, like 3, for example, then <code>math.sqrt(number) - int(math.sqrt(number))</code> will be 0, and the <code>if</code> statement will be <code>False</code>. If the square root was a real number like 3.2, then it will be <code>True</code> and print \"it's not a perfect square\".</p>\n<p><strong>It fails for</strong> a large non-square such as 152415789666209426002111556165263283035677490.</p>\n", "abstract": "A perfect square is a number that can be expressed as the product of two equal integers. math.sqrt(number) return a float. int(math.sqrt(number)) casts the outcome to int. If the square root is an integer, like 3, for example, then math.sqrt(number) - int(math.sqrt(number)) will be 0, and the if statement will be False. If the square root was a real number like 3.2, then it will be True and print \"it's not a perfect square\". It fails for a large non-square such as 152415789666209426002111556165263283035677490."}, {"id": 46499714, "score": 9, "vote": 0, "content": "<p>My answer is:</p>\n<pre><code class=\"python\">def is_square(x):\n    return x**.5 % 1 == 0\n</code></pre>\n<p>It basically does a square root, then modulo by 1 to strip the integer part and if the result is 0 return <code>True</code> otherwise return <code>False</code>. In this case x can be any large number, just not as large as the max float number that python can handle: 1.7976931348623157e+308</p>\n<p><strong>It is incorrect</strong> for a large non-square such as 152415789666209426002111556165263283035677490.</p>\n", "abstract": "My answer is: It basically does a square root, then modulo by 1 to strip the integer part and if the result is 0 return True otherwise return False. In this case x can be any large number, just not as large as the max float number that python can handle: 1.7976931348623157e+308 It is incorrect for a large non-square such as 152415789666209426002111556165263283035677490."}, {"id": 37957172, "score": 7, "vote": 0, "content": "<p>This can be solved using <a href=\"https://docs.python.org/3/library/decimal.html\" rel=\"noreferrer\">the <code>decimal</code> module</a> to get arbitrary precision square roots and easy checks for \"exactness\":</p>\n<pre><code class=\"python\">import math\nfrom decimal import localcontext, Context, Inexact\n\ndef is_perfect_square(x):\n    # If you want to allow negative squares, then set x = abs(x) instead\n    if x &lt; 0:\n        return False\n\n    # Create localized, default context so flags and traps unset\n    with localcontext(Context()) as ctx:\n        # Set a precision sufficient to represent x exactly; `x or 1` avoids\n        # math domain error for log10 when x is 0\n        ctx.prec = math.ceil(math.log10(x or 1)) + 1  # Wrap ceil call in int() on Py2\n        # Compute integer square root; don't even store result, just setting flags\n        ctx.sqrt(x).to_integral_exact()\n        # If previous line couldn't represent square root as exact int, sets Inexact flag\n        return not ctx.flags[Inexact]\n</code></pre>\n<p>For demonstration with truly huge values:</p>\n<pre><code class=\"python\"># I just kept mashing the numpad for awhile :-)\n&gt;&gt;&gt; base = 100009991439393999999393939398348438492389402490289028439083249803434098349083490340934903498034098390834980349083490384903843908309390282930823940230932490340983098349032098324908324098339779438974879480379380439748093874970843479280329708324970832497804329783429874329873429870234987234978034297804329782349783249873249870234987034298703249780349783497832497823497823497803429780324\n&gt;&gt;&gt; sqr = base ** 2\n&gt;&gt;&gt; sqr ** 0.5  # Too large to use floating point math\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nOverflowError: int too large to convert to float\n\n&gt;&gt;&gt; is_perfect_power(sqr)\nTrue\n&gt;&gt;&gt; is_perfect_power(sqr-1)\nFalse\n&gt;&gt;&gt; is_perfect_power(sqr+1)\nFalse\n</code></pre>\n<p>If you increase the size of the value being tested, this eventually gets rather slow (takes close to a second for a 200,000 bit square), but for more moderate numbers (say, 20,000 bits), it's still faster than a human would notice for individual values (~33 ms on my machine). But since speed wasn't your primary concern, this is a good way to do it with Python's standard libraries.</p>\n<p>Of course, it would be much faster to use <a href=\"https://pypi.python.org/pypi/gmpy2\" rel=\"noreferrer\"><code>gmpy2</code></a> and just test <code>gmpy2.mpz(x).is_square()</code>, but if third party packages aren't your thing, the above works quite well.</p>\n", "abstract": "This can be solved using the decimal module to get arbitrary precision square roots and easy checks for \"exactness\": For demonstration with truly huge values: If you increase the size of the value being tested, this eventually gets rather slow (takes close to a second for a 200,000 bit square), but for more moderate numbers (say, 20,000 bits), it's still faster than a human would notice for individual values (~33 ms on my machine). But since speed wasn't your primary concern, this is a good way to do it with Python's standard libraries. Of course, it would be much faster to use gmpy2 and just test gmpy2.mpz(x).is_square(), but if third party packages aren't your thing, the above works quite well."}, {"id": 5750280, "score": 6, "vote": 0, "content": "<p>I just posted a slight variation on some of the examples above on another thread (<a href=\"https://stackoverflow.com/questions/1547196/finding-perfect-square/5750159#5750159\">Finding perfect squares</a>) and thought I'd include a slight variation of what I posted there here (using nsqrt as a temporary variable), in case it's of interest / use:</p>\n<pre><code class=\"python\">import math\n\ndef is_square(n):\n  if not (isinstance(n, int) and (n &gt;= 0)):\n    return False \n  else:\n    nsqrt = math.sqrt(n)\n    return nsqrt == math.trunc(nsqrt)\n</code></pre>\n<p><strong>It is incorrect</strong> for a large non-square such as 152415789666209426002111556165263283035677490.</p>\n", "abstract": "I just posted a slight variation on some of the examples above on another thread (Finding perfect squares) and thought I'd include a slight variation of what I posted there here (using nsqrt as a temporary variable), in case it's of interest / use: It is incorrect for a large non-square such as 152415789666209426002111556165263283035677490."}, {"id": 45164692, "score": 2, "vote": 0, "content": "<p>This is my method:</p>\n<pre><code class=\"python\">def is_square(n) -&gt; bool:\n    return int(n**0.5)**2 == int(n)\n</code></pre>\n<p>Take square root of number. Convert to integer. Take the square. If the numbers are equal, then it is a perfect square otherwise not.</p>\n<p><strong>It is incorrect</strong> for a large square such as 152415789666209426002111556165263283035677489.</p>\n", "abstract": "This is my method: Take square root of number. Convert to integer. Take the square. If the numbers are equal, then it is a perfect square otherwise not. It is incorrect for a large square such as 152415789666209426002111556165263283035677489."}, {"id": 60121459, "score": 2, "vote": 0, "content": "<p>If the modulus (remainder) leftover from dividing by the square root is 0, then it is a perfect square.</p>\n<pre><code class=\"python\">def is_square(num: int) -&gt; bool:\n    return num % math.sqrt(num) == 0\n</code></pre>\n<p>I checked this against a list of perfect squares going up to 1000.</p>\n", "abstract": "If the modulus (remainder) leftover from dividing by the square root is 0, then it is a perfect square. I checked this against a list of perfect squares going up to 1000."}, {"id": 68528275, "score": 2, "vote": 0, "content": "<p>It is possible to improve the Babylonian method by observing that the successive terms form a decreasing sequence if one starts above the square root of n.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def is_square(n):\n    assert n &gt; 1\n    a = n\n    b = (a + n // a) // 2\n    while b &lt; a:\n        a = b\n        b = (a + n // a) // 2\n    return a * a == n\n</code></pre>\n", "abstract": "It is possible to improve the Babylonian method by observing that the successive terms form a decreasing sequence if one starts above the square root of n."}, {"id": 70547120, "score": 2, "vote": 0, "content": "<p>If it's a perfect square, its square root will be an integer, the fractional part will be 0, we can use modulus operator to check fractional part, and check if it's 0, it does fail for some numbers, so, for safety, we will also check if it's square of the square root even if the fractional part is 0.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import math\n\ndef isSquare(n):\n    root = math.sqrt(n)\n    if root % 1 == 0:\n        if int(root) * int(root) == n:\n            return True\n    return False\n\nisSquare(4761)\n</code></pre>\n", "abstract": "If it's a perfect square, its square root will be an integer, the fractional part will be 0, we can use modulus operator to check fractional part, and check if it's 0, it does fail for some numbers, so, for safety, we will also check if it's square of the square root even if the fractional part is 0."}, {"id": 2489474, "score": 1, "vote": 0, "content": "<p>You could binary-search for the rounded square root. Square the result to see if it matches the original value.</p>\n<p>You're probably better off with FogleBirds answer - though beware, as floating point arithmetic is approximate, which can throw this approach off. You could in principle get a false positive from a large integer which is one more than a perfect square, for instance, due to lost precision.</p>\n", "abstract": "You could binary-search for the rounded square root. Square the result to see if it matches the original value. You're probably better off with FogleBirds answer - though beware, as floating point arithmetic is approximate, which can throw this approach off. You could in principle get a false positive from a large integer which is one more than a perfect square, for instance, due to lost precision."}, {"id": 60667930, "score": 1, "vote": 0, "content": "<h1>A variant of @Alex Martelli's solution without <code>set</code></h1>\n<p>When <code>x in seen</code> is <code>True</code>:</p>\n<ul>\n<li>In most cases, it is the last one added, e.g. 1022 produces the <code>x</code>'s sequence  511, 256, 129, 68, 41, 32, <strong>31</strong>, <strong>31</strong>;</li>\n<li>In some cases (i.e., for the predecessors of perfect squares), it is the second-to-last one added, e.g. 1023 produces 511, 256, 129, 68, 41, <strong>32</strong>, 31, <strong>32</strong>.</li>\n</ul>\n<p>Hence, it suffices to stop as soon as the current <code>x</code> is greater than or equal to the previous one:</p>\n<pre><code class=\"python\">def is_square(n):\n    assert n &gt; 1\n    previous = n\n    x = n // 2\n    while x * x != n:\n        x = (x + (n // x)) // 2\n        if x &gt;= previous:\n            return False\n        previous = x\n    return True\n\nx = 12345678987654321234567 ** 2\nassert not is_square(x-1)\nassert is_square(x)\nassert not is_square(x+1)\n</code></pre>\n<p>Equivalence with the original algorithm tested for 1 &lt; n &lt; 10**7. On the same interval, this slightly simpler variant is about 1.4 times faster.</p>\n", "abstract": "When x in seen is True: Hence, it suffices to stop as soon as the current x is greater than or equal to the previous one: Equivalence with the original algorithm tested for 1 < n < 10**7. On the same interval, this slightly simpler variant is about 1.4 times faster."}, {"id": 72445589, "score": 1, "vote": 0, "content": "<p>A simple way to do it (faster than the second one) :</p>\n<pre><code class=\"python\">def is_square(n):  \n     return str(n**(1/2)).split(\".\")[1] == '0'\n</code></pre>\n<p>Another way:</p>\n<pre><code class=\"python\">def is_square(n):   \n    if n == 0:\n        return True\n    else:\n        if n % 2 == 0 :\n            for i in range(2,n,2):\n                if i*i == n:\n                    return True\n        else :\n            for i in range(1,n,2):\n                if i*i == n:\n                    return True\n    return False\n</code></pre>\n", "abstract": "A simple way to do it (faster than the second one) : Another way:"}, {"id": 2497133, "score": 0, "vote": 0, "content": "<p>This response doesn't pertain to your stated question, but to an implicit question I see in the code you posted, ie, \"how to check if something is an integer?\"</p>\n<p>The first answer you'll generally get to that question is \"Don't!\" And it's true that in Python, typechecking is usually not the right thing to do.</p>\n<p>For those rare exceptions, though, instead of looking for a decimal point in the string representation of the number, the thing to do is use the <em>isinstance</em> function:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; isinstance(5,int)\nTrue\n&gt;&gt;&gt; isinstance(5.0,int)\nFalse\n</code></pre>\n<p>Of course this applies to the variable rather than a value. If I wanted to determine whether the <em>value</em> was an integer, I'd do this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x=5.0\n&gt;&gt;&gt; round(x) == x\nTrue\n</code></pre>\n<p>But as everyone else has covered in detail, there are floating-point issues to be considered in most non-toy examples of this kind of thing.</p>\n", "abstract": "This response doesn't pertain to your stated question, but to an implicit question I see in the code you posted, ie, \"how to check if something is an integer?\" The first answer you'll generally get to that question is \"Don't!\" And it's true that in Python, typechecking is usually not the right thing to do. For those rare exceptions, though, instead of looking for a decimal point in the string representation of the number, the thing to do is use the isinstance function: Of course this applies to the variable rather than a value. If I wanted to determine whether the value was an integer, I'd do this: But as everyone else has covered in detail, there are floating-point issues to be considered in most non-toy examples of this kind of thing."}, {"id": 41945204, "score": 0, "vote": 0, "content": "<p>If you want to loop over a range and do something for every number that is NOT a perfect square, you could do something like this:</p>\n<pre><code class=\"python\">def non_squares(upper):\n    next_square = 0\n    diff = 1\n    for i in range(0, upper):\n        if i == next_square:\n            next_square += diff\n            diff += 2\n            continue\n        yield i\n</code></pre>\n<p>If you want to do something for every number that IS a perfect square, the generator is even easier:</p>\n<pre><code class=\"python\">(n * n for n in range(upper))\n</code></pre>\n", "abstract": "If you want to loop over a range and do something for every number that is NOT a perfect square, you could do something like this: If you want to do something for every number that IS a perfect square, the generator is even easier:"}, {"id": 45914080, "score": 0, "vote": 0, "content": "<p>I think that this works and is very simple: </p>\n<pre><code class=\"python\">import math\n\ndef is_square(num):\n    sqrt = math.sqrt(num)\n    return sqrt == int(sqrt)\n</code></pre>\n<p><strong>It is incorrect</strong> for a large non-square such as 152415789666209426002111556165263283035677490.</p>\n", "abstract": "I think that this works and is very simple:  It is incorrect for a large non-square such as 152415789666209426002111556165263283035677490."}, {"id": 61664309, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">a=int(input('enter any number'))\nflag=0\nfor i in range(1,a):\n    if a==i*i:\n        print(a,'is perfect square number')\n        flag=1\n        break\nif flag==1:\n    pass\nelse:\n    print(a,'is not perfect square number')\n</code></pre>\n", "abstract": ""}, {"id": 72180860, "score": 0, "vote": 0, "content": "<p>In kotlin :</p>\n<p>It's quite easy and it passed all test cases as well.</p>\n<p>really thanks to &gt;&gt;  <a href=\"https://%20https://www.quora.com/What-is-the-quickest-way-to-determine-if-a-number-is-a-perfect-square\" rel=\"nofollow noreferrer\">https://www.quora.com/What-is-the-quickest-way-to-determine-if-a-number-is-a-perfect-square</a></p>\n<pre><code class=\"python\">fun isPerfectSquare(num: Int): Boolean {\n    var result = false\n    \n    var sum=0L\n    var oddNumber=1L\n    \n     while(sum&lt;num){\n         sum = sum + oddNumber\n         oddNumber = oddNumber+2\n     }\n     \n    result = sum == num.toLong()\n    \n return result   \n}\n</code></pre>\n", "abstract": "In kotlin : It's quite easy and it passed all test cases as well. really thanks to >>  https://www.quora.com/What-is-the-quickest-way-to-determine-if-a-number-is-a-perfect-square"}, {"id": 72398551, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">def isPerfectSquare(self, num: int) -&gt; bool:\n    left, right = 0, num\n    while left &lt;= right:\n        mid = (left + right) // 2\n        if mid**2 &lt; num:\n            left = mid + 1\n        elif mid**2 &gt; num:\n            right = mid - 1\n        else:\n            return True\n    return False\n</code></pre>\n", "abstract": ""}, {"id": 2489814, "score": -1, "vote": 0, "content": "<ol>\n<li>Decide how long the number will be.</li>\n<li>take a delta 0.000000000000.......000001</li>\n<li>see if the (sqrt(x))^2 - x is greater / equal /smaller than delta and decide based on the delta error.</li>\n</ol>\n", "abstract": ""}, {"id": 42746012, "score": -3, "vote": 0, "content": "<pre><code class=\"python\">import math\n\ndef is_square(n):\n    sqrt = math.sqrt(n)\n    return sqrt == int(sqrt)\n</code></pre>\n<p><strong>It fails for</strong> a large non-square such as 152415789666209426002111556165263283035677490.</p>\n", "abstract": "It fails for a large non-square such as 152415789666209426002111556165263283035677490."}, {"id": 61773185, "score": -3, "vote": 0, "content": "<p>The idea is to run a loop from i = 1 to floor(sqrt(n)) then check if squaring it makes n.</p>\n<pre><code class=\"python\">bool isPerfectSquare(int n) \n{ \n    for (int i = 1; i * i &lt;= n; i++) { \n\n        // If (i * i = n) \n        if ((n % i == 0) &amp;&amp; (n / i == i)) { \n            return true; \n        } \n    } \n    return false; \n} \n</code></pre>\n", "abstract": "The idea is to run a loop from i = 1 to floor(sqrt(n)) then check if squaring it makes n."}]}, {"link": "https://stackoverflow.com/questions/1119722/base-62-conversion", "question": {"id": "1119722", "title": "Base 62 conversion", "content": "<p>How would you convert an integer to base 62 (like hexadecimal, but with these digits: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ').</p>\n<p>I have been trying to find a good Python library for it, but they all seems to be occupied with converting strings. The Python base64 module only accepts strings and turns a single digit into four characters. I was looking for something akin to what URL shorteners use.</p>\n", "abstract": "How would you convert an integer to base 62 (like hexadecimal, but with these digits: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'). I have been trying to find a good Python library for it, but they all seems to be occupied with converting strings. The Python base64 module only accepts strings and turns a single digit into four characters. I was looking for something akin to what URL shorteners use."}, "answers": [{"id": 1119769, "score": 193, "vote": 0, "content": "<p>There is no standard module for this, but I have written my own functions to achieve that.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">BASE62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\ndef encode(num, alphabet):\n    \"\"\"Encode a positive number into Base X and return the string.\n\n    Arguments:\n    - `num`: The number to encode\n    - `alphabet`: The alphabet to use for encoding\n    \"\"\"\n    if num == 0:\n        return alphabet[0]\n    arr = []\n    arr_append = arr.append  # Extract bound-method for faster access.\n    _divmod = divmod  # Access to locals is faster.\n    base = len(alphabet)\n    while num:\n        num, rem = _divmod(num, base)\n        arr_append(alphabet[rem])\n    arr.reverse()\n    return ''.join(arr)\n\ndef decode(string, alphabet=BASE62):\n    \"\"\"Decode a Base X encoded string into the number\n\n    Arguments:\n    - `string`: The encoded string\n    - `alphabet`: The alphabet to use for decoding\n    \"\"\"\n    base = len(alphabet)\n    strlen = len(string)\n    num = 0\n\n    idx = 0\n    for char in string:\n        power = (strlen - (idx + 1))\n        num += alphabet.index(char) * (base ** power)\n        idx += 1\n\n    return num\n</code></pre>\n<p>Notice the fact that you can give it any alphabet to use for encoding and decoding. If you leave the <code>alphabet</code> argument out, you are going to get the 62 character alphabet defined on the first line of code, and hence encoding/decoding to/from 62 base.</p>\n<p>Hope this helps.</p>\n<p>PS - For URL shorteners, I have found that it's better to leave out a few confusing characters like 0Ol1oI etc. Thus I use this alphabet for my URL shortening needs - <code>\"23456789abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"</code></p>\n<p>Have fun.</p>\n", "abstract": "There is no standard module for this, but I have written my own functions to achieve that. Notice the fact that you can give it any alphabet to use for encoding and decoding. If you leave the alphabet argument out, you are going to get the 62 character alphabet defined on the first line of code, and hence encoding/decoding to/from 62 base. Hope this helps. PS - For URL shorteners, I have found that it's better to leave out a few confusing characters like 0Ol1oI etc. Thus I use this alphabet for my URL shortening needs - \"23456789abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\" Have fun."}, {"id": 2549514, "score": 59, "vote": 0, "content": "<p>I once wrote a script to do this aswell, I think it's quite elegant :)</p>\n<pre><code class=\"python\">import string\n# Remove the `_@` below for base62, now it has 64 characters\nBASE_LIST = string.digits + string.letters + '_@'\nBASE_DICT = dict((c, i) for i, c in enumerate(BASE_LIST))\n\ndef base_decode(string, reverse_base=BASE_DICT):\n    length = len(reverse_base)\n    ret = 0\n    for i, c in enumerate(string[::-1]):\n        ret += (length ** i) * reverse_base[c]\n\n    return ret\n\ndef base_encode(integer, base=BASE_LIST):\n    if integer == 0:\n        return base[0]\n\n    length = len(base)\n    ret = ''\n    while integer != 0:\n        ret = base[integer % length] + ret\n        integer /= length\n\n    return ret\n</code></pre>\n<p>Example usage:</p>\n<pre><code class=\"python\">for i in range(100):                                    \n    print i, base_decode(base_encode(i)), base_encode(i)\n</code></pre>\n", "abstract": "I once wrote a script to do this aswell, I think it's quite elegant :) Example usage:"}, {"id": 1487304, "score": 10, "vote": 0, "content": "<p>The following decoder-maker works with any reasonable base, has a much tidier loop, and gives an explicit error message when it meets an invalid character.</p>\n<pre><code class=\"python\">def base_n_decoder(alphabet):\n    \"\"\"Return a decoder for a base-n encoded string\n    Argument:\n    - `alphabet`: The alphabet used for encoding\n    \"\"\"\n    base = len(alphabet)\n    char_value = dict(((c, v) for v, c in enumerate(alphabet)))\n    def f(string):\n        num = 0\n        try:\n            for char in string:\n                num = num * base + char_value[char]\n        except KeyError:\n            raise ValueError('Unexpected character %r' % char)\n        return num\n    return f\n\nif __name__ == \"__main__\":\n    func = base_n_decoder('0123456789abcdef')\n    for test in ('0', 'f', '2020', 'ffff', 'abqdef'):\n        print test\n        print func(test)\n</code></pre>\n", "abstract": "The following decoder-maker works with any reasonable base, has a much tidier loop, and gives an explicit error message when it meets an invalid character."}, {"id": 14259141, "score": 9, "vote": 0, "content": "<p>If you're looking for the highest efficiency (like django), you'll want something like the following. This code is a combination of efficient methods from Baishampayan Ghose and WoLpH and John Machin.</p>\n<pre><code class=\"python\"># Edit this list of characters as desired.\nBASE_ALPH = tuple(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\")\nBASE_DICT = dict((c, v) for v, c in enumerate(BASE_ALPH))\nBASE_LEN = len(BASE_ALPH)\n\ndef base_decode(string):\n    num = 0\n    for char in string:\n        num = num * BASE_LEN + BASE_DICT[char]\n    return num\n\ndef base_encode(num):\n    if not num:\n        return BASE_ALPH[0]\n\n    encoding = \"\"\n    while num:\n        num, rem = divmod(num, BASE_LEN)\n        encoding = BASE_ALPH[rem] + encoding\n    return encoding\n</code></pre>\n<p>You may want to also calculate your dictionary in advance. (Note: Encoding with a string shows more efficiency than with a list, even with very long numbers.)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; timeit.timeit(\"for i in xrange(1000000): base.base_decode(base.base_encode(i))\", setup=\"import base\", number=1)\n2.3302059173583984\n</code></pre>\n<p>Encoded and decoded 1 million numbers in under 2.5 seconds. (2.2Ghz i7-2670QM)</p>\n", "abstract": "If you're looking for the highest efficiency (like django), you'll want something like the following. This code is a combination of efficient methods from Baishampayan Ghose and WoLpH and John Machin. You may want to also calculate your dictionary in advance. (Note: Encoding with a string shows more efficiency than with a list, even with very long numbers.) Encoded and decoded 1 million numbers in under 2.5 seconds. (2.2Ghz i7-2670QM)"}, {"id": 48315905, "score": 7, "vote": 0, "content": "<p>If you use django framework, you can use django.utils.baseconv module.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from django.utils import baseconv\n&gt;&gt;&gt; baseconv.base62.encode(1234567890)\n1LY7VK\n</code></pre>\n<p>In addition to base62, baseconv also defined base2/base16/base36/base56/base64.</p>\n", "abstract": "If you use django framework, you can use django.utils.baseconv module. In addition to base62, baseconv also defined base2/base16/base36/base56/base64."}, {"id": 4634454, "score": 4, "vote": 0, "content": "<p>If all you need is to generate a short ID (since you mention URL shorteners) rather than encode/decode something, this module might help:</p>\n<p><a href=\"https://github.com/stochastic-technologies/shortuuid/\" rel=\"nofollow\">https://github.com/stochastic-technologies/shortuuid/</a></p>\n", "abstract": "If all you need is to generate a short ID (since you mention URL shorteners) rather than encode/decode something, this module might help: https://github.com/stochastic-technologies/shortuuid/"}, {"id": 1119762, "score": 3, "vote": 0, "content": "<p>You probably want base64, not base62. There's an URL-compatible version of it floating around, so the extra two filler characters shouldn't be a problem.</p>\n<p>The process is fairly simple; consider that base64 represents 6 bits and a regular byte represents 8. Assign a value from 000000 to 111111 to each of the 64 characters chosen, and put the 4 values together to match a set of 3 base256 bytes. Repeat for each set of 3 bytes, padding at the end with your choice of padding character (0 is generally useful).</p>\n", "abstract": "You probably want base64, not base62. There's an URL-compatible version of it floating around, so the extra two filler characters shouldn't be a problem. The process is fairly simple; consider that base64 represents 6 bits and a regular byte represents 8. Assign a value from 000000 to 111111 to each of the 64 characters chosen, and put the 4 values together to match a set of 3 base256 bytes. Repeat for each set of 3 bytes, padding at the end with your choice of padding character (0 is generally useful)."}, {"id": 30479452, "score": 3, "vote": 0, "content": "<p>There is now a python library for this.</p>\n<p>I'm working on making a pip package for this.</p>\n<p>I recommend you use my bases.py <a href=\"https://github.com/kamijoutouma/bases.py\" rel=\"nofollow\">https://github.com/kamijoutouma/bases.py</a> which was inspired by bases.js</p>\n<pre><code class=\"python\">from bases import Bases\nbases = Bases()\n\nbases.toBase16(200)                // =&gt; 'c8'\nbases.toBase(200, 16)              // =&gt; 'c8'\nbases.toBase62(99999)              // =&gt; 'q0T'\nbases.toBase(200, 62)              // =&gt; 'q0T'\nbases.toAlphabet(300, 'aAbBcC')    // =&gt; 'Abba'\n\nbases.fromBase16('c8')               // =&gt; 200\nbases.fromBase('c8', 16)             // =&gt; 200\nbases.fromBase62('q0T')              // =&gt; 99999\nbases.fromBase('q0T', 62)            // =&gt; 99999\nbases.fromAlphabet('Abba', 'aAbBcC') // =&gt; 300\n</code></pre>\n<p>refer to <a href=\"https://github.com/kamijoutouma/bases.py#known-basesalphabets\" rel=\"nofollow\">https://github.com/kamijoutouma/bases.py#known-basesalphabets</a>\nfor what bases are usable</p>\n", "abstract": "There is now a python library for this. I'm working on making a pip package for this. I recommend you use my bases.py https://github.com/kamijoutouma/bases.py which was inspired by bases.js refer to https://github.com/kamijoutouma/bases.py#known-basesalphabets\nfor what bases are usable"}, {"id": 1119967, "score": 2, "vote": 0, "content": "<p>you can download zbase62 module from <a href=\"http://pypi.python.org/pypi/zbase62\" rel=\"nofollow noreferrer\">pypi</a></p>\n<p>eg </p>\n<pre><code class=\"python\">&gt;&gt;&gt; import zbase62\n&gt;&gt;&gt; zbase62.b2a(\"abcd\")\n'1mZPsa'\n</code></pre>\n", "abstract": "you can download zbase62 module from pypi eg "}, {"id": 4728421, "score": 2, "vote": 0, "content": "<p>I have benefited greatly from others' posts here. I needed the python code originally for a Django project, but since then I have turned to node.js, so here's a <strong><em>javascript version</em></strong> of the code (the encoding part) that Baishampayan Ghose provided.</p>\n<pre><code class=\"python\">var ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nfunction base62_encode(n, alpha) {\n  var num = n || 0;\n  var alphabet = alpha || ALPHABET;\n\n  if (num == 0) return alphabet[0];\n  var arr = [];\n  var base = alphabet.length;\n\n  while(num) {\n    rem = num % base;\n    num = (num - rem)/base;\n    arr.push(alphabet.substring(rem,rem+1));\n  }\n\n  return arr.reverse().join('');\n}\n\nconsole.log(base62_encode(2390687438976, \"123456789ABCDEFGHIJKLMNPQRSTUVWXYZ\"));\n</code></pre>\n", "abstract": "I have benefited greatly from others' posts here. I needed the python code originally for a Django project, but since then I have turned to node.js, so here's a javascript version of the code (the encoding part) that Baishampayan Ghose provided."}, {"id": 16945658, "score": 2, "vote": 0, "content": "<p>I hope the following snippet could help. </p>\n<pre><code class=\"python\">def num2sym(num, sym, join_symbol=''):\n    if num == 0:\n        return sym[0]\n    if num &lt; 0 or type(num) not in (int, long):\n        raise ValueError('num must be positive integer')\n\n    l = len(sym)  # target number base\n    r = []\n    div = num\n    while div != 0: # base conversion\n        div, mod = divmod(div, l)\n        r.append(sym[mod])\n\n    return join_symbol.join([x for x in reversed(r)])\n</code></pre>\n<p>Usage for your case:</p>\n<pre><code class=\"python\">number = 367891\nalphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\nprint num2sym(number, alphabet)  # will print '1xHJ'\n</code></pre>\n<p>Obviously, you can specify another alphabet, consisting of lesser or greater number of symbols, then it will convert your number to the lesser or greater number base. For example, providing '01' as an alphabet will output string representing input number as binary.</p>\n<p>You may shuffle the alphabet initially to have your unique representation of the numbers. It can be helpful if you're making URL shortener service.</p>\n", "abstract": "I hope the following snippet could help.  Usage for your case: Obviously, you can specify another alphabet, consisting of lesser or greater number of symbols, then it will convert your number to the lesser or greater number base. For example, providing '01' as an alphabet will output string representing input number as binary. You may shuffle the alphabet initially to have your unique representation of the numbers. It can be helpful if you're making URL shortener service."}, {"id": 36875787, "score": 2, "vote": 0, "content": "<p>Here's my solution:</p>\n<pre><code class=\"python\">def base62(a):\n    baseit = (lambda a=a, b=62: (not a) and '0' or\n        baseit(a-a%b, b*62) + '0123456789abcdefghijklmnopqrstuvwxyz'\n                              'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[a%b%61 or -1*bool(a%b)])\n    return baseit()\n</code></pre>\n<hr/>\n<h2>explanation</h2>\n<p>In any base every number is equal to <code> a1+a2*base**2+a3*base**3...</code> So the goal is to find  all the <code>a</code>s.</p>\n<p>For every <code>N=1,2,3...</code> the code isolates the <code>aN*base**N</code> by \"moduloing\" by <code>b</code> for <code>b=base**(N+1)</code> which slices all <code>a</code>s bigger than <code>N</code>, and slicing all the <code>a</code>s so that their serial is smaller than <code>N</code> by decreasing <code>a</code> everytime the function is called recursively by the current <code>aN*base**N</code>.</p>\n<p><code>Base%(base-1)==1</code> therefore <code>base**p%(base-1)==1</code> and therefore <code>q*base^p%(base-1)==q</code> with only one exception, when <code>q==base-1</code> which returns <code>0</code>. To fix that case it returns <code>0</code>. The function checks for <code>0</code> from the beginning.</p>\n<hr/>\n<h2>advantages</h2>\n<p>In this sample there's only one multiplication (instead of a division) and some modulus operations, which are all relatively fast.</p>\n", "abstract": "Here's my solution: In any base every number is equal to  a1+a2*base**2+a3*base**3... So the goal is to find  all the as. For every N=1,2,3... the code isolates the aN*base**N by \"moduloing\" by b for b=base**(N+1) which slices all as bigger than N, and slicing all the as so that their serial is smaller than N by decreasing a everytime the function is called recursively by the current aN*base**N. Base%(base-1)==1 therefore base**p%(base-1)==1 and therefore q*base^p%(base-1)==q with only one exception, when q==base-1 which returns 0. To fix that case it returns 0. The function checks for 0 from the beginning. In this sample there's only one multiplication (instead of a division) and some modulus operations, which are all relatively fast."}, {"id": 61646764, "score": 2, "vote": 0, "content": "<p>Simplest ever.</p>\n<pre><code class=\"python\">BASE62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\ndef encode_base62(num):\n    s = \"\"\n    while num&gt;0:\n      num,r = divmod(num,62)\n      s = BASE62[r]+s\n    return s\n\n\ndef decode_base62(num):\n   x,s = 1,0\n   for i in range(len(num)-1,-1,-1):\n      s = int(BASE62.index(num[i])) *x + s\n      x*=62\n   return s\n\nprint(encode_base62(123))\nprint(decode_base62(\"1Z\"))\n</code></pre>\n", "abstract": "Simplest ever."}, {"id": 1123373, "score": 1, "vote": 0, "content": "<p>Personally I like the solution from Baishampayan, mostly because of stripping the confusing characters.</p>\n<p>For completeness, and solution with better performance, <a href=\"http://fi.am/entry/urlsafe-base64-encodingdecoding-in-two-lines/\" rel=\"nofollow noreferrer\">this post</a> shows a way to use the Python base64 module.</p>\n", "abstract": "Personally I like the solution from Baishampayan, mostly because of stripping the confusing characters. For completeness, and solution with better performance, this post shows a way to use the Python base64 module."}, {"id": 5137148, "score": 1, "vote": 0, "content": "<p>I wrote this a while back and it's worked pretty well (negatives and all included)</p>\n<pre><code class=\"python\">def code(number,base):\n    try:\n        int(number),int(base)\n    except ValueError:\n        raise ValueError('code(number,base): number and base must be in base10')\n    else:\n        number,base = int(number),int(base)\n    if base &lt; 2:\n        base = 2\n    if base &gt; 62:\n        base = 62\n    numbers = [0,1,2,3,4,5,6,7,8,9,\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\n               \"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\n               \"z\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\n               \"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\n    final = \"\"\n    loc = 0\n    if number &lt; 0:\n        final = \"-\"\n        number = abs(number)\n    while base**loc &lt;= number:\n        loc = loc + 1\n    for x in range(loc-1,-1,-1):\n        for y in range(base-1,-1,-1):\n            if y*(base**x) &lt;= number:\n                final = \"{}{}\".format(final,numbers[y])\n                number = number - y*(base**x)\n                break\n    return final\n\ndef decode(number,base):\n    try:\n        int(base)\n    except ValueError:\n        raise ValueError('decode(value,base): base must be in base10')\n    else:\n        base = int(base)\n    number = str(number)\n    if base &lt; 2:\n        base = 2\n    if base &gt; 62:\n        base = 62\n    numbers = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\n               \"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\n               \"w\",\"x\",\"y\",\"z\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\n               \"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"]\n    final = 0\n    if number.startswith(\"-\"):\n        neg = True\n        number = list(number)\n        del(number[0])\n        temp = number\n        number = \"\"\n        for x in temp:\n            number = \"{}{}\".format(number,x)\n    else:\n        neg = False\n    loc = len(number)-1\n    number = str(number)\n    for x in number:\n        if numbers.index(x) &gt; base:\n            raise ValueError('{} is out of base{} range'.format(x,str(base)))\n        final = final+(numbers.index(x)*(base**loc))\n        loc = loc - 1\n    if neg:\n        return -final\n    else:\n        return final\n</code></pre>\n<p>sorry about the length of it all</p>\n", "abstract": "I wrote this a while back and it's worked pretty well (negatives and all included) sorry about the length of it all"}, {"id": 15694685, "score": 1, "vote": 0, "content": "<pre><code class=\"python\">BASE_LIST = tuple(\"23456789ABCDEFGHJKLMNOPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz\")\nBASE_DICT = dict((c, v) for v, c in enumerate(BASE_LIST))\nBASE_LEN = len(BASE_LIST)\n\ndef nice_decode(str):\n    num = 0\n    for char in str[::-1]:\n        num = num * BASE_LEN + BASE_DICT[char]\n    return num\n\ndef nice_encode(num):\n    if not num:\n        return BASE_LIST[0]\n\n    encoding = \"\"\n    while num:\n        num, rem = divmod(num, BASE_LEN)\n        encoding += BASE_LIST[rem]\n    return encoding\n</code></pre>\n", "abstract": ""}, {"id": 26386020, "score": 1, "vote": 0, "content": "<p>Here is an recurive and iterative way to do that. The iterative one is a little faster depending on the count of execution.</p>\n<pre><code class=\"python\">def base62_encode_r(dec):\n    s = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    return s[dec] if dec &lt; 62 else base62_encode_r(dec / 62) + s[dec % 62]\nprint base62_encode_r(2347878234)\n\ndef base62_encode_i(dec):\n    s = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    ret = ''\n    while dec &gt; 0:\n        ret = s[dec % 62] + ret\n        dec /= 62\n    return ret\nprint base62_encode_i(2347878234)\n\ndef base62_decode_r(b62):\n    s = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    if len(b62) == 1:\n        return s.index(b62)\n    x = base62_decode_r(b62[:-1]) * 62 + s.index(b62[-1:]) % 62\n    return x\nprint base62_decode_r(\"2yTsnM\")\n\ndef base62_decode_i(b62):\n    s = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    ret = 0\n    for i in xrange(len(b62)-1,-1,-1):\n        ret = ret + s.index(b62[i]) * (62**(len(b62)-i-1))\n    return ret\nprint base62_decode_i(\"2yTsnM\")\n\nif __name__ == '__main__':\n    import timeit\n    print(timeit.timeit(stmt=\"base62_encode_r(2347878234)\", setup=\"from __main__ import base62_encode_r\", number=100000))\n    print(timeit.timeit(stmt=\"base62_encode_i(2347878234)\", setup=\"from __main__ import base62_encode_i\", number=100000))\n    print(timeit.timeit(stmt=\"base62_decode_r('2yTsnM')\", setup=\"from __main__ import base62_decode_r\", number=100000))\n    print(timeit.timeit(stmt=\"base62_decode_i('2yTsnM')\", setup=\"from __main__ import base62_decode_i\", number=100000))\n\n0.270266867033\n0.260915645986\n0.344734796766\n0.311662500262\n</code></pre>\n", "abstract": "Here is an recurive and iterative way to do that. The iterative one is a little faster depending on the count of execution."}, {"id": 58110013, "score": 1, "vote": 0, "content": "<h2>Python <code>3.7.x</code></h2>\n<p>I found a PhD's github for some algorithms when looking for an <a href=\"https://github.com/DoctorLai/Algorithms/blob/afa74f27469abb43c64258b119f6c330b9e92b6b/Base62/base62.py\" rel=\"nofollow noreferrer\">existing base62 script</a>. It didn't work for the current max-version of Python 3 at this time so I went ahead and fixed where needed and did a little refactoring. I don't usually work with Python and have always used it ad-hoc so YMMV. All credit goes to <a href=\"https://stackoverflow.com/cv/steakovercooked\">Dr. Zhihua Lai</a>. I just worked the kinks out for this version of Python. </p>\n<h3>file <code>base62.py</code></h3>\n<pre><code class=\"python\">#modified from Dr. Zhihua Lai's original on GitHub\nfrom math import floor\nbase = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\nb = 62;\ndef toBase10(b62: str) -&gt; int:\n    limit = len(b62)\n    res = 0\n    for i in range(limit):\n        res = b * res + base.find(b62[i])\n    return res\ndef toBase62(b10: int) -&gt; str:\n    if b &lt;= 0 or b &gt; 62:\n        return 0\n    r = b10 % b\n    res = base[r];\n    q = floor(b10 / b)\n    while q:\n        r = q % b\n        q = floor(q / b)\n        res = base[int(r)] + res\n    return res\n</code></pre>\n<h3>file <code>try_base62.py</code></h3>\n<pre><code class=\"python\">import base62\nprint(\"Base10 ==&gt; Base62\")\nfor i in range(999):\n    print(f'{i} =&gt; {base62.toBase62(i)}')\nbase62_samples = [\"gud\", \"GA\", \"mE\", \"lo\", \"lz\", \"OMFGWTFLMFAOENCODING\"]\nprint(\"Base62 ==&gt; Base10\")\nfor i in range(len(base62_samples)):\n    print(f'{base62_samples[i]} =&gt; {base62.toBase10(base62_samples[i])}')\n</code></pre>\n<h2>output of <code>try_base62.py</code></h2>\n<blockquote>\n<p><code>Base10 ==&gt; Base62</code> <br/>\n<code>0 =&gt; 0</code> <br/>\n<code>[...]</code> <br/>\n<code>998 =&gt; g6</code> <br/>\n<code>Base62 ==&gt; Base10</code> <br/>\n<code>gud =&gt; 63377</code> <br/>\n<code>GA =&gt; 2640</code> <br/>\n<code>mE =&gt; 1404</code> <br/>\n<code>lo =&gt; 1326</code> <br/>\n<code>lz =&gt; 1337</code> <br/>\n<code>OMFGWTFLMFAOENCODING =&gt; 577002768656147353068189971419611424</code></p>\n</blockquote>\n<p><sub><sup>Since there was no licensing info in the repo I did submit a <a href=\"https://github.com/DoctorLai/Algorithms/pull/1\" rel=\"nofollow noreferrer\">PR</a> so the original author at least knows other people are using and modifying their code.</sup></sub></p>\n", "abstract": "I found a PhD's github for some algorithms when looking for an existing base62 script. It didn't work for the current max-version of Python 3 at this time so I went ahead and fixed where needed and did a little refactoring. I don't usually work with Python and have always used it ad-hoc so YMMV. All credit goes to Dr. Zhihua Lai. I just worked the kinks out for this version of Python.  Base10 ==> Base62 \n0 => 0 \n[...] \n998 => g6 \nBase62 ==> Base10 \ngud => 63377 \nGA => 2640 \nmE => 1404 \nlo => 1326 \nlz => 1337 \nOMFGWTFLMFAOENCODING => 577002768656147353068189971419611424 Since there was no licensing info in the repo I did submit a PR so the original author at least knows other people are using and modifying their code."}, {"id": 73518400, "score": 1, "vote": 0, "content": "<p>In all solutions above they define the alphabet itself when in reality it's already available using the ASCII codes.</p>\n<pre><code class=\"python\">def converter_base62(count) -&gt; str:\n   result = ''\n   start = ord('0')\n   while count &gt; 0:\n      result = chr(count % 62 + start) + result\n      count //= 62\n   return result\n\n\ndef decode_base62(string_to_decode: str):\n    result = 0\n    start = ord('0')\n    for char in string_to_decode:\n        result = result * 62 + (ord(char)-start)\n    return result\n\nimport tqdm\n\nn = 10_000_000\n\nfor i in tqdm.tqdm(range(n)):\n    assert decode_base62(converter_base62(i)) == i\n</code></pre>\n", "abstract": "In all solutions above they define the alphabet itself when in reality it's already available using the ASCII codes."}, {"id": 1119768, "score": 0, "vote": 0, "content": "<p>Sorry, I can't help you with a library here. I would prefer using base64 and just adding to extra characters to your choice -- if possible!</p>\n<p>Then you can use the base64 module.</p>\n<p>If this is really, really not possible:</p>\n<p>You can do it yourself this way (this is pseudo-code):</p>\n<pre><code class=\"python\">base62vals = []\nmyBase = 62\nwhile num &gt; 0:\n   reminder = num % myBase\n   num = num / myBase\n   base62vals.insert(0, reminder)\n</code></pre>\n", "abstract": "Sorry, I can't help you with a library here. I would prefer using base64 and just adding to extra characters to your choice -- if possible! Then you can use the base64 module. If this is really, really not possible: You can do it yourself this way (this is pseudo-code):"}, {"id": 57069184, "score": 0, "vote": 0, "content": "<p>with simple recursion</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">\"\"\"\nThis module contains functions to transform a number to string and vice-versa\n\"\"\"\nBASE = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nLEN_BASE = len(BASE)\n\n\ndef encode(num):\n    \"\"\"\n    This function encodes the given number into alpha numeric string\n    \"\"\"\n\n    if num &lt; LEN_BASE:\n        return BASE[num]\n\n    return BASE[num % LEN_BASE] + encode(num//LEN_BASE)\n\n\ndef decode_recursive(string, index):\n    \"\"\"\n    recursive util function for decode\n    \"\"\"\n\n    if not string or index &gt;= len(string):\n        return 0\n\n    return (BASE.index(string[index]) * LEN_BASE ** index) + decode_recursive(string, index + 1)\n\n\ndef decode(string):\n    \"\"\"\n    This function decodes given string to number\n    \"\"\"\n\n    return decode_recursive(string, 0)\n\n</code></pre>\n", "abstract": "with simple recursion"}, {"id": 66403240, "score": 0, "vote": 0, "content": "<p>Benchmarking answers that worked for Python3 (machine: i7-8565U):</p>\n<pre><code class=\"python\">\"\"\"\nus per enc()+dec()  #  test\n\n(4.477935791015625, 2, '3Tx16Db2JPSS4ZdQ4dp6oW')\n(6.073190927505493, 5, '3Tx16Db2JPSS4ZdQ4dp6oW')\n(9.051250696182251, 9, '3Tx16Db2JPSS4ZdQ4dp6oW')\n(9.864609956741333, 6, '3Tx16Db2JOOqeo6GCGscmW')\n(10.868197917938232, 1, '3Tx16Db2JPSS4ZdQ4dp6oW')\n(11.018349647521973, 10, '3Tx16Db2JPSS4ZdQ4dp6oW')\n(12.448230504989624, 4, '03Tx16Db2JPSS4ZdQ4dp6oW')\n(13.016672611236572, 7, '3Tx16Db2JPSS4ZdQ4dp6oW')\n(13.212724447250366, 8, '3Tx16Db2JPSS4ZdQ4dp6oW')\n(24.119479656219482, 3, '3tX16dB2jpss4zDq4DP6Ow')\n\"\"\"\n\nfrom time import time\n\nhalf = 2 ** 127\nresults = []\n\n\ndef bench(n, enc, dec):\n    start = time()\n    for i in range(half, half + 1_000_000):\n        dec(enc(i))\n    end = time()\n    results.append(tuple([end - start, n, enc(half + 1234134134134314)]))\n\n\nBASE62 = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n\ndef encode(num, alphabet=BASE62):\n    \"\"\"Encode a positive number into Base X and return the string.\n\n    Arguments:\n    - `num`: The number to encode\n    - `alphabet`: The alphabet to use for encoding\n    \"\"\"\n    if num == 0:\n        return alphabet[0]\n    arr = []\n    arr_append = arr.append  # Extract bound-method for faster access.\n    _divmod = divmod  # Access to locals is faster.\n    base = len(alphabet)\n    while num:\n        num, rem = _divmod(num, base)\n        arr_append(alphabet[rem])\n    arr.reverse()\n    return ''.join(arr)\n\n\ndef decode(string, alphabet=BASE62):\n    \"\"\"Decode a Base X encoded string into the number\n\n    Arguments:\n    - `string`: The encoded string\n    - `alphabet`: The alphabet to use for decoding\n    \"\"\"\n    base = len(alphabet)\n    strlen = len(string)\n    num = 0\n\n    idx = 0\n    for char in string:\n        power = (strlen - (idx + 1))\n        num += alphabet.index(char) * (base ** power)\n        idx += 1\n\n    return num\n\n\nbench(1, encode, decode)\n###########################################################################################################\n# Remove the `_@` below for base62, now it has 64 characters\nBASE_ALPH = tuple(BASE62)\nBASE_LIST = BASE62\nBASE_DICT = dict((c, v) for v, c in enumerate(BASE_ALPH))\n\n###########################################################################################################\nBASE_LEN = len(BASE_ALPH)\n\n\ndef decode(string):\n    num = 0\n    for char in string:\n        num = num * BASE_LEN + BASE_DICT[char]\n    return num\n\n\ndef encode(num):\n    if not num:\n        return BASE_ALPH[0]\n\n    encoding = \"\"\n    while num:\n        num, rem = divmod(num, BASE_LEN)\n        encoding = BASE_ALPH[rem] + encoding\n    return encoding\n\n\nbench(2, encode, decode)\n\n###########################################################################################################\nfrom django.utils import baseconv\n\nbench(3, baseconv.base62.encode, baseconv.base62.decode)\n\n\n###########################################################################################################\ndef encode(a):\n    baseit = (lambda a=a, b=62: (not a) and '0' or\n                                baseit(a - a % b, b * 62) + '0123456789abcdefghijklmnopqrstuvwxyz'\n                                                            'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[\n                                    a % b % 61 or -1 * bool(a % b)])\n    return baseit()\n\n\nbench(4, encode, decode)\n\n\n###########################################################################################################\ndef encode(num, sym=BASE62, join_symbol=''):\n    if num == 0:\n        return sym[0]\n\n    l = len(sym)  # target number base\n    r = []\n    div = num\n    while div != 0:  # base conversion\n        div, mod = divmod(div, l)\n        r.append(sym[mod])\n\n    return join_symbol.join([x for x in reversed(r)])\n\n\nbench(5, encode, decode)\n\n###########################################################################################################\nfrom math import floor\n\nbase = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\nb = 62;\n\n\ndef decode(b62: str) -&gt; int:\n    limit = len(b62)\n    res = 0\n    for i in range(limit):\n        res = b * res + base.find(b62[i])\n    return res\n\n\ndef encode(b10: int) -&gt; str:\n    if b &lt;= 0 or b &gt; 62:\n        return 0\n    r = b10 % b\n    res = base[r];\n    q = floor(b10 / b)\n    while q:\n        r = q % b\n        q = floor(q / b)\n        res = base[int(r)] + res\n    return res\n\n\nbench(6, encode, decode)\n\n\n###########################################################################################################\ndef encode(dec):\n    s = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    return s[dec] if dec &lt; 62 else encode(dec // 62) + s[int(dec % 62)]\n\n\ndef decode(b62):\n    s = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    if len(b62) == 1:\n        return s.index(b62)\n    x = decode(b62[:-1]) * 62 + s.index(b62[-1:]) % 62\n    return x\n\n\nbench(7, encode, decode)\n\n\ndef encode(dec):\n    s = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    ret = ''\n    while dec &gt; 0:\n        ret = s[dec % 62] + ret\n        dec //= 62\n    return ret\n\n\ndef decode(b62):\n    s = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    ret = 0\n    for i in range(len(b62) - 1, -1, -1):\n        ret = ret + s.index(b62[i]) * (62 ** (len(b62) - i - 1))\n    return ret\n\n\nbench(8, encode, decode)\n\n\n###########################################################################################################\n\ndef encode(num):\n    s = \"\"\n    while num &gt; 0:\n        num, r = divmod(num, 62)\n        s = BASE62[r] + s\n    return s\n\n\ndef decode(num):\n    x, s = 1, 0\n    for i in range(len(num) - 1, -1, -1):\n        s = int(BASE62.index(num[i])) * x + s\n        x *= 62\n    return s\n\n\nbench(9, encode, decode)\n\n\n###########################################################################################################\n\ndef encode(number: int, alphabet=BASE62, padding: int = 22) -&gt; str:\n    l = len(alphabet)\n    res = []\n    while number &gt; 0:\n        number, rem = divmod(number, l)\n        res.append(alphabet[rem])\n        if number == 0:\n            break\n    return \"\".join(res)[::-1]  # .rjust(padding, \"0\")\n\n\ndef decode(digits: str, lookup=BASE_DICT) -&gt; int:\n    res = 0\n    last = len(digits) - 1\n    base = len(lookup)\n    for i, d in enumerate(digits):\n        res += lookup[d] * pow(base, last - i)\n    return res\n\n\nbench(10, encode, decode)\n\n###########################################################################################################\n\nfor row in sorted(results):\n    print(row)\n</code></pre>\n", "abstract": "Benchmarking answers that worked for Python3 (machine: i7-8565U):"}, {"id": 67829192, "score": 0, "vote": 0, "content": "<p>Original javascript version:</p>\n<pre><code class=\"python\">var hash = \"\", alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", alphabetLength = \nalphabet.length;\ndo {\n  hash = alphabet[input % alphabetLength] + hash;\n  input = parseInt(input / alphabetLength, 10);\n} while (input);\n</code></pre>\n<p>Source: <a href=\"https://hashids.org/\" rel=\"nofollow noreferrer\">https://hashids.org/</a></p>\n<p>python:</p>\n<pre><code class=\"python\">def to_base62(number):\n  alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  alphabetLength = len(alphabet)\n  result = \"\"\n  while True:\n    result = alphabet[number % alphabetLength] + result\n    number = int(number / alphabetLength)\n    if number == 0:\n      break\n  return result\n\nprint to_base62(59*(62**2) + 60*(62) + 61)\n# result: XYZ\n</code></pre>\n", "abstract": "Original javascript version: Source: https://hashids.org/ python:"}]}, {"link": "https://stackoverflow.com/questions/25169297/numpy-logarithm-with-base-n", "question": {"id": "25169297", "title": "NumPy: Logarithm with base n", "content": "<p>From the <a href=\"http://docs.scipy.org/doc/numpy/reference/routines.math.html#exponents-and-logarithms\">numpy documentation on logarithms</a>, I have found functions to take the logarithm with base <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html#numpy.log\"><em>e</em></a>, <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.log2.html#numpy.log2\">2</a>, and <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.log10.html#numpy.log10\">10</a>:</p>\n<pre><code class=\"python\">import numpy as np\nnp.log(np.e**3) #3.0\nnp.log2(2**3)   #3.0\nnp.log10(10**3) #3.0\n</code></pre>\n<p>However, how do I take the logarithm with base <em>n</em> (e.g. 42) in numpy?</p>\n", "abstract": "From the numpy documentation on logarithms, I have found functions to take the logarithm with base e, 2, and 10: However, how do I take the logarithm with base n (e.g. 42) in numpy?"}, "answers": [{"id": 25169298, "score": 208, "vote": 0, "content": "<p>To get the logarithm with a custom base using <a href=\"https://docs.python.org/3/library/math.html#math.log\" rel=\"noreferrer\"><code>math.log</code></a>:</p>\n<pre><code class=\"python\">import math\nnumber = 74088  # = 42^3\nbase = 42\nexponent = math.log(number, base)  # = 3\n</code></pre>\n<p>To get the logarithm with a custom base using <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html\" rel=\"noreferrer\"><code>numpy.log</code></a>:</p>\n<pre><code class=\"python\">import numpy as np\narray = np.array([74088, 3111696])  # = [42^3, 42^4]\nbase = 42\nexponent = np.log(array) / np.log(base)  # = [3, 4]\n</code></pre>\n<p>Which uses the logarithm <a href=\"https://en.wikipedia.org/wiki/Logarithm#Change_of_base\" rel=\"noreferrer\">base change</a> rule:</p>\n<p><img alt=\"\\log_b(x)=\\log_c(x)/\\log_c(b)\" src=\"https://chart.googleapis.com/chart?cht=tx&amp;chl=%5Clog_b%28x%29%3D%5Clog_c%28x%29%2F%5Clog_c%28b%29\"/></p>\n", "abstract": "To get the logarithm with a custom base using math.log: To get the logarithm with a custom base using numpy.log: Which uses the logarithm base change rule: "}]}, {"link": "https://stackoverflow.com/questions/8866046/python-round-up-integer-to-next-hundred", "question": {"id": "8866046", "title": "Python round up integer to next hundred", "content": "<p>Seems that should have already been asked hundreds (pun are fun =) of times but i can only find function for rounding floats. How do I round up an integer, for example: <code>130 -&gt; 200</code> ?</p>\n", "abstract": "Seems that should have already been asked hundreds (pun are fun =) of times but i can only find function for rounding floats. How do I round up an integer, for example: 130 -> 200 ?"}, "answers": [{"id": 8866125, "score": 191, "vote": 0, "content": "<p>Rounding is typically done on floating point numbers, and here there are three basic functions you should know: <a href=\"http://docs.python.org/library/functions.html#round\" rel=\"noreferrer\"><code>round</code></a> (rounds to the nearest integer), <a href=\"http://docs.python.org/library/math.html#math.floor\" rel=\"noreferrer\"><code>math.floor</code></a> (always rounds down), and <a href=\"http://docs.python.org/library/math.html#math.ceil\" rel=\"noreferrer\"><code>math.ceil</code></a> (always rounds up).</p>\n<p>You ask about integers and rounding up to hundreds, but we can still use <code>math.ceil</code> as long as your numbers smaller than 2<sup>53</sup>. To use <code>math.ceil</code>, we just divide by 100 first, round up, and multiply with 100 afterwards:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; def roundup(x):\n...     return int(math.ceil(x / 100.0)) * 100\n... \n&gt;&gt;&gt; roundup(100)\n100\n&gt;&gt;&gt; roundup(101)\n200\n</code></pre>\n<p>Dividing by 100 first and multiply with 100 afterwards \"shifts\" two decimal places to the right and left so that <code>math.ceil</code> works on the hundreds. You could use <code>10**n</code> instead of 100 if you want to round to tens (<code>n = 1</code>), thousands (<code>n = 3</code>), etc.</p>\n<p>An alternative way to do this is to avoid floating point numbers (they have limited precision) and instead use integers only. Integers have arbitrary precision in Python, so this lets you round numbers of any size. The rule for rounding is simple: find the remainder after division with 100, and add 100 minus this remainder if it's non-zero:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def roundup(x):\n...     return x if x % 100 == 0 else x + 100 - x % 100\n</code></pre>\n<p>This works for numbers of any size:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; roundup(100)\n100\n&gt;&gt;&gt; roundup(130)\n200\n&gt;&gt;&gt; roundup(1234567891234567891)\n1234567891234567900L\n</code></pre>\n<p>I did a mini-benchmark of the two solutions:</p>\n<pre><code class=\"python\">$ python -m timeit -s 'import math' -s 'x = 130' 'int(math.ceil(x/100.0)) * 100'\n1000000 loops, best of 3: 0.364 usec per loop\n$ python -m timeit -s 'x = 130' 'x if x % 100 == 0 else x + 100 - x % 100'\n10000000 loops, best of 3: 0.162 usec per loop\n</code></pre>\n<p>The pure integer solution is faster by a factor of two compared to the <code>math.ceil</code> solution. </p>\n<p>Thomas proposed an integer based solution that is identical to the one I have above, except that it uses a trick by multiplying Boolean values. It is interesting to see that there is no speed advantage of writing the code this way:</p>\n<pre><code class=\"python\">$ python -m timeit -s 'x = 130' 'x + 100*(x%100&gt;0) - x%100'\n10000000 loops, best of 3: 0.167 usec per loop\n</code></pre>\n<p>As a final remark, let me also note, that if you had wanted to round 101\u2013149 to 100 and round 150\u2013199 to 200, e.g., round to the <em>nearest</em> hundred, then the built-in <code>round</code> function can do that for you:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; int(round(130, -2))\n100\n&gt;&gt;&gt; int(round(170, -2))\n200\n</code></pre>\n", "abstract": "Rounding is typically done on floating point numbers, and here there are three basic functions you should know: round (rounds to the nearest integer), math.floor (always rounds down), and math.ceil (always rounds up). You ask about integers and rounding up to hundreds, but we can still use math.ceil as long as your numbers smaller than 253. To use math.ceil, we just divide by 100 first, round up, and multiply with 100 afterwards: Dividing by 100 first and multiply with 100 afterwards \"shifts\" two decimal places to the right and left so that math.ceil works on the hundreds. You could use 10**n instead of 100 if you want to round to tens (n = 1), thousands (n = 3), etc. An alternative way to do this is to avoid floating point numbers (they have limited precision) and instead use integers only. Integers have arbitrary precision in Python, so this lets you round numbers of any size. The rule for rounding is simple: find the remainder after division with 100, and add 100 minus this remainder if it's non-zero: This works for numbers of any size: I did a mini-benchmark of the two solutions: The pure integer solution is faster by a factor of two compared to the math.ceil solution.  Thomas proposed an integer based solution that is identical to the one I have above, except that it uses a trick by multiplying Boolean values. It is interesting to see that there is no speed advantage of writing the code this way: As a final remark, let me also note, that if you had wanted to round 101\u2013149 to 100 and round 150\u2013199 to 200, e.g., round to the nearest hundred, then the built-in round function can do that for you:"}, {"id": 14092788, "score": 40, "vote": 0, "content": "<p>This is a late answer, but there's a simple solution that combines the best aspects of the existing answers: the next multiple of <code>100</code> up from <code>x</code> is <code>x - x % -100</code> (or if you prefer, <code>x + (-x) % 100</code>).</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = 130\n&gt;&gt;&gt; x -= x % -100  # Round x up to next multiple of 100.\n&gt;&gt;&gt; x\n200\n</code></pre>\n<p>This is fast and simple, gives correct results for any integer <code>x</code> (like John Machin's answer) and also gives reasonable-ish results (modulo the usual caveats about floating-point representation) if <code>x</code> is a float (like Martin Geisler's answer).</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = 0.1\n&gt;&gt;&gt; x -= x % -100\n&gt;&gt;&gt; x\n100.0\n</code></pre>\n", "abstract": "This is a late answer, but there's a simple solution that combines the best aspects of the existing answers: the next multiple of 100 up from x is x - x % -100 (or if you prefer, x + (-x) % 100). This is fast and simple, gives correct results for any integer x (like John Machin's answer) and also gives reasonable-ish results (modulo the usual caveats about floating-point representation) if x is a float (like Martin Geisler's answer)."}, {"id": 8866054, "score": 25, "vote": 0, "content": "<p>Try this:</p>\n<pre><code class=\"python\">int(round(130 + 49, -2))\n</code></pre>\n", "abstract": "Try this:"}, {"id": 8866236, "score": 19, "vote": 0, "content": "<p>Here's a general way of rounding up to the nearest multiple of any positive integer:</p>\n<pre><code class=\"python\">def roundUpToMultiple(number, multiple):\n    num = number + (multiple - 1)\n    return num - (num % multiple)\n</code></pre>\n<p>Sample usage:</p>\n<pre>\n&gt;&gt;&gt; roundUpToMultiple(101, 100)\n200\n&gt;&gt;&gt; roundUpToMultiple(654, 321)\n963\n</pre>\n", "abstract": "Here's a general way of rounding up to the nearest multiple of any positive integer: Sample usage:"}, {"id": 8866377, "score": 8, "vote": 0, "content": "<p>For <code>a</code> non-negative, <code>b</code> positive, both integers:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; rup = lambda a, b: (a + b - 1) // b * b\n&gt;&gt;&gt; [(x, rup(x, 100)) for x in (199, 200, 201)]\n[(199, 200), (200, 200), (201, 300)]\n</code></pre>\n<p><strong>Update</strong> <em>The currently-accepted answer falls apart</em> with integers such that float(x) / float(y) can't be accurately represented as a <code>float</code>. See this code:</p>\n<pre><code class=\"python\">import math\n\ndef geisler(x, y): return int(math.ceil(x / float(y))) * y\n\ndef orozco(x, y): return x + y * (x % y &gt; 0) - x % y\n\ndef machin(x, y): return (x + y - 1) // y * y\n\nfor m, n in (\n    (123456789123456789, 100),\n    (1234567891234567891, 100),\n    (12345678912345678912, 100),\n    ):\n    print; print m, \"m\"; print n, \"n\"\n    for func in (geissler, orozco, machin):\n        print func(m, n), func.__name__\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">123456789123456789 m\n100 n\n123456789123456800 geisler\n123456789123456800 orozco\n123456789123456800 machin\n\n1234567891234567891 m\n100 n\n1234567891234568000 geisler &lt;&lt;&lt;=== wrong\n1234567891234567900 orozco\n1234567891234567900 machin\n\n12345678912345678912 m\n100 n\n12345678912345680000 geisler &lt;&lt;&lt;=== wrong\n12345678912345679000 orozco\n12345678912345679000 machin\n</code></pre>\n<p>And here are some timings:</p>\n<pre><code class=\"python\">&gt;\\python27\\python -m timeit -s \"import math;x =130\" \"int(math.ceil(x/100.0))*100\"\n1000000 loops, best of 3: 0.342 usec per loop\n\n&gt;\\python27\\python -m timeit -s \"x = 130\" \"x + 100 * (x % 100 &gt; 0) - x % 100\"\n10000000 loops, best of 3: 0.151 usec per loop\n\n&gt;\\python27\\python -m timeit -s \"x = 100\" \"(x + 99) // 100 * 100\"\n10000000 loops, best of 3: 0.0903 usec per loop\n</code></pre>\n", "abstract": "For a non-negative, b positive, both integers: Update The currently-accepted answer falls apart with integers such that float(x) / float(y) can't be accurately represented as a float. See this code: Output: And here are some timings:"}, {"id": 8866058, "score": 3, "vote": 0, "content": "<p>If your int is x: <code>x + 100 - x % 100</code></p>\n<p>However, as pointed in comments, this will  return 200 if <code>x==100</code>.</p>\n<p>If this is not the expected behavior, you can use <code>x + 100*(x%100&gt;0) - x%100</code></p>\n", "abstract": "If your int is x: x + 100 - x % 100 However, as pointed in comments, this will  return 200 if x==100. If this is not the expected behavior, you can use x + 100*(x%100>0) - x%100"}, {"id": 33885925, "score": 3, "vote": 0, "content": "<p>Try this:</p>\n<pre><code class=\"python\">import math\ndef ceilm(number,multiple):\n    '''Returns a float rounded up by a factor of the multiple specified'''\n    return math.ceil(float(number)/multiple)*multiple\n</code></pre>\n<p>Sample usage:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; ceilm(257,5)\n260\n&gt;&gt;&gt; ceilm(260,5)\n260\n</code></pre>\n", "abstract": "Try this: Sample usage:"}, {"id": 46542673, "score": 3, "vote": 0, "content": "<p>Warning: Premature optimizations ahead...</p>\n<p>Since so many of the answers here do the timing of this I wanted to add another alternative.</p>\n<p>Taking @Martin Geisler 's </p>\n<pre><code class=\"python\">def roundup(x):\n    return x if x % 100 == 0 else x + 100 - x % 100\n</code></pre>\n<p>(which i like best for several reasons)</p>\n<p>but factoring out the % action</p>\n<pre><code class=\"python\">def roundup2(x):\n    x100= x % 100\n    return x if x100 == 0 else x + 100 - x100\n</code></pre>\n<p>Yields a ~20% speed improvement over the original</p>\n<pre><code class=\"python\">def roundup3(x):\n    x100 = x % 100\n    return x if not x100 else x + 100 - x100\n</code></pre>\n<p>Is even better and is ~36% faster then the original</p>\n<p>finally I was thinking that I could drop the <code>not</code> operator and change the order of the branches hoping that this would also increase speed but was baffled to find out that it is actually slower dropping back to be only 23% faster then the original.</p>\n<pre><code class=\"python\">def roundup4(x):\n    x100 = x % 100\n    return x + 100 - x100  if x100 else x\n\n\n&gt;python -m timeit -s \"x = 130\" \"x if x % 100 == 0 else x + 100 - x % 100\"\n1000000 loops, best of 3: 0.359 usec per loop\n\n&gt;python -m timeit -s \"x = 130\" \"x100 = x % 100\"  \"x if x100 == 0 else x + 100 - x100\"\n1000000 loops, best of 3: 0.287 usec per loop\n\n&gt;python -m timeit -s \"x = 130\" \"x100 = x % 100\"  \"x if not x100 else x + 100 - x100\"\n1000000 loops, best of 3: 0.23 usec per loop\n\n&gt;python -m timeit -s \"x = 130\" \"x100 = x % 100\"  \"x + 100 - x100 if x100 else x\"\n1000000 loops, best of 3: 0.277 usec per loop\n</code></pre>\n<p>explanations as to why 3 is faster then 4 would be most welcome.</p>\n", "abstract": "Warning: Premature optimizations ahead... Since so many of the answers here do the timing of this I wanted to add another alternative. Taking @Martin Geisler 's  (which i like best for several reasons) but factoring out the % action Yields a ~20% speed improvement over the original Is even better and is ~36% faster then the original finally I was thinking that I could drop the not operator and change the order of the branches hoping that this would also increase speed but was baffled to find out that it is actually slower dropping back to be only 23% faster then the original. explanations as to why 3 is faster then 4 would be most welcome."}, {"id": 59511225, "score": 2, "vote": 0, "content": "<p>Here is a very simple solution:</p>\n<pre><code class=\"python\">next_hundred = x//100*100+100\n</code></pre>\n<hr/>\n<p><strong>How does it work?</strong></p>\n<ol>\n<li>Perform the integer division by 100 (it basically cuts off the fractional part of the normal division). In this way you obtain the tens of a number. For example: 243//100=2.</li>\n<li>Multiply by 100, getting the original number without its tens and ones. For example: 2*100=200.</li>\n<li>Add 100 to get the desired result. For example: 200+100=300</li>\n</ol>\n<p><strong>Some examples</strong></p>\n<ul>\n<li>0...99 rounded to 100</li>\n<li>100...199 rounded to 200</li>\n<li>etc.</li>\n</ul>\n<hr/>\n<p>A slightly modified approach rounds 1...100 to 100, 101...200 to 200, etc.:</p>\n<pre><code class=\"python\">next_hundred = (x-1)//100*100+100\n</code></pre>\n", "abstract": "Here is a very simple solution: How does it work? Some examples A slightly modified approach rounds 1...100 to 100, 101...200 to 200, etc.:"}, {"id": 67581601, "score": 1, "vote": 0, "content": "<p>Simply:</p>\n<pre><code class=\"python\">round(599, -2)\n</code></pre>\n<p>will give:</p>\n<blockquote>\n<p>600</p>\n</blockquote>\n", "abstract": "Simply: will give: 600"}]}, {"link": "https://stackoverflow.com/questions/9875964/how-can-i-convert-radians-to-degrees-with-python", "question": {"id": "9875964", "title": "How can I convert radians to degrees with Python?", "content": "<p>In the <a href=\"https://docs.python.org/3/library/math.html\" rel=\"noreferrer\"><code>math</code></a> module, I could only find <code>math.cos(x)</code>, with cos/sin/tan/acos/asin/atan. This returns the answer in radians. How can I get the answer in degrees?</p>\n<p>Here's my code:</p>\n<pre><code class=\"python\">import math\n\nx = math.cos(1)\ny = x * 180 / math.pi\nprint(y)\n30.9570417874\n</code></pre>\n<p>My calculator, on deg, gives me:</p>\n<pre><code class=\"python\">cos(1)\n0.9998476...\n</code></pre>\n", "abstract": "In the math module, I could only find math.cos(x), with cos/sin/tan/acos/asin/atan. This returns the answer in radians. How can I get the answer in degrees? Here's my code: My calculator, on deg, gives me:"}, "answers": [{"id": 9877360, "score": 205, "vote": 0, "content": "<p>Python includes two functions in the <code>math</code> package; <a href=\"https://docs.python.org/3/library/math.html#math.radians\" rel=\"noreferrer\"><code>radians</code></a> converts degrees to radians, and <a href=\"https://docs.python.org/3/library/math.html#math.degrees\" rel=\"noreferrer\"><code>degrees</code></a> converts radians to degrees.</p>\n<p>To match the output of your calculator you need:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; math.cos(math.radians(1))\n0.9998476951563913\n</code></pre>\n<p>Note that all of the trig functions convert between an angle and the ratio of two sides of a triangle. cos, sin, and tan take an angle in radians as input and return the ratio; acos, asin, and atan take a ratio as input and return an angle in radians. You only convert the angles, never the ratios.</p>\n", "abstract": "Python includes two functions in the math package; radians converts degrees to radians, and degrees converts radians to degrees. To match the output of your calculator you need: Note that all of the trig functions convert between an angle and the ratio of two sides of a triangle. cos, sin, and tan take an angle in radians as input and return the ratio; acos, asin, and atan take a ratio as input and return an angle in radians. You only convert the angles, never the ratios."}, {"id": 46249653, "score": 61, "vote": 0, "content": "<h2>Python convert radians to degrees or degrees to radians:</h2>\n<p><strong>What are Radians and what problem does it solve?:</strong></p>\n<p>Radians and degrees are two separate units of measure that help people express and communicate precise changes in direction.  Wikipedia has some great intuition with their infographics on how one Radian is defined relative to degrees:</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Radian\" rel=\"noreferrer\">https://en.wikipedia.org/wiki/Radian</a></p>\n<p><a href=\"https://i.stack.imgur.com/xsAa3.png\" rel=\"noreferrer\"><img alt=\"Conversion from radians to degrees\" src=\"https://i.stack.imgur.com/xsAa3.png\"/></a></p>\n<p><strong>Python examples using libraries calculating degrees from radians:</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.degrees(0)                       #0 radians == 0 degrees\n0.0\n&gt;&gt;&gt; math.degrees(math.pi/2)               #pi/2 radians is 90 degrees\n90.0\n&gt;&gt;&gt; math.degrees(math.pi)                 #pi radians is 180 degrees\n180.0      \n&gt;&gt;&gt; math.degrees(math.pi+(math.pi/2))     #pi+pi/2 radians is 270 degrees\n270.0 \n&gt;&gt;&gt; math.degrees(math.pi+math.pi)         #2*pi radians is 360 degrees\n360.0      \n</code></pre>\n<p><strong>Python examples using libraries calculating radians from degrees:</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.radians(0)           #0 degrees == 0 radians\n0.0\n&gt;&gt;&gt; math.radians(90)          #90 degrees is pi/2 radians\n1.5707963267948966\n&gt;&gt;&gt; math.radians(180)         #180 degrees is pi radians\n3.141592653589793\n&gt;&gt;&gt; math.radians(270)         #270 degrees is pi+(pi/2) radians\n4.71238898038469\n&gt;&gt;&gt; math.radians(360)         #360 degrees is 2*pi radians\n6.283185307179586\n</code></pre>\n<p>Source: <a href=\"https://docs.python.org/3/library/math.html#angular-conversion\" rel=\"noreferrer\">https://docs.python.org/3/library/math.html#angular-conversion</a></p>\n<p><strong>The mathematical notation:</strong></p>\n<p><a href=\"https://i.stack.imgur.com/ogMhv.png\" rel=\"noreferrer\"><img alt=\"Mathematical notation of degrees and radians\" src=\"https://i.stack.imgur.com/ogMhv.png\"/></a></p>\n<h2>You can do degree/radian conversion without python libraries:</h2>\n<p>If you roll your own degree/radian converter, you have to write your own code to handle edge cases.</p>\n<p>Mistakes here are easy to make, and will hurt just like it hurt the developers of the 1999 mars orbiter, who sunk $125m dollars crashing it into Mars because of non intuitive edge case here.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 0 * 180.0 / math.pi                         #0 radians is 0 degrees\n0.0\n&gt;&gt;&gt; (math.pi/2) * 180.0 / math.pi               #pi/2 radians is 90 degrees\n90.0\n&gt;&gt;&gt; (math.pi) * 180.0 / math.pi                 #pi radians is 180 degrees\n180.0\n&gt;&gt;&gt; (math.pi+(math.pi/2)) * 180.0 / math.pi     #pi+(pi/2) radians is 270 degrees\n270.0\n&gt;&gt;&gt; (2 * math.pi) * 180.0 / math.pi             #2*pi radians is 360 degrees\n360.0\n</code></pre>\n<p><strong>Degrees to radians:</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; 0 * math.pi / 180.0              #0 degrees in radians\n0.0\n&gt;&gt;&gt; 90 * math.pi / 180.0             #90 degrees in radians\n1.5707963267948966\n&gt;&gt;&gt; 180 * math.pi / 180.0            #180 degrees in radians\n3.141592653589793\n&gt;&gt;&gt; 270 * math.pi / 180.0            #270 degrees in radians\n4.71238898038469\n&gt;&gt;&gt; 360 * math.pi / 180.0            #360 degrees in radians\n6.283185307179586\n</code></pre>\n<p><strong>Expressing multiple rotations with degrees and radians</strong></p>\n<p>Single rotation valid radian values are between 0 and 2*pi.  Single rotation degree values are between 0 and 360.  However if you want to express multiple rotations, valid radian and degree values are between 0 and infinity.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.radians(360)                 #one complete rotation\n6.283185307179586\n&gt;&gt;&gt; math.radians(360+360)             #two rotations\n12.566370614359172\n&gt;&gt;&gt; math.degrees(12.566370614359172)  #math.degrees and math.radians preserve the\n720.0                                 #number of rotations\n</code></pre>\n<p><strong>Collapsing multiple rotations:</strong></p>\n<p>You can collapse multiple degree/radian rotations into a single rotation by modding against the value of one rotation.  For degrees you mod by 360, for radians you modulus by 2*pi.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.radians(720+90)        #2 whole rotations plus 90 is 14.14 radians\n14.137166941154069\n&gt;&gt;&gt; math.radians((720+90)%360)  #14.1 radians brings you to \n1.5707963267948966              #the end point as 1.57 radians.\n\n&gt;&gt;&gt; math.degrees((2*math.pi)+(math.pi/2))            #one rotation plus a quarter \n450.0                                                #rotation is 450 degrees.\n&gt;&gt;&gt; math.degrees(((2*math.pi)+(math.pi/2))%(2*math.pi)) #one rotation plus a quarter\n90.0                                                    #rotation brings you to 90.\n</code></pre>\n<p><strong>Fundamental education on Radians and Degrees</strong></p>\n<p>5 minute refresher using Trigonometry and expression of rotation to convert radians to degrees and back: <a href=\"https://youtu.be/ovLbCvq7FNA?t=31\" rel=\"noreferrer\">https://youtu.be/ovLbCvq7FNA?t=31</a></p>\n<p>Khan academy refresher on trigonometry, unit circle, angular mathematics to use sin,cos,tan to describe rotation and changes in rotation. <a href=\"https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:trig/x2ec2f6f830c9fb89:unit-circle/v/unit-circle-definition-of-trig-functions-1\" rel=\"noreferrer\">https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:trig/x2ec2f6f830c9fb89:unit-circle/v/unit-circle-definition-of-trig-functions-1</a></p>\n", "abstract": "What are Radians and what problem does it solve?: Radians and degrees are two separate units of measure that help people express and communicate precise changes in direction.  Wikipedia has some great intuition with their infographics on how one Radian is defined relative to degrees: https://en.wikipedia.org/wiki/Radian  Python examples using libraries calculating degrees from radians: Python examples using libraries calculating radians from degrees: Source: https://docs.python.org/3/library/math.html#angular-conversion The mathematical notation:  If you roll your own degree/radian converter, you have to write your own code to handle edge cases. Mistakes here are easy to make, and will hurt just like it hurt the developers of the 1999 mars orbiter, who sunk $125m dollars crashing it into Mars because of non intuitive edge case here. Degrees to radians: Expressing multiple rotations with degrees and radians Single rotation valid radian values are between 0 and 2*pi.  Single rotation degree values are between 0 and 360.  However if you want to express multiple rotations, valid radian and degree values are between 0 and infinity. Collapsing multiple rotations: You can collapse multiple degree/radian rotations into a single rotation by modding against the value of one rotation.  For degrees you mod by 360, for radians you modulus by 2*pi. Fundamental education on Radians and Degrees 5 minute refresher using Trigonometry and expression of rotation to convert radians to degrees and back: https://youtu.be/ovLbCvq7FNA?t=31 Khan academy refresher on trigonometry, unit circle, angular mathematics to use sin,cos,tan to describe rotation and changes in rotation. https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:trig/x2ec2f6f830c9fb89:unit-circle/v/unit-circle-definition-of-trig-functions-1"}, {"id": 9876182, "score": 20, "vote": 0, "content": "<p>You can simply convert your radian result to degree by using</p>\n<p><a href=\"http://docs.python.org/library/math.html#angular-conversion\" rel=\"noreferrer\">math.degrees</a> and rounding appropriately to the required decimal places</p>\n<p>for example</p>\n<pre><code class=\"python\">&gt;&gt;&gt; round(math.degrees(math.asin(0.5)),2)\n30.0\n&gt;&gt;&gt; \n</code></pre>\n", "abstract": "You can simply convert your radian result to degree by using math.degrees and rounding appropriately to the required decimal places for example"}, {"id": 51835709, "score": 4, "vote": 0, "content": "<p>radian can also be converted to degree by using numpy</p>\n<pre><code class=\"python\">print(np.rad2deg(1))\n57.29577951308232\n</code></pre>\n<p>if needed to roundoff ( I did with 6 digits after decimal below), then</p>\n<pre><code class=\"python\">print(np.round(np.rad2deg(1), 6)\n\n57.29578\n</code></pre>\n", "abstract": "radian can also be converted to degree by using numpy if needed to roundoff ( I did with 6 digits after decimal below), then"}, {"id": 39883806, "score": 2, "vote": 0, "content": "<p>I also like to define my own functions that take and return arguments in degrees rather than radians.  I am sure there some capitalization purest who don't like my names, but I just use a capital first letter for my custom functions.  The definitions and testing code are below.</p>\n<pre><code class=\"python\">#Definitions for trig functions using degrees.\ndef Cos(a):\n    return cos(radians(a))\ndef Sin(a):\n    return sin(radians(a))\ndef Tan(a):\n    return tan(radians(a))\ndef ArcTan(a):\n    return degrees(arctan(a))\ndef ArcSin(a):\n    return degrees(arcsin(a))\ndef ArcCos(a):\n    return degrees(arccos(a))\n\n#Testing Code\nprint(Cos(90))\nprint(Sin(90))\nprint(Tan(45))\nprint(ArcTan(1))\nprint(ArcSin(1))\nprint(ArcCos(0))\n</code></pre>\n<p>Note that I have imported math (or numpy) into the namespace with</p>\n<pre><code class=\"python\">from math import *\n</code></pre>\n<p>Also note, that my functions are in the namespace in which they were defined.  For instance,</p>\n<pre><code class=\"python\">math.Cos(45)\n</code></pre>\n<p>does not exist.</p>\n", "abstract": "I also like to define my own functions that take and return arguments in degrees rather than radians.  I am sure there some capitalization purest who don't like my names, but I just use a capital first letter for my custom functions.  The definitions and testing code are below. Note that I have imported math (or numpy) into the namespace with Also note, that my functions are in the namespace in which they were defined.  For instance, does not exist."}, {"id": 29286006, "score": 1, "vote": 0, "content": "<p>-fix-\nbecause you want to change from radians to degrees, it is actually \nrad=deg * math.pi /180\nand not deg*180/math.pi</p>\n<pre><code class=\"python\">import math\nx=1                # in deg\nx = x*math.pi/180  # convert to rad\ny = math.cos(x)    # calculate in rad\n\nprint y\n</code></pre>\n<p>in 1 line it can be like this</p>\n<pre><code class=\"python\">y=math.cos(1*math.pi/180)\n</code></pre>\n", "abstract": "-fix-\nbecause you want to change from radians to degrees, it is actually \nrad=deg * math.pi /180\nand not deg*180/math.pi in 1 line it can be like this"}, {"id": 66273182, "score": 0, "vote": 0, "content": "<p>I like this method,use <code>sind(x)</code> or <code>cosd(x)</code></p>\n<pre><code class=\"python\">import math\n\ndef sind(x):\n    return math.sin(math.radians(x))\n\ndef cosd(x):\n    return math.cos(math.radians(x))\n</code></pre>\n", "abstract": "I like this method,use sind(x) or cosd(x)"}]}, {"link": "https://stackoverflow.com/questions/13479163/round-float-to-x-decimals", "question": {"id": "13479163", "title": "Round float to x decimals?", "content": "<p>Is there a way to round a python float to x decimals? For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = roundfloat(66.66666666666, 4)\n66.6667\n&gt;&gt;&gt; x = roundfloat(1.29578293, 6)\n1.295783\n</code></pre>\n<p>I've found ways to trim/truncate them (66.666666666 --&gt; 66.6666), but not round (66.666666666 --&gt; 66.6667).</p>\n", "abstract": "Is there a way to round a python float to x decimals? For example: I've found ways to trim/truncate them (66.666666666 --> 66.6666), but not round (66.666666666 --> 66.6667)."}, "answers": [{"id": 22155830, "score": 161, "vote": 0, "content": "<p>I feel compelled to provide a counterpoint to Ashwini Chaudhary's answer.  Despite appearances, the two-argument form of the <code>round</code> function <em>does not</em> round a Python float to a given number of decimal places, and it's often not the solution you want, even when you think it is. Let me explain...</p>\n<p>The ability to round a (Python) float to some number of decimal places is something that's frequently requested, but turns out to be rarely what's actually needed.  The beguilingly simple answer <code>round(x, number_of_places)</code> is something of an attractive nuisance: it <em>looks</em> as though it does what you want, but thanks to the fact that Python floats are stored internally in binary, it's doing something rather subtler.  Consider the following example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; round(52.15, 1)\n52.1\n</code></pre>\n<p>With a naive understanding of what <code>round</code> does, this looks wrong:  surely it should be rounding <em>up</em> to <code>52.2</code> rather than <em>down</em> to <code>52.1</code>?  To understand why such behaviours can't be relied upon, you need to appreciate that while this looks like a simple decimal-to-decimal operation, it's far from simple.</p>\n<p>So here's what's <em>really</em> happening in the example above. (<em>deep breath</em>) We're displaying a <em>decimal</em> representation of the nearest <em>binary</em> floating-point number to the nearest <code>n</code>-digits-after-the-point <em>decimal</em> number to a <em>binary</em> floating-point approximation of a numeric literal written in <em>decimal</em>.  So to get from the original numeric literal to the displayed output, the underlying machinery has made <em>four</em> separate conversions between binary and decimal formats, two in each direction.  Breaking it down (and with the usual disclaimers about assuming IEEE 754 binary64 format, round-ties-to-even rounding, and IEEE 754 rules):</p>\n<ol>\n<li><p>First the numeric literal <code>52.15</code> gets parsed and converted to a Python float.  The actual number stored is <code>7339460017730355 * 2**-47</code>, or <code>52.14999999999999857891452847979962825775146484375</code>.</p></li>\n<li><p>Internally as the first step of the <code>round</code> operation, Python computes the closest 1-digit-after-the-point decimal string to the stored number.  Since that stored number is a touch under the original value of <code>52.15</code>, we end up rounding down and getting a string <code>52.1</code>.  This explains why we're getting <code>52.1</code> as the final output instead of <code>52.2</code>.</p></li>\n<li><p>Then in the second step of the <code>round</code> operation, Python turns that string back into a float, getting the closest binary floating-point number to <code>52.1</code>, which is now <code>7332423143312589 * 2**-47</code>, or <code>52.10000000000000142108547152020037174224853515625</code>.</p></li>\n<li><p>Finally, as part of Python's read-eval-print loop (REPL), the floating-point value is displayed (in decimal).  That involves converting the binary value back to a decimal string, getting <code>52.1</code> as the final output.</p></li>\n</ol>\n<p>In Python 2.7 and later, we have the pleasant situation that the two conversions in step 3 and 4 cancel each other out.  That's due to Python's choice of <code>repr</code> implementation, which produces the shortest decimal value guaranteed to round correctly to the actual float.  One consequence of that choice is that if you start with any (not too large, not too small) decimal literal with 15 or fewer significant digits then the corresponding float will be displayed showing those exact same digits:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = 15.34509809234\n&gt;&gt;&gt; x\n15.34509809234\n</code></pre>\n<p>Unfortunately, this furthers the illusion that Python is storing values in decimal.  Not so in Python 2.6, though! Here's the original example executed in Python 2.6:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; round(52.15, 1)\n52.200000000000003\n</code></pre>\n<p>Not only do we round in the opposite direction, getting <code>52.2</code> instead of <code>52.1</code>, but the displayed value doesn't even print as <code>52.2</code>!  This behaviour has caused numerous reports to the Python bug tracker along the lines of \"round is broken!\".  But it's not <code>round</code> that's broken, it's user expectations.  (Okay, okay, <code>round</code> is a <em>little</em> bit broken in Python 2.6, in that it doesn't use correct rounding.)</p>\n<p>Short version: if you're using two-argument round, and you're expecting predictable behaviour from a <em>binary</em> approximation to a <em>decimal</em> round of a <em>binary</em> approximation to a <em>decimal</em> halfway case, you're asking for trouble.</p>\n<p>So enough with the \"two-argument round is bad\" argument.  What <em>should</em> you be using instead?  There are a few possibilities, depending on what you're trying to do.</p>\n<ul>\n<li><p>If you're rounding for display purposes, then you don't want a float result at all;  you want a string.  In that case the answer is to use string formatting:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; format(66.66666666666, '.4f')\n'66.6667'\n&gt;&gt;&gt; format(1.29578293, '.6f')\n'1.295783'\n</code></pre>\n<p>Even then, one has to be aware of the internal binary representation in order not to be surprised by the behaviour of apparent decimal halfway cases.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; format(52.15, '.1f')\n'52.1'\n</code></pre></li>\n<li><p>If you're operating in a context where it matters which direction decimal halfway cases are rounded (for example, in some financial contexts), you might want to represent your numbers using the <code>Decimal</code> type.  Doing a decimal round on the <code>Decimal</code> type makes a lot more sense than on a binary type (equally, rounding to a fixed number of binary places makes perfect sense on a binary type).  Moreover, the <code>decimal</code> module gives you better control of the rounding mode.  In Python 3, <code>round</code> does the job directly.  In Python 2, you need the <code>quantize</code> method.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; Decimal('66.66666666666').quantize(Decimal('1e-4'))\nDecimal('66.6667')\n&gt;&gt;&gt; Decimal('1.29578293').quantize(Decimal('1e-6'))\nDecimal('1.295783')\n</code></pre></li>\n<li><p>In rare cases, the two-argument version of <code>round</code> really <em>is</em> what you want: perhaps you're binning floats into bins of size <code>0.01</code>, and you don't particularly care which way border cases go.  However, these cases are rare, and it's difficult to justify the existence of the two-argument version of the <code>round</code> builtin based on those cases alone.</p></li>\n</ul>\n", "abstract": "I feel compelled to provide a counterpoint to Ashwini Chaudhary's answer.  Despite appearances, the two-argument form of the round function does not round a Python float to a given number of decimal places, and it's often not the solution you want, even when you think it is. Let me explain... The ability to round a (Python) float to some number of decimal places is something that's frequently requested, but turns out to be rarely what's actually needed.  The beguilingly simple answer round(x, number_of_places) is something of an attractive nuisance: it looks as though it does what you want, but thanks to the fact that Python floats are stored internally in binary, it's doing something rather subtler.  Consider the following example: With a naive understanding of what round does, this looks wrong:  surely it should be rounding up to 52.2 rather than down to 52.1?  To understand why such behaviours can't be relied upon, you need to appreciate that while this looks like a simple decimal-to-decimal operation, it's far from simple. So here's what's really happening in the example above. (deep breath) We're displaying a decimal representation of the nearest binary floating-point number to the nearest n-digits-after-the-point decimal number to a binary floating-point approximation of a numeric literal written in decimal.  So to get from the original numeric literal to the displayed output, the underlying machinery has made four separate conversions between binary and decimal formats, two in each direction.  Breaking it down (and with the usual disclaimers about assuming IEEE 754 binary64 format, round-ties-to-even rounding, and IEEE 754 rules): First the numeric literal 52.15 gets parsed and converted to a Python float.  The actual number stored is 7339460017730355 * 2**-47, or 52.14999999999999857891452847979962825775146484375. Internally as the first step of the round operation, Python computes the closest 1-digit-after-the-point decimal string to the stored number.  Since that stored number is a touch under the original value of 52.15, we end up rounding down and getting a string 52.1.  This explains why we're getting 52.1 as the final output instead of 52.2. Then in the second step of the round operation, Python turns that string back into a float, getting the closest binary floating-point number to 52.1, which is now 7332423143312589 * 2**-47, or 52.10000000000000142108547152020037174224853515625. Finally, as part of Python's read-eval-print loop (REPL), the floating-point value is displayed (in decimal).  That involves converting the binary value back to a decimal string, getting 52.1 as the final output. In Python 2.7 and later, we have the pleasant situation that the two conversions in step 3 and 4 cancel each other out.  That's due to Python's choice of repr implementation, which produces the shortest decimal value guaranteed to round correctly to the actual float.  One consequence of that choice is that if you start with any (not too large, not too small) decimal literal with 15 or fewer significant digits then the corresponding float will be displayed showing those exact same digits: Unfortunately, this furthers the illusion that Python is storing values in decimal.  Not so in Python 2.6, though! Here's the original example executed in Python 2.6: Not only do we round in the opposite direction, getting 52.2 instead of 52.1, but the displayed value doesn't even print as 52.2!  This behaviour has caused numerous reports to the Python bug tracker along the lines of \"round is broken!\".  But it's not round that's broken, it's user expectations.  (Okay, okay, round is a little bit broken in Python 2.6, in that it doesn't use correct rounding.) Short version: if you're using two-argument round, and you're expecting predictable behaviour from a binary approximation to a decimal round of a binary approximation to a decimal halfway case, you're asking for trouble. So enough with the \"two-argument round is bad\" argument.  What should you be using instead?  There are a few possibilities, depending on what you're trying to do. If you're rounding for display purposes, then you don't want a float result at all;  you want a string.  In that case the answer is to use string formatting: Even then, one has to be aware of the internal binary representation in order not to be surprised by the behaviour of apparent decimal halfway cases. If you're operating in a context where it matters which direction decimal halfway cases are rounded (for example, in some financial contexts), you might want to represent your numbers using the Decimal type.  Doing a decimal round on the Decimal type makes a lot more sense than on a binary type (equally, rounding to a fixed number of binary places makes perfect sense on a binary type).  Moreover, the decimal module gives you better control of the rounding mode.  In Python 3, round does the job directly.  In Python 2, you need the quantize method. In rare cases, the two-argument version of round really is what you want: perhaps you're binning floats into bins of size 0.01, and you don't particularly care which way border cases go.  However, these cases are rare, and it's difficult to justify the existence of the two-argument version of the round builtin based on those cases alone."}, {"id": 13479195, "score": 109, "vote": 0, "content": "<p>Use the built-in function <code>round()</code>:</p>\n<pre><code class=\"python\">In [23]: round(66.66666666666,4)\nOut[23]: 66.6667\n\nIn [24]: round(1.29578293,6)\nOut[24]: 1.295783\n</code></pre>\n<p>help on <code>round()</code>:</p>\n<blockquote>\n<p>round(number[, ndigits]) -&gt; floating point number</p>\n<p>Round a number to a given precision in decimal digits (default 0\n  digits). This always returns a floating point number.  Precision may\n  be negative.</p>\n</blockquote>\n", "abstract": "Use the built-in function round(): help on round(): round(number[, ndigits]) -> floating point number Round a number to a given precision in decimal digits (default 0\n  digits). This always returns a floating point number.  Precision may\n  be negative."}, {"id": 63253742, "score": 1, "vote": 0, "content": "<p>Default rounding in python and numpy:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">In: [round(i) for i in np.arange(10) + .5]\nOut: [0, 2, 2, 4, 4, 6, 6, 8, 8, 10]\n</code></pre>\n<p>I used this to get integer rounding to be applied to a pandas series:</p>\n<p><code>import decimal</code></p>\n<p>and use this line to set the rounding to \"half up\" a.k.a rounding as taught in school:\n<code>decimal.getcontext().rounding = decimal.ROUND_HALF_UP</code></p>\n<p>Finally I made this function to apply it to a pandas series object</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def roundint(value):\n    return value.apply(lambda x: int(decimal.Decimal(x).to_integral_value()))\n</code></pre>\n<p>So now you can do <code>roundint(df.columnname)</code></p>\n<p>And for numbers:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">In: [int(decimal.Decimal(i).to_integral_value()) for i in np.arange(10) + .5]\nOut: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre>\n<p>Credit: <a href=\"https://stackoverflow.com/a/52607477/4289062\">kares</a></p>\n", "abstract": "Default rounding in python and numpy: I used this to get integer rounding to be applied to a pandas series: import decimal and use this line to set the rounding to \"half up\" a.k.a rounding as taught in school:\ndecimal.getcontext().rounding = decimal.ROUND_HALF_UP Finally I made this function to apply it to a pandas series object So now you can do roundint(df.columnname) And for numbers: Credit: kares"}, {"id": 63035573, "score": 0, "vote": 0, "content": "<p>The Mark Dickinson answer, although complete, didn't work with the float(52.15) case. After some tests, there is the solution that I'm using:</p>\n<pre><code class=\"python\">import decimal\n        \ndef value_to_decimal(value, decimal_places):\n    decimal.getcontext().rounding = decimal.ROUND_HALF_UP  # define rounding method\n    return decimal.Decimal(str(float(value))).quantize(decimal.Decimal('1e-{}'.format(decimal_places)))\n</code></pre>\n<p>(The conversion of the 'value' to float and then string is very important, that way, 'value' can be of the type float, decimal, integer or string!)</p>\n<p>Hope this helps anyone.</p>\n", "abstract": "The Mark Dickinson answer, although complete, didn't work with the float(52.15) case. After some tests, there is the solution that I'm using: (The conversion of the 'value' to float and then string is very important, that way, 'value' can be of the type float, decimal, integer or string!) Hope this helps anyone."}, {"id": 66385661, "score": 0, "vote": 0, "content": "<p>I coded a function (used in Django project for DecimalField) but it can be used in Python project :</p>\n<p>This code :</p>\n<ul>\n<li>Manage <strong>integers digits</strong> to avoid too high number</li>\n<li>Manage <strong>decimals digits</strong> to avoid too low number</li>\n<li>Manage <strong>signed and unsigned</strong> numbers</li>\n</ul>\n<p>Code with tests :</p>\n<pre><code class=\"python\">def convert_decimal_to_right(value, max_digits, decimal_places, signed=True):\n\n    integer_digits = max_digits - decimal_places\n    max_value = float((10**integer_digits)-float(float(1)/float((10**decimal_places))))\n\n    if signed:\n        min_value = max_value*-1\n    else:\n        min_value = 0\n\n    if value &gt; max_value:\n        value = max_value\n\n    if value &lt; min_value:\n        value = min_value\n\n    return round(value, decimal_places)\n\n\nvalue = 12.12345\nnb = convert_decimal_to_right(value, 4, 2)\n# nb : 12.12\n\nvalue = 12.126\nnb = convert_decimal_to_right(value, 4, 2)\n# nb : 12.13\n\nvalue = 1234.123\nnb = convert_decimal_to_right(value, 4, 2)\n# nb : 99.99\n\nvalue = -1234.123\nnb = convert_decimal_to_right(value, 4, 2)\n# nb : -99.99\n\nvalue = -1234.123\nnb = convert_decimal_to_right(value, 4, 2, signed = False)\n# nb : 0\n\nvalue = 12.123\nnb = convert_decimal_to_right(value, 8, 4)\n# nb : 12.123\n</code></pre>\n", "abstract": "I coded a function (used in Django project for DecimalField) but it can be used in Python project : This code : Code with tests :"}]}, {"link": "https://stackoverflow.com/questions/3425439/why-does-corrcoef-return-a-matrix", "question": {"id": "3425439", "title": "Why does corrcoef return a matrix?", "content": "<p>It seems strange to me that np.corrcoef returns a matrix.</p>\n<pre><code class=\"python\"> correlation1 = corrcoef(Strategy1Returns,Strategy2Returns)\n\n[[ 1.         -0.99598935]\n [-0.99598935  1.        ]]\n</code></pre>\n<p>Does anyone know why this is the case and whether it is possible to return just one value in the classical sense?</p>\n", "abstract": "It seems strange to me that np.corrcoef returns a matrix. Does anyone know why this is the case and whether it is possible to return just one value in the classical sense?"}, "answers": [{"id": 3425548, "score": 175, "vote": 0, "content": "<p>It allows you to compute correlation coefficients of &gt;2 data sets, e.g.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from numpy import *\n&gt;&gt;&gt; a = array([1,2,3,4,6,7,8,9])\n&gt;&gt;&gt; b = array([2,4,6,8,10,12,13,15])\n&gt;&gt;&gt; c = array([-1,-2,-2,-3,-4,-6,-7,-8])\n&gt;&gt;&gt; corrcoef([a,b,c])\narray([[ 1.        ,  0.99535001, -0.9805214 ],\n       [ 0.99535001,  1.        , -0.97172394],\n       [-0.9805214 , -0.97172394,  1.        ]])\n</code></pre>\n<p>Here we can get the correlation coefficient of a,b (0.995), a,c (-0.981) and b,c (-0.972) at once. The two-data-set case is just a special case of N-data-set class. And probably it's better to keep the same return type. Since the \"one value\" can be obtained simply with</p>\n<pre><code class=\"python\">&gt;&gt;&gt; corrcoef(a,b)[1,0]\n0.99535001355530017\n</code></pre>\n<p>there's no big reason to create the special case.</p>\n", "abstract": "It allows you to compute correlation coefficients of >2 data sets, e.g. Here we can get the correlation coefficient of a,b (0.995), a,c (-0.981) and b,c (-0.972) at once. The two-data-set case is just a special case of N-data-set class. And probably it's better to keep the same return type. Since the \"one value\" can be obtained simply with there's no big reason to create the special case."}, {"id": 3425496, "score": 58, "vote": 0, "content": "<p><a href=\"http://www.scipy.org/Numpy_Example_List_With_Doc#corrcoef\" rel=\"noreferrer\"><code>corrcoef</code></a> returns the normalised covariance matrix.</p>\n<p>The covariance matrix is the matrix</p>\n<pre><code class=\"python\">Cov( X, X )    Cov( X, Y )\n\nCov( Y, X )    Cov( Y, Y )\n</code></pre>\n<p>Normalised, this will yield the matrix:</p>\n<pre><code class=\"python\">Corr( X, X )    Corr( X, Y )\n\nCorr( Y, X )    Corr( Y, Y )\n</code></pre>\n<p><code>correlation1[0, 0 ]</code> is the correlation between <code>Strategy1Returns</code> and itself, which must be 1. You just want <code>correlation1[ 0, 1 ]</code>.</p>\n", "abstract": "corrcoef returns the normalised covariance matrix. The covariance matrix is the matrix Normalised, this will yield the matrix: correlation1[0, 0 ] is the correlation between Strategy1Returns and itself, which must be 1. You just want correlation1[ 0, 1 ]."}, {"id": 3425533, "score": 7, "vote": 0, "content": "<p>The correlation matrix is the standard way to express correlations between an arbitrary finite number of variables. The correlation matrix of <em>N</em> data vectors is a symmetric <em>N</em> \u00d7 <em>N</em> matrix with unity diagonal. Only in the case <em>N</em> = 2 does this matrix have one free parameter.</p>\n", "abstract": "The correlation matrix is the standard way to express correlations between an arbitrary finite number of variables. The correlation matrix of N data vectors is a symmetric N \u00d7 N matrix with unity diagonal. Only in the case N = 2 does this matrix have one free parameter."}, {"id": 54774500, "score": 3, "vote": 0, "content": "<p>You can use the following function to return only the correlation coefficient:</p>\n<pre><code class=\"python\">def pearson_r(x, y):\n\"\"\"Compute Pearson correlation coefficient between two arrays.\"\"\"\n\n   # Compute correlation matrix\n   corr_mat = np.corrcoef(x, y)\n\n   # Return entry [0,1]\n   return corr_mat[0,1]\n</code></pre>\n", "abstract": "You can use the following function to return only the correlation coefficient:"}, {"id": 5872566, "score": 1, "vote": 0, "content": "<p>Consider using matplotlib.cbook pieces</p>\n<p>for example:</p>\n<pre><code class=\"python\">import matplotlib.cbook as cbook\nsegments = cbook.pieces(np.arange(20), 3)\nfor s in segments:\n     print s\n</code></pre>\n", "abstract": "Consider using matplotlib.cbook pieces for example:"}, {"id": 7065980, "score": 1, "vote": 0, "content": "<p>The function Correlate of numpy works with 2 1D arrays that you want to correlate and returns one correlation value.</p>\n", "abstract": "The function Correlate of numpy works with 2 1D arrays that you want to correlate and returns one correlation value."}]}, {"link": "https://stackoverflow.com/questions/2745329/how-to-make-scipy-interpolate-give-an-extrapolated-result-beyond-the-input-range", "question": {"id": "2745329", "title": "How to make scipy.interpolate give an extrapolated result beyond the input range?", "content": "<p>I'm trying to port a program which uses a hand-rolled interpolator (developed by a mathematician colleage) over to use the interpolators provided by scipy. I'd like to use or wrap the scipy interpolator so that it has as close as possible behavior to the old interpolator.</p>\n<p>A key difference between the two functions is that in our original interpolator - if the input value is above or below the input range, our original interpolator will extrapolate the result. If you try this with the scipy interpolator it raises a <code>ValueError</code>. Consider this program as an example:</p>\n<pre><code class=\"python\">import numpy as np\nfrom scipy import interpolate\n\nx = np.arange(0,10)\ny = np.exp(-x/3.0)\nf = interpolate.interp1d(x, y)\n\nprint f(9)\nprint f(11) # Causes ValueError, because it's greater than max(x)\n</code></pre>\n<p>Is there a sensible way to make it so that instead of crashing, the final line will simply do a linear extrapolate, continuing the gradients defined by the first and last two points to infinity. </p>\n<p>Note, that in the real software I'm not actually using the exp function - that's here for illustration only!</p>\n", "abstract": "I'm trying to port a program which uses a hand-rolled interpolator (developed by a mathematician colleage) over to use the interpolators provided by scipy. I'd like to use or wrap the scipy interpolator so that it has as close as possible behavior to the old interpolator. A key difference between the two functions is that in our original interpolator - if the input value is above or below the input range, our original interpolator will extrapolate the result. If you try this with the scipy interpolator it raises a ValueError. Consider this program as an example: Is there a sensible way to make it so that instead of crashing, the final line will simply do a linear extrapolate, continuing the gradients defined by the first and last two points to infinity.  Note, that in the real software I'm not actually using the exp function - that's here for illustration only!"}, "answers": [{"id": 37172840, "score": 94, "vote": 0, "content": "<p>As of SciPy version 0.17.0, there is a new option for <a href=\"http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html\" rel=\"noreferrer\">scipy.interpolate.interp1d</a> that allows extrapolation. Simply set fill_value='extrapolate' in the call. Modifying your code in this way gives:</p>\n<pre><code class=\"python\">import numpy as np\nfrom scipy import interpolate\n\nx = np.arange(0,10)\ny = np.exp(-x/3.0)\nf = interpolate.interp1d(x, y, fill_value='extrapolate')\n\nprint f(9)\nprint f(11)\n</code></pre>\n<p>and the output is:</p>\n<pre><code class=\"python\">0.0497870683679\n0.010394302658\n</code></pre>\n", "abstract": "As of SciPy version 0.17.0, there is a new option for scipy.interpolate.interp1d that allows extrapolation. Simply set fill_value='extrapolate' in the call. Modifying your code in this way gives: and the output is:"}, {"id": 8166155, "score": 90, "vote": 0, "content": "<p>You can take a look at <a href=\"http://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.InterpolatedUnivariateSpline.html#scipy.interpolate.InterpolatedUnivariateSpline\">InterpolatedUnivariateSpline</a></p>\n<p>Here an example using it: </p>\n<pre><code class=\"python\">import matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.interpolate import InterpolatedUnivariateSpline\n\n# given values\nxi = np.array([0.2, 0.5, 0.7, 0.9])\nyi = np.array([0.3, -0.1, 0.2, 0.1])\n# positions to inter/extrapolate\nx = np.linspace(0, 1, 50)\n# spline order: 1 linear, 2 quadratic, 3 cubic ... \norder = 1\n# do inter/extrapolation\ns = InterpolatedUnivariateSpline(xi, yi, k=order)\ny = s(x)\n\n# example showing the interpolation for linear, quadratic and cubic interpolation\nplt.figure()\nplt.plot(xi, yi)\nfor order in range(1, 4):\n    s = InterpolatedUnivariateSpline(xi, yi, k=order)\n    y = s(x)\n    plt.plot(x, y)\nplt.show()\n</code></pre>\n", "abstract": "You can take a look at InterpolatedUnivariateSpline Here an example using it: "}, {"id": 2745496, "score": 41, "vote": 0, "content": "<h3>1. Constant extrapolation</h3>\n<p>You can use <code>interp</code> function from scipy, it extrapolates left and right values as constant beyond the range:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from scipy import interp, arange, exp\n&gt;&gt;&gt; x = arange(0,10)\n&gt;&gt;&gt; y = exp(-x/3.0)\n&gt;&gt;&gt; interp([9,10], x, y)\narray([ 0.04978707,  0.04978707])\n</code></pre>\n<h3>2. Linear (or other custom) extrapolation</h3>\n<p>You can write a wrapper around an interpolation function which takes care of linear extrapolation. For example:</p>\n<pre><code class=\"python\">from scipy.interpolate import interp1d\nfrom scipy import arange, array, exp\n\ndef extrap1d(interpolator):\n    xs = interpolator.x\n    ys = interpolator.y\n\n    def pointwise(x):\n        if x &lt; xs[0]:\n            return ys[0]+(x-xs[0])*(ys[1]-ys[0])/(xs[1]-xs[0])\n        elif x &gt; xs[-1]:\n            return ys[-1]+(x-xs[-1])*(ys[-1]-ys[-2])/(xs[-1]-xs[-2])\n        else:\n            return interpolator(x)\n\n    def ufunclike(xs):\n        return array(list(map(pointwise, array(xs))))\n\n    return ufunclike\n</code></pre>\n<p><code>extrap1d</code> takes an interpolation function and returns a function which can also extrapolate. And you can use it like this:</p>\n<pre><code class=\"python\">x = arange(0,10)\ny = exp(-x/3.0)\nf_i = interp1d(x, y)\nf_x = extrap1d(f_i)\n\nprint f_x([9,10])\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">[ 0.04978707  0.03009069]\n</code></pre>\n", "abstract": "You can use interp function from scipy, it extrapolates left and right values as constant beyond the range: You can write a wrapper around an interpolation function which takes care of linear extrapolation. For example: extrap1d takes an interpolation function and returns a function which can also extrapolate. And you can use it like this: Output:"}, {"id": 11124709, "score": 9, "vote": 0, "content": "<p>What about scipy.interpolate.splrep (with degree 1 and no smoothing):</p>\n<pre><code class=\"python\">&gt;&gt; tck = scipy.interpolate.splrep([1, 2, 3, 4, 5], [1, 4, 9, 16, 25], k=1, s=0)\n&gt;&gt; scipy.interpolate.splev(6, tck)\n34.0\n</code></pre>\n<p>It seems to do what you want, since 34 = 25 + (25 - 16). </p>\n", "abstract": "What about scipy.interpolate.splrep (with degree 1 and no smoothing): It seems to do what you want, since 34 = 25 + (25 - 16). "}, {"id": 6933490, "score": 7, "vote": 0, "content": "<p>Here's an alternative method that uses only the numpy package. It takes advantage of numpy's array functions, so may be faster when interpolating/extrapolating large arrays:</p>\n<pre><code class=\"python\">import numpy as np\n\ndef extrap(x, xp, yp):\n    \"\"\"np.interp function with linear extrapolation\"\"\"\n    y = np.interp(x, xp, yp)\n    y = np.where(x&lt;xp[0], yp[0]+(x-xp[0])*(yp[0]-yp[1])/(xp[0]-xp[1]), y)\n    y = np.where(x&gt;xp[-1], yp[-1]+(x-xp[-1])*(yp[-1]-yp[-2])/(xp[-1]-xp[-2]), y)\n    return y\n\nx = np.arange(0,10)\ny = np.exp(-x/3.0)\nxtest = np.array((8.5,9.5))\n\nprint np.exp(-xtest/3.0)\nprint np.interp(xtest, x, y)\nprint extrap(xtest, x, y)\n</code></pre>\n<p>Edit: Mark Mikofski's suggested modification of the \"extrap\" function:</p>\n<pre><code class=\"python\">def extrap(x, xp, yp):\n    \"\"\"np.interp function with linear extrapolation\"\"\"\n    y = np.interp(x, xp, yp)\n    y[x &lt; xp[0]] = yp[0] + (x[x&lt;xp[0]]-xp[0]) * (yp[0]-yp[1]) / (xp[0]-xp[1])\n    y[x &gt; xp[-1]]= yp[-1] + (x[x&gt;xp[-1]]-xp[-1])*(yp[-1]-yp[-2])/(xp[-1]-xp[-2])\n    return y\n</code></pre>\n", "abstract": "Here's an alternative method that uses only the numpy package. It takes advantage of numpy's array functions, so may be faster when interpolating/extrapolating large arrays: Edit: Mark Mikofski's suggested modification of the \"extrap\" function:"}, {"id": 16834876, "score": 7, "vote": 0, "content": "<p>It may be faster to use <strong>boolean indexing</strong> with <strong>large datasets</strong>, since the algorithm checks if every point is in outside the interval, whereas boolean indexing allows an easier and faster comparison.</p>\n<p>For example:</p>\n<pre><code class=\"python\"># Necessary modules\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\n# Original data\nx = np.arange(0,10)\ny = np.exp(-x/3.0)\n\n# Interpolator class\nf = interp1d(x, y)\n\n# Output range (quite large)\nxo = np.arange(0, 10, 0.001)\n\n# Boolean indexing approach\n\n# Generate an empty output array for \"y\" values\nyo = np.empty_like(xo)\n\n# Values lower than the minimum \"x\" are extrapolated at the same time\nlow = xo &lt; f.x[0]\nyo[low] =  f.y[0] + (xo[low]-f.x[0])*(f.y[1]-f.y[0])/(f.x[1]-f.x[0])\n\n# Values higher than the maximum \"x\" are extrapolated at same time\nhigh = xo &gt; f.x[-1]\nyo[high] = f.y[-1] + (xo[high]-f.x[-1])*(f.y[-1]-f.y[-2])/(f.x[-1]-f.x[-2])\n\n# Values inside the interpolation range are interpolated directly\ninside = np.logical_and(xo &gt;= f.x[0], xo &lt;= f.x[-1])\nyo[inside] = f(xo[inside])\n</code></pre>\n<p>In my case, with a data set of 300000 points, this means an speed up from 25.8 to 0.094 seconds, this is <strong>more than 250 times faster</strong>.</p>\n", "abstract": "It may be faster to use boolean indexing with large datasets, since the algorithm checks if every point is in outside the interval, whereas boolean indexing allows an easier and faster comparison. For example: In my case, with a data set of 300000 points, this means an speed up from 25.8 to 0.094 seconds, this is more than 250 times faster."}, {"id": 4206158, "score": 2, "vote": 0, "content": "<p>I did it by adding a point to my initial arrays. In this way I avoid defining self-made functions, and the linear extrapolation (in the example below: right extrapolation) looks ok.</p>\n<pre><code class=\"python\">import numpy as np  \nfrom scipy import interp as itp  \n\nxnew = np.linspace(0,1,51)  \nx1=xold[-2]  \nx2=xold[-1]  \ny1=yold[-2]  \ny2=yold[-1]  \nright_val=y1+(xnew[-1]-x1)*(y2-y1)/(x2-x1)  \nx=np.append(xold,xnew[-1])  \ny=np.append(yold,right_val)  \nf = itp(xnew,x,y)  \n</code></pre>\n", "abstract": "I did it by adding a point to my initial arrays. In this way I avoid defining self-made functions, and the linear extrapolation (in the example below: right extrapolation) looks ok."}, {"id": 2745510, "score": 1, "vote": 0, "content": "<p>I'm afraid that there is no easy to do this in Scipy to my knowledge. You can, as I'm fairly sure that you are aware, turn off the bounds errors and fill all function values beyond the range with a constant, but that doesn't really help. See <a href=\"http://mail.scipy.org/pipermail/scipy-user/2009-January/019409.html\" rel=\"nofollow noreferrer\">this question</a> on the mailing list for some more ideas. Maybe you could use some kind of piecewise function, but that seems like a major pain.</p>\n", "abstract": "I'm afraid that there is no easy to do this in Scipy to my knowledge. You can, as I'm fairly sure that you are aware, turn off the bounds errors and fill all function values beyond the range with a constant, but that doesn't really help. See this question on the mailing list for some more ideas. Maybe you could use some kind of piecewise function, but that seems like a major pain."}, {"id": 26244747, "score": 1, "vote": 0, "content": "<p>The below code gives you the simple extrapolation module. <em>k</em> is the value to which the data set <em>y</em> has to be extrapolated based on the data set <em>x.</em> The <code>numpy</code> module is required.</p>\n<pre><code class=\"python\"> def extrapol(k,x,y):\n        xm=np.mean(x);\n        ym=np.mean(y);\n        sumnr=0;\n        sumdr=0;\n        length=len(x);\n        for i in range(0,length):\n            sumnr=sumnr+((x[i]-xm)*(y[i]-ym));\n            sumdr=sumdr+((x[i]-xm)*(x[i]-xm));\n\n        m=sumnr/sumdr;\n        c=ym-(m*xm);\n        return((m*k)+c)\n</code></pre>\n", "abstract": "The below code gives you the simple extrapolation module. k is the value to which the data set y has to be extrapolated based on the data set x. The numpy module is required."}, {"id": 65307992, "score": 1, "vote": 0, "content": "<p>I don't have enough reputation to comment, but in case somebody is looking for an extrapolation wrapper for a linear 2d-interpolation with scipy, I have adapted the answer that was given here for the 1d interpolation.</p>\n<pre><code class=\"python\">def extrap2d(interpolator):\nxs = interpolator.x\nys = interpolator.y\nzs = interpolator.z\nzs = np.reshape(zs, (-1, len(xs)))\ndef pointwise(x, y):\n    if x &lt; xs[0] or y &lt; ys[0]:\n        x1_index = np.argmin(np.abs(xs - x))\n        x2_index = x1_index + 1\n        y1_index = np.argmin(np.abs(ys - y))\n        y2_index = y1_index + 1\n        x1 = xs[x1_index]\n        x2 = xs[x2_index]\n        y1 = ys[y1_index]\n        y2 = ys[y2_index]\n        z11 = zs[x1_index, y1_index]\n        z12 = zs[x1_index, y2_index]\n        z21 = zs[x2_index, y1_index]\n        z22 = zs[x2_index, y2_index]\n\n        return (z11 * (x2 - x) * (y2 - y) +\n        z21 * (x - x1) * (y2 - y) +\n        z12 * (x2 - x) * (y - y1) +\n        z22 * (x - x1) * (y - y1)\n       ) / ((x2 - x1) * (y2 - y1) + 0.0)\n\n\n    elif x &gt; xs[-1] or y &gt; ys[-1]:\n        x1_index = np.argmin(np.abs(xs - x))\n        x2_index = x1_index - 1\n        y1_index = np.argmin(np.abs(ys - y))\n        y2_index = y1_index - 1\n        x1 = xs[x1_index]\n        x2 = xs[x2_index]\n        y1 = ys[y1_index]\n        y2 = ys[y2_index]\n        z11 = zs[x1_index, y1_index]\n        z12 = zs[x1_index, y2_index]\n        z21 = zs[x2_index, y1_index]\n        z22 = zs[x2_index, y2_index]#\n\n        return (z11 * (x2 - x) * (y2 - y) +\n        z21 * (x - x1) * (y2 - y) +\n        z12 * (x2 - x) * (y - y1) +\n        z22 * (x - x1) * (y - y1)\n        ) / ((x2 - x1) * (y2 - y1) + 0.0)\n    else:\n        return interpolator(x, y)\ndef ufunclike(xs, ys):\n    if  isinstance(xs, int) or isinstance(ys, int) or isinstance(xs, np.int32) or isinstance(ys, np.int32):\n        res_array = pointwise(xs, ys)\n    else:\n        res_array = np.zeros((len(xs), len(ys)))\n        for x_c in range(len(xs)):\n            res_array[x_c, :] = np.array([pointwise(xs[x_c], ys[y_c]) for y_c in range(len(ys))]).T\n\n    return res_array\nreturn ufunclike\n</code></pre>\n<p>I haven't commented a lot and I am aware, that the code isn't super clean. If anybody sees any errors, please let me know. In my current use-case it is working without a problem :)</p>\n", "abstract": "I don't have enough reputation to comment, but in case somebody is looking for an extrapolation wrapper for a linear 2d-interpolation with scipy, I have adapted the answer that was given here for the 1d interpolation. I haven't commented a lot and I am aware, that the code isn't super clean. If anybody sees any errors, please let me know. In my current use-case it is working without a problem :)"}, {"id": 27491713, "score": 0, "vote": 0, "content": "<p>Standard interpolate + linear extrapolate:</p>\n<pre><code class=\"python\">    def interpola(v, x, y):\n        if v &lt;= x[0]:\n            return y[0]+(y[1]-y[0])/(x[1]-x[0])*(v-x[0])\n        elif v &gt;= x[-1]:\n            return y[-2]+(y[-1]-y[-2])/(x[-1]-x[-2])*(v-x[-2])\n        else:\n            f = interp1d(x, y, kind='cubic') \n            return f(v)\n</code></pre>\n", "abstract": "Standard interpolate + linear extrapolate:"}]}, {"link": "https://stackoverflow.com/questions/24587994/infinite-integer-in-python", "question": {"id": "24587994", "title": "Infinite integer in Python", "content": "<p>Python 3 has <code>float('inf')</code> and <code>Decimal('Infinity')</code> but no <code>int('inf')</code>. So, why a number representing the infinite set of integers is missing in the language? Is <code>int('inf')</code> unreasonable?</p>\n", "abstract": "Python 3 has float('inf') and Decimal('Infinity') but no int('inf'). So, why a number representing the infinite set of integers is missing in the language? Is int('inf') unreasonable?"}, "answers": [{"id": 35725065, "score": 17, "vote": 0, "content": "<p>You are right that an integer infinity is possible, and that none has been added to the Python standard.  This is probably because <code>math.inf</code> supplants it in almost all cases (as Martijn stated in his comment).</p>\n<p>In the meantime, I added an implementation of <a href=\"https://pypi.org/project/extended-int/\" rel=\"noreferrer\">extended integers</a> on PyPI:</p>\n<pre><code class=\"python\">In [0]: from numbers import Integral, Real\n\nIn [0]: from extended_int import int_inf, ExtendedIntegral, Infinite\n\nIn [0]: i = int_inf\n\nIn [4]: float(i)\nOut[4]: inf\n\nIn [5]: print(i)\ninf\n\nIn [6]: i ** i\n\nOut[6]: inf\n\nIn [7]: i\nOut[7]: inf\n\nIn [9]: isinstance(i, Real)\n\nOut[9]: True\n\nIn [10]: isinstance(i, Integral)\n\nOut[10]: False\n\nIn [11]: isinstance(i, Infinite)\n\nOut[11]: True\n\nIn [12]: isinstance(i, ExtendedIntegral)\n\nOut[12]: True\n\nIn [13]: isinstance(2, ExtendedIntegral)\n\nOut[13]: True\n\nIn [14]: isinstance(2, Infinite)\n\nOut[14]: False\n</code></pre>\n", "abstract": "You are right that an integer infinity is possible, and that none has been added to the Python standard.  This is probably because math.inf supplants it in almost all cases (as Martijn stated in his comment). In the meantime, I added an implementation of extended integers on PyPI:"}, {"id": 24588043, "score": 13, "vote": 0, "content": "<p>Taken from here: <a href=\"https://www.gnu.org/software/libc/manual/html_node/Infinity-and-NaN.html\">https://www.gnu.org/software/libc/manual/html_node/Infinity-and-NaN.html</a></p>\n<blockquote>\n<p>IEEE 754 floating point numbers can represent positive or negative infinity, and NaN (not a number)</p>\n</blockquote>\n<p>That is, the representation of <code>float</code> and <code>Decimal</code> can store these special values. However, there is nothing within the basic type <code>int</code> that can store the same. As you exceed the limit of 2^32 in an unsigned 32-bit int, you simply roll over to 0 again.</p>\n<p>If you want, you could create a class containing an integer which could feature the possibility of infinite values.</p>\n", "abstract": "Taken from here: https://www.gnu.org/software/libc/manual/html_node/Infinity-and-NaN.html IEEE 754 floating point numbers can represent positive or negative infinity, and NaN (not a number) That is, the representation of float and Decimal can store these special values. However, there is nothing within the basic type int that can store the same. As you exceed the limit of 2^32 in an unsigned 32-bit int, you simply roll over to 0 again. If you want, you could create a class containing an integer which could feature the possibility of infinite values."}, {"id": 28878708, "score": 5, "vote": 0, "content": "<p>For python 2.\nIt is sometimes the case that you need a very large integer. For example, I may want to produce a subarray with x[:n] and, I may wish to sometimes set n to a value such that the whole array will be produced. Since you can't use a float for n (python wants an integer), you need a \"large integer\". A good way of doing this is to use the largest integer available: sys.maxint.\nHere is an example:</p>\n<pre><code class=\"python\"># MAX_SOURCES = sys.maxint # normal setting\nMAX_SOURCES = 5 # while testing\n\n# code to use an array ...\n... sources[:MAX_SOURCES]\n</code></pre>\n<p>So, while testing, I could use a smaller sources array but use the full array in production.</p>\n", "abstract": "For python 2.\nIt is sometimes the case that you need a very large integer. For example, I may want to produce a subarray with x[:n] and, I may wish to sometimes set n to a value such that the whole array will be produced. Since you can't use a float for n (python wants an integer), you need a \"large integer\". A good way of doing this is to use the largest integer available: sys.maxint.\nHere is an example: So, while testing, I could use a smaller sources array but use the full array in production."}]}, {"link": "https://stackoverflow.com/questions/5228383/how-do-i-find-the-distance-between-two-points", "question": {"id": "5228383", "title": "How do I find the distance between two points?", "content": "<p>Let's say I have x1, y1 and also x2, y2.</p>\n<p>How can I find the distance between them?\nIt's a simple math function, but is there a snippet of this online?</p>\n", "abstract": "Let's say I have x1, y1 and also x2, y2. How can I find the distance between them?\nIt's a simple math function, but is there a snippet of this online?"}, "answers": [{"id": 5228392, "score": 140, "vote": 0, "content": "<pre><code class=\"python\">dist = sqrt( (x2 - x1)**2 + (y2 - y1)**2 )\n</code></pre>\n<p>As others have pointed out, you can also use the equivalent built-in <a href=\"http://docs.python.org/2/library/math.html#math.hypot\" rel=\"noreferrer\"><code>math.hypot()</code></a>:</p>\n<pre><code class=\"python\">dist = math.hypot(x2 - x1, y2 - y1)\n</code></pre>\n", "abstract": "As others have pointed out, you can also use the equivalent built-in math.hypot():"}, {"id": 5230380, "score": 71, "vote": 0, "content": "<p>Let's not forget math.hypot:</p>\n<pre><code class=\"python\">dist = math.hypot(x2-x1, y2-y1)\n</code></pre>\n<p>Here's hypot as part of a snippet to compute the length of a path defined by a list of (x, y) tuples:</p>\n<pre><code class=\"python\">from math import hypot\n\npts = [\n    (10,10),\n    (10,11),\n    (20,11),\n    (20,10),\n    (10,10),\n    ]\n\n# Py2 syntax - no longer allowed in Py3\n# ptdiff = lambda (p1,p2): (p1[0]-p2[0], p1[1]-p2[1])\nptdiff = lambda p1, p2: (p1[0]-p2[0], p1[1]-p2[1])\n\ndiffs = (ptdiff(p1, p2) for p1, p2 in zip (pts, pts[1:]))\npath = sum(hypot(*d) for d in  diffs)\nprint(path)\n</code></pre>\n", "abstract": "Let's not forget math.hypot: Here's hypot as part of a snippet to compute the length of a path defined by a list of (x, y) tuples:"}, {"id": 5228423, "score": 18, "vote": 0, "content": "<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/O4MPw.png\"/>\nIt is an implementation of Pythagorean theorem. Link: <a href=\"http://en.wikipedia.org/wiki/Pythagorean_theorem\" rel=\"noreferrer\">http://en.wikipedia.org/wiki/Pythagorean_theorem</a></p>\n", "abstract": "\nIt is an implementation of Pythagorean theorem. Link: http://en.wikipedia.org/wiki/Pythagorean_theorem"}]}, {"link": "https://stackoverflow.com/questions/9320766/python-math-typeerror-nonetype-object-is-not-subscriptable", "question": {"id": "9320766", "title": "Python Math - TypeError: &#39;NoneType&#39; object is not subscriptable", "content": "<p>I'm making a small program for math (no particular reason, just kind of wanted to) and I ran into the error \"TypeError: 'NoneType' object is not subscriptable.</p>\n<p>I have never before seen this error, so I have no idea what it means.</p>\n<pre><code class=\"python\">import math\n\nprint(\"The format you should consider:\")\nprint str(\"value 1a\")+str(\" + \")+str(\"value 2\")+str(\" = \")+str(\"value 3a \")+str(\"value 4\")+str(\"\\n\")\n\nprint(\"Do not include the letters in the input, it automatically adds them\")\n\nv1 = input(\"Value 1: \")\nv2 = input(\"Value 2: \")\nv3 = input(\"Value 3: \")\nv4 = input(\"Value 4: \")\n\nlista = [v1, v3]\nlista = list.sort(lista)\n\na = lista[1] - lista[0]\n\nlist = [v2, v4]\nlist = list.sort(list)\n\nb = list[1] = list[0]\n\nprint str(a)+str(\"a\")+str(\" = \")+str(b)\n</code></pre>\n<p>The error:</p>\n<pre><code class=\"python\">Traceback (most recent call last):\n  File \"C:/Users/Nathan/Documents/Python/New thing\", line 16, in &lt;module&gt;\n    a = lista[1] - lista[0]\nTypeError: 'NoneType' object is not subscriptable\n</code></pre>\n", "abstract": "I'm making a small program for math (no particular reason, just kind of wanted to) and I ran into the error \"TypeError: 'NoneType' object is not subscriptable. I have never before seen this error, so I have no idea what it means. The error:"}, "answers": [{"id": 9320799, "score": 70, "vote": 0, "content": "<pre><code class=\"python\">lista = list.sort(lista)\n</code></pre>\n<p>This should be</p>\n<pre><code class=\"python\">lista.sort()\n</code></pre>\n<p>The <code>.sort()</code> method is in-place, and returns None.  If you want something not in-place, which returns a value, you could use</p>\n<pre><code class=\"python\">sorted_list = sorted(lista)\n</code></pre>\n<p>Aside #1: please don't call your lists <code>list</code>.  That clobbers the builtin list type.</p>\n<p>Aside #2: I'm not sure what this line is meant to do:</p>\n<pre><code class=\"python\">print str(\"value 1a\")+str(\" + \")+str(\"value 2\")+str(\" = \")+str(\"value 3a \")+str(\"value 4\")+str(\"\\n\")\n</code></pre>\n<p>is it simply</p>\n<pre><code class=\"python\">print \"value 1a + value 2 = value 3a value 4\"\n</code></pre>\n<p>?  In other words, I don't know why you're calling str on things which are already str.</p>\n<p>Aside #3: sometimes you use <code>print(\"something\")</code> (Python 3 syntax) and sometimes you use <code>print \"something\"</code> (Python 2).  The latter would give you a SyntaxError in py3, so you must be running 2.*, in which case you probably don't want to get in the habit or you'll wind up printing tuples, with extra parentheses.  I admit that it'll work well enough here, because if there's only one element in the parentheses it's not interpreted as a tuple, but it looks strange to the pythonic eye..</p>\n", "abstract": "This should be The .sort() method is in-place, and returns None.  If you want something not in-place, which returns a value, you could use Aside #1: please don't call your lists list.  That clobbers the builtin list type. Aside #2: I'm not sure what this line is meant to do: is it simply ?  In other words, I don't know why you're calling str on things which are already str. Aside #3: sometimes you use print(\"something\") (Python 3 syntax) and sometimes you use print \"something\" (Python 2).  The latter would give you a SyntaxError in py3, so you must be running 2.*, in which case you probably don't want to get in the habit or you'll wind up printing tuples, with extra parentheses.  I admit that it'll work well enough here, because if there's only one element in the parentheses it's not interpreted as a tuple, but it looks strange to the pythonic eye.."}, {"id": 9320883, "score": 33, "vote": 0, "content": "<p>The exception <code>TypeError: 'NoneType' object is not subscriptable</code> happens because the value of <code>lista</code> is actually <code>None</code>. You can reproduce <code>TypeError</code> that you get in your code if you try this at the Python command line:</p>\n<pre><code class=\"python\">None[0]\n</code></pre>\n<p>The reason that <code>lista</code> gets set to None is because the return value of <code>list.sort()</code> is <code>None</code>... it does <em>not</em> return a sorted copy of the original list. Instead, as the <a href=\"http://docs.python.org/tutorial/datastructures.html#more-on-lists\">documentation points out</a>, the list gets sorted <strong>in-place</strong> instead of a copy being made (this is for efficiency reasons).</p>\n<p>If you do not want to alter the original version you can use</p>\n<pre><code class=\"python\">other_list = sorted(lista)\n</code></pre>\n", "abstract": "The exception TypeError: 'NoneType' object is not subscriptable happens because the value of lista is actually None. You can reproduce TypeError that you get in your code if you try this at the Python command line: The reason that lista gets set to None is because the return value of list.sort() is None... it does not return a sorted copy of the original list. Instead, as the documentation points out, the list gets sorted in-place instead of a copy being made (this is for efficiency reasons). If you do not want to alter the original version you can use"}, {"id": 50196690, "score": 0, "vote": 0, "content": "<p>At this link <a href=\"https://docs.python.org/2/tutorial/datastructures.html\" rel=\"nofollow noreferrer\">https://docs.python.org/2/tutorial/datastructures.html</a> you can read this method \n\"Sort the items of the list in place\" this means that the result value will on sorted and \nthe result will be on itself. The function returns None. </p>\n<p>When you assign the result to \"lista\" in line 14 </p>\n<pre><code class=\"python\">lista = list.sort(lista)\n</code></pre>\n<p>you area setting it to None. That is the error. None always has no data and can not be\nsubscriptable. \"TypeError: 'NoneType' object is not subscriptable\"</p>\n<p>to correct this error (for sort the list) do this at line 14:</p>\n<pre><code class=\"python\">lista.sort() # this will sort the list in line\n</code></pre>\n<p>But there are some other errors: \nin line 18 when you assign:</p>\n<pre><code class=\"python\">list = [v2, v4]\n</code></pre>\n<p>You clob this built in type \"list\" and you will get the following error:</p>\n<pre><code class=\"python\">TypeError: 'list' object is not callable\n</code></pre>\n<p>To correct this do that, say:</p>\n<pre><code class=\"python\">lista2 = [v2, v4]\n</code></pre>\n<p>Again in line 19 the same error of line 14. Do this to sort the other list:</p>\n<pre><code class=\"python\">lista2.sort()\n</code></pre>\n<p>In line 21 you are trying to index the built in type list. To correct do this:</p>\n<pre><code class=\"python\">b = lista2[1] = lista2[0]\n</code></pre>\n<p>With this your code will run fine. Finally the whole correct code:</p>\n<pre><code class=\"python\">import math\n\nprint(\"The format you should consider:\")\nprint str(\"value 1a\")+str(\" + \")+str(\"value 2\")+str(\" = \")+str(\"value 3a \")+str(\"value 4\")+str(\"\\n\")\n\nprint(\"Do not include the letters in the input, it automatically adds them\")\n\nv1 = input(\"Value 1: \")\nv2 = input(\"Value 2: \")\nv3 = input(\"Value 3: \")\nv4 = input(\"Value 4: \")\n\nlista = [v1, v3]\nlista.sort()\n\na = lista[1] - lista[0]\n\nlista2 = [v2, v4]\nlista2.sort()\n\nb = lista2[1] = lista2[0]\n\nprint str(a)+str(\"a\")+str(\" = \")+str(b)\n</code></pre>\n", "abstract": "At this link https://docs.python.org/2/tutorial/datastructures.html you can read this method \n\"Sort the items of the list in place\" this means that the result value will on sorted and \nthe result will be on itself. The function returns None.  When you assign the result to \"lista\" in line 14  you area setting it to None. That is the error. None always has no data and can not be\nsubscriptable. \"TypeError: 'NoneType' object is not subscriptable\" to correct this error (for sort the list) do this at line 14: But there are some other errors: \nin line 18 when you assign: You clob this built in type \"list\" and you will get the following error: To correct this do that, say: Again in line 19 the same error of line 14. Do this to sort the other list: In line 21 you are trying to index the built in type list. To correct do this: With this your code will run fine. Finally the whole correct code:"}, {"id": 54001455, "score": 0, "vote": 0, "content": "<p>As previously said in one of the answers this error occurs when value of the list turns out to be empty. Well though not fully relevant to this question, the same error occured for me while reading images using opencv and numpy because the file name was found to be different than that specified probably or because the working directory has not been specified properly.</p>\n", "abstract": "As previously said in one of the answers this error occurs when value of the list turns out to be empty. Well though not fully relevant to this question, the same error occured for me while reading images using opencv and numpy because the file name was found to be different than that specified probably or because the working directory has not been specified properly."}]}, {"link": "https://stackoverflow.com/questions/3939660/sieve-of-eratosthenes-finding-primes-python", "question": {"id": "3939660", "title": "Sieve of Eratosthenes - Finding Primes Python", "content": "<p>Just to clarify, this is not a homework problem :)</p>\n<p>I wanted to find primes for a math application I am building &amp; came across <a href=\"http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\" rel=\"noreferrer\"><strong>Sieve of Eratosthenes</strong></a> approach. </p>\n<p>I have written an implementation of it in Python. But it's terribly slow. For say, if I want to find all primes less than 2 million. It takes &gt; 20 mins. (I stopped it at this point). How can I speed this up?</p>\n<pre><code class=\"python\">def primes_sieve(limit):\n    limitn = limit+1\n    primes = range(2, limitn)\n\n    for i in primes:\n        factors = range(i, limitn, i)\n        for f in factors[1:]:\n            if f in primes:\n                primes.remove(f)\n    return primes\n\nprint primes_sieve(2000)\n</code></pre>\n<p><strong>UPDATE:</strong>\nI ended up doing profiling on this code &amp; found that quite a lot of time was spent on removing an element from the list. Quite understandable considering it has to traverse the entire list (worst-case) to find the element &amp; then remove it and then readjust the list (maybe some copy goes on?). Anyway, I chucked out list for dictionary. My new implementation - </p>\n<pre><code class=\"python\">def primes_sieve1(limit):\n    limitn = limit+1\n    primes = dict()\n    for i in range(2, limitn): primes[i] = True\n\n    for i in primes:\n        factors = range(i,limitn, i)\n        for f in factors[1:]:\n            primes[f] = False\n    return [i for i in primes if primes[i]==True]\n\nprint primes_sieve1(2000000)\n</code></pre>\n", "abstract": "Just to clarify, this is not a homework problem :) I wanted to find primes for a math application I am building & came across Sieve of Eratosthenes approach.  I have written an implementation of it in Python. But it's terribly slow. For say, if I want to find all primes less than 2 million. It takes > 20 mins. (I stopped it at this point). How can I speed this up? UPDATE:\nI ended up doing profiling on this code & found that quite a lot of time was spent on removing an element from the list. Quite understandable considering it has to traverse the entire list (worst-case) to find the element & then remove it and then readjust the list (maybe some copy goes on?). Anyway, I chucked out list for dictionary. My new implementation - "}, "answers": [{"id": 3941967, "score": 124, "vote": 0, "content": "<p>You're not quite implementing the correct algorithm:</p>\n<p>In your first example, <code>primes_sieve</code> doesn't maintain a list of primality flags to strike/unset (as in the algorithm), but instead resizes a list of integers continuously, which is very expensive: removing an item from a list requires shifting all subsequent items down by one.</p>\n<p>In the second example, <code>primes_sieve1</code> maintains a <em>dictionary</em> of primality flags, which is a step in the right direction, but it iterates over the dictionary in undefined order, and redundantly strikes out factors of factors (instead of only factors of primes, as in the algorithm). You could fix this by sorting the keys, and skipping non-primes (which already makes it an order of magnitude faster), but it's still much more efficient to just use a list directly.</p>\n<p>The correct algorithm (with a list instead of a dictionary) looks something like:</p>\n<pre><code class=\"python\">def primes_sieve2(limit):\n    a = [True] * limit                          # Initialize the primality list\n    a[0] = a[1] = False\n\n    for (i, isprime) in enumerate(a):\n        if isprime:\n            yield i\n            for n in range(i*i, limit, i):     # Mark factors non-prime\n                a[n] = False\n</code></pre>\n<p>(Note that this also includes the algorithmic optimization of starting the non-prime marking at the prime's square (<code>i*i</code>) instead of its double.)</p>\n", "abstract": "You're not quite implementing the correct algorithm: In your first example, primes_sieve doesn't maintain a list of primality flags to strike/unset (as in the algorithm), but instead resizes a list of integers continuously, which is very expensive: removing an item from a list requires shifting all subsequent items down by one. In the second example, primes_sieve1 maintains a dictionary of primality flags, which is a step in the right direction, but it iterates over the dictionary in undefined order, and redundantly strikes out factors of factors (instead of only factors of primes, as in the algorithm). You could fix this by sorting the keys, and skipping non-primes (which already makes it an order of magnitude faster), but it's still much more efficient to just use a list directly. The correct algorithm (with a list instead of a dictionary) looks something like: (Note that this also includes the algorithmic optimization of starting the non-prime marking at the prime's square (i*i) instead of its double.)"}, {"id": 20924623, "score": 15, "vote": 0, "content": "<pre><code class=\"python\">def eratosthenes(n):\n    multiples = []\n    for i in range(2, n+1):\n        if i not in multiples:\n            print (i)\n            for j in range(i*i, n+1, i):\n                multiples.append(j)\n\neratosthenes(100)\n</code></pre>\n", "abstract": ""}, {"id": 3939703, "score": 8, "vote": 0, "content": "<p>Removing from the beginning of an array (list) requires moving all of the items after it down.  That means that removing every element from a list in this way starting from the front is an O(n^2) operation.</p>\n<p>You can do this much more efficiently with sets:</p>\n<pre><code class=\"python\">def primes_sieve(limit):\n    limitn = limit+1\n    not_prime = set()\n    primes = []\n\n    for i in range(2, limitn):\n        if i in not_prime:\n            continue\n\n        for f in range(i*2, limitn, i):\n            not_prime.add(f)\n\n        primes.append(i)\n\n    return primes\n\nprint primes_sieve(1000000)\n</code></pre>\n<p>... or alternatively, avoid having to rearrange the list:</p>\n<pre><code class=\"python\">def primes_sieve(limit):\n    limitn = limit+1\n    not_prime = [False] * limitn\n    primes = []\n\n    for i in range(2, limitn):\n        if not_prime[i]:\n            continue\n        for f in xrange(i*2, limitn, i):\n            not_prime[f] = True\n\n        primes.append(i)\n\n    return primes\n</code></pre>\n", "abstract": "Removing from the beginning of an array (list) requires moving all of the items after it down.  That means that removing every element from a list in this way starting from the front is an O(n^2) operation. You can do this much more efficiently with sets: ... or alternatively, avoid having to rearrange the list:"}, {"id": 32012083, "score": 5, "vote": 0, "content": "<p>Much faster:</p>\n<pre><code class=\"python\">import time\ndef get_primes(n):\n  m = n+1\n  #numbers = [True for i in range(m)]\n  numbers = [True] * m #EDIT: faster\n  for i in range(2, int(n**0.5 + 1)):\n    if numbers[i]:\n      for j in range(i*i, m, i):\n        numbers[j] = False\n  primes = []\n  for i in range(2, m):\n    if numbers[i]:\n      primes.append(i)\n  return primes\n\nstart = time.time()\nprimes = get_primes(10000)\nprint(time.time() - start)\nprint(get_primes(100))\n</code></pre>\n", "abstract": "Much faster:"}, {"id": 24849646, "score": 2, "vote": 0, "content": "<p>I realise this isn't really answering the question of how to generate primes quickly, but perhaps some will find this alternative interesting: because python provides lazy evaluation via generators, eratosthenes' sieve can be implemented exactly as stated:</p>\n<pre><code class=\"python\">def intsfrom(n):\n    while True:\n        yield n\n        n += 1\n\ndef sieve(ilist):\n    p = next(ilist)\n    yield p\n    for q in sieve(n for n in ilist if n%p != 0):\n        yield q\n\n\ntry:\n    for p in sieve(intsfrom(2)):\n        print p,\n\n    print ''\nexcept RuntimeError as e:\n    print e\n</code></pre>\n<p>The try block is there because the algorithm runs until it blows the stack and without the\ntry block the backtrace is displayed pushing the actual output you want to see off screen.</p>\n", "abstract": "I realise this isn't really answering the question of how to generate primes quickly, but perhaps some will find this alternative interesting: because python provides lazy evaluation via generators, eratosthenes' sieve can be implemented exactly as stated: The try block is there because the algorithm runs until it blows the stack and without the\ntry block the backtrace is displayed pushing the actual output you want to see off screen."}, {"id": 39312927, "score": 2, "vote": 0, "content": "<p>By combining contributions from many enthusiasts (including Glenn Maynard and MrHIDEn from above comments), I came up with following piece of code in python 2:</p>\n<pre><code class=\"python\">def simpleSieve(sieveSize):\n    #creating Sieve.\n    sieve = [True] * (sieveSize+1)\n    # 0 and 1 are not considered prime.\n    sieve[0] = False\n    sieve[1] = False\n    for i in xrange(2,int(math.sqrt(sieveSize))+1):\n        if sieve[i] == False:\n            continue\n        for pointer in xrange(i**2, sieveSize+1, i):\n            sieve[pointer] = False\n    # Sieve is left with prime numbers == True\n    primes = []\n    for i in xrange(sieveSize+1):\n        if sieve[i] == True:\n            primes.append(i)\n    return primes\n\nsieveSize = input()\nprimes = simpleSieve(sieveSize)\n</code></pre>\n<p>Time taken for computation on my machine for different inputs in power of 10 is:</p>\n<ul>\n<li>3 : 0.3 ms</li>\n<li>4 : 2.4 ms</li>\n<li>5 : 23 ms</li>\n<li>6 : 0.26 s</li>\n<li>7 : 3.1 s</li>\n<li>8 : 33 s</li>\n</ul>\n", "abstract": "By combining contributions from many enthusiasts (including Glenn Maynard and MrHIDEn from above comments), I came up with following piece of code in python 2: Time taken for computation on my machine for different inputs in power of 10 is:"}, {"id": 58325110, "score": 2, "vote": 0, "content": "<p>Using a bit of <code>numpy</code>, I could find all primes below 100 million in a little over 2 seconds. </p>\n<p>There are two key features one should note</p>\n<ul>\n<li>Cut out multiples of <code>i</code> only for <code>i</code> up to root of <code>n</code></li>\n<li>Setting multiples of <code>i</code> to <code>False</code> using <code>x[2*i::i] = False</code> is much faster than an explicit python for loop.</li>\n</ul>\n<p>These two significantly speed up your code. For limits below one million, there is no perceptible running time.</p>\n<pre><code class=\"python\">import numpy as np\n\ndef primes(n):\n    x = np.ones((n+1,), dtype=np.bool)\n    x[0] = False\n    x[1] = False\n    for i in range(2, int(n**0.5)+1):\n        if x[i]:\n            x[2*i::i] = False\n\n    primes = np.where(x == True)[0]\n    return primes\n\nprint(len(primes(100_000_000)))\n</code></pre>\n", "abstract": "Using a bit of numpy, I could find all primes below 100 million in a little over 2 seconds.  There are two key features one should note These two significantly speed up your code. For limits below one million, there is no perceptible running time."}, {"id": 28267902, "score": 1, "vote": 0, "content": "<p>A simple speed hack: when you define the variable \"primes,\" set the step to 2 to skip all even numbers automatically, and set the starting point to 1.</p>\n<p>Then you can further optimize by instead of for i in primes, use for i in primes[:round(len(primes) ** 0.5)]. That will dramatically increase performance. In addition, you can eliminate numbers ending with 5 to further increase speed.</p>\n", "abstract": "A simple speed hack: when you define the variable \"primes,\" set the step to 2 to skip all even numbers automatically, and set the starting point to 1. Then you can further optimize by instead of for i in primes, use for i in primes[:round(len(primes) ** 0.5)]. That will dramatically increase performance. In addition, you can eliminate numbers ending with 5 to further increase speed."}, {"id": 37018738, "score": 1, "vote": 0, "content": "<p>My implementation:</p>\n<pre><code class=\"python\">import math\nn = 100\nmarked = {}\nfor i in range(2, int(math.sqrt(n))):\n    if not marked.get(i):\n        for x in range(i * i, n, i):\n            marked[x] = True\n\nfor i in range(2, n):\n    if not marked.get(i):\n        print i\n</code></pre>\n", "abstract": "My implementation:"}, {"id": 41493607, "score": 1, "vote": 0, "content": "<p>Here's a version that's a bit more memory-efficient (and: a proper sieve, not trial divisions).  Basically, instead of keeping an array of all the numbers, and crossing out those that aren't prime, this keeps an array of counters - one for each prime it's discovered - and leap-frogging them ahead of the putative prime.  That way, it uses storage proportional to the number of primes, not up to to the highest prime.</p>\n<pre><code class=\"python\">import itertools\n\ndef primes():\n\n    class counter:\n        def __init__ (this,  n): this.n, this.current,  this.isVirgin = n, n*n,  True\n            # isVirgin means it's never been incremented\n        def advancePast (this,  n): # return true if the counter advanced\n            if this.current &gt; n:\n                if this.isVirgin: raise StopIteration # if this is virgin, then so will be all the subsequent counters.  Don't need to iterate further.\n                return False\n            this.current += this.n # pre: this.current == n; post: this.current &gt; n.\n            this.isVirgin = False # when it's gone, it's gone\n            return True\n\n    yield 1\n    multiples = []\n    for n in itertools.count(2):\n        isPrime = True\n        for p in (m.advancePast(n) for m in multiples):\n            if p: isPrime = False\n        if isPrime:\n            yield n\n            multiples.append (counter (n))\n</code></pre>\n<p>You'll note that <code>primes()</code> is a generator, so you can keep the results in a list or you can use them directly.  Here's the first <code>n</code> primes:</p>\n<pre><code class=\"python\">import itertools\n\nfor k in itertools.islice (primes(),  n):\n    print (k)\n</code></pre>\n<p>And, for completeness, here's a timer to measure the performance:</p>\n<pre><code class=\"python\">import time\n\ndef timer ():\n    t,  k = time.process_time(),  10\n    for p in primes():\n        if p&gt;k:\n            print (time.process_time()-t,  \" to \",  p,  \"\\n\")\n            k *= 10\n            if k&gt;100000: return\n</code></pre>\n<p>Just in case you're wondering, I also wrote <code>primes()</code> as a simple iterator (using <code>__iter__</code> and <code>__next__</code>), and it ran at almost the same speed.  Surprised me too!</p>\n", "abstract": "Here's a version that's a bit more memory-efficient (and: a proper sieve, not trial divisions).  Basically, instead of keeping an array of all the numbers, and crossing out those that aren't prime, this keeps an array of counters - one for each prime it's discovered - and leap-frogging them ahead of the putative prime.  That way, it uses storage proportional to the number of primes, not up to to the highest prime. You'll note that primes() is a generator, so you can keep the results in a list or you can use them directly.  Here's the first n primes: And, for completeness, here's a timer to measure the performance: Just in case you're wondering, I also wrote primes() as a simple iterator (using __iter__ and __next__), and it ran at almost the same speed.  Surprised me too!"}, {"id": 46216475, "score": 1, "vote": 0, "content": "<p>I prefer NumPy because of speed.</p>\n<pre><code class=\"python\">import numpy as np\n\n# Find all prime numbers using Sieve of Eratosthenes\ndef get_primes1(n):\n    m = int(np.sqrt(n))\n    is_prime = np.ones(n, dtype=bool)\n    is_prime[:2] = False  # 0 and 1 are not primes\n\n    for i in range(2, m):\n        if is_prime[i] == False:\n            continue\n        is_prime[i*i::i] = False\n\n    return np.nonzero(is_prime)[0]\n\n# Find all prime numbers using brute-force.\ndef isprime(n):\n    ''' Check if integer n is a prime '''\n    n = abs(int(n))  # n is a positive integer\n    if n &lt; 2:  # 0 and 1 are not primes\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if not n &amp; 1:  # all other even numbers are not primes\n        return False\n    # Range starts with 3 and only needs to go up the square root\n    # of n for all odd numbers\n    for x in range(3, int(n**0.5)+1, 2):\n        if n % x == 0:\n            return False\n    return True\n\n# To apply a function to a numpy array, one have to vectorize the function\ndef get_primes2(n):\n    vectorized_isprime = np.vectorize(isprime)\n    a = np.arange(n)\n    return a[vectorized_isprime(a)]\n</code></pre>\n<p>Check the output:</p>\n<pre><code class=\"python\">n = 100\nprint(get_primes1(n))\nprint(get_primes2(n))    \n    [ 2  3  5  7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]\n    [ 2  3  5  7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97]\n</code></pre>\n<p>Compare the speed of Sieve of Eratosthenes and brute-force on Jupyter Notebook. Sieve of Eratosthenes in 539 times faster than brute-force for million elements. </p>\n<pre><code class=\"python\">%timeit get_primes1(1000000)\n%timeit get_primes2(1000000)\n4.79 ms \u00b1 90.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n2.58 s \u00b1 31.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code></pre>\n", "abstract": "I prefer NumPy because of speed. Check the output: Compare the speed of Sieve of Eratosthenes and brute-force on Jupyter Notebook. Sieve of Eratosthenes in 539 times faster than brute-force for million elements. "}, {"id": 49064457, "score": 1, "vote": 0, "content": "<p>I figured it must be possible to simply use the empty list as the terminating condition for the loop and came up with this:</p>\n<pre><code class=\"python\">limit = 100\nints = list(range(2, limit))   # Will end up empty\n\nwhile len(ints) &gt; 0:\n    prime = ints[0]\n    print prime\n    ints.remove(prime)\n    i = 2\n    multiple = prime * i\n    while multiple &lt;= limit:\n        if multiple in ints:\n            ints.remove(multiple)\n        i += 1\n        multiple = prime * i\n</code></pre>\n", "abstract": "I figured it must be possible to simply use the empty list as the terminating condition for the loop and came up with this:"}, {"id": 52509945, "score": 1, "vote": 0, "content": "<pre><code class=\"python\">import math\ndef sieve(n):\n    primes = [True]*n\n    primes[0] = False\n    primes[1] = False\n    for i in range(2,int(math.sqrt(n))+1):\n            j = i*i\n            while j &lt; n:\n                    primes[j] = False\n                    j = j+i\n    return [x for x in range(n) if primes[x] == True]\n</code></pre>\n", "abstract": ""}, {"id": 55987038, "score": 1, "vote": 0, "content": "<p>The fastest implementation I could come up with:</p>\n<pre><code class=\"python\">isprime = [True]*N\nisprime[0] = isprime[1] = False\nfor i in range(4, N, 2):\n    isprime[i] = False\nfor i in range(3, N, 2):\n    if isprime[i]:\n        for j in range(i*i, N, 2*i):\n            isprime[j] = False\n</code></pre>\n", "abstract": "The fastest implementation I could come up with:"}, {"id": 55997777, "score": 1, "vote": 0, "content": "<p>i think this is shortest code for finding primes with eratosthenes method</p>\n<pre><code class=\"python\">def prime(r):\n    n = range(2,r)\n    while len(n)&gt;0:\n        yield n[0]\n        n = [x for x in n if x not in range(n[0],r,n[0])]\n\n\nprint(list(prime(r)))\n</code></pre>\n", "abstract": "i think this is shortest code for finding primes with eratosthenes method"}, {"id": 64186248, "score": 1, "vote": 0, "content": "<p>I just came up with this. It may not be the fastest, but I'm not using anything other than straight additions and comparisons. Of course, what stops you here is the recursion limit.</p>\n<pre><code class=\"python\">def nondivsby2():\n    j = 1\n    while True:\n        j += 2\n        yield j\n\ndef nondivsbyk(k, nondivs):\n    j = 0\n    for i in nondivs:\n        while j &lt; i:\n            j += k\n        if j &gt; i:\n            yield i\n\ndef primes():\n    nd = nondivsby2()\n    while True:\n        p = next(nd)\n        nd = nondivsbyk(p, nd)\n        yield p\n\ndef main():\n    for p in primes():\n        print(p)\n</code></pre>\n", "abstract": "I just came up with this. It may not be the fastest, but I'm not using anything other than straight additions and comparisons. Of course, what stops you here is the recursion limit."}, {"id": 67854923, "score": 1, "vote": 0, "content": "<p>I made a one liner version of the Sieve of Eratosthenes</p>\n<pre><code class=\"python\">sieve = lambda j: [print(x) for x in filter(lambda n: 0 not in map(lambda i: n % i, range(2, n)) and (n!=1)&amp;(n!=0), range(j + 1))]\n</code></pre>\n<p>In terms of performance, I am pretty sure this isn't the fastest thing by any means, and in terms of readability / following PEP8, this is pretty terrible, but it's more the novelty of the length than anything.</p>\n<p>EDIT: Note that this simply prints the sieve &amp; does not return (if you attempt to print it you will get a list of Nones, if you want to return, change the print(x) in the list comprehension to just \"x\".</p>\n", "abstract": "I made a one liner version of the Sieve of Eratosthenes In terms of performance, I am pretty sure this isn't the fastest thing by any means, and in terms of readability / following PEP8, this is pretty terrible, but it's more the novelty of the length than anything. EDIT: Note that this simply prints the sieve & does not return (if you attempt to print it you will get a list of Nones, if you want to return, change the print(x) in the list comprehension to just \"x\"."}, {"id": 62730013, "score": 0, "vote": 0, "content": "<p>not sure if my code is efficeient, anyone care to comment?</p>\n<pre><code class=\"python\">from math import isqrt\n\ndef isPrime(n):\n    if n &gt;= 2: # cheating the 2, is 2 even prime?\n        for i in range(3, int(n / 2 + 1),2): # dont waste time with even numbers\n            if n % i == 0:\n                return False\n    return True\n\ndef primesTo(n): \n    x = [2] if n &gt;= 2 else [] # cheat the only even prime\n    if n &gt;= 2:\n        for i in range(3, n + 1,2): # dont waste time with even numbers\n            if isPrime(i):\n                x.append(i)  \n    return x\n\ndef primes2(n): # trying to do this using set methods and the \"Sieve of Eratosthenes\"\n    base = {2} # again cheating the 2\n    base.update(set(range(3, n + 1, 2))) # build the base of odd numbers\n    for i in range(3, isqrt(n) + 1, 2): # apply the sieve\n        base.difference_update(set(range(2 * i, n + 1 , i)))\n    return list(base)\n\nprint(primesTo(10000)) # 2 different methods for comparison\nprint(primes2(10000))\n</code></pre>\n", "abstract": "not sure if my code is efficeient, anyone care to comment?"}, {"id": 65050145, "score": 0, "vote": 0, "content": "<p>Probably the quickest way to have primary numbers is the following:</p>\n<pre><code class=\"python\">import sympy\nlist(sympy.primerange(lower, upper+1))\n</code></pre>\n<p>In case you don't need to store them, just use the code above without conversion to the <code>list</code>. <code>sympy.primerange</code> is a generator, so it does not consume memory.</p>\n", "abstract": "Probably the quickest way to have primary numbers is the following: In case you don't need to store them, just use the code above without conversion to the list. sympy.primerange is a generator, so it does not consume memory."}, {"id": 66091820, "score": 0, "vote": 0, "content": "<p>Using recursion and walrus operator:</p>\n<pre><code class=\"python\">def prime_factors(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if (q_r := divmod(n, i))[1] == 0:\n            return [i] + factor_list(q_r[0])\n    return [n]\n</code></pre>\n", "abstract": "Using recursion and walrus operator:"}, {"id": 71175467, "score": 0, "vote": 0, "content": "<h4>Basic sieve</h4>\n<p>with <code>numpy</code> is amazing fast. May be the fastest implementation</p>\n<pre><code class=\"python\"># record: sieve 1_000_000_000 in 6.9s (core i7 - 2.6Ghz)\ndef sieve_22max_naive(bound):\n    sieve = np.ones(bound, dtype=bool)  # default all prime\n    sieve[:2] = False  # 0, 1 is not prime\n\n    sqrt_bound = math.ceil(math.sqrt(bound))\n\n    for i in range(2, sqrt_bound):\n        if sieve[i]:\n            inc = i if i == 2 else 2 * i\n            sieve[i * i:bound:inc] = False\n\n    return np.arange(bound)[sieve]\n\n\nif __name__ == '__main__':\n    start = time.time()\n    prime_list = sieve_22max_naive(1_000_000_000)\n    print(f'Count: {len(prime_list):,}\\n'\n          f'Greatest: {prime_list[-1]:,}\\n'\n          f'Elapsed: %.3f' % (time.time() - start))\n</code></pre>\n<h4>Segment sieve (use less memory)</h4>\n<pre><code class=\"python\"># find prime in range [from..N), base on primes in range [2..from)\ndef sieve_era_part(primes, nfrom, n):\n    sieve_part = np.ones(n - nfrom, dtype=bool)  # default all prime\n\n    limit = math.ceil(math.sqrt(n))\n    # [2,3,5,7,11...p] can find primes &lt; (p+2)^2\n    if primes[-1] &lt; limit - 2:\n        print(f'Not enough base primes to find up to {n:,}')\n        return\n\n    for p in primes:\n        if p &gt;= limit: break\n\n        mul = p * p\n        inc = p * (2 if p &gt; 2 else 1)\n        if mul &lt; nfrom:\n            mul = math.ceil(nfrom / p) * p\n            (mul := mul + p) if p &gt; 2 and (mul &amp; 1) == 0 else ...  # odd, not even\n\n        sieve_part[mul - nfrom::inc] = False\n\n    return np.arange(nfrom, n)[sieve_part]\n    # return np.where(sieve_part)[0] + nfrom\n    # return [i + nfrom for i, is_p in enumerate(sieve_part) if is_p]\n    # return [i for i in range(max(nfrom, 2), n) if sieve_part[i - nfrom]]\n\n\n# find nth prime number, use less memory,\n# extend bound to SEG_SIZE each loop\n# record: 50_847_534 nth prime in 6.78s, core i7 - 9850H 2.6GHhz\ndef nth_prime(n):\n    # find prime up to bound\n    bound = 500_000\n    primes = sieve_22max_naive(bound)\n\n    SEG_SIZE = int(50e6)\n\n    while len(primes) &lt; n:\n        # sieve for next segment\n        new_primes = sieve_era_part(primes, bound, bound + SEG_SIZE)\n        # extend primes\n        bound += SEG_SIZE\n        primes = np.append(primes, new_primes)\n\n    return primes[n - 1]\n\n\nif __name__ == '__main__':\n    start = time.time()\n    prime = nth_prime(50_847_534)\n    print(f'{prime:,} Time %.6f' % (time.time() - start))\n</code></pre>\n", "abstract": "with numpy is amazing fast. May be the fastest implementation"}, {"id": 72444985, "score": 0, "vote": 0, "content": "<p>here is my solution, the same as <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\" rel=\"nofollow noreferrer\">Wikipedia</a></p>\n<pre><code class=\"python\">import math\n\n\ndef sieve_of_eratosthenes(n):\n    a = [i for i in range(2, n+1)]\n    clone_a = a[:]\n    b = [i for i in range(2, int(math.sqrt(n))+1)]\n    for i in b:\n        if i in a:\n            c = [pow(i, 2)+(j*i) for j in range(0, n+1)]\n            for j in c:\n                if j in clone_a:\n                    clone_a.remove(j)\n    return clone_a\n\n\nif __name__ == '__main__':\n    print(sieve_of_eratosthenes(23))\n</code></pre>\n", "abstract": "here is my solution, the same as Wikipedia"}]}, {"link": "https://stackoverflow.com/questions/20969773/exponentials-in-python-xy-vs-math-powx-y", "question": {"id": "20969773", "title": "Exponentials in python: x**y vs math.pow(x, y)", "content": "<p>Which one is more efficient using <code>math.pow</code> or the <code>**</code> operator? When should I use one over the other?</p>\n<p>So far I know that <code>x**y</code> can return an <code>int</code> or a <code>float</code> if you use a decimal\nthe function <code>pow</code> will return a float</p>\n<pre><code class=\"python\">import math\n\nprint( math.pow(10, 2) )\n\nprint( 10. ** 2 )\n</code></pre>\n", "abstract": "Which one is more efficient using math.pow or the ** operator? When should I use one over the other? So far I know that x**y can return an int or a float if you use a decimal\nthe function pow will return a float"}, "answers": [{"id": 20970087, "score": 130, "vote": 0, "content": "<p>Using the power operator <code>**</code> will be faster as it won\u2019t have the overhead of a function call. You can see this if you disassemble the Python code:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; dis.dis('7. ** i')\n  1           0 LOAD_CONST               0 (7.0) \n              3 LOAD_NAME                0 (i) \n              6 BINARY_POWER         \n              7 RETURN_VALUE         \n&gt;&gt;&gt; dis.dis('pow(7., i)')\n  1           0 LOAD_NAME                0 (pow) \n              3 LOAD_CONST               0 (7.0) \n              6 LOAD_NAME                1 (i) \n              9 CALL_FUNCTION            2 (2 positional, 0 keyword pair) \n             12 RETURN_VALUE         \n&gt;&gt;&gt; dis.dis('math.pow(7, i)')\n  1           0 LOAD_NAME                0 (math) \n              3 LOAD_ATTR                1 (pow) \n              6 LOAD_CONST               0 (7) \n              9 LOAD_NAME                2 (i) \n             12 CALL_FUNCTION            2 (2 positional, 0 keyword pair) \n             15 RETURN_VALUE         \n</code></pre>\n<p>Note that I\u2019m using a variable <code>i</code> as the exponent here because constant expressions like <code>7. ** 5</code> are actually evaluated at compile time.</p>\n<p>Now, in practice, this difference does not matter that much, as you can see when timing it:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from timeit import timeit\n&gt;&gt;&gt; timeit('7. ** i', setup='i = 5')\n0.2894785532627111\n&gt;&gt;&gt; timeit('pow(7., i)', setup='i = 5')\n0.41218495570683444\n&gt;&gt;&gt; timeit('math.pow(7, i)', setup='import math; i = 5')\n0.5655053168791255\n</code></pre>\n<p>So, while <code>pow</code> and <code>math.pow</code> are about twice as slow, they are still fast enough to not care much. Unless you can actually identify the exponentiation as a bottleneck, there won\u2019t be a reason to choose one method over the other if clarity decreases. This especially applies since <a href=\"http://docs.python.org/3/library/functions.html#pow\" rel=\"noreferrer\"><code>pow</code></a> offers an integrated modulo operation for example.</p>\n<hr/>\n<p>Alfe asked a good question in the comments above:</p>\n<blockquote>\n<p><code>timeit</code> shows that <code>math.pow</code> is slower than <code>**</code> in all cases. What is <code>math.pow()</code> good for anyway? Has anybody an idea where it can be of any advantage then?</p>\n</blockquote>\n<p>The big difference of <code>math.pow</code> to both the builtin <code>pow</code> and the power operator <code>**</code> is that it <em>always</em> uses float semantics. So if you, for some reason, want to make sure you get a float as a result back, then <code>math.pow</code> will ensure this property.</p>\n<p>Let\u2019s think of an example: We have two numbers, <code>i</code> and <code>j</code>, and have no idea if they are floats or integers. But we want to have a float result of <code>i^j</code>. So what options do we have?</p>\n<ul>\n<li>We can convert at least one of the arguments to a float and then do <code>i ** j</code>.</li>\n<li>We can do <code>i ** j</code> and convert the result to a float (float exponentation is automatically used when either <code>i</code> or <code>j</code> are floats, so the result is the same).</li>\n<li>We can use <code>math.pow</code>.</li>\n</ul>\n<p>So, let\u2019s test this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; timeit('float(i) ** j', setup='i, j = 7, 5')\n0.7610865891750791\n&gt;&gt;&gt; timeit('i ** float(j)', setup='i, j = 7, 5')\n0.7930400942188385\n&gt;&gt;&gt; timeit('float(i ** j)', setup='i, j = 7, 5')\n0.8946636625872202\n&gt;&gt;&gt; timeit('math.pow(i, j)', setup='import math; i, j = 7, 5')\n0.5699394063529439\n</code></pre>\n<p>As you can see, <code>math.pow</code> is actually faster! And if you think about it, the overhead from the function call is also gone now, because in all the other alternatives we have to call <code>float()</code>.</p>\n<hr/>\n<p>In addition, it might be worth to note that the behavior of <code>**</code> and <code>pow</code> can be overridden by implementing the special <code>__pow__</code> (and <code>__rpow__</code>) method for custom types. So if you don\u2019t want that (for whatever reason), using <code>math.pow</code> won\u2019t do that.</p>\n", "abstract": "Using the power operator ** will be faster as it won\u2019t have the overhead of a function call. You can see this if you disassemble the Python code: Note that I\u2019m using a variable i as the exponent here because constant expressions like 7. ** 5 are actually evaluated at compile time. Now, in practice, this difference does not matter that much, as you can see when timing it: So, while pow and math.pow are about twice as slow, they are still fast enough to not care much. Unless you can actually identify the exponentiation as a bottleneck, there won\u2019t be a reason to choose one method over the other if clarity decreases. This especially applies since pow offers an integrated modulo operation for example. Alfe asked a good question in the comments above: timeit shows that math.pow is slower than ** in all cases. What is math.pow() good for anyway? Has anybody an idea where it can be of any advantage then? The big difference of math.pow to both the builtin pow and the power operator ** is that it always uses float semantics. So if you, for some reason, want to make sure you get a float as a result back, then math.pow will ensure this property. Let\u2019s think of an example: We have two numbers, i and j, and have no idea if they are floats or integers. But we want to have a float result of i^j. So what options do we have? So, let\u2019s test this: As you can see, math.pow is actually faster! And if you think about it, the overhead from the function call is also gone now, because in all the other alternatives we have to call float(). In addition, it might be worth to note that the behavior of ** and pow can be overridden by implementing the special __pow__ (and __rpow__) method for custom types. So if you don\u2019t want that (for whatever reason), using math.pow won\u2019t do that."}, {"id": 59143871, "score": 26, "vote": 0, "content": "<p>The pow() function will allow you to add a third argument as a modulus. </p>\n<p>For example: I was recently faced with a memory error when doing </p>\n<blockquote>\n<p>2**23375247598357347582 % 23375247598357347583 </p>\n</blockquote>\n<p>Instead I did:</p>\n<blockquote>\n<p><code>pow(2, 23375247598357347582, 23375247598357347583)</code></p>\n</blockquote>\n<p>This returns in mere milliseconds instead of the massive amount of time and memory that the plain exponent takes. So, when dealing with large numbers and parallel modulus, pow() is more efficient, however when dealing with smaller numbers without modulus, ** is more efficient.</p>\n", "abstract": "The pow() function will allow you to add a third argument as a modulus.  For example: I was recently faced with a memory error when doing  2**23375247598357347582 % 23375247598357347583  Instead I did: pow(2, 23375247598357347582, 23375247598357347583) This returns in mere milliseconds instead of the massive amount of time and memory that the plain exponent takes. So, when dealing with large numbers and parallel modulus, pow() is more efficient, however when dealing with smaller numbers without modulus, ** is more efficient."}, {"id": 28539821, "score": 7, "vote": 0, "content": "<p>Just for the protocol: The <code>**</code> operator is equivalent to the two-argument version of the <a href=\"https://docs.python.org/2/library/functions.html#pow\" rel=\"nofollow noreferrer\">built-in <code>pow</code> function</a>, the <code>pow</code> <em>function</em> accepts an optional third argument (modulus) if the first two arguments are integers.</p>\n<p>So, if you intend to calculate remainders from powers, use the built-in function. The <code>math.pow</code> will give you false results for arguments of reasonable size:</p>\n<pre><code class=\"python\">import math\n\nbase = 13\nexp = 100\nmod = 2\nprint math.pow(base, exp) % mod\nprint pow(base, exp, mod)\n</code></pre>\n<p>When I ran this, I got <code>0.0</code> in the first case which obviously cannot be true, because 13 is odd (and therefore all of it's integral powers). The <code>math.pow</code> version uses the limited accuracy of the <a href=\"https://en.wikipedia.org/wiki/IEEE_754\" rel=\"nofollow noreferrer\">IEEE-754</a> <em>Double precision</em> (52 bits mantissa, slightly less than 16 decimal places) which causes an error here.</p>\n<p>For sake of fairness, we must say, <code>math.pow</code> <em>can</em> also be faster:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; min(timeit.repeat(\"pow(1.1, 9.9)\", number=2000000, repeat=5))\n0.3063715160001266\n&gt;&gt;&gt; min(timeit.repeat(\"math.pow(1.1, 9.9)\", setup=\"import math\", number=2000000, repeat=5))\n0.2647279420000359\n</code></pre>\n<p>The <code>math.pow</code> function had (and still has) its strength in engineering applications, but for number theoretical applications, you should use the built-in <code>pow</code> function.</p>\n<hr/>\n<p>Some online examples</p>\n<ul>\n<li><a href=\"http://ideone.com/qaDWRd\" rel=\"nofollow noreferrer\">http://ideone.com/qaDWRd</a> (wrong remainder with <code>math.pow</code>)</li>\n<li><a href=\"http://ideone.com/g7J9Un\" rel=\"nofollow noreferrer\">http://ideone.com/g7J9Un</a> (lower performance with <code>pow</code> on int values)</li>\n<li><a href=\"http://ideone.com/KnEtXj\" rel=\"nofollow noreferrer\">http://ideone.com/KnEtXj</a> (slightly lower performance with <code>pow</code> on float values)</li>\n</ul>\n<hr/>\n<p><strong>Update (inevitable correction):</strong> <br/>\nI removed the timing comparison of <code>math.pow(2,100)</code> and <code>pow(2,100)</code> since <code>math.pow</code> gives a wrong result whereas, for example, the comparison between <code>pow(2,50)</code> and <code>math.pow(2,50)</code> would have been fair (although not a realistic use of the <code>math</code>-module function). I added a better one and also the details that cause the limitation of <code>math.pow</code>.</p>\n", "abstract": "Just for the protocol: The ** operator is equivalent to the two-argument version of the built-in pow function, the pow function accepts an optional third argument (modulus) if the first two arguments are integers. So, if you intend to calculate remainders from powers, use the built-in function. The math.pow will give you false results for arguments of reasonable size: When I ran this, I got 0.0 in the first case which obviously cannot be true, because 13 is odd (and therefore all of it's integral powers). The math.pow version uses the limited accuracy of the IEEE-754 Double precision (52 bits mantissa, slightly less than 16 decimal places) which causes an error here. For sake of fairness, we must say, math.pow can also be faster: The math.pow function had (and still has) its strength in engineering applications, but for number theoretical applications, you should use the built-in pow function. Some online examples Update (inevitable correction): \nI removed the timing comparison of math.pow(2,100) and pow(2,100) since math.pow gives a wrong result whereas, for example, the comparison between pow(2,50) and math.pow(2,50) would have been fair (although not a realistic use of the math-module function). I added a better one and also the details that cause the limitation of math.pow."}, {"id": 30165286, "score": 6, "vote": 0, "content": "<p><code>**</code> is indeed faster then <code>math.pow()</code>, but if you want a simple quadratic function like in your example it is even faster to use a product.</p>\n<pre><code class=\"python\">10.*10.\n</code></pre>\n<p>will be faster then </p>\n<pre><code class=\"python\">10.**2\n</code></pre>\n<p>The difference is not big and not noticable with one operation (using <code>timeit</code>), but with a large number of operations it can be significant.</p>\n", "abstract": "** is indeed faster then math.pow(), but if you want a simple quadratic function like in your example it is even faster to use a product. will be faster then  The difference is not big and not noticable with one operation (using timeit), but with a large number of operations it can be significant."}, {"id": 20969837, "score": 4, "vote": 0, "content": "<p>Well, they are for different tasks, really.  </p>\n<p>Use <code>pow</code> (equivalent to <code>x ** y</code> with two arguments) when you want integer arithmetic.  </p>\n<p>And use <code>math.pow</code> if either argument is float, and you want float output.  </p>\n<p>For a discussion on the differences between <code>pow</code> and <code>math.pow</code>, see this <a href=\"https://stackoverflow.com/q/10282674/674039\">question</a>.</p>\n", "abstract": "Well, they are for different tasks, really.   Use pow (equivalent to x ** y with two arguments) when you want integer arithmetic.   And use math.pow if either argument is float, and you want float output.   For a discussion on the differences between pow and math.pow, see this question."}]}, {"link": "https://stackoverflow.com/questions/15894182/wrong-math-with-python", "question": {"id": "15894182", "title": "Wrong math with Python?", "content": "<p>Just starting out with Python, so this is probably my mistake, but...</p>\n<p>I'm trying out Python. I like to use it as a calculator, and I'm slowly working through some tutorials.</p>\n<p>I ran into something weird today. I wanted to find out 2013*2013, but I wrote the wrong thing and wrote 2013*013, and got this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 2013*013\n22143\n</code></pre>\n<p>I checked with my calculator, and 22143 is the wrong answer! 2013 * 13 is supposed to be 26169.</p>\n<p>Why is Python giving me a wrong answer? My old Casio calculator doesn't do this...</p>\n", "abstract": "Just starting out with Python, so this is probably my mistake, but... I'm trying out Python. I like to use it as a calculator, and I'm slowly working through some tutorials. I ran into something weird today. I wanted to find out 2013*2013, but I wrote the wrong thing and wrote 2013*013, and got this: I checked with my calculator, and 22143 is the wrong answer! 2013 * 13 is supposed to be 26169. Why is Python giving me a wrong answer? My old Casio calculator doesn't do this..."}, "answers": [{"id": 15894199, "score": 137, "vote": 0, "content": "<p>Because of octal arithmetic, 013 is actually the integer 11.  </p>\n<pre><code class=\"python\">&gt;&gt;&gt; 013\n11\n</code></pre>\n<p>With a leading zero, <code>013</code> is interpreted as a base-8 number and 1*8<sup>1</sup> + 3*8<sup>0</sup> = 11.  </p>\n<p>Note: this behaviour was <a href=\"http://docs.python.org/release/3.0.1/whatsnew/2.6.html#pep-3127-integer-literal-support-and-syntax\" rel=\"noreferrer\">changed in python 3</a>.  Here is a particularly appropriate quote from <a href=\"http://www.python.org/dev/peps/pep-3127/\" rel=\"noreferrer\">PEP 3127</a></p>\n<blockquote>\n<p>The default octal representation of integers is silently confusing to\n  people unfamiliar with C-like languages. It is extremely easy to\n  inadvertently create an integer object with the wrong value, because\n  '013' means 'decimal 11', not 'decimal 13', to the Python language\n  itself, which is not the meaning that most humans would assign to this\n  literal.</p>\n</blockquote>\n", "abstract": "Because of octal arithmetic, 013 is actually the integer 11.   With a leading zero, 013 is interpreted as a base-8 number and 1*81 + 3*80 = 11.   Note: this behaviour was changed in python 3.  Here is a particularly appropriate quote from PEP 3127 The default octal representation of integers is silently confusing to\n  people unfamiliar with C-like languages. It is extremely easy to\n  inadvertently create an integer object with the wrong value, because\n  '013' means 'decimal 11', not 'decimal 13', to the Python language\n  itself, which is not the meaning that most humans would assign to this\n  literal."}, {"id": 15894264, "score": 36, "vote": 0, "content": "<p><code>013</code> is an octal integer literal (equivalent to the decimal integer literal <code>11</code>), due to the leading 0.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 2013*013\n22143\n&gt;&gt;&gt; 2013*11\n22143\n&gt;&gt;&gt; 2013*13\n26169\n</code></pre>\n<p>It is very common (certainly in most of the languages I'm familiar with) to have octal integer literals start with <code>0</code> and hexadecimal integer literals start with <code>0x</code>.  Due to the exact confusion you experienced, Python 3 raises a SyntaxError:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 2013*013\n  File \"&lt;stdin&gt;\", line 1\n    2013*013\n           ^\nSyntaxError: invalid token\n</code></pre>\n<p>and requires either <code>0o</code> or <code>0O</code> instead:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 2013*0o13\n22143\n&gt;&gt;&gt; 2013*0O13\n22143 \n</code></pre>\n", "abstract": "013 is an octal integer literal (equivalent to the decimal integer literal 11), due to the leading 0. It is very common (certainly in most of the languages I'm familiar with) to have octal integer literals start with 0 and hexadecimal integer literals start with 0x.  Due to the exact confusion you experienced, Python 3 raises a SyntaxError: and requires either 0o or 0O instead:"}, {"id": 15913517, "score": 7, "vote": 0, "content": "<p>Python's 'leading zero' syntax for octal literals is a common gotcha:</p>\n<pre><code class=\"python\">Python 2.7.3\n&gt;&gt;&gt; 010\n8\n</code></pre>\n<p>The syntax was changed in Python 3.x <a href=\"http://docs.python.org/3.0/whatsnew/3.0.html#integers\" rel=\"nofollow\">http://docs.python.org/3.0/whatsnew/3.0.html#integers</a></p>\n", "abstract": "Python's 'leading zero' syntax for octal literals is a common gotcha: The syntax was changed in Python 3.x http://docs.python.org/3.0/whatsnew/3.0.html#integers"}, {"id": 15894380, "score": 5, "vote": 0, "content": "<p>This is mostly just expanding on @Wim's answer a bit, but Python indicates the base of integer literals using certain prefixes. Without a prefix, integers are interpreted as being in base-10. With an \"0x\", the integer will be interpreted as a hexadecimal int. The full grammar specification is here, though it's a bit tricky to understand if you're not familiar with formal grammars: <a href=\"http://docs.python.org/2/reference/lexical_analysis.html#integers\" rel=\"nofollow\">http://docs.python.org/2/reference/lexical_analysis.html#integers</a></p>\n<p>The table essentially says that if you want a long value (i.e. one that exceeds the capacity of a normal int), write the number followed by the letter \"L\" or \"l\"; if you want your number to be interpreted in decimal, write the number normally (with no leading 0); if you want it interpreted in octal, prefix it with \"0\", \"0o\", or \"0O\"; if you want it in hex, prefix it with \"0x\"; and if you want it in binary, prefix it with \"0b\" or \"0B\".</p>\n", "abstract": "This is mostly just expanding on @Wim's answer a bit, but Python indicates the base of integer literals using certain prefixes. Without a prefix, integers are interpreted as being in base-10. With an \"0x\", the integer will be interpreted as a hexadecimal int. The full grammar specification is here, though it's a bit tricky to understand if you're not familiar with formal grammars: http://docs.python.org/2/reference/lexical_analysis.html#integers The table essentially says that if you want a long value (i.e. one that exceeds the capacity of a normal int), write the number followed by the letter \"L\" or \"l\"; if you want your number to be interpreted in decimal, write the number normally (with no leading 0); if you want it interpreted in octal, prefix it with \"0\", \"0o\", or \"0O\"; if you want it in hex, prefix it with \"0x\"; and if you want it in binary, prefix it with \"0b\" or \"0B\"."}]}, {"link": "https://stackoverflow.com/questions/1907565/c-and-python-different-behaviour-of-the-modulo-operation", "question": {"id": "1907565", "title": "C and Python - different behaviour of the modulo (%) operation", "content": "<p>I have found that the same mod operation produces different results depending on what language is being used.</p>\n<p>In Python:</p>\n<pre><code class=\"python\">-1 % 10\n</code></pre>\n<p>produces <strong>9</strong></p>\n<p>In C it produces <strong>-1</strong> !</p>\n<ol>\n<li>Which one is the right modulo? <br/></li>\n<li>How to make mod operation in C to be the same like in Python?</li>\n</ol>\n", "abstract": "I have found that the same mod operation produces different results depending on what language is being used. In Python: produces 9 In C it produces -1 !"}, "answers": [{"id": 1907585, "score": 87, "vote": 0, "content": "<ol>\n<li>Both variants are correct, however in mathematics (number theory in particular), Python's <a href=\"http://en.wikipedia.org/wiki/Modulo_operation\" rel=\"noreferrer\">modulo</a> is most commonly used.</li>\n<li>In C, you do <code>((n % M) + M) % M</code> to get the same result as in Python. E. g. <code>((-1 % 10) + 10) % 10</code>. Note, how it still works for positive integers: <code>((17 % 10) + 10) % 10 == 17 % 10</code>, as well as for both variants of C implementations (positive or negative remainder).</li>\n</ol>\n", "abstract": ""}, {"id": 1907723, "score": 36, "vote": 0, "content": "<p>Python has a \"true\" modulo operation, while C has a <em>remainder</em> operation.</p>\n<p>It has a direct relation with how the negative integer division is handled, i.e. rounded towards 0 or minus infinite. Python rounds towards minus infinite and C(99) towards 0, but in both languages <code>(n/m)*m + n%m == n</code>, so the % operator must compensate in the correct direction.</p>\n<p>Ada is more explicit and has both, as <code>mod</code> and <code>rem</code>.</p>\n", "abstract": "Python has a \"true\" modulo operation, while C has a remainder operation. It has a direct relation with how the negative integer division is handled, i.e. rounded towards 0 or minus infinite. Python rounds towards minus infinite and C(99) towards 0, but in both languages (n/m)*m + n%m == n, so the % operator must compensate in the correct direction. Ada is more explicit and has both, as mod and rem."}, {"id": 1907889, "score": 17, "vote": 0, "content": "<p>In C89/90 the behavior of division operator and remainder operator with negative operands is <em>implementation-defined</em>, meaning that depending on the implementation you can get either behavior. It is just required that the operators agree with each other: from <code>a / b = q</code> and <code>a % b = r</code> follows <code>a = b * q + r</code>. Use static asserts in your code to check the behavior, if it relies critically on the result. </p>\n<p>In C99 the behavior you observe has become standard.</p>\n<p>In fact, either behaviors have certain logic in it. The Python's behavior implements the true modulo operation. The behavior you observed is C is consistent with rounding towards 0 (it's also Fortran behavior). </p>\n<p>One of the reasons the rounding towards 0 is preferred in C is that it is rather natural to expect the result of <code>-a / b</code> be the same as <code>-(a / b)</code>. In case of true modulo behavior, <code>-1 % 10</code> would evaluate to 9, meaning that <code>-1 / 10</code> has to be -1. This might be seen as rather unnatural, since <code>-(1 / 10)</code> is 0.</p>\n", "abstract": "In C89/90 the behavior of division operator and remainder operator with negative operands is implementation-defined, meaning that depending on the implementation you can get either behavior. It is just required that the operators agree with each other: from a / b = q and a % b = r follows a = b * q + r. Use static asserts in your code to check the behavior, if it relies critically on the result.  In C99 the behavior you observe has become standard. In fact, either behaviors have certain logic in it. The Python's behavior implements the true modulo operation. The behavior you observed is C is consistent with rounding towards 0 (it's also Fortran behavior).  One of the reasons the rounding towards 0 is preferred in C is that it is rather natural to expect the result of -a / b be the same as -(a / b). In case of true modulo behavior, -1 % 10 would evaluate to 9, meaning that -1 / 10 has to be -1. This might be seen as rather unnatural, since -(1 / 10) is 0."}, {"id": 1907584, "score": 5, "vote": 0, "content": "<p>Both answers are correct since <code>-1 modulo 10</code> is the same as <code>9 modulo 10</code>. </p>\n<pre><code class=\"python\">r = (a mod m)\na = n*q + r\n</code></pre>\n<p>You can be sure that <code>|r| &lt; |n|</code>, but not what the value of <code>r</code> is.   There are 2 answers, negative and positive.</p>\n<hr/>\n<p>In C89, although the answer will always be correct, the exact value of a modulo operation (they refer to it as remainder) is undefined, meaning it can be either a negative result or a positive result.   In C99 the result is defined. </p>\n<p>If you want the positive answer though, you can simply add 10 if you find your answer is negative. </p>\n<p>To get the modulo operator to work the same on all languages, just remember that:</p>\n<pre><code class=\"python\">n mod M == (n + M) mod M\n</code></pre>\n<p>and in general: </p>\n<pre><code class=\"python\">n mod M == (n + X * M) mod M\n</code></pre>\n", "abstract": "Both answers are correct since -1 modulo 10 is the same as 9 modulo 10.  You can be sure that |r| < |n|, but not what the value of r is.   There are 2 answers, negative and positive. In C89, although the answer will always be correct, the exact value of a modulo operation (they refer to it as remainder) is undefined, meaning it can be either a negative result or a positive result.   In C99 the result is defined.  If you want the positive answer though, you can simply add 10 if you find your answer is negative.  To get the modulo operator to work the same on all languages, just remember that: and in general: "}, {"id": 50958151, "score": 4, "vote": 0, "content": "<p>Performing Euclidean division <code>a = b*q + r</code>, is like rounding the fraction <code>a/b</code> to an integer quotient <code>q</code>, and then compute the remainder <code>r</code>.</p>\n<p>The different results you see depends on the convention used for rounding the quotient...</p>\n<p>If you round toward zero (truncate), you will get a symmetry around zero like in C:</p>\n<pre><code class=\"python\">truncate(7/3) = 2\n7 = 3*2 + 1\n\ntruncate(-7/3) = -2\n-7 = 3* -2 - 1\n\ntruncate(7/-3) = -2\n7 = -3* -2 + 1\n</code></pre>\n<p>If you round toward negative infinity (floor), you will get a remainder like in Python:</p>\n<pre><code class=\"python\">floor(7/3) = 2\n7 = 3*2 + 1\n\nfloor(-7/3) = -3\n-7 = 3* -3 + 2\n\nfloor(7/-3) = -3\n7 = -3* -3 - 2\n</code></pre>\n<p>If you round to nearest int (tie to whatever you want, to even, or away from zero) you'll get a centered modulo:</p>\n<pre><code class=\"python\">round(7/3) = 2\n7 = 3*2 + 1\n\nround(8/3) = 3\n8 = 3*3 - 1\n\nround(-7/3) = -2\n-7 = 3* -2 - 1\n\nround(7/-3) = -2\n7 = -3* -2 + 1\n</code></pre>\n<p>You could try to implement your own modulo with rounding toward positive infinity (ceil), and you would <em>invent</em> a rather unconventional modulo, but it would still be kind of modulo...</p>\n", "abstract": "Performing Euclidean division a = b*q + r, is like rounding the fraction a/b to an integer quotient q, and then compute the remainder r. The different results you see depends on the convention used for rounding the quotient... If you round toward zero (truncate), you will get a symmetry around zero like in C: If you round toward negative infinity (floor), you will get a remainder like in Python: If you round to nearest int (tie to whatever you want, to even, or away from zero) you'll get a centered modulo: You could try to implement your own modulo with rounding toward positive infinity (ceil), and you would invent a rather unconventional modulo, but it would still be kind of modulo..."}, {"id": 43851548, "score": 1, "vote": 0, "content": "<p>Since python 3.7 you can also use <a href=\"https://docs.python.org/3.7/library/math.html#math.remainder\" rel=\"nofollow noreferrer\"><code>.remainder()</code></a> from <a href=\"https://docs.python.org/3.7/library/math.html\" rel=\"nofollow noreferrer\"><code>math</code></a> built-in module.</p>\n<pre><code class=\"python\">Python 3.7.0a0 (heads/master:f34c685020, May  8 2017, 15:35:30)\n[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.remainder(-1, 10)\n-1.0\n</code></pre>\n<p>From <a href=\"https://docs.python.org/3.7/library/math.html#math.remainder\" rel=\"nofollow noreferrer\">docs</a>:</p>\n<blockquote>\n<p>Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference <code>x - n*y</code>, where n is the closest integer to the exact value of the quotient <code>x / y</code>. If <code>x / y</code> is exactly halfway between two consecutive integers, the nearest even integer is used for <code>n</code>. The remainder <code>r = remainder(x, y)</code> thus always satisfies <code>abs(r) &lt;= 0.5 * abs(y)</code>.</p>\n<p>Special cases follow IEEE 754: in particular, <code>remainder(x, math.inf)</code> is x for any finite x, and <code>remainder(x, 0)</code> and <code>remainder(math.inf, x)</code> raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x.</p>\n<p>On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced.</p>\n</blockquote>\n", "abstract": "Since python 3.7 you can also use .remainder() from math built-in module. From docs: Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference x - n*y, where n is the closest integer to the exact value of the quotient x / y. If x / y is exactly halfway between two consecutive integers, the nearest even integer is used for n. The remainder r = remainder(x, y) thus always satisfies abs(r) <= 0.5 * abs(y). Special cases follow IEEE 754: in particular, remainder(x, math.inf) is x for any finite x, and remainder(x, 0) and remainder(math.inf, x) raise ValueError for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced."}]}, {"link": "https://stackoverflow.com/questions/13670333/multiple-variables-in-scipys-optimize-minimize", "question": {"id": "13670333", "title": "Multiple variables in SciPy&#39;s optimize.minimize", "content": "<p>According to the <a href=\"http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html\" rel=\"noreferrer\">SciPy documentation</a> it is possible to minimize functions with multiple variables, yet it doesn't tell how to optimize on such functions.</p>\n<pre><code class=\"python\">from scipy.optimize import minimize\nfrom math import *\n\ndef f(c):\n  return sqrt((sin(pi/2) + sin(0) + sin(c) - 2)**2 + (cos(pi/2) + cos(0) + cos(c) - 1)**2)\n\nprint minimize(f, 3.14/2 + 3.14/7)\n</code></pre>\n<p>The above code does try to minimize the function <code>f</code>, but for my task I need to minimize with respect to three variables.</p>\n<p>Simply introducing a second argument and adjusting minimize accordingly yields an error (<code>TypeError: f() takes exactly 2 arguments (1 given)</code>).</p>\n<p><strong>How does <code>minimize</code> work when minimizing with multiple variables.</strong></p>\n", "abstract": "According to the SciPy documentation it is possible to minimize functions with multiple variables, yet it doesn't tell how to optimize on such functions. The above code does try to minimize the function f, but for my task I need to minimize with respect to three variables. Simply introducing a second argument and adjusting minimize accordingly yields an error (TypeError: f() takes exactly 2 arguments (1 given)). How does minimize work when minimizing with multiple variables."}, "answers": [{"id": 13670414, "score": 104, "vote": 0, "content": "<p>Pack the multiple variables into a single array: </p>\n<pre><code class=\"python\">import scipy.optimize as optimize\n\ndef f(params):\n    # print(params)  # &lt;-- you'll see that params is a NumPy array\n    a, b, c = params # &lt;-- for readability you may wish to assign names to the component variables\n    return a**2 + b**2 + c**2\n\ninitial_guess = [1, 1, 1]\nresult = optimize.minimize(f, initial_guess)\nif result.success:\n    fitted_params = result.x\n    print(fitted_params)\nelse:\n    raise ValueError(result.message)\n</code></pre>\n<p>yields</p>\n<pre><code class=\"python\">[ -1.66705302e-08  -1.66705302e-08  -1.66705302e-08]\n</code></pre>\n", "abstract": "Pack the multiple variables into a single array:  yields"}]}, {"link": "https://stackoverflow.com/questions/24633618/what-does-numpy-gradient-do", "question": {"id": "24633618", "title": "What does numpy.gradient do?", "content": "<p>So I know what the gradient of a (mathematical) function is, so I feel like I should know what <code>numpy.gradient</code> does. But I don't. The <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.gradient.html\" rel=\"noreferrer\">documentation</a> is not really helpful either:</p>\n<blockquote>\n<p>Return the gradient of an N-dimensional array.</p>\n</blockquote>\n<p>What is the gradient of an array? When is <code>numpy.gradient</code> useful?</p>\n", "abstract": "So I know what the gradient of a (mathematical) function is, so I feel like I should know what numpy.gradient does. But I don't. The documentation is not really helpful either: Return the gradient of an N-dimensional array. What is the gradient of an array? When is numpy.gradient useful?"}, "answers": [{"id": 24633888, "score": 161, "vote": 0, "content": "<p>Also in the documentation<sup>1</sup>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; y = np.array([1, 2, 4, 7, 11, 16], dtype=np.float)\n&gt;&gt;&gt; j = np.gradient(y)\n&gt;&gt;&gt; j \narray([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n</code></pre>\n<ul>\n<li><p>Gradient is defined as (change in <code>y</code>)/(change in <code>x</code>).</p>\n</li>\n<li><p><code>x</code>, here, is the list index, so the difference between adjacent values is 1.</p>\n</li>\n<li><p>At the boundaries, the first difference is calculated. This means that at each end of the array, the gradient given is simply, the difference between the end two values (divided by 1)</p>\n</li>\n<li><p>Away from the boundaries the gradient for a particular index is given by taking the difference between the the values either side and dividing by 2.</p>\n</li>\n</ul>\n<p>So, the gradient of <code>y</code>, above, is calculated thus:</p>\n<pre><code class=\"python\">j[0] = (y[1]-y[0])/1 = (2-1)/1  = 1\nj[1] = (y[2]-y[0])/2 = (4-1)/2  = 1.5\nj[2] = (y[3]-y[1])/2 = (7-2)/2  = 2.5\nj[3] = (y[4]-y[2])/2 = (11-4)/2 = 3.5\nj[4] = (y[5]-y[3])/2 = (16-7)/2 = 4.5\nj[5] = (y[5]-y[4])/1 = (16-11)/1 = 5\n</code></pre>\n<p>You could find the minima of all the absolute values in the resulting array to find the turning points of a curve, for example.</p>\n<hr/>\n<p><sup>1</sup>The array is actually called <code>x</code> in the example in the docs, I've changed it to <code>y</code> to avoid confusion.</p>\n", "abstract": "Also in the documentation1: Gradient is defined as (change in y)/(change in x). x, here, is the list index, so the difference between adjacent values is 1. At the boundaries, the first difference is calculated. This means that at each end of the array, the gradient given is simply, the difference between the end two values (divided by 1) Away from the boundaries the gradient for a particular index is given by taking the difference between the the values either side and dividing by 2. So, the gradient of y, above, is calculated thus: You could find the minima of all the absolute values in the resulting array to find the turning points of a curve, for example. 1The array is actually called x in the example in the docs, I've changed it to y to avoid confusion."}, {"id": 24637575, "score": 22, "vote": 0, "content": "<blockquote>\n<p>The gradient is computed using central differences in the interior and\n  first differences at the boundaries.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p>The default distance is 1</p>\n</blockquote>\n<p>This <a href=\"http://en.wikipedia.org/wiki/Finite_difference\" rel=\"noreferrer\">means</a> that in the interior it is computed as</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Dv9F1.png\"/></p>\n<p>where h = 1.0</p>\n<p>and at the boundaries</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/lS3pt.png\"/></p>\n", "abstract": "The gradient is computed using central differences in the interior and\n  first differences at the boundaries. and The default distance is 1 This means that in the interior it is computed as  where h = 1.0 and at the boundaries "}, {"id": 60794187, "score": 22, "vote": 0, "content": "<p>Here is what is going on. The Taylor series expansion guides us on how to approximate the derivative, given the value at close points. The simplest comes from the first order Taylor series expansion for a C^2 function (two continuous derivatives)...</p>\n<ul>\n<li>f(x+h) = f(x) + f'(x)h+f''(xi)h^2/2.</li>\n</ul>\n<p>One can solve for f'(x)... </p>\n<ul>\n<li>f'(x) = [f(x+h) - f(x)]/h + O(h).</li>\n</ul>\n<p>Can we do better? Yes indeed. If we assume C^3, then the Taylor expansion is </p>\n<ul>\n<li>f(x+h) = f(x) + f'(x)h + f''(x)h^2/2 + f'''(xi) h^3/6, and </li>\n<li>f(x-h) = f(x) - f'(x)h + f''(x)h^2/2 - f'''(xi) h^3/6.</li>\n</ul>\n<p>Subtracting these (both the h^0 and h^2 terms drop out!) and solve for f'(x):</p>\n<ul>\n<li>f'(x) = [f(x+h) - f(x-h)]/(2h) + O(h^2).</li>\n</ul>\n<p>So, if we have a discretized function defined on equal distant partitions: \nx = x_0,x_0+h(=x_1),....,x_n=x_0+h*n, then numpy gradient will yield a \"derivative\" array using the first order estimate on the ends and the better estimates in the middle. </p>\n<p><strong>Example 1.</strong> If you don't specify any spacing, the interval is assumed to be 1. so if you call</p>\n<pre><code class=\"python\">f = np.array([5, 7, 4, 8])\n</code></pre>\n<p>what you are saying is that f(0) = 5, f(1) = 7, f(2) = 4, and f(3) = 8. Then </p>\n<pre><code class=\"python\">np.gradient(f) \n</code></pre>\n<p>will be: f'(0) = (7 - 5)/1 = 2, f'(1) = (4 - 5)/(2*1) = -0.5, f'(2) = (8 - 7)/(2*1) = 0.5, f'(3) = (8 - 4)/1 = 4.</p>\n<p><strong>Example 2.</strong> If you specify a single spacing, the spacing is uniform but not 1.</p>\n<p>For example, if you call </p>\n<pre><code class=\"python\">np.gradient(f, 0.5)\n</code></pre>\n<p>this is saying that h = 0.5, not 1, i.e., the function is really f(0) = 5, f(0.5) = 7, f(1.0) = 4, f(1.5) = 8. The net effect is to replace h = 1 with h = 0.5 and all the results will be doubled. </p>\n<p><strong>Example 3.</strong> Suppose the discretized function f(x) is not defined on uniformly spaced intervals, for instance f(0) = 5, f(1) = 7, f(3) = 4, f(3.5) = 8, then there is a messier discretized differentiation function that the numpy gradient function uses and you will get the discretized derivatives by calling</p>\n<pre><code class=\"python\">np.gradient(f, np.array([0,1,3,3.5]))\n</code></pre>\n<p>Lastly, if your input is a 2d array, then you are thinking of a function f of x, y defined on a grid. The numpy gradient will output the arrays of \"discretized\" partial derivatives in x and y. </p>\n", "abstract": "Here is what is going on. The Taylor series expansion guides us on how to approximate the derivative, given the value at close points. The simplest comes from the first order Taylor series expansion for a C^2 function (two continuous derivatives)... One can solve for f'(x)...  Can we do better? Yes indeed. If we assume C^3, then the Taylor expansion is  Subtracting these (both the h^0 and h^2 terms drop out!) and solve for f'(x): So, if we have a discretized function defined on equal distant partitions: \nx = x_0,x_0+h(=x_1),....,x_n=x_0+h*n, then numpy gradient will yield a \"derivative\" array using the first order estimate on the ends and the better estimates in the middle.  Example 1. If you don't specify any spacing, the interval is assumed to be 1. so if you call what you are saying is that f(0) = 5, f(1) = 7, f(2) = 4, and f(3) = 8. Then  will be: f'(0) = (7 - 5)/1 = 2, f'(1) = (4 - 5)/(2*1) = -0.5, f'(2) = (8 - 7)/(2*1) = 0.5, f'(3) = (8 - 4)/1 = 4. Example 2. If you specify a single spacing, the spacing is uniform but not 1. For example, if you call  this is saying that h = 0.5, not 1, i.e., the function is really f(0) = 5, f(0.5) = 7, f(1.0) = 4, f(1.5) = 8. The net effect is to replace h = 1 with h = 0.5 and all the results will be doubled.  Example 3. Suppose the discretized function f(x) is not defined on uniformly spaced intervals, for instance f(0) = 5, f(1) = 7, f(3) = 4, f(3.5) = 8, then there is a messier discretized differentiation function that the numpy gradient function uses and you will get the discretized derivatives by calling Lastly, if your input is a 2d array, then you are thinking of a function f of x, y defined on a grid. The numpy gradient will output the arrays of \"discretized\" partial derivatives in x and y. "}, {"id": 24633911, "score": 2, "vote": 0, "content": "<p>Think about N-dimensional array as a matrix.\nThen gradient is nothing else as <em>matrix differentiation</em></p>\n<p>For a good explanation look at <a href=\"http://www.mathworks.ch/ch/help/matlab/ref/gradient.html\" rel=\"nofollow\">gradient</a> description in matlab documentation.</p>\n", "abstract": "Think about N-dimensional array as a matrix.\nThen gradient is nothing else as matrix differentiation For a good explanation look at gradient description in matlab documentation."}]}, {"link": "https://stackoverflow.com/questions/15390807/integer-square-root-in-python", "question": {"id": "15390807", "title": "Integer square root in python", "content": "<p>Is there an integer square root somewhere in python, or in standard libraries?  I want it to be exact (i.e. return an integer), and bark if there's no solution.  </p>\n<p>At the moment I rolled my own naive one:</p>\n<pre><code class=\"python\">def isqrt(n):\n    i = int(math.sqrt(n) + 0.5)\n    if i**2 == n:\n        return i\n    raise ValueError('input was not a perfect square')\n</code></pre>\n<p>But it's ugly and I don't really trust it for large integers.  I could iterate through the squares and give up if I've exceeded the value, but I assume it would be kinda slow to do something like that.  Also I guess I'd probably be reinventing the wheel, something like this must surely exist in python already...  </p>\n", "abstract": "Is there an integer square root somewhere in python, or in standard libraries?  I want it to be exact (i.e. return an integer), and bark if there's no solution.   At the moment I rolled my own naive one: But it's ugly and I don't really trust it for large integers.  I could iterate through the squares and give up if I've exceeded the value, but I assume it would be kinda slow to do something like that.  Also I guess I'd probably be reinventing the wheel, something like this must surely exist in python already...  "}, "answers": [{"id": 15391420, "score": 101, "vote": 0, "content": "<p><em><strong>Note:</strong> There is now <a href=\"https://docs.python.org/3/library/math.html#math.isqrt\" rel=\"nofollow noreferrer\"><code>math.isqrt</code></a> in stdlib, available since Python 3.8.</em></p>\n<p>Newton's method works perfectly well on integers:</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">def isqrt(n):\n    x = n\n    y = (x + 1) // 2\n    while y &lt; x:\n        x = y\n        y = (x + n // x) // 2\n    return x\n</code></pre>\n<p>This returns the largest integer <em>x</em> for which <em>x</em> * <em>x</em> does not exceed <em>n</em>. If you want to check if the result is exactly the square root, simply perform the multiplication to check if <em>n</em> is a perfect square.</p>\n<p>I discuss this algorithm, and three other algorithms for calculating square roots, at <a href=\"http://programmingpraxis.com/2012/06/01/square-roots/\" rel=\"nofollow noreferrer\">my blog</a>.</p>\n", "abstract": "Note: There is now math.isqrt in stdlib, available since Python 3.8. Newton's method works perfectly well on integers: This returns the largest integer x for which x * x does not exceed n. If you want to check if the result is exactly the square root, simply perform the multiplication to check if n is a perfect square. I discuss this algorithm, and three other algorithms for calculating square roots, at my blog."}, {"id": 53983683, "score": 41, "vote": 0, "content": "<p><strong>Update:</strong> <a href=\"https://docs.python.org/3/library/math.html#math.isqrt\" rel=\"noreferrer\">Python 3.8 has a <code>math.isqrt</code> function</a> in the standard library!</p>\n<p>I benchmarked every (correct) function here on both small (0\u20262<sup>22</sup>) and large (2<sup>50001</sup>) inputs.  The clear winners in both cases are <a href=\"https://stackoverflow.com/a/17495624/115030\"><code>gmpy2.isqrt</code> suggested by mathmandan</a> in first place, followed by Python 3.8\u2019s <a href=\"https://docs.python.org/3.8/library/math.html#math.isqrt\" rel=\"noreferrer\"><code>math.isqrt</code></a> in second, followed by the <a href=\"https://stackoverflow.com/a/15391114/115030\">ActiveState recipe linked by NPE</a> in third.  The ActiveState recipe has a bunch of divisions that can be replaced by shifts, which makes it a bit faster (but still behind the native functions):</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">def isqrt(n):\n    if n &gt; 0:\n        x = 1 &lt;&lt; (n.bit_length() + 1 &gt;&gt; 1)\n        while True:\n            y = (x + n // x) &gt;&gt; 1\n            if y &gt;= x:\n                return x\n            x = y\n    elif n == 0:\n        return 0\n    else:\n        raise ValueError(\"square root not defined for negative numbers\")\n</code></pre>\n<p>Benchmark results:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/a/17495624/115030\"><code>gmpy2.isqrt()</code> (mathmandan)</a>: 0.08 \u00b5s small, 0.07 ms large</li>\n<li><code>int(gmpy2.isqrt())</code>*: 0.3 \u00b5s small, 0.07 ms large</li>\n<li>Python 3.8 <a href=\"https://docs.python.org/3.8/library/math.html#math.isqrt\" rel=\"noreferrer\"><code>math.isqrt</code></a>: 0.13 \u00b5s small, 0.9 ms large</li>\n<li><strong>ActiveState (optimized as above)</strong>: 0.6 \u00b5s small, 17.0 ms large</li>\n<li><a href=\"https://stackoverflow.com/a/15391114/115030\">ActiveState (NPE)</a>: 1.0 \u00b5s small, 17.3 ms large</li>\n<li><a href=\"https://stackoverflow.com/a/39708338/115030\">castlebravo long-hand</a>: 4 \u00b5s small, 80 ms large</li>\n<li><a href=\"https://stackoverflow.com/a/31224469/115030\">mathmandan improved</a>: 2.7 \u00b5s small, 120 ms large</li>\n<li><a href=\"https://stackoverflow.com/a/15391068/115030\">martineau</a> (with <a href=\"https://stackoverflow.com/questions/15390807/integer-square-root-in-python/23279113#comment94803887_15391068\">this correction</a>): 2.3 \u00b5s small, 140 ms large</li>\n<li><a href=\"https://stackoverflow.com/a/23279113/115030\">nibot</a>: 8 \u00b5s small, 1000 ms large</li>\n<li><a href=\"https://stackoverflow.com/a/31224469/115030\">mathmandan</a>: 1.8 \u00b5s small, 2200 ms large</li>\n<li><a href=\"https://stackoverflow.com/a/39708338/115030\">castlebravo Newton\u2019s method</a>: 1.5 \u00b5s small, 19000 ms large</li>\n<li><a href=\"https://stackoverflow.com/a/15391420/115030\">user448810</a>: 1.4 \u00b5s small, 20000 ms large</li>\n</ul>\n<p>(* Since <code>gmpy2.isqrt</code> returns a <code>gmpy2.mpz</code> object, which behaves mostly but not exactly like an <code>int</code>, you may need to convert it back to an <code>int</code> for some uses.)</p>\n", "abstract": "Update: Python 3.8 has a math.isqrt function in the standard library! I benchmarked every (correct) function here on both small (0\u2026222) and large (250001) inputs.  The clear winners in both cases are gmpy2.isqrt suggested by mathmandan in first place, followed by Python 3.8\u2019s math.isqrt in second, followed by the ActiveState recipe linked by NPE in third.  The ActiveState recipe has a bunch of divisions that can be replaced by shifts, which makes it a bit faster (but still behind the native functions): Benchmark results: (* Since gmpy2.isqrt returns a gmpy2.mpz object, which behaves mostly but not exactly like an int, you may need to convert it back to an int for some uses.)"}, {"id": 17495624, "score": 21, "vote": 0, "content": "<p>Sorry for the very late response; I just stumbled onto this page.  In case anyone visits this page in the future, the python module gmpy2 is designed to work with very large inputs, and includes among other things an integer square root function.</p>\n<p>Example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import gmpy2\n&gt;&gt;&gt; gmpy2.isqrt((10**100+1)**2)\nmpz(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001L)\n&gt;&gt;&gt; gmpy2.isqrt((10**100+1)**2 - 1)\nmpz(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000L)\n</code></pre>\n<p>Granted, everything will have the \"mpz\" tag, but mpz's are compatible with int's:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; gmpy2.mpz(3)*4\nmpz(12)\n\n&gt;&gt;&gt; int(gmpy2.mpz(12))\n12\n</code></pre>\n<p>See <a href=\"https://stackoverflow.com/a/31224469/2554867\">my other answer</a> for a discussion of this method's performance relative to some other answers to this question.</p>\n<p>Download: <a href=\"https://code.google.com/p/gmpy/\" rel=\"noreferrer\">https://code.google.com/p/gmpy/</a></p>\n", "abstract": "Sorry for the very late response; I just stumbled onto this page.  In case anyone visits this page in the future, the python module gmpy2 is designed to work with very large inputs, and includes among other things an integer square root function. Example: Granted, everything will have the \"mpz\" tag, but mpz's are compatible with int's: See my other answer for a discussion of this method's performance relative to some other answers to this question. Download: https://code.google.com/p/gmpy/"}, {"id": 23279113, "score": 8, "vote": 0, "content": "<p><strong>Long-hand square root algorithm</strong></p>\n<p>It turns out that there is an algorithm for computing square roots that you can compute by hand, something like long-division.  Each iteration of the algorithm produces exactly one digit of the resulting square root while consuming two digits of the number whose square root you seek.  While the \"long hand\" version of the algorithm is specified in decimal, it works in any base, with binary being simplest to implement and perhaps the fastest to execute (depending on the underlying bignum representation).</p>\n<p>Because this algorithm operates on numbers digit-by-digit, it produces exact results for arbitrarily large perfect squares, and for non-perfect-squares, can produce as many digits of precision (to the right of the decimal place) as desired.</p>\n<p>There are two nice writeups on the \"Dr. Math\" site that explain the algorithm:</p>\n<ul>\n<li><a href=\"http://mathforum.org/library/drmath/view/52656.html\">Square Roots in Binary</a> </li>\n<li><a href=\"http://mathforum.org/library/drmath/view/52610.html\">Longhand Square Roots</a></li>\n</ul>\n<p>And here's an implementation in Python:</p>\n<pre><code class=\"python\">def exact_sqrt(x):\n    \"\"\"Calculate the square root of an arbitrarily large integer. \n\n    The result of exact_sqrt(x) is a tuple (a, r) such that a**2 + r = x, where\n    a is the largest integer such that a**2 &lt;= x, and r is the \"remainder\".  If\n    x is a perfect square, then r will be zero.\n\n    The algorithm used is the \"long-hand square root\" algorithm, as described at\n    http://mathforum.org/library/drmath/view/52656.html\n\n    Tobin Fricke 2014-04-23\n    Max Planck Institute for Gravitational Physics\n    Hannover, Germany\n    \"\"\"\n\n    N = 0   # Problem so far\n    a = 0   # Solution so far\n\n    # We'll process the number two bits at a time, starting at the MSB\n    L = x.bit_length()\n    L += (L % 2)          # Round up to the next even number\n\n    for i in xrange(L, -1, -1):\n\n        # Get the next group of two bits\n        n = (x &gt;&gt; (2*i)) &amp; 0b11\n\n        # Check whether we can reduce the remainder\n        if ((N - a*a) &lt;&lt; 2) + n &gt;= (a&lt;&lt;2) + 1:\n            b = 1\n        else:\n            b = 0\n\n        a = (a &lt;&lt; 1) | b   # Concatenate the next bit of the solution\n        N = (N &lt;&lt; 2) | n   # Concatenate the next bit of the problem\n\n    return (a, N-a*a)\n</code></pre>\n<p>You could easily modify this function to conduct additional iterations to calculate the fractional part of the square root.  I was most interested in computing roots of large perfect squares.</p>\n<p>I'm not sure how this compares to the \"integer Newton's method\" algorithm.  I suspect that Newton's method is faster, since it can in principle generate multiple bits of the solution in one iteration, while the \"long hand\" algorithm generates exactly one bit of the solution per iteration.</p>\n<p>Source repo: <a href=\"https://gist.github.com/tobin/11233492\">https://gist.github.com/tobin/11233492</a></p>\n", "abstract": "Long-hand square root algorithm It turns out that there is an algorithm for computing square roots that you can compute by hand, something like long-division.  Each iteration of the algorithm produces exactly one digit of the resulting square root while consuming two digits of the number whose square root you seek.  While the \"long hand\" version of the algorithm is specified in decimal, it works in any base, with binary being simplest to implement and perhaps the fastest to execute (depending on the underlying bignum representation). Because this algorithm operates on numbers digit-by-digit, it produces exact results for arbitrarily large perfect squares, and for non-perfect-squares, can produce as many digits of precision (to the right of the decimal place) as desired. There are two nice writeups on the \"Dr. Math\" site that explain the algorithm: And here's an implementation in Python: You could easily modify this function to conduct additional iterations to calculate the fractional part of the square root.  I was most interested in computing roots of large perfect squares. I'm not sure how this compares to the \"integer Newton's method\" algorithm.  I suspect that Newton's method is faster, since it can in principle generate multiple bits of the solution in one iteration, while the \"long hand\" algorithm generates exactly one bit of the solution per iteration. Source repo: https://gist.github.com/tobin/11233492"}, {"id": 31224469, "score": 8, "vote": 0, "content": "<p>Here's a very straightforward implementation:</p>\n<pre><code class=\"python\">def i_sqrt(n):\n    i = n.bit_length() &gt;&gt; 1    # i = floor( (1 + floor(log_2(n))) / 2 )\n    m = 1 &lt;&lt; i    # m = 2^i\n    #\n    # Fact: (2^(i + 1))^2 &gt; n, so m has at least as many bits \n    # as the floor of the square root of n.\n    #\n    # Proof: (2^(i+1))^2 = 2^(2i + 2) &gt;= 2^(floor(log_2(n)) + 2)\n    # &gt;= 2^(ceil(log_2(n) + 1) &gt;= 2^(log_2(n) + 1) &gt; 2^(log_2(n)) = n. QED.\n    #\n    while m*m &gt; n:\n        m &gt;&gt;= 1\n        i -= 1\n    for k in xrange(i-1, -1, -1):\n        x = m | (1 &lt;&lt; k)\n        if x*x &lt;= n:\n            m = x\n    return m\n</code></pre>\n<p>This is just a binary search.  Initialize the value <code>m</code> to be the largest power of 2 that does not exceed the square root, then check whether each smaller bit can be set while keeping the result no larger than the square root. (Check the bits one at a time, in descending order.)</p>\n<p>For reasonably large values of <code>n</code> (say, around <code>10**6000</code>, or around <code>20000</code> bits), this seems to be:</p>\n<ul>\n<li>Faster than the Newton's method implementation <a href=\"https://stackoverflow.com/a/15391420/2554867\">described by user448810</a>.</li>\n<li>Much, much slower than the <code>gmpy2</code> built-in method in <a href=\"https://stackoverflow.com/a/17495624/2554867\">my other answer</a>.</li>\n<li>Comparable to, but somewhat slower than, the Longhand Square Root <a href=\"https://stackoverflow.com/a/23279113/2554867\">described by nibot</a>.</li>\n</ul>\n<p>All of these approaches succeed on inputs of this size, but on my machine, this function takes around 1.5 seconds, while @Nibot's takes about 0.9 seconds, @user448810's takes around 19 seconds, and the gmpy2 built-in method takes less than a millisecond(!). Example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import random\n&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; import gmpy2\n&gt;&gt;&gt; r = random.getrandbits\n&gt;&gt;&gt; t = timeit.timeit\n&gt;&gt;&gt; t('i_sqrt(r(20000))', 'from __main__ import *', number = 5)/5. # This function\n1.5102493192883117\n&gt;&gt;&gt; t('exact_sqrt(r(20000))', 'from __main__ import *', number = 5)/5. # Nibot\n0.8952787937686366\n&gt;&gt;&gt; t('isqrt(r(20000))', 'from __main__ import *', number = 5)/5. # user448810\n19.326695976676184\n&gt;&gt;&gt; t('gmpy2.isqrt(r(20000))', 'from __main__ import *', number = 5)/5. # gmpy2\n0.0003599147067689046\n&gt;&gt;&gt; all(i_sqrt(n)==isqrt(n)==exact_sqrt(n)[0]==int(gmpy2.isqrt(n)) for n in (r(1500) for i in xrange(1500)))\nTrue\n</code></pre>\n<p>This function can be generalized easily, though it's not quite as nice because I don't have quite as precise of an  initial guess for <code>m</code>:</p>\n<pre><code class=\"python\">def i_root(num, root, report_exactness = True):\n    i = num.bit_length() / root\n    m = 1 &lt;&lt; i\n    while m ** root &lt; num:\n        m &lt;&lt;= 1\n        i += 1\n    while m ** root &gt; num:\n        m &gt;&gt;= 1\n        i -= 1\n    for k in xrange(i-1, -1, -1):\n        x = m | (1 &lt;&lt; k)\n        if x ** root &lt;= num:\n            m = x\n    if report_exactness:\n        return m, m ** root == num\n    return m\n</code></pre>\n<p>However, note that <code>gmpy2</code> also has an <code>i_root</code> method.</p>\n<p>In fact this method could be adapted and applied to any (nonnegative, increasing) function <code>f</code> to determine an \"integer inverse of <code>f</code>\". However, to choose an efficient initial value of <code>m</code> you'd still want to know something about <code>f</code>.</p>\n<p><strong>Edit: Thanks to @Greggo for pointing out that the <code>i_sqrt</code> function can be rewritten to avoid using any multiplications.</strong> This yields an impressive performance boost!</p>\n<pre><code class=\"python\">def improved_i_sqrt(n):\n    assert n &gt;= 0\n    if n == 0:\n        return 0\n    i = n.bit_length() &gt;&gt; 1    # i = floor( (1 + floor(log_2(n))) / 2 )\n    m = 1 &lt;&lt; i    # m = 2^i\n    #\n    # Fact: (2^(i + 1))^2 &gt; n, so m has at least as many bits\n    # as the floor of the square root of n.\n    #\n    # Proof: (2^(i+1))^2 = 2^(2i + 2) &gt;= 2^(floor(log_2(n)) + 2)\n    # &gt;= 2^(ceil(log_2(n) + 1) &gt;= 2^(log_2(n) + 1) &gt; 2^(log_2(n)) = n. QED.\n    #\n    while (m &lt;&lt; i) &gt; n: # (m&lt;&lt;i) = m*(2^i) = m*m\n        m &gt;&gt;= 1\n        i -= 1\n    d = n - (m &lt;&lt; i) # d = n-m^2\n    for k in xrange(i-1, -1, -1):\n        j = 1 &lt;&lt; k\n        new_diff = d - (((m&lt;&lt;1) | j) &lt;&lt; k) # n-(m+2^k)^2 = n-m^2-2*m*2^k-2^(2k)\n        if new_diff &gt;= 0:\n            d = new_diff\n            m |= j\n    return m\n</code></pre>\n<p>Note that by construction, the <code>k</code>th bit of <code>m &lt;&lt; 1</code> is not set, so bitwise-or may be used to implement the addition of <code>(m&lt;&lt;1) + (1&lt;&lt;k)</code>.  Ultimately I have <code>(2*m*(2**k) + 2**(2*k))</code> written as <code>(((m&lt;&lt;1) | (1&lt;&lt;k)) &lt;&lt; k)</code>, so it's three shifts and one bitwise-or (followed by a subtraction to get <code>new_diff</code>).  Maybe there is still a more efficient way to get this?  Regardless, it's far better than multiplying <code>m*m</code>! Compare with above:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; t('improved_i_sqrt(r(20000))', 'from __main__ import *', number = 5)/5.\n0.10908999762373242\n&gt;&gt;&gt; all(improved_i_sqrt(n) == i_sqrt(n) for n in xrange(10**6))\nTrue\n</code></pre>\n", "abstract": "Here's a very straightforward implementation: This is just a binary search.  Initialize the value m to be the largest power of 2 that does not exceed the square root, then check whether each smaller bit can be set while keeping the result no larger than the square root. (Check the bits one at a time, in descending order.) For reasonably large values of n (say, around 10**6000, or around 20000 bits), this seems to be: All of these approaches succeed on inputs of this size, but on my machine, this function takes around 1.5 seconds, while @Nibot's takes about 0.9 seconds, @user448810's takes around 19 seconds, and the gmpy2 built-in method takes less than a millisecond(!). Example: This function can be generalized easily, though it's not quite as nice because I don't have quite as precise of an  initial guess for m: However, note that gmpy2 also has an i_root method. In fact this method could be adapted and applied to any (nonnegative, increasing) function f to determine an \"integer inverse of f\". However, to choose an efficient initial value of m you'd still want to know something about f. Edit: Thanks to @Greggo for pointing out that the i_sqrt function can be rewritten to avoid using any multiplications. This yields an impressive performance boost! Note that by construction, the kth bit of m << 1 is not set, so bitwise-or may be used to implement the addition of (m<<1) + (1<<k).  Ultimately I have (2*m*(2**k) + 2**(2*k)) written as (((m<<1) | (1<<k)) << k), so it's three shifts and one bitwise-or (followed by a subtraction to get new_diff).  Maybe there is still a more efficient way to get this?  Regardless, it's far better than multiplying m*m! Compare with above:"}, {"id": 15391357, "score": 5, "vote": 0, "content": "<p>One option would be to use the <code>decimal</code> module, and do it in sufficiently-precise floats:</p>\n<pre><code class=\"python\">import decimal\n\ndef isqrt(n):\n    nd = decimal.Decimal(n)\n    with decimal.localcontext() as ctx:\n        ctx.prec = n.bit_length()\n        i = int(nd.sqrt())\n    if i**2 != n:\n        raise ValueError('input was not a perfect square')\n    return i\n</code></pre>\n<p>which I think should work:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; isqrt(1)\n1\n&gt;&gt;&gt; isqrt(7**14) == 7**7\nTrue\n&gt;&gt;&gt; isqrt(11**1000) == 11**500\nTrue\n&gt;&gt;&gt; isqrt(11**1000+1)\nTraceback (most recent call last):\n  File \"&lt;ipython-input-121-e80953fb4d8e&gt;\", line 1, in &lt;module&gt;\n    isqrt(11**1000+1)\n  File \"&lt;ipython-input-100-dd91f704e2bd&gt;\", line 10, in isqrt\n    raise ValueError('input was not a perfect square')\nValueError: input was not a perfect square\n</code></pre>\n", "abstract": "One option would be to use the decimal module, and do it in sufficiently-precise floats: which I think should work:"}, {"id": 15391068, "score": 4, "vote": 0, "content": "<p>Seems like you could check like this:</p>\n<pre><code class=\"python\">if int(math.sqrt(n))**2 == n:\n    print n, 'is a perfect square'\n</code></pre>\n<p>Update:</p>\n<p>As you pointed out the above fails for large values of <code>n</code>. For those the following looks promising, which is an adaptation of the example C code, by Martin Guy @ UKC, June 1985, for the relatively simple looking binary numeral digit-by-digit calculation method mentioned in the Wikipedia article <a href=\"http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_.28base_2.29\" rel=\"nofollow\">Methods of computing square roots</a>:</p>\n<pre><code class=\"python\">from math import ceil, log\n\ndef isqrt(n):\n    res = 0\n    bit = 4**int(ceil(log(n, 4))) if n else 0  # smallest power of 4 &gt;= the argument\n    while bit:\n        if n &gt;= res + bit:\n            n -= res + bit\n            res = (res &gt;&gt; 1) + bit\n        else:\n            res &gt;&gt;= 1\n        bit &gt;&gt;= 2\n    return res\n\nif __name__ == '__main__':\n    from math import sqrt  # for comparison purposes\n\n    for i in range(17)+[2**53, (10**100+1)**2]:\n        is_perfect_sq = isqrt(i)**2 == i\n        print '{:21,d}:  math.sqrt={:12,.7G}, isqrt={:10,d} {}'.format(\n            i, sqrt(i), isqrt(i), '(perfect square)' if is_perfect_sq else '')\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">                    0:  math.sqrt=           0, isqrt=         0 (perfect square)\n                    1:  math.sqrt=           1, isqrt=         1 (perfect square)\n                    2:  math.sqrt=    1.414214, isqrt=         1\n                    3:  math.sqrt=    1.732051, isqrt=         1\n                    4:  math.sqrt=           2, isqrt=         2 (perfect square)\n                    5:  math.sqrt=    2.236068, isqrt=         2\n                    6:  math.sqrt=     2.44949, isqrt=         2\n                    7:  math.sqrt=    2.645751, isqrt=         2\n                    8:  math.sqrt=    2.828427, isqrt=         2\n                    9:  math.sqrt=           3, isqrt=         3 (perfect square)\n                   10:  math.sqrt=    3.162278, isqrt=         3\n                   11:  math.sqrt=    3.316625, isqrt=         3\n                   12:  math.sqrt=    3.464102, isqrt=         3\n                   13:  math.sqrt=    3.605551, isqrt=         3\n                   14:  math.sqrt=    3.741657, isqrt=         3\n                   15:  math.sqrt=    3.872983, isqrt=         3\n                   16:  math.sqrt=           4, isqrt=         4 (perfect square)\n9,007,199,254,740,992:  math.sqrt=9.490627E+07, isqrt=94,906,265\n100,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,020,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,001:  math.sqrt=      1E+100, isqrt=10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,001 (perfect square)\n</code></pre>\n", "abstract": "Seems like you could check like this: Update: As you pointed out the above fails for large values of n. For those the following looks promising, which is an adaptation of the example C code, by Martin Guy @ UKC, June 1985, for the relatively simple looking binary numeral digit-by-digit calculation method mentioned in the Wikipedia article Methods of computing square roots: Output:"}, {"id": 66855184, "score": 4, "vote": 0, "content": "<p>Python's default <code>math</code> library has an integer square root function:</p>\n<blockquote>\n<h3><a href=\"https://docs.python.org/3/library/math.html#math.isqrt\" rel=\"nofollow noreferrer\"><code>math.isqrt(n)</code></a></h3>\n<p>Return the integer square root of the nonnegative integer <em>n</em>. This is the floor of the exact square root of <em>n</em>, or equivalently the greatest integer a such that <em>a\u00b2 \u2264 n</em>.</p>\n</blockquote>\n", "abstract": "Python's default math library has an integer square root function: Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a\u00b2 \u2264 n."}, {"id": 70841843, "score": 3, "vote": 0, "content": "<p>The script below extracts integer square roots. It uses no divisions, only bitshifts, so it is quite fast. It uses <a href=\"https://en.wikipedia.org/wiki/Newton%27s_method\" rel=\"nofollow noreferrer\">Newton's method</a> on the inverse square root, a technique made famous by <em>Quake III Arena</em> as mentioned in the Wikipedia article, <a href=\"https://en.wikipedia.org/wiki/Fast_inverse_square_root\" rel=\"nofollow noreferrer\">Fast inverse square root</a>.</p>\n<p>The strategy of the algorithm to compute <code>s = sqrt(Y)</code> is as follows.</p>\n<ol>\n<li>Reduce the argument Y to y in the range [1/4, 1), i.e., y = Y/B, with 1/4 &lt;= y &lt; 1, where B is an even power of 2, so <code>B = 2**(2*k)</code> for some integer k. We want to find X, where x = X/B, and x = 1 / sqrt(y).</li>\n<li>Determine a first approximation to X using a quadratic <a href=\"https://en.wikipedia.org/wiki/Minimax_approximation_algorithm\" rel=\"nofollow noreferrer\">minimax polynomial</a>.</li>\n<li>Refine X using Newton's method.</li>\n<li>Calculate <code>s = X*Y/(2**(3*k))</code>.</li>\n</ol>\n<p>We don't actually create fractions or perform any divisions. All the arithmetic is done with integers, and we use bit shifting to divide by various powers of B.</p>\n<p>Range reduction lets us find a good initial approximation to feed to Newton's method. Here's a version of the 2nd degree minimax polynomial approximation to the inverse square root in the interval [1/4, 1):</p>\n<p><a href=\"https://latex.codecogs.com/svg.image?y=(463x%5E2-896x+698)/256\" rel=\"nofollow noreferrer\"><img alt=\"Minimax poly for 1/sqrt(x)\" src=\"https://latex.codecogs.com/svg.image?y=(463x%5E2-896x+698)/256\"/></a></p>\n<p>(Sorry, I've reversed the meaning of x &amp; y here, to conform to the usual conventions). The maximum error of this approximation is around 0.0355 ~= 1/28. Here's a graph showing the error:</p>\n<p><a href=\"https://i.stack.imgur.com/1P3uy.png\" rel=\"nofollow noreferrer\"><img alt=\"Minimax poly error graph\" src=\"https://i.stack.imgur.com/1P3uy.png\"/></a></p>\n<p>Using this poly, our initial x starts with at least 4 or 5 bits of precision. Each round of Newton's method doubles the precision, so it doesn't take many rounds to get thousands of bits, if we want them.</p>\n<hr/>\n<pre><code class=\"python\">\"\"\" Integer square root\n\n    Uses no divisions, only shifts\n    \"Quake\" style algorithm,\n    i.e., Newton's method for 1 / sqrt(y)\n    Uses a quadratic minimax polynomial for the first approximation\n\n    Written by PM 2Ring 2022.01.23\n\"\"\"\n\ndef int_sqrt(y):\n    if y &lt; 0:\n        raise ValueError(\"int_sqrt arg must be &gt;= 0, not %s\" % y)\n    if y &lt; 2:\n        return y\n\n    # print(\"\\n*\", y, \"*\")\n    # Range reduction.\n    # Find k such that 1/4 &lt;= y/b &lt; 1, where b = 2 ** (k*2)\n    j = y.bit_length()\n    # Round k*2 up to the next even number\n    k2 = j + (j &amp; 1)\n    # k and some useful multiples\n    k = k2 &gt;&gt; 1\n    k3 = k2 + k\n    k6 = k3 &lt;&lt; 1\n    kd = k6 + 1\n    # b cubed\n    b3 = 1 &lt;&lt; k6\n\n    # Minimax approximation: x/b ~= 1 / sqrt(y/b)\n    x = (((463 * y * y) &gt;&gt; k2) - (896 * y) + (698 &lt;&lt; k2)) &gt;&gt; 8\n    # print(\"   \", x, h)\n\n    # Newton's method for 1 / sqrt(y/b)\n    epsilon = 1 &lt;&lt; k\n    for i in range(1, 99):\n        dx = x * (b3 - y * x * x) &gt;&gt; kd\n        x += dx\n        # print(f\" {i}: {x} {dx}\")\n        if abs(dx) &lt;= epsilon:\n            break\n\n    # s == sqrt(y)\n    s = x * y &gt;&gt; k3\n    # Adjust if too low\n    ss = s + 1\n    return ss if ss * ss &lt;= y else s\n\ndef test(lo, hi, step=1):\n    for y in range(lo, hi, step):\n        s = int_sqrt(y)\n        ss = s + 1\n        s2, ss2 = s * s, ss * ss\n        assert s2 &lt;= y &lt; ss2, (y, s2, ss2)\n    print(\"ok\")\n\ntest(0, 100000, 1)\n</code></pre>\n<p>This code is certainly <em>slower</em> than <code>math.isqrt</code> and <code>decimal.Decimal.sqrt</code>. Its purpose is simply to illustrate the algorithm. It would be interesting to see how fast it would be if it were implemented in C...</p>\n<hr/>\n<p>Here's a <a href=\"https://sagecell.sagemath.org/?z=eJx9VE1v2zgQvftXPGjRruyojiUXRhJYQfewBXpo0Rbd7aVAQFm0xUgmtSTVSAjS394h9WFnUVSABMzozczjmxkGQYB30vID1zD_NUxzaKXsbAZ6_jHcQCrk4rswQkkTQcmqgynE3hoPCT41rOQBjO0qDlYdlBa2OEb-p1jyZYQP_MEq-afBkdtC5dgrjRiXVE7bsJufKjEQgVwzK3Y4CimOrEWtqk6qo2CVj7MFx15oY8HqWquWMJaI9XS_UmnLJbIOH98j-SzkAckqSZareJmsZ0EQzGY530NIezcUv-l57tFhi1VvuUczYTj-ZVXD_9Za6TAYg8D0AceGGGQctylWESlk8cIEeIHhNEO-5Cwft42W6Hqif6DWlC8MvslFEKGLECyC-fDrM5MHagLPm5072nJwvxUyRwnT7ApSgVnEl6-xTdFdZlQqjvBQcGpehhQJFguE5SLpU96Tq1tmwt5VXB5sEU6VVONyLhI0Nazy4kreWvDvpKJsjhnXHlomlOIeFwjv8RLxGF-CUbxRR47G8H1TkS6VFXXF-9koKYpCb28R9_a6d1yg7O2Ns9fYbkdA7hwbAsRDiQy7JuO5tzIXHjt0uRl1fD-MybNpuEFLovxIz6bsMutJt5QiDMPXmzUW1CN6545fmczxCuHV9aZ30Uk311e-VDL3iKvnjXOTH6GNUMxHKr8f85EAr42olJxO4p0OKmgsaeyo9yE18_p6fhqe3LFuiVlIErzytJ3V9tTzCdfiIiXwZI9s9wEexdMNHtsnPObt0zBqw6SyzIQ55aJZGsidKnvZNWfleEiDNH22uGag1nku6wH2V37vNoSyW6VQqYce68Bm6u6wE-QlHH0X7uMmGryi5TOz2RtizzXbWb-2lhsbViqljStEGq_cE9HFw-uUFGONVXdNnTPL07eMEpx2uxAu7dl2G7oZ6LZK8UU3fPISLCWuEz_H4hcxPvls6lt36lulHLOe0ln73KnPrpyT_7kc3pVQtEm8n-SIRlkmADOG0x1EEC_U1qEjhHSDDKF9-mFKVRkM4-kU9gc40eoxrkYy_7_T9Ll-AjbIm1w=&amp;lang=python\" rel=\"nofollow noreferrer\">live version</a>, running on the SageMathCell server. Set <code>hi</code> &lt;= 0 to calculate and display the results for a single value set in <code>lo</code>. You can put expressions in the input boxes, eg set <code>hi</code> to 0 and <code>lo</code> to <code>2 * 10**100</code> to get <code>sqrt(2) * 10**50</code>.</p>\n", "abstract": "The script below extracts integer square roots. It uses no divisions, only bitshifts, so it is quite fast. It uses Newton's method on the inverse square root, a technique made famous by Quake III Arena as mentioned in the Wikipedia article, Fast inverse square root. The strategy of the algorithm to compute s = sqrt(Y) is as follows. We don't actually create fractions or perform any divisions. All the arithmetic is done with integers, and we use bit shifting to divide by various powers of B. Range reduction lets us find a good initial approximation to feed to Newton's method. Here's a version of the 2nd degree minimax polynomial approximation to the inverse square root in the interval [1/4, 1):  (Sorry, I've reversed the meaning of x & y here, to conform to the usual conventions). The maximum error of this approximation is around 0.0355 ~= 1/28. Here's a graph showing the error:  Using this poly, our initial x starts with at least 4 or 5 bits of precision. Each round of Newton's method doubles the precision, so it doesn't take many rounds to get thousands of bits, if we want them. This code is certainly slower than math.isqrt and decimal.Decimal.sqrt. Its purpose is simply to illustrate the algorithm. It would be interesting to see how fast it would be if it were implemented in C... Here's a live version, running on the SageMathCell server. Set hi <= 0 to calculate and display the results for a single value set in lo. You can put expressions in the input boxes, eg set hi to 0 and lo to 2 * 10**100 to get sqrt(2) * 10**50."}, {"id": 73843172, "score": 1, "vote": 0, "content": "<p>Inspired by all answers, decided to implement in pure C++ several best methods from these answers. As everybody knows C++ is always faster than Python.</p>\n<p>To glue C++ and Python I used <a href=\"https://cython.org/\" rel=\"nofollow noreferrer\">Cython</a>. It allows to make out of C++ a Python module and then call C++ functions directly from Python functions.</p>\n<p>Also as complementary I provided not only Python-adopted code, but pure C++ with tests too.</p>\n<p>Here are timings from pure C++ tests:</p>\n<pre><code class=\"python\">Test           'GMP', bits     64, time  0.000001 sec\nTest 'AndersKaseorg', bits     64, time  0.000003 sec\nTest    'Babylonian', bits     64, time  0.000006 sec\nTest  'ChordTangent', bits     64, time  0.000018 sec\n\nTest           'GMP', bits  50000, time  0.000118 sec\nTest 'AndersKaseorg', bits  50000, time  0.002777 sec\nTest    'Babylonian', bits  50000, time  0.003062 sec\nTest  'ChordTangent', bits  50000, time  0.009120 sec\n</code></pre>\n<p>and same C++ functions but as adopted Python module have timings:</p>\n<pre><code class=\"python\">Bits 50000\n         math.isqrt:   2.819 ms\n        gmpy2.isqrt:   0.166 ms\n          ISqrt_GMP:   0.252 ms\nISqrt_AndersKaseorg:   3.338 ms\n   ISqrt_Babylonian:   3.756 ms\n ISqrt_ChordTangent:  10.564 ms\n</code></pre>\n<p>My Cython-C++ is nice in a sence as a framework for those people who want to write and test his own C++ method from Python directly.</p>\n<p>As you noticed in above timings as example I used following methods:</p>\n<ol>\n<li><p><a href=\"https://docs.python.org/3/library/math.html#math.isqrt\" rel=\"nofollow noreferrer\">math.isqrt</a>, implementation from standard library.</p>\n</li>\n<li><p><a href=\"https://gmpy2.readthedocs.io/en/latest/mpz.html\" rel=\"nofollow noreferrer\">gmpy2.isqrt</a>, GMPY2 library's implementation.</p>\n</li>\n<li><p><a href=\"https://gmpy2.readthedocs.io/en/latest/mpz.html\" rel=\"nofollow noreferrer\">ISqrt_GMP</a> - same as GMPY2, but using my Cython module, there I use C++ GMP library (<code>&lt;gmpxx.h&gt;</code>) directly.</p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/a/53983683/941531\">ISqrt_AndersKaseorg</a>, code taken from <a href=\"https://stackoverflow.com/a/53983683/941531\">answer</a> of @AndersKaseorg.</p>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\" rel=\"nofollow noreferrer\">ISqrt_Babylonian</a>, method taken from Wikipedia <a href=\"https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\" rel=\"nofollow noreferrer\">article</a>, so-called Babylonian method. My own implementation as I understand it.</p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/a/71530812/941531\">ISqrt_ChordTangent</a>, it is my own method that I called Chord-Tangent, because it uses chord and tangent line to iteratively shorten interval of search. This method is described in moderate details in <a href=\"https://stackoverflow.com/a/71530812/941531\">my other article</a>. This method is nice because it searches not only square root, but also K-th root for any K. I drew a <a href=\"https://i.stack.imgur.com/s2AS9.jpg\" rel=\"nofollow noreferrer\">small picture</a> showing details of this algorithm.</p>\n</li>\n</ol>\n<p>Regarding compiling C++/Cython code, I used <a href=\"http://gmplib.org/\" rel=\"nofollow noreferrer\">GMP</a> library. You need to install it first, under Linux it is easy through <code>sudo apt install libgmp-dev</code>.</p>\n<p>Under Windows easiest is to install really great program <a href=\"https://vcpkg.io/\" rel=\"nofollow noreferrer\">VCPKG</a>, this is software Package Manager, similar to APT in Linux. VCPKG compiles all packages from sources using <a href=\"https://visualstudio.com/\" rel=\"nofollow noreferrer\">Visual Studio</a> (don't forget to <a href=\"https://visualstudio.microsoft.com/free-developer-offers/\" rel=\"nofollow noreferrer\">install</a> Community version of Visual Studio). After installing VCPKG you can install GMP by <code>vcpkg install gmp</code>. Also you may install <a href=\"http://mpir.org/\" rel=\"nofollow noreferrer\">MPIR</a>, this is alternative fork of GMP, you can install it through <code>vcpkg install mpir</code>.</p>\n<p>After GMP is installed under Windows please edit my Python code and replace path to include directory and library file. VCPKG at the end of installation should show you path to ZIP file with GMP library, there are .lib and .h files.</p>\n<p>You may notice in Python code that I also designed special handy <code>cython_compile()</code> function that I use to compile any C++ code into Python module. This function is really good as it allows for you to easily plug-in any C++ code into Python, this can be reused many times.</p>\n<p>If you have any questions or suggestions, or something doesn't work on your PC, please write in comments.</p>\n<p>Below first I show code in Python, afterwards in C++. See <code>Try it online!</code> link above C++ code to run code online on GodBolt servers. Both code snippets I fully runnable from scratch as they are, nothing needs to be edited in them.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def cython_compile(srcs):\n    import json, hashlib, os, glob, importlib, sys, shutil, tempfile\n    srch = hashlib.sha256(json.dumps(srcs, sort_keys = True, ensure_ascii = True).encode('utf-8')).hexdigest().upper()[:12]\n    pdir = 'cyimp'\n    \n    if len(glob.glob(f'{pdir}/cy{srch}*')) == 0:\n        class ChDir:\n            def __init__(self, newd):\n                self.newd = newd\n            def __enter__(self):\n                self.curd = os.getcwd()\n                os.chdir(self.newd)\n                return self\n            def __exit__(self, ext, exv, tb):\n                os.chdir(self.curd)\n\n        os.makedirs(pdir, exist_ok = True)\n        with tempfile.TemporaryDirectory(dir = pdir) as td, ChDir(str(td)) as chd:\n            os.makedirs(pdir, exist_ok = True)\n                \n            for k, v in srcs.items():\n                with open(f'cys{srch}_{k}', 'wb') as f:\n                    f.write(v.replace('{srch}', srch).encode('utf-8'))\n\n            import numpy as np\n            from setuptools import setup, Extension\n            from Cython.Build import cythonize\n\n            sys.argv += ['build_ext', '--inplace']\n            setup(\n                ext_modules = cythonize(\n                    Extension(\n                        f'{pdir}.cy{srch}', [f'cys{srch}_{k}' for k in filter(lambda e: e[e.rfind('.') + 1:] in ['pyx', 'c', 'cpp'], srcs.keys())],\n                        depends = [f'cys{srch}_{k}' for k in filter(lambda e: e[e.rfind('.') + 1:] not in ['pyx', 'c', 'cpp'], srcs.keys())],\n                        extra_compile_args = ['/O2', '/std:c++latest',\n                            '/ID:/dev/_3party/vcpkg_bin/gmp/include/',\n                        ],\n                    ),\n                    compiler_directives = {'language_level': 3, 'embedsignature': True},\n                    annotate = True,\n                ),\n                include_dirs = [np.get_include()],\n            )\n            del sys.argv[-2:]\n            for f in glob.glob(f'{pdir}/cy{srch}*'):\n                shutil.copy(f, f'./../')\n\n    print('Cython module:', f'cy{srch}')\n    return importlib.import_module(f'{pdir}.cy{srch}')\n\ndef cython_import():\n    srcs = {\n        'lib.h': \"\"\"\n#include &lt;cstring&gt;\n#include &lt;cstdint&gt;\n#include &lt;stdexcept&gt;\n#include &lt;tuple&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;sstream&gt;\n\n#include &lt;gmpxx.h&gt;\n\n#pragma comment(lib, \"D:/dev/_3party/vcpkg_bin/gmp/lib/gmp.lib\")\n\n#define ASSERT_MSG(cond, msg) { if (!(cond)) throw std::runtime_error(\"Assertion (\" #cond \") failed at line \" + std::to_string(__LINE__) + \"! Msg '\" + std::string(msg) + \"'.\"); }\n#define ASSERT(cond) ASSERT_MSG(cond, \"\")\n#define LN { std::cout &lt;&lt; \"LN \" &lt;&lt; __LINE__ &lt;&lt; std::endl; }\n\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\ntemplate &lt;typename T&gt;\nsize_t BitLen(T n) {\n    if constexpr(std::is_same_v&lt;std::decay_t&lt;T&gt;, mpz_class&gt;)\n        return mpz_sizeinbase(n.get_mpz_t(), 2);\n    else {\n        size_t cnt = 0;\n        while (n &gt;= (1ULL &lt;&lt; 32)) {\n            cnt += 32;\n            n &gt;&gt;= 32;\n        }\n        while (n &gt;= (1 &lt;&lt; 8)) {\n            cnt += 8;\n            n &gt;&gt;= 8;\n        }\n        while (n) {\n            ++cnt;\n            n &gt;&gt;= 1;\n        }\n        return cnt;\n    }\n}\n\ntemplate &lt;typename T&gt;\nT ISqrt_Babylonian(T const &amp; y) {\n    // https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n    if (y &lt;= 1)\n        return y;\n    T x = T(1) &lt;&lt; (BitLen(y) / 2), a = 0, b = 0, limit = 3;\n    while (true) {\n        size_t constexpr loops = 3;\n        for (size_t i = 0; i &lt; loops; ++i) {\n            if (i + 1 &gt;= loops)\n                a = x;\n            b = y;\n            b /= x;\n            x += b;\n            x &gt;&gt;= 1;\n        }\n        if (b &lt; a)\n            std::swap(a, b);\n        if (b - a &gt; limit)\n            continue;\n        ++b;\n        for (size_t i = 0; a &lt;= b; ++a, ++i)\n            if (a * a &gt; y) {\n                if (i == 0)\n                    break;\n                else\n                    return a - 1;\n            }\n        ASSERT(false);\n    }\n}\n\ntemplate &lt;typename T&gt;\nT ISqrt_AndersKaseorg(T const &amp; n) {\n    // https://stackoverflow.com/a/53983683/941531\n    if (n &gt; 0) {\n        T y = 0, x = T(1) &lt;&lt; ((BitLen(n) + 1) &gt;&gt; 1);\n        while (true) {\n            y = (x + n / x) &gt;&gt; 1;\n            if (y &gt;= x)\n                return x;\n            x = y;\n        }\n    } else if (n == 0)\n        return 0;\n    else\n        ASSERT_MSG(false, \"square root not defined for negative numbers\");\n}\n\ntemplate &lt;typename T&gt;\nT ISqrt_GMP(T const &amp; y) {\n    // https://gmplib.org/manual/Integer-Roots\n    mpz_class r, n;\n    bool constexpr is_mpz = std::is_same_v&lt;std::decay_t&lt;T&gt;, mpz_class&gt;;\n    if constexpr(is_mpz)\n        n = y;\n    else {\n        static_assert(sizeof(T) &lt;= 8);\n        n = u32(y &gt;&gt; 32);\n        n &lt;&lt;= 32;\n        n |= u32(y);\n    }\n    mpz_sqrt(r.get_mpz_t(), n.get_mpz_t());\n    if constexpr(is_mpz)\n        return r;\n    else\n        return (u64(mpz_get_ui(mpz_class(r &gt;&gt; 32).get_mpz_t())) &lt;&lt; 32) | u64(mpz_get_ui(mpz_class(r &amp; u32(-1)).get_mpz_t()));\n}\n\ntemplate &lt;typename T&gt;\nT KthRoot_ChordTangent(T const &amp; n, size_t k = 2) {\n    // https://i.stack.imgur.com/et9O0.jpg\n    if (n &lt;= 1)\n        return n;\n    auto KthPow = [&amp;](auto const &amp; x){\n        T y = x * x;\n        for (size_t i = 2; i &lt; k; ++i)\n            y *= x;\n        return y;\n    };\n    auto KthPowDer = [&amp;](auto const &amp; x){\n        T y = x * u32(k);\n        for (size_t i = 1; i + 1 &lt; k; ++i)\n            y *= x;\n        return y;\n    };\n    size_t root_bit_len = (BitLen(n) + k - 1) / k;\n    T   hi = T(1) &lt;&lt; root_bit_len,\n        x_begin = hi &gt;&gt; 1, x_end = hi,\n        y_begin = KthPow(x_begin), y_end = KthPow(x_end),\n        x_mid = 0, y_mid = 0, x_n = 0, y_n = 0, tangent_x = 0, chord_x = 0;\n    for (size_t icycle = 0; icycle &lt; (1 &lt;&lt; 30); ++icycle) {\n        if (x_end &lt;= x_begin + 2)\n            break;\n        if constexpr(0) { // Do Binary Search step if needed\n            x_mid = (x_begin + x_end) &gt;&gt; 1;\n            y_mid = KthPow(x_mid);\n            if (y_mid &gt; n) {\n                x_end = x_mid; y_end = y_mid;\n            } else {\n                x_begin = x_mid; y_begin = y_mid;\n            }\n        }\n        // (y_end - y_begin) / (x_end - x_begin) = (n - y_begin) / (x_n - x_begin) -&gt;\n        x_n = x_begin + (n - y_begin) * (x_end - x_begin) / (y_end - y_begin);\n        y_n = KthPow(x_n);\n        tangent_x = x_n + (n - y_n) / KthPowDer(x_n) + 1;\n        chord_x = x_n + (n - y_n) * (x_end - x_n) / (y_end - y_n);\n        //ASSERT(chord_x &lt;= tangent_x);\n        x_begin = chord_x; x_end = tangent_x;\n        y_begin = KthPow(x_begin); y_end = KthPow(x_end);\n        //ASSERT(y_begin &lt;= n);\n        //ASSERT(y_end &gt; n);\n    }\n    for (size_t i = 0; x_begin &lt;= x_end; ++x_begin, ++i)\n        if (x_begin * x_begin &gt; n) {\n            if (i == 0)\n                break;\n            else\n                return x_begin - 1;\n        }\n    ASSERT(false);\n    return 0;\n}\n\nmpz_class FromLimbs(uint64_t * limbs, uint64_t * cnt) {\n    mpz_class r;\n    mpz_import(r.get_mpz_t(), *cnt, -1, 8, -1, 0, limbs);\n    return r;\n}\n\nvoid ToLimbs(mpz_class const &amp; n, uint64_t * limbs, uint64_t * cnt) {\n    uint64_t cnt_before = *cnt;\n    size_t cnt_res = 0;\n    mpz_export(limbs, &amp;cnt_res, -1, 8, -1, 0, n.get_mpz_t());\n    ASSERT(cnt_res &lt;= cnt_before);\n    std::memset(limbs + cnt_res, 0, (cnt_before - cnt_res) * 8);\n    *cnt = cnt_res;\n}\n\nvoid ISqrt_GMP_Py(uint64_t * limbs, uint64_t * cnt) {\n    ToLimbs(ISqrt_GMP&lt;mpz_class&gt;(FromLimbs(limbs, cnt)), limbs, cnt);\n}\n\nvoid ISqrt_AndersKaseorg_Py(uint64_t * limbs, uint64_t * cnt) {\n    ToLimbs(ISqrt_AndersKaseorg&lt;mpz_class&gt;(FromLimbs(limbs, cnt)), limbs, cnt);\n}\n\nvoid ISqrt_Babylonian_Py(uint64_t * limbs, uint64_t * cnt) {\n    ToLimbs(ISqrt_Babylonian&lt;mpz_class&gt;(FromLimbs(limbs, cnt)), limbs, cnt);\n}\n\nvoid ISqrt_ChordTangent_Py(uint64_t * limbs, uint64_t * cnt) {\n    ToLimbs(KthRoot_ChordTangent&lt;mpz_class&gt;(FromLimbs(limbs, cnt), 2), limbs, cnt);\n}\n        \"\"\",\n        'main.pyx': r\"\"\"\n# distutils: language = c++\n# distutils: define_macros=NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION\n\nimport numpy as np\ncimport numpy as np\ncimport cython\nfrom libc.stdint cimport *\n\ncdef extern from \"cys{srch}_lib.h\" nogil:\n    void ISqrt_ChordTangent_Py(uint64_t * limbs, uint64_t * cnt);\n    void ISqrt_GMP_Py(uint64_t * limbs, uint64_t * cnt);\n    void ISqrt_AndersKaseorg_Py(uint64_t * limbs, uint64_t * cnt);\n    void ISqrt_Babylonian_Py(uint64_t * limbs, uint64_t * cnt);\n\n@cython.boundscheck(False)\n@cython.wraparound(False)\ndef ISqrt(method, n):\n    mask64 = (1 &lt;&lt; 64) - 1\n    def ToLimbs():\n        return np.copy(np.frombuffer(n.to_bytes((n.bit_length() + 63) // 64 * 8, 'little'), dtype = np.uint64))\n        \n        words = (n.bit_length() + 63) // 64\n        t = n\n        r = np.zeros((words,), dtype = np.uint64)\n        for i in range(words):\n            r[i] = np.uint64(t &amp; mask64)\n            t &gt;&gt;= 64\n        return r\n    def FromLimbs(x):\n        return int.from_bytes(x.tobytes(), 'little')\n        \n        n = 0\n        for i in range(x.shape[0]):\n            n |= int(x[i]) &lt;&lt; (i * 64)\n        return n\n    n = ToLimbs()\n    cdef uint64_t[:] cn = n\n    cdef uint64_t ccnt = len(n)\n    cdef uint64_t cmethod = {'GMP': 0, 'AndersKaseorg': 1, 'Babylonian': 2, 'ChordTangent': 3}[method]\n    with nogil:\n        (ISqrt_GMP_Py if cmethod == 0 else ISqrt_AndersKaseorg_Py if cmethod == 1 else ISqrt_Babylonian_Py if cmethod == 2 else ISqrt_ChordTangent_Py)(\n            &lt;uint64_t *&gt;&amp;cn[0], &lt;uint64_t *&gt;&amp;ccnt\n        )\n    return FromLimbs(n[:ccnt])\n        \"\"\",\n    }\n    return cython_compile(srcs)\n\ndef main():\n    import math, gmpy2, timeit, random\n    mod = cython_import()\n    fs = [\n        ('math.isqrt', math.isqrt),\n        ('gmpy2.isqrt', gmpy2.isqrt),\n        ('ISqrt_GMP', lambda n: mod.ISqrt('GMP', n)),\n        ('ISqrt_AndersKaseorg', lambda n: mod.ISqrt('AndersKaseorg', n)),\n        ('ISqrt_Babylonian', lambda n: mod.ISqrt('Babylonian', n)),\n        ('ISqrt_ChordTangent', lambda n: mod.ISqrt('ChordTangent', n)),\n    ]\n    times = [0] * len(fs)\n    ntests = 1 &lt;&lt; 6\n    bits = 50000\n    for i in range(ntests):\n        n = random.randrange(1 &lt;&lt; (bits - 1), 1 &lt;&lt; bits)\n        ref = None\n        for j, (fn, f) in enumerate(fs):\n            timeit_cnt = 3\n            tim = timeit.timeit(lambda: f(n), number = timeit_cnt) / timeit_cnt\n            times[j] += tim\n            x = f(n)\n            if j == 0:\n                ref = x\n            else:\n                assert x == ref, (fn, ref, x)\n    print('Bits', bits)\n    print('\\n'.join([f'{fs[i][0]:&gt;19}: {round(times[i] / ntests * 1000, 3):&gt;7} ms' for i in range(len(fs))]))\n\nif __name__ == '__main__':\n    main()\n</code></pre>\n<p>and C++:</p>\n<p><a href=\"https://godbolt.org/z/bssTrszcj\" rel=\"nofollow noreferrer\">Try it online!</a></p>\n<pre class=\"lang-cpp prettyprint-override\"><code class=\"python\">#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n#include &lt;stdexcept&gt;\n#include &lt;tuple&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;sstream&gt;\n\n#include &lt;gmpxx.h&gt;\n\n#define ASSERT_MSG(cond, msg) { if (!(cond)) throw std::runtime_error(\"Assertion (\" #cond \") failed at line \" + std::to_string(__LINE__) + \"! Msg '\" + std::string(msg) + \"'.\"); }\n#define ASSERT(cond) ASSERT_MSG(cond, \"\")\n#define LN { std::cout &lt;&lt; \"LN \" &lt;&lt; __LINE__ &lt;&lt; std::endl; }\n\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\ntemplate &lt;typename T&gt;\nsize_t BitLen(T n) {\n    if constexpr(std::is_same_v&lt;std::decay_t&lt;T&gt;, mpz_class&gt;)\n        return mpz_sizeinbase(n.get_mpz_t(), 2);\n    else {\n        size_t cnt = 0;\n        while (n &gt;= (1ULL &lt;&lt; 32)) {\n            cnt += 32;\n            n &gt;&gt;= 32;\n        }\n        while (n &gt;= (1 &lt;&lt; 8)) {\n            cnt += 8;\n            n &gt;&gt;= 8;\n        }\n        while (n) {\n            ++cnt;\n            n &gt;&gt;= 1;\n        }\n        return cnt;\n    }\n}\n\ntemplate &lt;typename T&gt;\nT ISqrt_Babylonian(T const &amp; y) {\n    // https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n    if (y &lt;= 1)\n        return y;\n    T x = T(1) &lt;&lt; (BitLen(y) / 2), a = 0, b = 0, limit = 3;\n    while (true) {\n        size_t constexpr loops = 3;\n        for (size_t i = 0; i &lt; loops; ++i) {\n            if (i + 1 &gt;= loops)\n                a = x;\n            b = y;\n            b /= x;\n            x += b;\n            x &gt;&gt;= 1;\n        }\n        if (b &lt; a)\n            std::swap(a, b);\n        if (b - a &gt; limit)\n            continue;\n        ++b;\n        for (size_t i = 0; a &lt;= b; ++a, ++i)\n            if (a * a &gt; y) {\n                if (i == 0)\n                    break;\n                else\n                    return a - 1;\n            }\n        ASSERT(false);\n    }\n}\n\ntemplate &lt;typename T&gt;\nT ISqrt_AndersKaseorg(T const &amp; n) {\n    // https://stackoverflow.com/a/53983683/941531\n    if (n &gt; 0) {\n        T y = 0, x = T(1) &lt;&lt; ((BitLen(n) + 1) &gt;&gt; 1);\n        while (true) {\n            y = (x + n / x) &gt;&gt; 1;\n            if (y &gt;= x)\n                return x;\n            x = y;\n        }\n    } else if (n == 0)\n        return 0;\n    else\n        ASSERT_MSG(false, \"square root not defined for negative numbers\");\n}\n\ntemplate &lt;typename T&gt;\nT ISqrt_GMP(T const &amp; y) {\n    // https://gmplib.org/manual/Integer-Roots\n    mpz_class r, n;\n    bool constexpr is_mpz = std::is_same_v&lt;std::decay_t&lt;T&gt;, mpz_class&gt;;\n    if constexpr(is_mpz)\n        n = y;\n    else {\n        static_assert(sizeof(T) &lt;= 8);\n        n = u32(y &gt;&gt; 32);\n        n &lt;&lt;= 32;\n        n |= u32(y);\n    }\n    mpz_sqrt(r.get_mpz_t(), n.get_mpz_t());\n    if constexpr(is_mpz)\n        return r;\n    else\n        return (u64(mpz_get_ui(mpz_class(r &gt;&gt; 32).get_mpz_t())) &lt;&lt; 32) | u64(mpz_get_ui(mpz_class(r &amp; u32(-1)).get_mpz_t()));\n}\n\ntemplate &lt;typename T&gt;\nstd::string IntToStr(T n) {\n    if constexpr(std::is_same_v&lt;std::decay_t&lt;T&gt;, mpz_class&gt;)\n        return n.get_str();\n    else {\n        std::ostringstream ss;\n        ss &lt;&lt; n;\n        return ss.str();\n    }\n}\n\ntemplate &lt;typename T&gt;\nT KthRoot_ChordTangent(T const &amp; n, size_t k = 2) {\n    // https://i.stack.imgur.com/et9O0.jpg\n    if (n &lt;= 1)\n        return n;\n    auto KthPow = [&amp;](auto const &amp; x){\n        T y = x * x;\n        for (size_t i = 2; i &lt; k; ++i)\n            y *= x;\n        return y;\n    };\n    auto KthPowDer = [&amp;](auto const &amp; x){\n        T y = x * u32(k);\n        for (size_t i = 1; i + 1 &lt; k; ++i)\n            y *= x;\n        return y;\n    };\n    size_t root_bit_len = (BitLen(n) + k - 1) / k;\n    T   hi = T(1) &lt;&lt; root_bit_len,\n        x_begin = hi &gt;&gt; 1, x_end = hi,\n        y_begin = KthPow(x_begin), y_end = KthPow(x_end),\n        x_mid = 0, y_mid = 0, x_n = 0, y_n = 0, tangent_x = 0, chord_x = 0;\n    for (size_t icycle = 0; icycle &lt; (1 &lt;&lt; 30); ++icycle) {\n        //std::cout &lt;&lt; \"x_begin, x_end = \" &lt;&lt; IntToStr(x_begin) &lt;&lt; \", \" &lt;&lt; IntToStr(x_end) &lt;&lt; \", n \" &lt;&lt; IntToStr(n) &lt;&lt; std::endl;\n        if (x_end &lt;= x_begin + 2)\n            break;\n        if constexpr(0) { // Do Binary Search step if needed\n            x_mid = (x_begin + x_end) &gt;&gt; 1;\n            y_mid = KthPow(x_mid);\n            if (y_mid &gt; n) {\n                x_end = x_mid; y_end = y_mid;\n            } else {\n                x_begin = x_mid; y_begin = y_mid;\n            }\n        }\n        // (y_end - y_begin) / (x_end - x_begin) = (n - y_begin) / (x_n - x_begin) -&gt;\n        x_n = x_begin + (n - y_begin) * (x_end - x_begin) / (y_end - y_begin);\n        y_n = KthPow(x_n);\n        tangent_x = x_n + (n - y_n) / KthPowDer(x_n) + 1;\n        chord_x = x_n + (n - y_n) * (x_end - x_n) / (y_end - y_n);\n        //ASSERT(chord_x &lt;= tangent_x);\n        x_begin = chord_x; x_end = tangent_x;\n        y_begin = KthPow(x_begin); y_end = KthPow(x_end);\n        //ASSERT(y_begin &lt;= n);\n        //ASSERT(y_end &gt; n);\n    }\n    for (size_t i = 0; x_begin &lt;= x_end; ++x_begin, ++i)\n        if (x_begin * x_begin &gt; n) {\n            if (i == 0)\n                break;\n            else\n                return x_begin - 1;\n        }\n    ASSERT(false);\n    return 0;\n}\n\nmpz_class FromLimbs(uint64_t * limbs, uint64_t * cnt) {\n    mpz_class r;\n    mpz_import(r.get_mpz_t(), *cnt, -1, 8, -1, 0, limbs);\n    return r;\n}\n\nvoid ToLimbs(mpz_class const &amp; n, uint64_t * limbs, uint64_t * cnt) {\n    uint64_t cnt_before = *cnt;\n    size_t cnt_res = 0;\n    mpz_export(limbs, &amp;cnt_res, -1, 8, -1, 0, n.get_mpz_t());\n    ASSERT(cnt_res &lt;= cnt_before);\n    std::memset(limbs + cnt_res, 0, (cnt_before - cnt_res) * 8);\n    *cnt = cnt_res;\n}\n\nvoid ISqrt_ChordTangent_Py(uint64_t * limbs, uint64_t * cnt) {\n    ToLimbs(KthRoot_ChordTangent&lt;mpz_class&gt;(FromLimbs(limbs, cnt), 2), limbs, cnt);\n}\n\nvoid ISqrt_GMP_Py(uint64_t * limbs, uint64_t * cnt) {\n    ToLimbs(ISqrt_GMP&lt;mpz_class&gt;(FromLimbs(limbs, cnt)), limbs, cnt);\n}\n\nvoid ISqrt_AndersKaseorg_Py(uint64_t * limbs, uint64_t * cnt) {\n    ToLimbs(ISqrt_AndersKaseorg&lt;mpz_class&gt;(FromLimbs(limbs, cnt)), limbs, cnt);\n}\n\nvoid ISqrt_Babylonian_Py(uint64_t * limbs, uint64_t * cnt) {\n    ToLimbs(ISqrt_Babylonian&lt;mpz_class&gt;(FromLimbs(limbs, cnt)), limbs, cnt);\n}\n\n// Testing\n\n#include &lt;chrono&gt;\n#include &lt;random&gt;\n#include &lt;vector&gt;\n#include &lt;iomanip&gt;\n\ninline double Time() {\n    static auto const gtb = std::chrono::high_resolution_clock::now();\n    return std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(std::chrono::high_resolution_clock::now() - gtb)\n        .count();\n}\n\ntemplate &lt;typename T, typename F&gt;\nstd::vector&lt;T&gt; Test0(std::string const &amp; test_name, size_t bits, size_t ntests, F &amp;&amp; f) {\n    std::mt19937_64 rng{123};\n    std::vector&lt;T&gt; nums;\n    for (size_t i = 0; i &lt; ntests; ++i) {\n        T n = 0;\n        for (size_t j = 0; j &lt; bits; j += 32) {\n            size_t const cbits = std::min&lt;size_t&gt;(32, bits - j);\n            n &lt;&lt;= cbits;\n            n ^= u32(rng()) &gt;&gt; (32 - cbits);\n        }\n        nums.push_back(n);\n    }\n    auto tim = Time();\n    for (auto &amp; n: nums)\n        n = f(n);\n    tim = Time() - tim;\n    std::cout &lt;&lt; \"Test \" &lt;&lt; std::setw(15) &lt;&lt; (\"'\" + test_name + \"'\")\n        &lt;&lt; \", bits \" &lt;&lt; std::setw(6) &lt;&lt; bits &lt;&lt; \", time \"\n        &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; std::setw(9) &lt;&lt; tim / ntests &lt;&lt; \" sec\" &lt;&lt; std::endl;\n    return nums;\n}\n\nvoid Test() {\n    auto f = [](auto ty, size_t bits, size_t ntests){\n        using T = std::decay_t&lt;decltype(ty)&gt;;\n        auto tim = Time();\n        auto a = Test0&lt;T&gt;(\"GMP\",           bits, ntests, [](auto const &amp; x){ return ISqrt_GMP&lt;T&gt;(x); });\n        auto b = Test0&lt;T&gt;(\"AndersKaseorg\", bits, ntests, [](auto const &amp; x){ return ISqrt_AndersKaseorg&lt;T&gt;(x); });\n        ASSERT(b == a);\n        auto c = Test0&lt;T&gt;(\"Babylonian\",    bits, ntests, [](auto const &amp; x){ return ISqrt_Babylonian&lt;T&gt;(x); });\n        ASSERT(c == a);\n        auto d = Test0&lt;T&gt;(\"ChordTangent\",  bits, ntests, [](auto const &amp; x){ return KthRoot_ChordTangent&lt;T&gt;(x); });\n        ASSERT(d == a);\n        std::cout &lt;&lt; \"Bits \" &lt;&lt; bits &lt;&lt; \" nums \" &lt;&lt; ntests &lt;&lt; \" time \" &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; (Time() - tim) &lt;&lt; \" sec\" &lt;&lt; std::endl;\n    };\n    for (auto p: std::vector&lt;std::pair&lt;int, int&gt;&gt;{{15, 1 &lt;&lt; 19}, {30, 1 &lt;&lt; 19}})\n        f(u64(), p.first, p.second);\n    for (auto p: std::vector&lt;std::pair&lt;int, int&gt;&gt;{{64, 1 &lt;&lt; 15}, {8192, 1 &lt;&lt; 10}, {50000, 1 &lt;&lt; 5}})\n        f(mpz_class(), p.first, p.second);\n}\n\nint main() {\n    try {\n        Test();\n        return 0;\n    } catch (std::exception const &amp; ex) {\n        std::cout &lt;&lt; \"Exception: \" &lt;&lt; ex.what() &lt;&lt; std::endl;\n        return -1;\n    }\n}\n</code></pre>\n", "abstract": "Inspired by all answers, decided to implement in pure C++ several best methods from these answers. As everybody knows C++ is always faster than Python. To glue C++ and Python I used Cython. It allows to make out of C++ a Python module and then call C++ functions directly from Python functions. Also as complementary I provided not only Python-adopted code, but pure C++ with tests too. Here are timings from pure C++ tests: and same C++ functions but as adopted Python module have timings: My Cython-C++ is nice in a sence as a framework for those people who want to write and test his own C++ method from Python directly. As you noticed in above timings as example I used following methods: math.isqrt, implementation from standard library. gmpy2.isqrt, GMPY2 library's implementation. ISqrt_GMP - same as GMPY2, but using my Cython module, there I use C++ GMP library (<gmpxx.h>) directly. ISqrt_AndersKaseorg, code taken from answer of @AndersKaseorg. ISqrt_Babylonian, method taken from Wikipedia article, so-called Babylonian method. My own implementation as I understand it. ISqrt_ChordTangent, it is my own method that I called Chord-Tangent, because it uses chord and tangent line to iteratively shorten interval of search. This method is described in moderate details in my other article. This method is nice because it searches not only square root, but also K-th root for any K. I drew a small picture showing details of this algorithm. Regarding compiling C++/Cython code, I used GMP library. You need to install it first, under Linux it is easy through sudo apt install libgmp-dev. Under Windows easiest is to install really great program VCPKG, this is software Package Manager, similar to APT in Linux. VCPKG compiles all packages from sources using Visual Studio (don't forget to install Community version of Visual Studio). After installing VCPKG you can install GMP by vcpkg install gmp. Also you may install MPIR, this is alternative fork of GMP, you can install it through vcpkg install mpir. After GMP is installed under Windows please edit my Python code and replace path to include directory and library file. VCPKG at the end of installation should show you path to ZIP file with GMP library, there are .lib and .h files. You may notice in Python code that I also designed special handy cython_compile() function that I use to compile any C++ code into Python module. This function is really good as it allows for you to easily plug-in any C++ code into Python, this can be reused many times. If you have any questions or suggestions, or something doesn't work on your PC, please write in comments. Below first I show code in Python, afterwards in C++. See Try it online! link above C++ code to run code online on GodBolt servers. Both code snippets I fully runnable from scratch as they are, nothing needs to be edited in them. and C++: Try it online!"}, {"id": 15391114, "score": 0, "vote": 0, "content": "<p>Your function fails for large inputs:</p>\n<pre><code class=\"python\">In [26]: isqrt((10**100+1)**2)\n\nValueError: input was not a perfect square\n</code></pre>\n<p>There is a <a href=\"http://code.activestate.com/recipes/577821-integer-square-root-function/\" rel=\"nofollow noreferrer\">recipe on the ActiveState site</a> which should hopefully be more reliable since it uses integer maths only. It is based on an earlier StackOverflow question: <a href=\"https://stackoverflow.com/questions/1623375/writing-your-own-square-root-function\">Writing your own square root function</a></p>\n", "abstract": "Your function fails for large inputs: There is a recipe on the ActiveState site which should hopefully be more reliable since it uses integer maths only. It is based on an earlier StackOverflow question: Writing your own square root function"}, {"id": 15391406, "score": -3, "vote": 0, "content": "<p>Floats cannot be precisely represented on computers.  You can test for a desired proximity setting epsilon to a small value within the accuracy of python's floats.</p>\n<pre><code class=\"python\">def isqrt(n):\n    epsilon = .00000000001\n    i = int(n**.5 + 0.5)\n    if abs(i**2 - n) &lt; epsilon:\n        return i\n    raise ValueError('input was not a perfect square')\n</code></pre>\n", "abstract": "Floats cannot be precisely represented on computers.  You can test for a desired proximity setting epsilon to a small value within the accuracy of python's floats."}, {"id": 41125406, "score": -3, "vote": 0, "content": "<p>I have compared the different methods given here with a loop:</p>\n<pre><code class=\"python\">for i in range (1000000): # 700 msec\n    r=int(123456781234567**0.5+0.5)\n    if r**2==123456781234567:rr=r\n    else:rr=-1\n</code></pre>\n<p>finding that this one is fastest and need no math-import. Very long might fail, but look at this</p>\n<pre><code class=\"python\">15241576832799734552675677489**0.5 = 123456781234567.0\n</code></pre>\n", "abstract": "I have compared the different methods given here with a loop: finding that this one is fastest and need no math-import. Very long might fail, but look at this"}, {"id": 15390917, "score": -4, "vote": 0, "content": "<p>Try this condition (no additional computation):</p>\n<pre><code class=\"python\">def isqrt(n):\n  i = math.sqrt(n)\n  if i != int(i):\n    raise ValueError('input was not a perfect square')  \n  return i\n</code></pre>\n<p>If you need it to return an <code>int</code> (not a <code>float</code> with a trailing zero) then either assign a 2nd variable or compute <code>int(i)</code> twice.</p>\n", "abstract": "Try this condition (no additional computation): If you need it to return an int (not a float with a trailing zero) then either assign a 2nd variable or compute int(i) twice."}]}, {"link": "https://stackoverflow.com/questions/117250/how-do-i-get-a-decimal-value-when-using-the-division-operator-in-python", "question": {"id": "117250", "title": "How do I get a decimal value when using the division operator in Python?", "content": "<p>For example, the standard division symbol '/' rounds to zero:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 4 / 100\n0\n</code></pre>\n<p>However, I want it to return 0.04. What do I use?</p>\n", "abstract": "For example, the standard division symbol '/' rounds to zero: However, I want it to return 0.04. What do I use?"}, "answers": [{"id": 117264, "score": 146, "vote": 0, "content": "<p>There are three options:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 4 / float(100)\n0.04\n&gt;&gt;&gt; 4 / 100.0\n0.04\n</code></pre>\n<p>which is the same behavior as the C, C++, Java etc, or </p>\n<pre><code class=\"python\">&gt;&gt;&gt; from __future__ import division\n&gt;&gt;&gt; 4 / 100\n0.04\n</code></pre>\n<p>You can also activate this behavior by passing the argument <code>-Qnew</code> to the Python interpreter:</p>\n<pre><code class=\"python\">$ python -Qnew\n&gt;&gt;&gt; 4 / 100\n0.04\n</code></pre>\n<p>The second option will be the default in Python 3.0. If you want to have the old integer division, you have to use the <code>//</code> operator. </p>\n<p><strong>Edit</strong>: added section about <code>-Qnew</code>, thanks to <a href=\"https://stackoverflow.com/users/6899/\">\u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5</a>!</p>\n", "abstract": "There are three options: which is the same behavior as the C, C++, Java etc, or  You can also activate this behavior by passing the argument -Qnew to the Python interpreter: The second option will be the default in Python 3.0. If you want to have the old integer division, you have to use the // operator.  Edit: added section about -Qnew, thanks to \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5!"}, {"id": 117682, "score": 26, "vote": 0, "content": "<p>Other answers suggest how to get a floating-point value.  While this wlil be close to what you want, it won't be exact:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 0.4/100.\n0.0040000000000000001\n</code></pre>\n<p>If you actually want a <em>decimal</em> value, do this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import decimal\n&gt;&gt;&gt; decimal.Decimal('4') / decimal.Decimal('100')\nDecimal(\"0.04\")\n</code></pre>\n<p>That will give you an object that properly knows that 4 / 100 in <em>base 10</em> is \"0.04\".  Floating-point numbers are actually in base 2, i.e. binary, not decimal.</p>\n", "abstract": "Other answers suggest how to get a floating-point value.  While this wlil be close to what you want, it won't be exact: If you actually want a decimal value, do this: That will give you an object that properly knows that 4 / 100 in base 10 is \"0.04\".  Floating-point numbers are actually in base 2, i.e. binary, not decimal."}, {"id": 117270, "score": 7, "vote": 0, "content": "<p>Make one or both of the terms a floating point number, like so:</p>\n<pre><code class=\"python\">4.0/100.0\n</code></pre>\n<p>Alternatively, turn on the feature that will be default in Python 3.0, 'true division', that does what you want. At the top of your module or script, do:</p>\n<pre><code class=\"python\">from __future__ import division\n</code></pre>\n", "abstract": "Make one or both of the terms a floating point number, like so: Alternatively, turn on the feature that will be default in Python 3.0, 'true division', that does what you want. At the top of your module or script, do:"}, {"id": 117806, "score": 5, "vote": 0, "content": "<p>You might want to look at Python's <a href=\"http://docs.python.org/lib/module-decimal.html\" rel=\"noreferrer\">decimal</a> package, also.  This will provide nice decimal results.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; decimal.Decimal('4')/100\nDecimal(\"0.04\")\n</code></pre>\n", "abstract": "You might want to look at Python's decimal package, also.  This will provide nice decimal results."}, {"id": 117258, "score": 4, "vote": 0, "content": "<p>You need to tell Python to use floating point values, not integers. You can do that simply by using a decimal point yourself in the inputs:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 4/100.0\n0.040000000000000001\n</code></pre>\n", "abstract": "You need to tell Python to use floating point values, not integers. You can do that simply by using a decimal point yourself in the inputs:"}, {"id": 117257, "score": 1, "vote": 0, "content": "<p>A simple route 4 / 100.0 </p>\n<p>or</p>\n<p>4.0 / 100</p>\n", "abstract": "A simple route 4 / 100.0  or 4.0 / 100"}, {"id": 48145519, "score": 1, "vote": 0, "content": "<p>Here we have two possible cases given below    </p>\n<pre><code class=\"python\">from __future__ import division\n\nprint(4/100)\nprint(4//100)\n</code></pre>\n", "abstract": "Here we have two possible cases given below    "}, {"id": 117256, "score": 0, "vote": 0, "content": "<p>Try 4.0/100</p>\n", "abstract": "Try 4.0/100"}, {"id": 117285, "score": 0, "vote": 0, "content": "<p>You cant get a decimal value by dividing one integer with another, you'll allways get an integer that way (result truncated to integer). You need at least one value to be a decimal number.</p>\n", "abstract": "You cant get a decimal value by dividing one integer with another, you'll allways get an integer that way (result truncated to integer). You need at least one value to be a decimal number."}, {"id": 51169141, "score": 0, "vote": 0, "content": "<p>Add the following function in your code with its callback.</p>\n<pre><code class=\"python\"># Starting of the function\ndef divide(number_one, number_two, decimal_place = 4):\n    quotient = number_one/number_two\n    remainder = number_one % number_two\n    if remainder != 0:\n        quotient_str = str(quotient)\n        for loop in range(0, decimal_place):\n            if loop == 0:\n                quotient_str += \".\"\n            surplus_quotient = (remainder * 10) / number_two\n            quotient_str += str(surplus_quotient)\n            remainder = (remainder * 10) % number_two\n            if remainder == 0:\n                break\n        return float(quotient_str)\n    else:\n        return quotient\n#Ending of the function\n\n# Calling back the above function\n# Structure : divide(&lt;divident&gt;, &lt;divisor&gt;, &lt;decimal place(optional)&gt;)\ndivide(1, 7, 10) # Output : 0.1428571428\n# OR\ndivide(1, 7) # Output : 0.1428\n</code></pre>\n<p>This function works on the basis of \"Euclid Division Algorithm\". This function is very useful if you don't want to import any external header files in your project.</p>\n<p>Syntex : divide([divident], [divisor], [decimal place(optional))</p>\n<p>Code : <code>divide(1, 7, 10)</code> OR <code>divide(1, 7)</code></p>\n<p>Comment below for any queries.</p>\n", "abstract": "Add the following function in your code with its callback. This function works on the basis of \"Euclid Division Algorithm\". This function is very useful if you don't want to import any external header files in your project. Syntex : divide([divident], [divisor], [decimal place(optional)) Code : divide(1, 7, 10) OR divide(1, 7) Comment below for any queries."}, {"id": 54601667, "score": 0, "vote": 0, "content": "<p>You could also try adding a \".0\" at the end of the number.</p>\n<p>4.0/100.0</p>\n", "abstract": "You could also try adding a \".0\" at the end of the number. 4.0/100.0"}, {"id": 59146683, "score": -1, "vote": 0, "content": "<p>It's only dropping the fractional part after decimal.\nHave you tried :  4.0 / 100</p>\n", "abstract": "It's only dropping the fractional part after decimal.\nHave you tried :  4.0 / 100"}, {"id": 48924804, "score": -3, "vote": 0, "content": "<p>Import division from future library like this:  </p>\n<pre><code class=\"python\">from__future__ import division\n</code></pre>\n", "abstract": "Import division from future library like this:  "}]}, {"link": "https://stackoverflow.com/questions/15193927/what-do-these-operators-mean", "question": {"id": "15193927", "title": "What do these operators mean (** , ^ , %, //)?", "content": "<p>Other than the standard <code>+</code>, <code>-</code>, <code>*</code>and <code>/</code> operators; but what does these mean (<code>**</code> , <code>^</code> , <code>%</code>, <code>//</code>) ?</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 9+float(2) # addition\n11.0\n&gt;&gt;&gt; 9-float(2) # subtraction\n7.0\n&gt;&gt;&gt; 9*float(2) # multiplication\n18.0\n&gt;&gt;&gt; 9/float(2) # division\n4.5\n&gt;&gt;&gt;\n&gt;&gt;&gt; 9**float(2) # This looks like a square, (i.e. power 2) \n81.0\n&gt;&gt;&gt; 9**float(3) # So ** is equivalent to `math.pow(x,p)` ?\n729.0\n</code></pre>\n<p><strong>How about the <code>^</code> operator?</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; 9^int(2) # What is `^` in `x^u` , it only allows `int` for `u`\n11\n&gt;&gt;&gt; 9^int(3)\n10\n&gt;&gt;&gt; 9^int(4)\n13\n&gt;&gt;&gt; 9^int(5)\n12\n&gt;&gt;&gt; 9^int(6)\n15\n&gt;&gt;&gt; 9^int(7)\n14\n&gt;&gt;&gt; 9^int(8)\n1\n&gt;&gt;&gt; 9^int(9)\n0\n&gt;&gt;&gt; 9^int(10)\n3\n&gt;&gt;&gt; 9^int(11)\n2\n&gt;&gt;&gt; 9^int(12)\n5\n</code></pre>\n<p><strong><code>%</code> in <code>x%m</code> returns a normal remainder modulus, but only if <code>m &lt; x</code>, why is that so? What does <code>%</code> do?</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; 9%float(2)\n1.0\n&gt;&gt;&gt; 9%float(3)\n0.0\n&gt;&gt;&gt; 9%float(4)\n1.0\n&gt;&gt;&gt; 9%float(5)\n4.0\n&gt;&gt;&gt; 9%float(6)\n3.0\n&gt;&gt;&gt; 9%float(7)\n2.0\n&gt;&gt;&gt; 9%float(8)\n1.0\n&gt;&gt;&gt; 9%float(9)\n0.0\n&gt;&gt;&gt; 9%float(10)\n9.0\n&gt;&gt;&gt; 9%float(11)\n9.0\n&gt;&gt;&gt; 9%float(12)\n9.0\n</code></pre>\n<p><strong>How about the <code>//</code> operator? what does it do?</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; 9//float(2)\n4.0\n&gt;&gt;&gt; 9//float(3)\n3.0\n&gt;&gt;&gt; 9//float(4)\n2.0\n&gt;&gt;&gt; 9//float(5)\n1.0\n&gt;&gt;&gt; 9//float(6)\n1.0\n&gt;&gt;&gt; 9//float(7)\n1.0\n&gt;&gt;&gt; 9//float(8)\n1.0\n&gt;&gt;&gt; 9//float(9)\n1.0\n&gt;&gt;&gt; 9//float(1)\n9.0\n&gt;&gt;&gt; 9//float(0.5)\n18.0\n</code></pre>\n", "abstract": "Other than the standard +, -, *and / operators; but what does these mean (** , ^ , %, //) ? How about the ^ operator? % in x%m returns a normal remainder modulus, but only if m < x, why is that so? What does % do? How about the // operator? what does it do?"}, "answers": [{"id": 15193961, "score": 130, "vote": 0, "content": "<ul>\n<li><code>**</code>: exponentiation</li>\n<li><code>^</code>: exclusive-or (bitwise)</li>\n<li><code>%</code>: modulus</li>\n<li><code>//</code>: divide with integral result (discard remainder)</li>\n</ul>\n", "abstract": ""}, {"id": 15194137, "score": 37, "vote": 0, "content": "<p>You can find all of those operators in the <a href=\"http://docs.python.org/2/reference/expressions.html\" rel=\"noreferrer\">Python language reference</a>, though you'll have to scroll around a bit to find them all. As other answers have said:</p>\n<ul>\n<li>The <code>**</code> operator does exponentiation. <code>a ** b</code> is <code>a</code> raised to the <code>b</code> power. The same <code>**</code> symbol is also used in function argument and calling notations, with a different meaning (passing and receiving arbitrary keyword arguments).</li>\n<li>The <code>^</code> operator does a binary xor. <code>a ^ b</code> will return a value with only the bits set in <code>a</code> or in <code>b</code> but not both. This one is simple!</li>\n<li>The <code>%</code> operator is mostly to find the modulus of two integers. <code>a % b</code> returns the remainder after dividing <code>a</code> by <code>b</code>. Unlike the modulus operators in some other programming languages (such as C), in Python a modulus it will have the same sign as <code>b</code>, rather than the same sign as <code>a</code>. The same operator is also used for the \"old\" style of string formatting, so <code>a % b</code> can return a string if <code>a</code> is a format string and <code>b</code> is a value (or tuple of values) which can be inserted into <code>a</code>.</li>\n<li>The <code>//</code> operator does Python's version of integer division. Python's integer division is not exactly the same as the integer division offered by some other languages (like C), since it rounds towards negative infinity, rather than towards zero. Together with the modulus operator, you can say that <code>a == (a // b)*b + (a % b)</code>. In Python 2, floor division is the default behavior when you divide two integers (using the normal division operator <code>/</code>). Since this can be unexpected (especially when you're not picky about what types of numbers you get as arguments to a function), Python 3 has changed to make \"true\" (floating point) division the norm for division that would be rounded off otherwise, and it will do \"floor\" division only when explicitly requested. (You can also get the new behavior in Python 2 by putting <code>from __future__ import division</code> at the top of your files. I strongly recommend it!)</li>\n</ul>\n", "abstract": "You can find all of those operators in the Python language reference, though you'll have to scroll around a bit to find them all. As other answers have said:"}, {"id": 15193971, "score": 10, "vote": 0, "content": "<p>You are correct that <code>**</code> is the power function.</p>\n<p><code>^</code> is bitwise XOR.</p>\n<p><code>%</code> is indeed the modulus operation, but note that for positive numbers, <code>x % m = x</code> whenever <code>m &gt; x</code>. This follows from the definition of modulus. (Additionally, Python specifies <code>x % m</code> to have the sign of <code>m</code>.)</p>\n<p><code>//</code> is a division operation that returns an integer by discarding the remainder. This is the standard form of division using the <code>/</code> in most programming languages. However, Python <strong>3</strong> changed the behavior of <code>/</code> to perform floating-point division <em>even if the arguments are integers</em>. The <code>//</code> operator was introduced in Python 2.6 and Python 3 to provide an integer-division operator that would behave consistently between Python 2 and Python 3. This means:</p>\n<pre><code class=\"python\">| context                                | `/` behavior   | `//` behavior |\n---------------------------------------------------------------------------\n| floating-point arguments, Python 2 &amp; 3 | float division | int divison   |\n---------------------------------------------------------------------------\n| integer arguments, python 2            | int division   | int division  |\n---------------------------------------------------------------------------\n| integer arguments, python 3            | float division | int division  |\n</code></pre>\n<p>For more details, see this question: <a href=\"https://stackoverflow.com/q/21316968/1858225\">Division in Python 2.7. and 3.3</a></p>\n", "abstract": "You are correct that ** is the power function. ^ is bitwise XOR. % is indeed the modulus operation, but note that for positive numbers, x % m = x whenever m > x. This follows from the definition of modulus. (Additionally, Python specifies x % m to have the sign of m.) // is a division operation that returns an integer by discarding the remainder. This is the standard form of division using the / in most programming languages. However, Python 3 changed the behavior of / to perform floating-point division even if the arguments are integers. The // operator was introduced in Python 2.6 and Python 3 to provide an integer-division operator that would behave consistently between Python 2 and Python 3. This means: For more details, see this question: Division in Python 2.7. and 3.3"}]}, {"link": "https://stackoverflow.com/questions/10282674/difference-between-the-built-in-pow-and-math-pow-for-floats-in-python", "question": {"id": "10282674", "title": "Difference between the built-in pow() and math.pow() for floats, in Python?", "content": "<p>Is there a difference in the results returned by Python's built-in <code>pow(x, y)</code> (no third argument) and the values returned by <code>math.pow()</code>, in the case of two <em>float</em> arguments.</p>\n<p>I am asking this question because the <a href=\"http://docs.python.org/library/math.html#math.pow\" rel=\"noreferrer\">documentation</a> for <code>math.pow()</code> implies that <code>pow(x, y)</code> (i.e. <code>x**y</code>) is essentially the same as <code>math.pow(x, y)</code>:</p>\n<blockquote>\n<p><strong>math.pow(x, y)</strong></p>\n<p>Return x raised to the power y. Exceptional cases\n  follow Annex \u2018F\u2019 of the C99 standard as far as possible. In\n  particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x\n  is a zero or a NaN. If both x and y are finite, x is negative, and y\n  is not an integer then pow(x, y) is undefined, and raises ValueError.</p>\n<p>Changed in version 2.6: The outcome of 1**nan and nan**0 was undefined.</p>\n</blockquote>\n<p>Note the last line: the documentation implies that the behavior of <code>math.pow()</code> is that of the exponentiation operator <code>**</code> (and therefore of <code>pow(x, y)</code>).  Is this officially guaranteed?</p>\n<p>Background: My goal is to provide an implementation of <em>both</em> the built-in <code>pow()</code> and of <code>math.pow()</code> for numbers with uncertainty <em>that behaves in the same way</em> as with regular Python floats (same numerical results, same exceptions, same results for corner cases, etc.). I have <a href=\"http://packages.python.org/uncertainties/\" rel=\"noreferrer\">already implemented</a> something that works quite well, but there are some <a href=\"https://stackoverflow.com/questions/10198753/zero-division-error-in-python-uncertainties-package\">corner cases</a> that need to be handled.</p>\n", "abstract": "Is there a difference in the results returned by Python's built-in pow(x, y) (no third argument) and the values returned by math.pow(), in the case of two float arguments. I am asking this question because the documentation for math.pow() implies that pow(x, y) (i.e. x**y) is essentially the same as math.pow(x, y): math.pow(x, y) Return x raised to the power y. Exceptional cases\n  follow Annex \u2018F\u2019 of the C99 standard as far as possible. In\n  particular, pow(1.0, x) and pow(x, 0.0) always return 1.0, even when x\n  is a zero or a NaN. If both x and y are finite, x is negative, and y\n  is not an integer then pow(x, y) is undefined, and raises ValueError. Changed in version 2.6: The outcome of 1**nan and nan**0 was undefined. Note the last line: the documentation implies that the behavior of math.pow() is that of the exponentiation operator ** (and therefore of pow(x, y)).  Is this officially guaranteed? Background: My goal is to provide an implementation of both the built-in pow() and of math.pow() for numbers with uncertainty that behaves in the same way as with regular Python floats (same numerical results, same exceptions, same results for corner cases, etc.). I have already implemented something that works quite well, but there are some corner cases that need to be handled."}, "answers": [{"id": 10282852, "score": 61, "vote": 0, "content": "<h2>Quick Check</h2>\n<p>From the signatures, we can tell that they are different:</p>\n<blockquote>\n<p><strong>pow(x, y[, z])</strong></p>\n<p><strong>math.pow(x, y)</strong></p>\n</blockquote>\n<p>Also, trying it in the shell will give you a quick idea:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; pow is math.pow\nFalse\n</code></pre>\n<h2>Testing the differences</h2>\n<p>Another way to understand the differences in behaviour between the two functions is to test for them:</p>\n<pre><code class=\"python\">import math\nimport traceback\nimport sys\n\ninf = float(\"inf\")\nNaN = float(\"nan\")\n\nvals = [inf, NaN, 0.0, 1.0, 2.2, -1.0, -0.0, -2.2, -inf, 1, 0, 2]\n\ntests = set([])\n\nfor vala in vals:\n  for valb in vals:\n    tests.add( (vala, valb) )\n    tests.add( (valb, vala) )\n\n\nfor a,b in tests:\n  print(\"math.pow(%f,%f)\"%(a,b) )\n  try:\n    print(\"    %f \"%math.pow(a,b))\n  except:\n    traceback.print_exc()\n  \n  print(\"__builtins__.pow(%f,%f)\"%(a,b) )\n  try:\n    print(\"    %f \"%__builtins__.pow(a,b))\n  except:\n    traceback.print_exc()\n</code></pre>\n<p>We can then notice some subtle differences. For example:</p>\n<pre><code class=\"python\">math.pow(0.000000,-2.200000)\n    ValueError: math domain error\n\n__builtins__.pow(0.000000,-2.200000)\n    ZeroDivisionError: 0.0 cannot be raised to a negative power\n</code></pre>\n<p>There are other differences, and the test list above is not complete (no long numbers, no complex, etc...), but this will give us a pragmatic list of how the two functions behave differently. I would also recommend extending the above test to check for the type that each function returns. You could probably write something similar that creates a report of the differences between the two functions.</p>\n<h2><code>math.pow()</code></h2>\n<p><code>math.pow()</code> handles its arguments very differently from the builtin <code>**</code> or <code>pow()</code>. This comes at the cost of flexibility. Having a look at <a href=\"http://hg.python.org/cpython/file/c7163a7f7cd2/Modules/mathmodule.c#l1781\" rel=\"nofollow noreferrer\">the source</a>, we can see that the arguments to <code>math.pow()</code> are <strong>cast directly to doubles</strong>:</p>\n<pre><code class=\"python\">static PyObject *\nmath_pow(PyObject *self, PyObject *args)\n{\n    PyObject *ox, *oy;\n    double r, x, y;\n    int odd_y;\n\n    if (! PyArg_UnpackTuple(args, \"pow\", 2, 2, &amp;ox, &amp;oy))\n        return NULL;\n    x = PyFloat_AsDouble(ox);\n    y = PyFloat_AsDouble(oy);\n/*...*/\n</code></pre>\n<p>The checks are then carried out against the doubles for validity, and then the result is passed to the underlying C math library.</p>\n<h2>builtin <code>pow()</code></h2>\n<p>The built-in <code>pow()</code> (same as the <code>**</code> operator) on the other hand behaves very differently, it actually uses the Objects's own implementation of the <code>**</code> operator, which can be overridden by the end user if need be by replacing a number's <code>__pow__()</code>, <code>__rpow__()</code> or <code>__ipow__()</code>,  method.</p>\n<p>For built-in types, it is instructive to study the difference between the power function implemented for two numeric types, for example, <a href=\"http://hg.python.org/cpython/file/6a60359556f9/Objects/floatobject.c#l807\" rel=\"nofollow noreferrer\">floats</a>, <a href=\"http://hg.python.org/cpython/file/c7163a7f7cd2/Objects/longobject.c#l3599\" rel=\"nofollow noreferrer\">long</a> and <a href=\"http://hg.python.org/cpython/file/c7163a7f7cd2/Objects/complexobject.c#l510\" rel=\"nofollow noreferrer\">complex</a>.</p>\n<h2>Overriding the default behaviour</h2>\n<p>Emulating numeric types is described <a href=\"http://docs.python.org/reference/datamodel.html#numeric-types\" rel=\"nofollow noreferrer\">here</a>. essentially, if you are creating a new type for numbers with uncertainty, what you will have to do is provide the <code>__pow__()</code>, <code>__rpow__()</code> and possibly <code>__ipow__()</code> methods for your type. This will allow your numbers to be used with the operator:</p>\n<pre><code class=\"python\">class Uncertain:\n  def __init__(self, x, delta=0):\n    self.delta = delta\n    self.x = x\n  def __pow__(self, other):\n    return Uncertain(\n      self.x**other.x, \n      Uncertain._propagate_power(self, other)\n    )\n  @staticmethod\n  def _propagate_power(A, B):\n    return math.sqrt(\n      ((B.x*(A.x**(B.x-1)))**2)*A.delta*A.delta +\n      (((A.x**B.x)*math.log(B.x))**2)*B.delta*B.delta\n    )\n</code></pre>\n<p>In order to override <code>math.pow()</code> you will have to monkey patch it to support your new type:</p>\n<pre><code class=\"python\">def new_pow(a,b):\n    _a = Uncertain(a)\n    _b = Uncertain(b)\n    return _a ** _b\n\nmath.pow = new_pow\n</code></pre>\n<p>Note that for this to work you'll have to wrangle the <code>Uncertain</code> class to cope with an <code>Uncertain</code> instance as an input to <code>__init__()</code></p>\n", "abstract": "From the signatures, we can tell that they are different: pow(x, y[, z]) math.pow(x, y) Also, trying it in the shell will give you a quick idea: Another way to understand the differences in behaviour between the two functions is to test for them: We can then notice some subtle differences. For example: There are other differences, and the test list above is not complete (no long numbers, no complex, etc...), but this will give us a pragmatic list of how the two functions behave differently. I would also recommend extending the above test to check for the type that each function returns. You could probably write something similar that creates a report of the differences between the two functions. math.pow() handles its arguments very differently from the builtin ** or pow(). This comes at the cost of flexibility. Having a look at the source, we can see that the arguments to math.pow() are cast directly to doubles: The checks are then carried out against the doubles for validity, and then the result is passed to the underlying C math library. The built-in pow() (same as the ** operator) on the other hand behaves very differently, it actually uses the Objects's own implementation of the ** operator, which can be overridden by the end user if need be by replacing a number's __pow__(), __rpow__() or __ipow__(),  method. For built-in types, it is instructive to study the difference between the power function implemented for two numeric types, for example, floats, long and complex. Emulating numeric types is described here. essentially, if you are creating a new type for numbers with uncertainty, what you will have to do is provide the __pow__(), __rpow__() and possibly __ipow__() methods for your type. This will allow your numbers to be used with the operator: In order to override math.pow() you will have to monkey patch it to support your new type: Note that for this to work you'll have to wrangle the Uncertain class to cope with an Uncertain instance as an input to __init__()"}, {"id": 10283032, "score": 37, "vote": 0, "content": "<p><code>math.pow()</code> implicitly converts its arguments to <code>float</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; math.pow(Fraction(1, 3), 2)\n0.1111111111111111\n&gt;&gt;&gt; math.pow(Decimal(10), -1)\n0.1\n</code></pre>\n<p>but the built-in <code>pow</code> does not:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; pow(Fraction(1, 3), 2)\nFraction(1, 9)\n&gt;&gt;&gt; pow(Decimal(10), -1)\nDecimal('0.1')\n</code></pre>\n<blockquote>\n<p>My goal is to provide an implementation of both the built-in pow() and of math.pow() for numbers with uncertainty</p>\n</blockquote>\n<p>You can overload <code>pow</code> and <code>**</code> by defining <code>__pow__</code> and <code>__rpow__</code> methods for your class.</p>\n<p>However, you can't overload <code>math.pow</code> (without hacks like <code>math.pow = pow</code>).  You can make a class usable with <code>math.pow</code> by defining a <code>__float__</code> conversion, but then you'll lose the uncertainty attached to your numbers.</p>\n", "abstract": "math.pow() implicitly converts its arguments to float: but the built-in pow does not: My goal is to provide an implementation of both the built-in pow() and of math.pow() for numbers with uncertainty You can overload pow and ** by defining __pow__ and __rpow__ methods for your class. However, you can't overload math.pow (without hacks like math.pow = pow).  You can make a class usable with math.pow by defining a __float__ conversion, but then you'll lose the uncertainty attached to your numbers."}, {"id": 10282880, "score": 12, "vote": 0, "content": "<p>Python's standard <code>pow</code> includes a simple hack that makes <code>pow(2, 3, 2)</code> faster than <code>(2 ** 3) % 2</code> (of course, you'll only notice that with large numbers).</p>\n<p>Another big difference is how the two functions handle different input formats.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; pow(2, 1+0.5j)\n(1.8810842093664877+0.679354250205337j)\n&gt;&gt;&gt; math.pow(2, 1+0.5j)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: can't convert complex to float\n</code></pre>\n<p>However, I have no idea why anyone would prefer <code>math.pow</code> over <code>pow</code>.</p>\n", "abstract": "Python's standard pow includes a simple hack that makes pow(2, 3, 2) faster than (2 ** 3) % 2 (of course, you'll only notice that with large numbers). Another big difference is how the two functions handle different input formats. However, I have no idea why anyone would prefer math.pow over pow."}, {"id": 57285446, "score": 1, "vote": 0, "content": "<p>Just adding %timeit comparison</p>\n<pre><code class=\"python\">In [1]: def pair_generator(): \n    ...:     yield (random.random()*10, random.random()*10) \n    ...:   \n\nIn [2]: %timeit [a**b for a, b in pair_generator()]                                                                    \n538 ns \u00b1 1.94 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n\nIn [3]: %timeit [math.pow(a, b) for a, b in pair_generator()]                                                          \n632 ns \u00b1 2.77 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n</code></pre>\n", "abstract": "Just adding %timeit comparison"}]}, {"link": "https://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python", "question": {"id": "457408", "title": "Is there an easily available implementation of erf() for Python?", "content": "<p>I can implement the error function, erf, myself, but I'd prefer not to. Is there a python package with no external dependencies that contains an implementation of this function? I have found <a href=\"http://pylab.sourceforge.net/packages/included_functions.html\" rel=\"noreferrer\">this</a> but this seems to be part of some much larger package (and it's not even clear which one!).</p>\n", "abstract": "I can implement the error function, erf, myself, but I'd prefer not to. Is there a python package with no external dependencies that contains an implementation of this function? I have found this but this seems to be part of some much larger package (and it's not even clear which one!)."}, "answers": [{"id": 6662057, "score": 75, "vote": 0, "content": "<p>Since v.2.7. the standard <em>math</em> module contains <em>erf</em> function. This should be the easiest way.</p>\n<p><a href=\"http://docs.python.org/2/library/math.html#math.erf\">http://docs.python.org/2/library/math.html#math.erf</a></p>\n", "abstract": "Since v.2.7. the standard math module contains erf function. This should be the easiest way. http://docs.python.org/2/library/math.html#math.erf"}, {"id": 457805, "score": 56, "vote": 0, "content": "<p>I recommend SciPy for numerical functions in Python, but if you want something with no dependencies, here is a function with an error error is less than 1.5 * 10<sup>-7</sup> for all inputs.</p>\n<pre><code class=\"python\">def erf(x):\n    # save the sign of x\n    sign = 1 if x &gt;= 0 else -1\n    x = abs(x)\n\n    # constants\n    a1 =  0.254829592\n    a2 = -0.284496736\n    a3 =  1.421413741\n    a4 = -1.453152027\n    a5 =  1.061405429\n    p  =  0.3275911\n\n    # A&amp;S formula 7.1.26\n    t = 1.0/(1.0 + p*x)\n    y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*math.exp(-x*x)\n    return sign*y # erf(-x) = -erf(x)\n</code></pre>\n<p>The algorithm comes from <a href=\"https://rads.stackoverflow.com/amzn/click/com/0486612724\" rel=\"nofollow noreferrer\">Handbook of Mathematical Functions</a>, formula 7.1.26.</p>\n", "abstract": "I recommend SciPy for numerical functions in Python, but if you want something with no dependencies, here is a function with an error error is less than 1.5 * 10-7 for all inputs. The algorithm comes from Handbook of Mathematical Functions, formula 7.1.26."}, {"id": 457475, "score": 26, "vote": 0, "content": "<p>I would recommend you download <a href=\"http://sourceforge.net/project/showfiles.php?group_id=1369&amp;package_id=175103\" rel=\"noreferrer\">numpy</a> (to have efficiant matrix in python) and <a href=\"http://www.scipy.org/\" rel=\"noreferrer\">scipy</a> (a  Matlab toolbox substitute, which uses numpy). The erf function lies in scipy.</p>\n<pre><code class=\"python\">&gt;&gt;&gt;from scipy.special import erf\n&gt;&gt;&gt;help(erf)\n</code></pre>\n<p>You can also use the erf function defined in pylab, but this is more intended at plotting the results of the things you compute with numpy and scipy. If you want an all-in-one \ninstallation of these software you can use directly the <a href=\"http://www.enthought.com/products/epd.php\" rel=\"noreferrer\">Python Enthought distribution</a>.</p>\n", "abstract": "I would recommend you download numpy (to have efficiant matrix in python) and scipy (a  Matlab toolbox substitute, which uses numpy). The erf function lies in scipy. You can also use the erf function defined in pylab, but this is more intended at plotting the results of the things you compute with numpy and scipy. If you want an all-in-one \ninstallation of these software you can use directly the Python Enthought distribution."}, {"id": 463261, "score": 8, "vote": 0, "content": "<p>A pure python implementation can be found in the mpmath module (<a href=\"http://code.google.com/p/mpmath/\" rel=\"noreferrer\">http://code.google.com/p/mpmath/</a>)</p>\n<p>From the doc string:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from mpmath import *\n&gt;&gt;&gt; mp.dps = 15\n&gt;&gt;&gt; print erf(0)\n0.0\n&gt;&gt;&gt; print erf(1)\n0.842700792949715\n&gt;&gt;&gt; print erf(-1)\n-0.842700792949715\n&gt;&gt;&gt; print erf(inf)\n1.0\n&gt;&gt;&gt; print erf(-inf)\n-1.0\n</code></pre>\n<p>For large real <code>x</code>, <code>\\mathrm{erf}(x)</code> approaches 1 very\nrapidly::</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print erf(3)\n0.999977909503001\n&gt;&gt;&gt; print erf(5)\n0.999999999998463\n</code></pre>\n<p>The error function is an odd function::</p>\n<pre><code class=\"python\">&gt;&gt;&gt; nprint(chop(taylor(erf, 0, 5)))\n[0.0, 1.12838, 0.0, -0.376126, 0.0, 0.112838]\n</code></pre>\n<p>:func:<code>erf</code> implements arbitrary-precision evaluation and\nsupports complex numbers::</p>\n<pre><code class=\"python\">&gt;&gt;&gt; mp.dps = 50\n&gt;&gt;&gt; print erf(0.5)\n0.52049987781304653768274665389196452873645157575796\n&gt;&gt;&gt; mp.dps = 25\n&gt;&gt;&gt; print erf(1+j)\n(1.316151281697947644880271 + 0.1904534692378346862841089j)\n</code></pre>\n<p><strong>Related functions</strong></p>\n<p>See also :func:<code>erfc</code>, which is more accurate for large <code>x</code>,\nand :func:<code>erfi</code> which gives the antiderivative of\n<code>\\exp(t^2)</code>.</p>\n<p>The Fresnel integrals :func:<code>fresnels</code> and :func:<code>fresnelc</code>\nare also related to the error function.</p>\n", "abstract": "A pure python implementation can be found in the mpmath module (http://code.google.com/p/mpmath/) From the doc string: For large real x, \\mathrm{erf}(x) approaches 1 very\nrapidly:: The error function is an odd function:: :func:erf implements arbitrary-precision evaluation and\nsupports complex numbers:: Related functions See also :func:erfc, which is more accurate for large x,\nand :func:erfi which gives the antiderivative of\n\\exp(t^2). The Fresnel integrals :func:fresnels and :func:fresnelc\nare also related to the error function."}, {"id": 458069, "score": 7, "vote": 0, "content": "<p>To answer my own question, I have ended up using the following code, adapted from a Java version I found elsewhere on the web:</p>\n<pre><code class=\"python\"># from: http://www.cs.princeton.edu/introcs/21function/ErrorFunction.java.html\n# Implements the Gauss error function.\n#   erf(z) = 2 / sqrt(pi) * integral(exp(-t*t), t = 0..z)\n#\n# fractional error in math formula less than 1.2 * 10 ^ -7.\n# although subject to catastrophic cancellation when z in very close to 0\n# from Chebyshev fitting formula for erf(z) from Numerical Recipes, 6.2\ndef erf(z):\n    t = 1.0 / (1.0 + 0.5 * abs(z))\n        # use Horner's method\n        ans = 1 - t * math.exp( -z*z -  1.26551223 +\n                            t * ( 1.00002368 +\n                            t * ( 0.37409196 + \n                            t * ( 0.09678418 + \n                            t * (-0.18628806 + \n                            t * ( 0.27886807 + \n                            t * (-1.13520398 + \n                            t * ( 1.48851587 + \n                            t * (-0.82215223 + \n                            t * ( 0.17087277))))))))))\n        if z &gt;= 0.0:\n            return ans\n        else:\n            return -ans\n</code></pre>\n", "abstract": "To answer my own question, I have ended up using the following code, adapted from a Java version I found elsewhere on the web:"}, {"id": 4021276, "score": 6, "vote": 0, "content": "<p>I have a function which does 10^5 erf calls. On my machine...</p>\n<p>scipy.special.erf makes it time at 6.1s</p>\n<p>erf Handbook of Mathematical Functions takes     8.3s</p>\n<p>erf Numerical Recipes 6.2    takes     9.5s</p>\n<p>(three-run averages, code taken from above posters).</p>\n", "abstract": "I have a function which does 10^5 erf calls. On my machine... scipy.special.erf makes it time at 6.1s erf Handbook of Mathematical Functions takes     8.3s erf Numerical Recipes 6.2    takes     9.5s (three-run averages, code taken from above posters)."}, {"id": 20745660, "score": 6, "vote": 0, "content": "<p>One note for those aiming for higher performance: vectorize, if possible.</p>\n<pre><code class=\"python\">import numpy as np\nfrom scipy.special import erf\n\ndef vectorized(n):\n    x = np.random.randn(n)\n    return erf(x)\n\ndef loopstyle(n):\n    x = np.random.randn(n)\n    return [erf(v) for v in x]\n\n%timeit vectorized(10e5)\n%timeit loopstyle(10e5)\n</code></pre>\n<p>gives results</p>\n<pre><code class=\"python\"># vectorized\n10 loops, best of 3: 108 ms per loop\n\n# loops\n1 loops, best of 3: 2.34 s per loop\n</code></pre>\n", "abstract": "One note for those aiming for higher performance: vectorize, if possible. gives results"}, {"id": 60827322, "score": 0, "vote": 0, "content": "<p>SciPy has an implementation of the <code>erf</code> function, see <a href=\"https://docs.scipy.org/doc/scipy-1.4.1/reference/generated/scipy.special.erf.html\" rel=\"nofollow noreferrer\">scipy.special.erf</a>.</p>\n", "abstract": "SciPy has an implementation of the erf function, see scipy.special.erf."}, {"id": 68692212, "score": 0, "vote": 0, "content": "<p>From <a href=\"https://github.com/python/cpython/blob/main/Modules/mathmodule.c\" rel=\"nofollow noreferrer\">Python's math.erf function documentation</a>, it uses up to 50 terms in the approximation:</p>\n<pre><code class=\"python\">Implementations of the error function erf(x) and the complementary error\n   function erfc(x).\n   Method: we use a series approximation for erf for small x, and a continued\n   fraction approximation for erfc(x) for larger x;\n   combined with the relations erf(-x) = -erf(x) and erfc(x) = 1.0 - erf(x),\n   this gives us erf(x) and erfc(x) for all x.\n   The series expansion used is:\n      erf(x) = x*exp(-x*x)/sqrt(pi) * [\n                     2/1 + 4/3 x**2 + 8/15 x**4 + 16/105 x**6 + ...]\n   The coefficient of x**(2k-2) here is 4**k*factorial(k)/factorial(2*k).\n   This series converges well for smallish x, but slowly for larger x.\n   The continued fraction expansion used is:\n      erfc(x) = x*exp(-x*x)/sqrt(pi) * [1/(0.5 + x**2 -) 0.5/(2.5 + x**2 - )\n                              3.0/(4.5 + x**2 - ) 7.5/(6.5 + x**2 - ) ...]\n   after the first term, the general term has the form:\n      k*(k-0.5)/(2*k+0.5 + x**2 - ...).\n   This expansion converges fast for larger x, but convergence becomes\n   infinitely slow as x approaches 0.0.  The (somewhat naive) continued\n   fraction evaluation algorithm used below also risks overflow for large x;\n   but for large x, erfc(x) == 0.0 to within machine precision.  (For\n   example, erfc(30.0) is approximately 2.56e-393).\n   Parameters: use series expansion for abs(x) &lt; ERF_SERIES_CUTOFF and\n   continued fraction expansion for ERF_SERIES_CUTOFF &lt;= abs(x) &lt;\n   ERFC_CONTFRAC_CUTOFF.  ERFC_SERIES_TERMS and ERFC_CONTFRAC_TERMS are the\n   numbers of terms to use for the relevant expansions. \n\n#define ERF_SERIES_CUTOFF 1.5\n#define ERF_SERIES_TERMS 25\n#define ERFC_CONTFRAC_CUTOFF 30.0\n#define ERFC_CONTFRAC_TERMS 50\n\n   Error function, via power series.\n   Given a finite float x, return an approximation to erf(x).\n   Converges reasonably fast for small x.\n</code></pre>\n", "abstract": "From Python's math.erf function documentation, it uses up to 50 terms in the approximation:"}]}, {"link": "https://stackoverflow.com/questions/558216/function-to-determine-if-two-numbers-are-nearly-equal-when-rounded-to-n-signific", "question": {"id": "558216", "title": "Function to determine if two numbers are nearly equal when rounded to n significant decimal digits", "content": "<p>I have been asked to test a library provided by a 3rd party. The library is known to be accurate to <em>n</em> significant figures. Any less-significant errors can safely be ignored. I want to write a function to help me compare the results:</p>\n<pre><code class=\"python\">def nearlyequal( a, b, sigfig=5 ):\n</code></pre>\n<p>The purpose of this function is to determine if two floating-point numbers (a and b) are approximately equal. The function will return True if a==b (exact match) or if a and b have the same value when rounded to <strong>sigfig</strong> significant-figures when written in decimal. </p>\n<p>Can anybody suggest a good implementation? I've written a mini unit-test. Unless you can see a bug in my tests then a good implementation should pass the following:</p>\n<pre><code class=\"python\">assert nearlyequal(1, 1, 5) \nassert nearlyequal(1.0, 1.0, 5) \nassert nearlyequal(1.0, 1.0, 5) \nassert nearlyequal(-1e-9, 1e-9, 5) \nassert nearlyequal(1e9, 1e9 + 1 , 5) \nassert not nearlyequal( 1e4, 1e4 + 1, 5) \nassert nearlyequal( 0.0, 1e-15, 5 ) \nassert not nearlyequal( 0.0, 1e-4, 6 ) \n</code></pre>\n<p>Additional notes:</p>\n<ol>\n<li>Values a and b might be of type int, float or numpy.float64. Values a and b will always be of the same type. It's vital that conversion does not introduce additional error into the function.</li>\n<li>Lets keep this numerical, so functions that convert to strings or use non-mathematical tricks are not ideal. This program will be audited by somebody who is a mathematician who will want to be able to prove that the function does what it is supposed to do.</li>\n<li>Speed... I've got to compare a lot of numbers so the faster the better.</li>\n<li>I've got numpy, scipy and the standard-library. Anything else will be hard for me to get, especially for such a small part of the project.</li>\n</ol>\n", "abstract": "I have been asked to test a library provided by a 3rd party. The library is known to be accurate to n significant figures. Any less-significant errors can safely be ignored. I want to write a function to help me compare the results: The purpose of this function is to determine if two floating-point numbers (a and b) are approximately equal. The function will return True if a==b (exact match) or if a and b have the same value when rounded to sigfig significant-figures when written in decimal.  Can anybody suggest a good implementation? I've written a mini unit-test. Unless you can see a bug in my tests then a good implementation should pass the following: Additional notes:"}, "answers": [{"id": 36407955, "score": 134, "vote": 0, "content": "<p>As of Python 3.5, the standard way to do this (using the standard library) is with the <a href=\"https://docs.python.org/3/library/math.html#math.isclose\"><code>math.isclose</code></a> function.</p>\n<p>It has the following signature:</p>\n<pre><code class=\"python\">isclose(a, b, rel_tol=1e-9, abs_tol=0.0)\n</code></pre>\n<p>An example of usage with absolute error tolerance:</p>\n<pre><code class=\"python\">from math import isclose\na = 1.0\nb = 1.00000001\nassert isclose(a, b, abs_tol=1e-8)\n</code></pre>\n<p>If you want it with precision of <strong><em>n</em></strong> significant digits, simply replace the last line with:</p>\n<pre><code class=\"python\">assert isclose(a, b, abs_tol=10**-n)\n</code></pre>\n", "abstract": "As of Python 3.5, the standard way to do this (using the standard library) is with the math.isclose function. It has the following signature: An example of usage with absolute error tolerance: If you want it with precision of n significant digits, simply replace the last line with:"}, {"id": 558322, "score": 31, "vote": 0, "content": "<p>There is a function <code>assert_approx_equal</code> in <code>numpy.testing</code> (source <a href=\"https://github.com/numpy/numpy/blob/1225aef37298ec82048d0828f6cb7e0be8ed58cc/numpy/testing/utils.py#L513\" rel=\"noreferrer\">here) </a>which may be a good starting point. </p>\n<pre><code class=\"python\">def assert_approx_equal(actual,desired,significant=7,err_msg='',verbose=True):\n    \"\"\"\n    Raise an assertion if two items are not equal up to significant digits.\n\n    .. note:: It is recommended to use one of `assert_allclose`,\n              `assert_array_almost_equal_nulp` or `assert_array_max_ulp`\n              instead of this function for more consistent floating point\n              comparisons.\n\n    Given two numbers, check that they are approximately equal.\n    Approximately equal is defined as the number of significant digits\n    that agree.\n</code></pre>\n", "abstract": "There is a function assert_approx_equal in numpy.testing (source here) which may be a good starting point. "}, {"id": 558289, "score": 8, "vote": 0, "content": "<p>Here's a take.</p>\n<pre><code class=\"python\">def nearly_equal(a,b,sig_fig=5):\n    return ( a==b or \n             int(a*10**sig_fig) == int(b*10**sig_fig)\n           )\n</code></pre>\n", "abstract": "Here's a take."}, {"id": 558359, "score": 7, "vote": 0, "content": "<p>I believe your question is not defined well enough, and the unit-tests you present prove it:</p>\n<p>If by 'round to N sig-fig decimal places' you mean 'N decimal places to the right of the decimal point', then the test <code>assert nearlyequal(1e9, 1e9 + 1 , 5)</code> should fail, because even when you round 1000000000 and 1000000001 to 0.00001 accuracy, they are still different.</p>\n<p>And if by 'round to N sig-fig decimal places' you mean 'The N most significant digits, regardless of the decimal point', then the test <code>assert nearlyequal(-1e-9, 1e-9, 5)</code> should fail, because 0.000000001 and -0.000000001 are totally different when viewed this way.</p>\n<p>If you meant the first definition, then the first answer on this page (by Triptych) is good.\nIf you meant the second definition, please say it, I promise to think about it :-)</p>\n", "abstract": "I believe your question is not defined well enough, and the unit-tests you present prove it: If by 'round to N sig-fig decimal places' you mean 'N decimal places to the right of the decimal point', then the test assert nearlyequal(1e9, 1e9 + 1 , 5) should fail, because even when you round 1000000000 and 1000000001 to 0.00001 accuracy, they are still different. And if by 'round to N sig-fig decimal places' you mean 'The N most significant digits, regardless of the decimal point', then the test assert nearlyequal(-1e-9, 1e-9, 5) should fail, because 0.000000001 and -0.000000001 are totally different when viewed this way. If you meant the first definition, then the first answer on this page (by Triptych) is good.\nIf you meant the second definition, please say it, I promise to think about it :-)"}, {"id": 564086, "score": 6, "vote": 0, "content": "<p>There are already plenty of great answers, but here's a think:</p>\n<pre><code class=\"python\">def closeness(a, b):\n  \"\"\"Returns measure of equality (for two floats), in unit\n     of decimal significant figures.\"\"\"\n  if a == b:\n    return float(\"infinity\")\n  difference = abs(a - b)\n  avg = (a + b)/2\n  return math.log10( avg / difference )\n\n\nif closeness(1000, 1000.1) &gt; 3:\n  print \"Joy!\"\n</code></pre>\n", "abstract": "There are already plenty of great answers, but here's a think:"}, {"id": 558298, "score": 3, "vote": 0, "content": "<p>\"Significant figures\" in decimal is a matter of adjusting the decimal point and truncating to an integer.  </p>\n<pre><code class=\"python\">&gt;&gt;&gt; int(3.1415926 * 10**3)\n3141\n&gt;&gt;&gt; int(1234567 * 10**-3)\n1234\n&gt;&gt;&gt;\n</code></pre>\n", "abstract": "\"Significant figures\" in decimal is a matter of adjusting the decimal point and truncating to an integer.  "}, {"id": 563955, "score": 3, "vote": 0, "content": "<p>This is a fairly common issue with floating point numbers. I solve it based on the discussion in Section 1.5 of Demmel[1]. (1) Calculate the roundoff error. (2) Check that the roundoff error is less than some epsilon. I haven't used python in some time and only have version 2.4.3, but I'll try to get this correct.</p>\n<p>Step 1. Roundoff error</p>\n<pre><code class=\"python\">def roundoff_error(exact, approximate):\n    return abs(approximate/exact - 1.0)\n</code></pre>\n<p>Step 2. Floating point equality</p>\n<pre><code class=\"python\">def float_equal(float1, float2, epsilon=2.0e-9):\n    return (roundoff_error(float1, float2) &lt; epsilon)\n</code></pre>\n<p>There are a couple obvious deficiencies with this code.</p>\n<ol>\n<li>Division by zero error if the exact value is Zero.</li>\n<li>Does not verify that the arguments are floating point values.</li>\n</ol>\n<p>Revision 1.</p>\n<pre><code class=\"python\">def roundoff_error(exact, approximate):\n    if (exact == 0.0 or approximate == 0.0):\n        return abs(exact + approximate)\n    else:\n        return abs(approximate/exact - 1.0)\n\ndef float_equal(float1, float2, epsilon=2.0e-9):\n    if not isinstance(float1,float):\n        raise TypeError,\"First argument is not a float.\"\n    elif not isinstance(float2,float):\n        raise TypeError,\"Second argument is not a float.\"\n    else:\n        return (roundoff_error(float1, float2) &lt; epsilon)\n</code></pre>\n<p>That's a little better. If either the exact or the approximate value is zero, than the error is equal to the value of the other. If something besides a floating point value is provided, a TypeError is raised.</p>\n<p>At this point, the only difficult thing is setting the correct value for epsilon. I noticed in the documentation for version 2.6.1 that there is an epsilon attribute in sys.float_info, so I would use twice that value as the default epsilon. But the correct value depends on both your application and your algorithm.</p>\n<p>[1] James W. Demmel, <em>Applied Numerical Linear Algebra</em>, SIAM, 1997.</p>\n", "abstract": "This is a fairly common issue with floating point numbers. I solve it based on the discussion in Section 1.5 of Demmel[1]. (1) Calculate the roundoff error. (2) Check that the roundoff error is less than some epsilon. I haven't used python in some time and only have version 2.4.3, but I'll try to get this correct. Step 1. Roundoff error Step 2. Floating point equality There are a couple obvious deficiencies with this code. Revision 1. That's a little better. If either the exact or the approximate value is zero, than the error is equal to the value of the other. If something besides a floating point value is provided, a TypeError is raised. At this point, the only difficult thing is setting the correct value for epsilon. I noticed in the documentation for version 2.6.1 that there is an epsilon attribute in sys.float_info, so I would use twice that value as the default epsilon. But the correct value depends on both your application and your algorithm. [1] James W. Demmel, Applied Numerical Linear Algebra, SIAM, 1997."}, {"id": 563993, "score": 1, "vote": 0, "content": "<p>Oren Shemesh got part of the problem with the problem as stated but there's more:</p>\n<p>assert nearlyequal( 0.0, 1e-15, 5 ) </p>\n<p>also fails the second definition (and that's the definition I learned in school.)</p>\n<p>No matter how many digits you are looking at, 0 will not equal a not-zero.  This could prove to be a headache for such tests if you have a case whose correct answer is zero.</p>\n", "abstract": "Oren Shemesh got part of the problem with the problem as stated but there's more: assert nearlyequal( 0.0, 1e-15, 5 )  also fails the second definition (and that's the definition I learned in school.) No matter how many digits you are looking at, 0 will not equal a not-zero.  This could prove to be a headache for such tests if you have a case whose correct answer is zero."}, {"id": 1595078, "score": 1, "vote": 0, "content": "<p>There is a interesting solution to this by B. Dawson (with C++ code)\nat <a href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\" rel=\"nofollow noreferrer\">\"Comparing Floating Point Numbers\"</a>.  His approach relies on strict IEEE representation of two numbers and the enforced lexicographical ordering when said numbers are represented as unsigned integers.</p>\n", "abstract": "There is a interesting solution to this by B. Dawson (with C++ code)\nat \"Comparing Floating Point Numbers\".  His approach relies on strict IEEE representation of two numbers and the enforced lexicographical ordering when said numbers are represented as unsigned integers."}, {"id": 51963714, "score": 1, "vote": 0, "content": "<blockquote>\n<p>I have been asked to test a library provided by a 3rd party</p>\n</blockquote>\n<p>If you are using the default Python <a href=\"https://docs.python.org/3/library/unittest.html#module-unittest\" rel=\"nofollow noreferrer\"><code>unittest</code> framework</a>, you can use <a href=\"https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual\" rel=\"nofollow noreferrer\"><code>assertAlmostEqual</code></a></p>\n<pre><code class=\"python\">self.assertAlmostEqual(a, b, places=5)\n</code></pre>\n", "abstract": "I have been asked to test a library provided by a 3rd party If you are using the default Python unittest framework, you can use assertAlmostEqual"}, {"id": 20585965, "score": 0, "vote": 0, "content": "<p>There are lots of ways of comparing two numbers to see if they agree to N significant digits. Roughly speaking you just want to make sure that their difference is less than 10^-N times the largest of the two numbers being compared. That's easy enough.</p>\n<p>But, what if one of the numbers is zero? The whole concept of relative-differences or significant-digits falls down when comparing against zero. To handle that case you need to have an absolute-difference as well, which should be specified differently from the relative-difference.</p>\n<p>I discuss the problems of comparing floating-point numbers -- including a specific case of handling zero -- in this blog post:</p>\n<p><a href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\" rel=\"nofollow\">http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/</a></p>\n", "abstract": "There are lots of ways of comparing two numbers to see if they agree to N significant digits. Roughly speaking you just want to make sure that their difference is less than 10^-N times the largest of the two numbers being compared. That's easy enough. But, what if one of the numbers is zero? The whole concept of relative-differences or significant-digits falls down when comparing against zero. To handle that case you need to have an absolute-difference as well, which should be specified differently from the relative-difference. I discuss the problems of comparing floating-point numbers -- including a specific case of handling zero -- in this blog post: http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/"}]}, {"link": "https://stackoverflow.com/questions/15736995/how-can-i-quickly-estimate-the-distance-between-two-latitude-longitude-points", "question": {"id": "15736995", "title": "How can I quickly estimate the distance between two (latitude, longitude) points?", "content": "<p>I want to be able to get a estimate of the distance between two (latitude, longitude) points. I want to undershoot, as this will be for A* graph search and I want it to be <strong>fast</strong>. The points will be at most 800 km apart.</p>\n", "abstract": "I want to be able to get a estimate of the distance between two (latitude, longitude) points. I want to undershoot, as this will be for A* graph search and I want it to be fast. The points will be at most 800 km apart."}, "answers": [{"id": 15737218, "score": 122, "vote": 0, "content": "<p>The answers to <a href=\"https://stackoverflow.com/questions/4913349/haversine-formula-in-python-bearing-and-distance-between-two-gps-points\">Haversine Formula in Python (Bearing and Distance between two GPS points)</a> provide Python implementations that answer your question.</p>\n<p>Using the implementation below I <strong>performed 100,000 iterations in less than 1 second</strong> on an older laptop.  I think for your purposes this should be sufficient.  However, you should profile anything before you optimize for performance.\n<code><pre>from math import radians, cos, sin, asin, sqrt\ndef haversine(lon1, lat1, lon2, lat2):\n    \"\"\"\n    Calculate the great circle distance between two points \n    on the earth (specified in decimal degrees)\n    \"\"\"\n    # convert decimal degrees to radians \n    lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])\n    # haversine formula \n    dlon = lon2 - lon1 \n    dlat = lat2 - lat1 \n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * asin(sqrt(a)) \n    # Radius of earth in kilometers is 6371\n    km = 6371* c\n    return km</pre></code></p>\n<p>To underestimate <code>haversine(lat1, long1, lat2, long2) * 0.90</code> or whatever factor you want.  I don't see how introducing error to your underestimation is useful.</p>\n", "abstract": "The answers to Haversine Formula in Python (Bearing and Distance between two GPS points) provide Python implementations that answer your question. Using the implementation below I performed 100,000 iterations in less than 1 second on an older laptop.  I think for your purposes this should be sufficient.  However, you should profile anything before you optimize for performance.\nfrom math import radians, cos, sin, asin, sqrt\ndef haversine(lon1, lat1, lon2, lat2):\n    \"\"\"\n    Calculate the great circle distance between two points \n    on the earth (specified in decimal degrees)\n    \"\"\"\n    # convert decimal degrees to radians \n    lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])\n    # haversine formula \n    dlon = lon2 - lon1 \n    dlat = lat2 - lat1 \n    a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2\n    c = 2 * asin(sqrt(a)) \n    # Radius of earth in kilometers is 6371\n    km = 6371* c\n    return km To underestimate haversine(lat1, long1, lat2, long2) * 0.90 or whatever factor you want.  I don't see how introducing error to your underestimation is useful."}, {"id": 15742266, "score": 44, "vote": 0, "content": "<p>Since the distance is relatively small, you can use the equirectangular distance approximation.  This approximation is faster than using the Haversine formula.  So, to get the distance from your reference point (lat1, lon1) to the point you're testing (lat2, lon2) use the formula below:</p>\n<pre><code class=\"python\">from math import sqrt, cos, radians\n\nR = 6371  # radius of the earth in km\nx = (radians(lon2) - radians(lon1)) * cos(0.5 * (radians(lat2) + radians(lat1)))\ny = radians(lat2) - radians(lat1)\nd = R * sqrt(x*x + y*y)\n</code></pre>\n<p>Since <code>R</code> is in km, the distance <code>d</code> will be in km.</p>\n<p>Reference: <a href=\"http://www.movable-type.co.uk/scripts/latlong.html\" rel=\"nofollow noreferrer\">http://www.movable-type.co.uk/scripts/latlong.html</a></p>\n", "abstract": "Since the distance is relatively small, you can use the equirectangular distance approximation.  This approximation is faster than using the Haversine formula.  So, to get the distance from your reference point (lat1, lon1) to the point you're testing (lat2, lon2) use the formula below: Since R is in km, the distance d will be in km. Reference: http://www.movable-type.co.uk/scripts/latlong.html"}, {"id": 15737078, "score": 8, "vote": 0, "content": "<p>One idea for speed is to transform the long/lat coordinated into 3D (x,y,z) coordinates.  After preprocessing the points, use the Euclidean distance between the points as a quickly computed undershoot of the actual distance.</p>\n", "abstract": "One idea for speed is to transform the long/lat coordinated into 3D (x,y,z) coordinates.  After preprocessing the points, use the Euclidean distance between the points as a quickly computed undershoot of the actual distance."}, {"id": 53712712, "score": 4, "vote": 0, "content": "<p>If the distance between points is relatively small (meters to few km range)\nthen one of the fast approaches could be</p>\n<pre><code class=\"python\">from math import cos, sqrt\ndef qick_distance(Lat1, Long1, Lat2, Long2):\n    x = Lat2 - Lat1\n    y = (Long2 - Long1) * cos((Lat2 + Lat1)*0.00872664626)  \n    return 111.319 * sqrt(x*x + y*y)\n</code></pre>\n<p>Lat, Long are in radians, distance in km.</p>\n<p>Deviation from Haversine distance is in the order of 1%, while the speed gain is more than ~10x.</p>\n<p>0.00872664626 = 0.5 * pi/180,</p>\n<p>111.319 - is the distance that corresponds to 1degree at Equator, you could replace it with your median value like here\n<a href=\"https://www.cartographyunchained.com/cgsta1/\" rel=\"nofollow noreferrer\">https://www.cartographyunchained.com/cgsta1/</a>\nor replace it with a simple lookup table.</p>\n", "abstract": "If the distance between points is relatively small (meters to few km range)\nthen one of the fast approaches could be Lat, Long are in radians, distance in km. Deviation from Haversine distance is in the order of 1%, while the speed gain is more than ~10x. 0.00872664626 = 0.5 * pi/180, 111.319 - is the distance that corresponds to 1degree at Equator, you could replace it with your median value like here\nhttps://www.cartographyunchained.com/cgsta1/\nor replace it with a simple lookup table."}, {"id": 15737369, "score": 3, "vote": 0, "content": "<p>For maximal speed, you could create something like a <a href=\"http://en.wikipedia.org/wiki/Rainbow_table\" rel=\"nofollow\">rainbow table</a> for coordinate distances.  It sounds like you already know the area that you are working with, so it seems like pre-computing them might be feasible.  Then, you could load the nearest combination and just use that.  </p>\n<p>For example, in the continental United States, the longitude is a 55 degree span and latitude is 20, which would be 1100 whole number points.  The distance between all the possible combinations is a <a href=\"http://en.wikipedia.org/wiki/Metcalfe%27s_law\" rel=\"nofollow\">handshake problem</a> which is answered by (n-1)(n)/2 or about 600k combinations.  That seems pretty feasible to store and retrieve.  If you provide more information about your requirements, I could be more specific.</p>\n", "abstract": "For maximal speed, you could create something like a rainbow table for coordinate distances.  It sounds like you already know the area that you are working with, so it seems like pre-computing them might be feasible.  Then, you could load the nearest combination and just use that.   For example, in the continental United States, the longitude is a 55 degree span and latitude is 20, which would be 1100 whole number points.  The distance between all the possible combinations is a handshake problem which is answered by (n-1)(n)/2 or about 600k combinations.  That seems pretty feasible to store and retrieve.  If you provide more information about your requirements, I could be more specific."}, {"id": 63898329, "score": 1, "vote": 0, "content": "<p>You can use <code>cdist</code> from <code>scipy</code> spacial distance class:</p>\n<p><strong>For example</strong>:</p>\n<pre><code class=\"python\">from scipy.spatial.distance import cdist \ndf1_latlon = df1[['lat','lon']]\ndf2_latlon = df2[['lat', 'lon']]\ndistanceCalc = cdist(df1_latlon, df2_latlon, metric=haversine)\n</code></pre>\n", "abstract": "You can use cdist from scipy spacial distance class: For example:"}, {"id": 54074194, "score": 0, "vote": 0, "content": "<p>To calculate a haversine distance between 2 points u can simply use <a href=\"https://mpu.readthedocs.io/en/latest/mpu.html\" rel=\"nofollow noreferrer\">mpu.haversine_distance()</a> library, like this:  </p>\n<pre><code class=\"python\">&gt;&gt;&gt; import mpu\n&gt;&gt;&gt; munich = (48.1372, 11.5756)\n&gt;&gt;&gt; berlin = (52.5186, 13.4083)\n&gt;&gt;&gt; round(mpu.haversine_distance(munich, berlin), 1)\n&gt;&gt;&gt; 504.2\n</code></pre>\n", "abstract": "To calculate a haversine distance between 2 points u can simply use mpu.haversine_distance() library, like this:  "}, {"id": 38714237, "score": -1, "vote": 0, "content": "<p>Please use the following code.</p>\n<pre><code class=\"python\">def distance(lat1, lng1, lat2, lng2):\n    #return distance as meter if you want km distance, remove \"* 1000\"\n    radius = 6371 * 1000 \n\n    dLat = (lat2-lat1) * math.pi / 180\n    dLng = (lng2-lng1) * math.pi / 180\n\n    lat1 = lat1 * math.pi / 180\n    lat2 = lat2 * math.pi / 180\n\n    val = sin(dLat/2) * sin(dLat/2) + sin(dLng/2) * sin(dLng/2) * cos(lat1) * cos(lat2)    \n    ang = 2 * atan2(sqrt(val), sqrt(1-val))\n    return radius * ang\n</code></pre>\n", "abstract": "Please use the following code."}]}, {"link": "https://stackoverflow.com/questions/18965524/exponentiation-in-python-should-i-prefer-operator-instead-of-math-pow-and-m", "question": {"id": "18965524", "title": "Exponentiation in Python - should I prefer ** operator instead of math.pow and math.sqrt?", "content": "<p>In my field it's very common to square some numbers, operate them together, and take the square root of the result. This is done in pythagorean theorem, and the RMS calculation, for example.</p>\n<p>In numpy, I have done the following:</p>\n<pre><code class=\"python\">result = numpy.sqrt(numpy.sum(numpy.pow(some_vector, 2)))\n</code></pre>\n<p>And in pure python something like this would be expected:</p>\n<pre><code class=\"python\">result = math.sqrt(math.pow(A, 2) + math.pow(B,2)) # example with two dimensions.\n</code></pre>\n<p>However, I have been using this pure python form, since I find it much more compact, import-independent, and seemingly equivalent:</p>\n<pre><code class=\"python\">result = (A**2 + B**2)**0.5   # two dimensions\nresult = (A**2 + B**2 + C**2 + D**2)**0.5\n</code></pre>\n<p>I have heard some people argue that the <code>**</code> operator is sort of a hack, and that squaring a number by exponentiating it by <code>0.5</code> is not so readable. But what I'd like to ask is if:</p>\n<p>\"Is there any COMPUTATIONAL reason to prefer the former two alternatives over the third one(s)?\"</p>\n<p>Thanks for reading!</p>\n", "abstract": "In my field it's very common to square some numbers, operate them together, and take the square root of the result. This is done in pythagorean theorem, and the RMS calculation, for example. In numpy, I have done the following: And in pure python something like this would be expected: However, I have been using this pure python form, since I find it much more compact, import-independent, and seemingly equivalent: I have heard some people argue that the ** operator is sort of a hack, and that squaring a number by exponentiating it by 0.5 is not so readable. But what I'd like to ask is if: \"Is there any COMPUTATIONAL reason to prefer the former two alternatives over the third one(s)?\" Thanks for reading!"}, "answers": [{"id": 18965845, "score": 60, "vote": 0, "content": "<p><code>math.sqrt</code> is the C implementation of square root and is therefore different from using the <code>**</code> operator which implements Python's built-in <code>pow</code> function. Thus, using <code>math.sqrt</code> actually gives a different answer than using the <code>**</code> operator and there is indeed a computational reason to prefer <code>numpy</code> or <code>math</code> module implementation over the built-in. Specifically the sqrt functions are probably implemented in the most efficient way possible whereas <code>**</code> operates over a large number of bases and exponents and is probably unoptimized for the specific case of square root. On the other hand, the built-in <code>pow</code> function handles a few extra cases like \"complex numbers, unbounded integer powers, and modular exponentiation\".</p>\n<p><a href=\"https://stackoverflow.com/questions/842245/which-is-more-accurate-x-5-or-math-sqrtx\">See this Stack Overflow question for more information on the difference  between <code>**</code> and <code>math.sqrt</code>.</a></p>\n<p>In terms of which is more \"Pythonic\", I think we need to discuss the very definition of that word. From <a href=\"http://docs.python.org/2/glossary.html#term-pythonic\" rel=\"noreferrer\">the official Python glossary</a>, it states that a piece of code or idea is Pythonic if it \"closely follows the most common idioms of the Python language, rather than implementing code using concepts common to other languages.\" In every single other language I can think of, there is some math module with basic square root functions. However there are languages that lack a power operator like <code>**</code> e.g. C++. So <code>**</code> is probably more Pythonic, but whether or not it's objectively better depends on the use case.</p>\n", "abstract": "math.sqrt is the C implementation of square root and is therefore different from using the ** operator which implements Python's built-in pow function. Thus, using math.sqrt actually gives a different answer than using the ** operator and there is indeed a computational reason to prefer numpy or math module implementation over the built-in. Specifically the sqrt functions are probably implemented in the most efficient way possible whereas ** operates over a large number of bases and exponents and is probably unoptimized for the specific case of square root. On the other hand, the built-in pow function handles a few extra cases like \"complex numbers, unbounded integer powers, and modular exponentiation\". See this Stack Overflow question for more information on the difference  between ** and math.sqrt. In terms of which is more \"Pythonic\", I think we need to discuss the very definition of that word. From the official Python glossary, it states that a piece of code or idea is Pythonic if it \"closely follows the most common idioms of the Python language, rather than implementing code using concepts common to other languages.\" In every single other language I can think of, there is some math module with basic square root functions. However there are languages that lack a power operator like ** e.g. C++. So ** is probably more Pythonic, but whether or not it's objectively better depends on the use case."}, {"id": 18965819, "score": 18, "vote": 0, "content": "<p>Even in base Python you can do the computation in generic form</p>\n<pre><code class=\"python\">result = sum(x**2 for x in some_vector) ** 0.5\n</code></pre>\n<p><code>x ** 2</code> is surely not an hack and the computation performed is the same (I checked with cpython source code). I actually find it more readable (and readability counts).</p>\n<p>Using instead <code>x ** 0.5</code> to take the square root doesn't do the exact same computations as <code>math.sqrt</code> as the former (probably) is computed using logarithms and the latter (probably) using the specific numeric instruction of the math processor.</p>\n<p>I often use <code>x ** 0.5</code> simply because I don't want to add <code>math</code> just for that. I'd expect however a specific instruction for the square root to work better (more accurately) than a multi-step operation with logarithms.</p>\n", "abstract": "Even in base Python you can do the computation in generic form x ** 2 is surely not an hack and the computation performed is the same (I checked with cpython source code). I actually find it more readable (and readability counts). Using instead x ** 0.5 to take the square root doesn't do the exact same computations as math.sqrt as the former (probably) is computed using logarithms and the latter (probably) using the specific numeric instruction of the math processor. I often use x ** 0.5 simply because I don't want to add math just for that. I'd expect however a specific instruction for the square root to work better (more accurately) than a multi-step operation with logarithms."}]}, {"link": "https://stackoverflow.com/questions/19255120/is-there-a-short-hand-for-nth-root-of-x-in-python", "question": {"id": "19255120", "title": "Is there a short-hand for nth root of x in Python?", "content": "<p>In maths, if I wish to calculate 3 to the power of 2 then no symbol is required, but I write the 2 small: <code>3\u00b2</code>. In Python this operation seems to be represented by the <code>**</code> syntax.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 3**2\n9\n</code></pre>\n<p>If I want to go the other direction and calculate the 2nd root of 9 then in maths I need to use a symbol: <code>2\u221a9 = 3</code></p>\n<p>Is there a short-hand symbol in Python, similar to <code>**</code> that achieves this i.e. <code>2&lt;symbol&gt;9</code>? Or do I need to use the <code>math</code> module?</p>\n", "abstract": "In maths, if I wish to calculate 3 to the power of 2 then no symbol is required, but I write the 2 small: 3\u00b2. In Python this operation seems to be represented by the ** syntax. If I want to go the other direction and calculate the 2nd root of 9 then in maths I need to use a symbol: 2\u221a9 = 3 Is there a short-hand symbol in Python, similar to ** that achieves this i.e. 2<symbol>9? Or do I need to use the math module?"}, "answers": [{"id": 19255188, "score": 107, "vote": 0, "content": "<p>nth root of <code>x</code> is <code>x^(1/n)</code>, so you can do <code>9**(1/2)</code> to find the 2nd root of 9, for example. In general, you can compute the nth root of x as:</p>\n<pre><code class=\"python\">x**(1/n)\n</code></pre>\n<p><strong>Note</strong>: In Python 2, you had to do <code>1/float(n)</code> or <code>1.0/n</code> so that the result would be a <code>float</code> rather than an <code>int</code>. For more details, see <a href=\"https://stackoverflow.com/questions/9595135/why-does-python-give-the-wrong-answer-for-square-root\">Why does Python give the \"wrong\" answer for square root?</a></p>\n", "abstract": "nth root of x is x^(1/n), so you can do 9**(1/2) to find the 2nd root of 9, for example. In general, you can compute the nth root of x as: Note: In Python 2, you had to do 1/float(n) or 1.0/n so that the result would be a float rather than an int. For more details, see Why does Python give the \"wrong\" answer for square root?"}, {"id": 56400152, "score": 10, "vote": 0, "content": "<p>You may also use some logarithms:</p>\n<p>Nth root of <code>x</code>:</p>\n<pre><code class=\"python\">exp(log(x)/n)\n</code></pre>\n<p>For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from math import exp, log\n&gt;&gt;&gt; x = 8\n&gt;&gt;&gt; n = 3\n&gt;&gt;&gt; exp(log(x)/n)\n2.0\n</code></pre>\n", "abstract": "You may also use some logarithms: Nth root of x: For example:"}, {"id": 19255238, "score": 5, "vote": 0, "content": "<p>Also: <code>x**(n**-1)</code>, which is the same but shorter than <code>x**(1/float(n))</code></p>\n", "abstract": "Also: x**(n**-1), which is the same but shorter than x**(1/float(n))"}, {"id": 19255394, "score": 5, "vote": 0, "content": "<p>If you prefer to apply this operation functionally rather than with an infix operator (the <code>**</code> symbol), you can pass the base and exponent as arguments to the <code>pow</code> function:</p>\n<pre><code class=\"python\">In [23]: (9**(0.5)) == pow(9, 0.5)\nOut[23]: True\n</code></pre>\n<p>I am also fond of finding new uses for <a href=\"http://code.activestate.com/recipes/384122/\" rel=\"noreferrer\">this Infix hack in Python</a> although it's more of a fun aside than a heavy-duty solution. But you could effectively make your own personal symbol for this by doing the following:</p>\n<pre><code class=\"python\">class Infix:\n    def __init__(self, function):\n        self.function = function\n    def __ror__(self, other):\n        return Infix(lambda x, self=self, other=other: self.function(other, x))\n    def __or__(self, other):\n        return self.function(other)\n    def __rlshift__(self, other):\n        return Infix(lambda x, self=self, other=other: self.function(other, x))\n    def __rshift__(self, other):\n        return self.function(other)\n    def __call__(self, value1, value2):\n        return self.function(value1, value2)\n\n\nroot_of = Infix(lambda x,y: y**(1.0/x))\n\nprint 2 |root_of| 9\n3.0\n</code></pre>\n", "abstract": "If you prefer to apply this operation functionally rather than with an infix operator (the ** symbol), you can pass the base and exponent as arguments to the pow function: I am also fond of finding new uses for this Infix hack in Python although it's more of a fun aside than a heavy-duty solution. But you could effectively make your own personal symbol for this by doing the following:"}, {"id": 19255202, "score": 3, "vote": 0, "content": "<p>There is. It's just <code>**</code> =)</p>\n<p>Any nth root is an exponentiation by <code>1/n</code>, so to get the square root of 9, you use <code>9**(1/2)</code> (or <code>9**0.5</code>) to get the cube root, you use <code>9 ** (1/3)</code> (which we can't write with a simpler fraction), and to get the nth root, <code>9 ** (1/n)</code>.</p>\n<p>Also note that as of Python 3, adding periods to integers to make them a float is no longer necessary. Saying <code>1/3</code> works the way you would actually expect it to, giving <code>0.333...</code> as result, rather than zero. For legacy versions of Python, you'll have to remember to use that period (but also critically wonder why you're using a legacy version of a programming language)</p>\n", "abstract": "There is. It's just ** =) Any nth root is an exponentiation by 1/n, so to get the square root of 9, you use 9**(1/2) (or 9**0.5) to get the cube root, you use 9 ** (1/3) (which we can't write with a simpler fraction), and to get the nth root, 9 ** (1/n). Also note that as of Python 3, adding periods to integers to make them a float is no longer necessary. Saying 1/3 works the way you would actually expect it to, giving 0.333... as result, rather than zero. For legacy versions of Python, you'll have to remember to use that period (but also critically wonder why you're using a legacy version of a programming language)"}, {"id": 19255199, "score": 2, "vote": 0, "content": "<p>Basically sqrt(9) is equivalent to 9^.5<br/></p>\n<pre><code class=\"python\">&gt;&gt;&gt;9**.5\n3.0\n</code></pre>\n", "abstract": "Basically sqrt(9) is equivalent to 9^.5"}, {"id": 19255268, "score": 2, "vote": 0, "content": "<p>You should do </p>\n<pre><code class=\"python\">16**(0.5) #If you print it, you get 4, So you can use this formula.\n</code></pre>\n", "abstract": "You should do "}, {"id": 51629805, "score": 2, "vote": 0, "content": "<pre><code class=\"python\">def nthrootofm(a,n):\n    return pow(a,(1/n))\na=81\nn=4\nq=nthrootofm(a,n)\nprint(q)\n</code></pre>\n<p>pow() function takes two parameters . </p>\n", "abstract": "pow() function takes two parameters . "}]}, {"link": "https://stackoverflow.com/questions/28077733/numpy-sin-function-in-degrees", "question": {"id": "28077733", "title": "numpy.sin function in degrees?", "content": "<p>I'm working on a problem that has to do with calculating angles of refraction and what not. However, it seems that I'm unable to use the numpy.sin() function in degrees. I have tried to use numpy.degrees() and numpy.rad2deg().</p>\n<pre><code class=\"python\">numpy.sin(90)\n\nnumpy.degrees(numpy.sin(90))\n</code></pre>\n<p>Both return ~ 0.894 and ~ 51.2 respectively.</p>\n<p>Thanks for your help.</p>\n", "abstract": "I'm working on a problem that has to do with calculating angles of refraction and what not. However, it seems that I'm unable to use the numpy.sin() function in degrees. I have tried to use numpy.degrees() and numpy.rad2deg(). Both return ~ 0.894 and ~ 51.2 respectively. Thanks for your help."}, "answers": [{"id": 28077771, "score": 88, "vote": 0, "content": "<p>You don't want to convert <em>to</em> degrees, because you already have your number (90) in degrees.  You need to convert 90 <em>from</em> degrees to radians, and you need to do it <em>before</em> you take the sine:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; np.sin(np.deg2rad(90))\n1.0\n</code></pre>\n<p>(You can use either <code>deg2rad</code> or <code>radians</code>.)</p>\n", "abstract": "You don't want to convert to degrees, because you already have your number (90) in degrees.  You need to convert 90 from degrees to radians, and you need to do it before you take the sine: (You can use either deg2rad or radians.)"}, {"id": 28077914, "score": 19, "vote": 0, "content": "<p>Use the <code>math</code> module from the standard Python library:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; math.sin(math.radians(90))\n</code></pre>\n", "abstract": "Use the math module from the standard Python library:"}, {"id": 70908297, "score": 2, "vote": 0, "content": "<p>You can define the following symbols to work in degrees:</p>\n<pre><code class=\"python\">sind = lambda degrees: np.sin(np.deg2rad(degrees))\ncosd = lambda degrees: np.cos(np.deg2rad(degrees))\nprint(sind(90)) # Output 1.0\n</code></pre>\n", "abstract": "You can define the following symbols to work in degrees:"}]}, {"link": "https://stackoverflow.com/questions/34372480/rotate-point-about-another-point-in-degrees-python", "question": {"id": "34372480", "title": "Rotate point about another point in degrees python", "content": "<p>If you had a point (in 2d), how could you rotate that point by degrees around the other point (the origin) in python?</p>\n<p>You might, for example, tilt the first point around the origin by 10 degrees.</p>\n<p>Basically you have one point PointA and origin that it rotates around.\nThe code could look something like this:</p>\n<pre><code class=\"python\">PointA=(200,300)\norigin=(100,100)\n\nNewPointA=rotate(origin,PointA,10) #The rotate function rotates it by 10 degrees\n</code></pre>\n", "abstract": "If you had a point (in 2d), how could you rotate that point by degrees around the other point (the origin) in python? You might, for example, tilt the first point around the origin by 10 degrees. Basically you have one point PointA and origin that it rotates around.\nThe code could look something like this:"}, "answers": [{"id": 34374437, "score": 116, "vote": 0, "content": "<p>The following <code>rotate</code> function performs a rotation of the point <code>point</code> by the angle <code>angle</code> (counterclockwise, in radians) around <code>origin</code>, in the Cartesian plane, with the usual axis conventions: x increasing from left to right, y increasing vertically upwards. All points are represented as length-2 tuples of the form <code>(x_coord, y_coord)</code>.</p>\n<pre><code class=\"python\">import math\n\ndef rotate(origin, point, angle):\n    \"\"\"\n    Rotate a point counterclockwise by a given angle around a given origin.\n\n    The angle should be given in radians.\n    \"\"\"\n    ox, oy = origin\n    px, py = point\n\n    qx = ox + math.cos(angle) * (px - ox) - math.sin(angle) * (py - oy)\n    qy = oy + math.sin(angle) * (px - ox) + math.cos(angle) * (py - oy)\n    return qx, qy\n</code></pre>\n<p>If your angle is specified in degrees, you can convert it to radians first using <code>math.radians</code>. For a clockwise rotation, negate the angle.</p>\n<p>Example: rotating the point <code>(3, 4)</code> around an origin of <code>(2, 2)</code> counterclockwise by an angle of 10 degrees:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; point = (3, 4)\n&gt;&gt;&gt; origin = (2, 2)\n&gt;&gt;&gt; rotate(origin, point, math.radians(10))\n(2.6375113976783475, 4.143263683691346)\n</code></pre>\n<p>Note that there's some obvious repeated calculation in the <code>rotate</code> function: <code>math.cos(angle)</code> and <code>math.sin(angle)</code> are each computed twice, as are <code>px - ox</code> and <code>py - oy</code>. I leave it to you to factor that out if necessary.</p>\n", "abstract": "The following rotate function performs a rotation of the point point by the angle angle (counterclockwise, in radians) around origin, in the Cartesian plane, with the usual axis conventions: x increasing from left to right, y increasing vertically upwards. All points are represented as length-2 tuples of the form (x_coord, y_coord). If your angle is specified in degrees, you can convert it to radians first using math.radians. For a clockwise rotation, negate the angle. Example: rotating the point (3, 4) around an origin of (2, 2) counterclockwise by an angle of 10 degrees: Note that there's some obvious repeated calculation in the rotate function: math.cos(angle) and math.sin(angle) are each computed twice, as are px - ox and py - oy. I leave it to you to factor that out if necessary."}, {"id": 58781388, "score": 39, "vote": 0, "content": "<p>An option to rotate a point by some degrees about another point is to use <code>numpy</code> instead of <code>math</code>. This allows to easily generalize the function to take any number of points as input, which might e.g. be useful when rotating a polygon.</p>\n<pre><code class=\"python\">import numpy as np\n\ndef rotate(p, origin=(0, 0), degrees=0):\n    angle = np.deg2rad(degrees)\n    R = np.array([[np.cos(angle), -np.sin(angle)],\n                  [np.sin(angle),  np.cos(angle)]])\n    o = np.atleast_2d(origin)\n    p = np.atleast_2d(p)\n    return np.squeeze((R @ (p.T-o.T) + o.T).T)\n\n\npoints=[(200, 300), (100, 300)]\norigin=(100,100)\n\nnew_points = rotate(points, origin=origin, degrees=10)\nprint(new_points)\n</code></pre>\n", "abstract": "An option to rotate a point by some degrees about another point is to use numpy instead of math. This allows to easily generalize the function to take any number of points as input, which might e.g. be useful when rotating a polygon."}, {"id": 51127723, "score": 8, "vote": 0, "content": "<pre><code class=\"python\">import math\n\ndef rotate(x,y,xo,yo,theta): #rotate x,y around xo,yo by theta (rad)\n    xr=math.cos(theta)*(x-xo)-math.sin(theta)*(y-yo)   + xo\n    yr=math.sin(theta)*(x-xo)+math.cos(theta)*(y-yo)  + yo\n    return [xr,yr]\n</code></pre>\n", "abstract": ""}, {"id": 62004641, "score": 5, "vote": 0, "content": "<p>After going through a lot of code and repositories. This function worked best for me. Also it is efficient as it calculates sine and cosine values only once.</p>\n<pre><code class=\"python\">import numpy as np\ndef rotate(point, origin, degrees):\n    radians = np.deg2rad(degrees)\n    x,y = point\n    offset_x, offset_y = origin\n    adjusted_x = (x - offset_x)\n    adjusted_y = (y - offset_y)\n    cos_rad = np.cos(radians)\n    sin_rad = np.sin(radians)\n    qx = offset_x + cos_rad * adjusted_x + sin_rad * adjusted_y\n    qy = offset_y + -sin_rad * adjusted_x + cos_rad * adjusted_y\n    return qx, qy\n</code></pre>\n", "abstract": "After going through a lot of code and repositories. This function worked best for me. Also it is efficient as it calculates sine and cosine values only once."}, {"id": 67764548, "score": 4, "vote": 0, "content": "<p>This is easy if you represent your points as complex numbers and use the exp function with an imaginary argument (which is equivalent to the cos/sin operations shown in the other answers, but is easier to write and remember). Here's a function that rotates any number of points about the chosen origin:</p>\n<pre><code class=\"python\">import numpy as np\n\ndef rotate(points, origin, angle):\n    return (points - origin) * np.exp(complex(0, angle)) + origin\n</code></pre>\n<p>To rotate a single point (x1,y1) about the origin (x0,y0) with an angle in degrees, you could call the function with these arguments:</p>\n<pre><code class=\"python\">points = complex(x1,y1)\norigin = complex(x0,y0)\nangle = np.deg2rad(degrees)\n</code></pre>\n<p>To rotate multiple points (x1,y1), (x2,y2), ..., use:</p>\n<pre><code class=\"python\">points = np.array([complex(x1,y1), complex(x2,y2), ...])\n</code></pre>\n<p>An example with a single point (200,300) rotated 10 degrees about (100,100):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; new_point = rotate(complex(200,300), complex(100,100), np.deg2rad(10))\n&gt;&gt;&gt; new_point\n(163.75113976783473+314.3263683691346j)\n&gt;&gt;&gt; (new_point.real, new_point.imag)\n(163.75113976783473, 314.3263683691346)\n</code></pre>\n", "abstract": "This is easy if you represent your points as complex numbers and use the exp function with an imaginary argument (which is equivalent to the cos/sin operations shown in the other answers, but is easier to write and remember). Here's a function that rotates any number of points about the chosen origin: To rotate a single point (x1,y1) about the origin (x0,y0) with an angle in degrees, you could call the function with these arguments: To rotate multiple points (x1,y1), (x2,y2), ..., use: An example with a single point (200,300) rotated 10 degrees about (100,100):"}]}, {"link": "https://stackoverflow.com/questions/877479/whats-the-simplest-way-to-extend-a-numpy-array-in-2-dimensions", "question": {"id": "877479", "title": "What&#39;s the simplest way to extend a numpy array in 2 dimensions?", "content": "<p>I have a 2d array that looks like this:</p>\n<pre><code class=\"python\">XX\nxx\n</code></pre>\n<p>What's the most efficient way to add an extra row and column:</p>\n<pre><code class=\"python\">xxy\nxxy\nyyy\n</code></pre>\n<p>For bonus points, I'd like to also be able to knock out single rows and columns, so for example in the matrix below I'd like to be able to knock out all of the a's leaving only the x's - specifically I'm trying to delete the nth row and the nth column at the same time - and I want to be able to do this as quickly as possible:</p>\n<pre><code class=\"python\">xxaxx\nxxaxx\naaaaa\nxxaxx\nxxaxx\n</code></pre>\n", "abstract": "I have a 2d array that looks like this: What's the most efficient way to add an extra row and column: For bonus points, I'd like to also be able to knock out single rows and columns, so for example in the matrix below I'd like to be able to knock out all of the a's leaving only the x's - specifically I'm trying to delete the nth row and the nth column at the same time - and I want to be able to do this as quickly as possible:"}, "answers": [{"id": 877564, "score": 66, "vote": 0, "content": "<p>The shortest in terms of lines of code i can think of is for the first question.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; p = np.array([[1,2],[3,4]])\n\n&gt;&gt;&gt; p = np.append(p, [[5,6]], 0)\n&gt;&gt;&gt; p = np.append(p, [[7],[8],[9]],1)\n\n&gt;&gt;&gt; p\narray([[1, 2, 7],\n   [3, 4, 8],\n   [5, 6, 9]])\n</code></pre>\n<p>And the for the second question</p>\n<pre><code class=\"python\">    p = np.array(range(20))\n&gt;&gt;&gt; p.shape = (4,5)\n&gt;&gt;&gt; p\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14],\n       [15, 16, 17, 18, 19]])\n&gt;&gt;&gt; n = 2\n&gt;&gt;&gt; p = np.append(p[:n],p[n+1:],0)\n&gt;&gt;&gt; p = np.append(p[...,:n],p[...,n+1:],1)\n&gt;&gt;&gt; p\narray([[ 0,  1,  3,  4],\n       [ 5,  6,  8,  9],\n       [15, 16, 18, 19]])\n</code></pre>\n", "abstract": "The shortest in terms of lines of code i can think of is for the first question. And the for the second question"}, {"id": 5650582, "score": 43, "vote": 0, "content": "<p><strong>A useful alternative answer to the first question, using the examples from</strong> tomeedee\u2019s <strong>answer, would be to use numpy\u2019s</strong> vstack <strong>and</strong> column_stack <strong>methods:</strong></p>\n<p>Given a matrix p,</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; p = np.array([ [1,2] , [3,4] ])\n</code></pre>\n<p>an augmented matrix can be generated by:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = np.vstack( [ p , [5 , 6] ] )\n&gt;&gt;&gt; p = np.column_stack( [ p , [ 7 , 8 , 9 ] ] )\n&gt;&gt;&gt; p\narray([[1, 2, 7],\n       [3, 4, 8],\n       [5, 6, 9]])\n</code></pre>\n<p>These methods may be convenient in practice than np.append() as they allow 1D arrays to be appended to a matrix without any modification, in contrast to the following scenario:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = np.array([ [ 1 , 2 ] , [ 3 , 4 ] , [ 5 , 6 ] ] )\n&gt;&gt;&gt; p = np.append( p , [ 7 , 8 , 9 ] , 1 )\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\", line 3234, in append\n    return concatenate((arr, values), axis=axis)\nValueError: arrays must have same number of dimensions\n</code></pre>\n<p><strong>In answer to the second question, a nice way to remove rows and columns is to use logical array indexing as follows:</strong></p>\n<p>Given a matrix p,</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = np.arange( 20 ).reshape( ( 4 , 5 ) )\n</code></pre>\n<p>suppose we want to remove row 1 and column 2:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; r , c = 1 , 2\n&gt;&gt;&gt; p = p [ np.arange( p.shape[0] ) != r , : ] \n&gt;&gt;&gt; p = p [ : , np.arange( p.shape[1] ) != c ]\n&gt;&gt;&gt; p\narray([[ 0,  1,  3,  4],\n       [10, 11, 13, 14],\n       [15, 16, 18, 19]])\n</code></pre>\n<p>Note - for reformed Matlab users - if you wanted to do these in a one-liner you need to index twice:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = np.arange( 20 ).reshape( ( 4 , 5 ) )    \n&gt;&gt;&gt; p = p [ np.arange( p.shape[0] ) != r , : ] [ : , np.arange( p.shape[1] ) != c ]\n</code></pre>\n<p>This technique can also be extended to remove <em>sets</em> of rows and columns, so if we wanted to remove rows 0 &amp; 2 and columns 1, 2 &amp; 3 we could use numpy's <strong>setdiff1d</strong> function to generate the desired logical index:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = np.arange( 20 ).reshape( ( 4 , 5 ) )\n&gt;&gt;&gt; r = [ 0 , 2 ]\n&gt;&gt;&gt; c = [ 1 , 2 , 3 ]\n&gt;&gt;&gt; p = p [ np.setdiff1d( np.arange( p.shape[0] ), r ) , : ] \n&gt;&gt;&gt; p = p [ : , np.setdiff1d( np.arange( p.shape[1] ) , c ) ]\n&gt;&gt;&gt; p\narray([[ 5,  9],\n       [15, 19]])\n</code></pre>\n", "abstract": "A useful alternative answer to the first question, using the examples from tomeedee\u2019s answer, would be to use numpy\u2019s vstack and column_stack methods: Given a matrix p, an augmented matrix can be generated by: These methods may be convenient in practice than np.append() as they allow 1D arrays to be appended to a matrix without any modification, in contrast to the following scenario: In answer to the second question, a nice way to remove rows and columns is to use logical array indexing as follows: Given a matrix p, suppose we want to remove row 1 and column 2: Note - for reformed Matlab users - if you wanted to do these in a one-liner you need to index twice: This technique can also be extended to remove sets of rows and columns, so if we wanted to remove rows 0 & 2 and columns 1, 2 & 3 we could use numpy's setdiff1d function to generate the desired logical index:"}, {"id": 18207897, "score": 8, "vote": 0, "content": "<p>Another elegant solution to the <strong>first question</strong> may be the <code>insert</code> command:</p>\n<pre><code class=\"python\">p = np.array([[1,2],[3,4]])\np = np.insert(p, 2, values=0, axis=1) # insert values before column 2\n</code></pre>\n<p>Leads to:</p>\n<pre><code class=\"python\">array([[1, 2, 0],\n       [3, 4, 0]])\n</code></pre>\n<p><code>insert</code> may be slower than <code>append</code> but allows you to fill the whole row/column with one value easily.</p>\n<p>As for the <strong>second question</strong>, <code>delete</code> has been suggested before:</p>\n<pre><code class=\"python\">p = np.delete(p, 2, axis=1)\n</code></pre>\n<p>Which restores the original array again:</p>\n<pre><code class=\"python\">array([[1, 2],\n       [3, 4]])\n</code></pre>\n", "abstract": "Another elegant solution to the first question may be the insert command: Leads to: insert may be slower than append but allows you to fill the whole row/column with one value easily. As for the second question, delete has been suggested before: Which restores the original array again:"}, {"id": 32546514, "score": 7, "vote": 0, "content": "<p>You can use: </p>\n<pre><code class=\"python\">&gt;&gt;&gt; np.concatenate([array1, array2, ...]) \n</code></pre>\n<p>e.g.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; a = [[1, 2, 3],[10, 20, 30]]\n&gt;&gt;&gt; b = [[100,200,300]]\n&gt;&gt;&gt; a = np.array(a) # not necessary, but numpy objects prefered to built-in\n&gt;&gt;&gt; b = np.array(b) # \"^\n&gt;&gt;&gt; a\narray([[ 1,  2,  3],\n       [10, 20, 30]])\n&gt;&gt;&gt; b\narray([[100, 200, 300]])\n&gt;&gt;&gt; c = np.concatenate([a,b])\n&gt;&gt;&gt; c\narray([[  1,   2,   3],\n       [ 10,  20,  30],\n       [100, 200, 300]])\n&gt;&gt;&gt; print c\n[[  1   2   3]\n [ 10  20  30]\n [100 200 300]]\n</code></pre>\n<p>~-+-~-+-~-+-~ </p>\n<p>Sometimes, you will come across trouble if a numpy array object is initialized with incomplete values for its shape property. This problem is fixed by assigning to the shape property the tuple: (array_length, element_length).</p>\n<p>Note: Here, 'array_length' and 'element_length' are integer parameters, which you substitute values in for. A 'tuple' is just a pair of numbers in parentheses.</p>\n<p>e.g.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; a = np.array([[1,2,3],[10,20,30]])\n&gt;&gt;&gt; b = np.array([100,200,300]) # initialize b with incorrect dimensions\n&gt;&gt;&gt; a.shape\n(2, 3)\n&gt;&gt;&gt; b.shape\n(3,)\n&gt;&gt;&gt; c = np.concatenate([a,b])\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#191&gt;\", line 1, in &lt;module&gt;\n    c = np.concatenate([a,b])\nValueError: all the input arrays must have same number of dimensions\n&gt;&gt;&gt; b.shape = (1,3)\n&gt;&gt;&gt; c = np.concatenate([a,b])\n&gt;&gt;&gt; c\narray([[  1,   2,   3],\n       [ 10,  20,  30],\n       [100, 200, 300]])\n</code></pre>\n", "abstract": "You can use:  e.g. ~-+-~-+-~-+-~  Sometimes, you will come across trouble if a numpy array object is initialized with incomplete values for its shape property. This problem is fixed by assigning to the shape property the tuple: (array_length, element_length). Note: Here, 'array_length' and 'element_length' are integer parameters, which you substitute values in for. A 'tuple' is just a pair of numbers in parentheses. e.g."}, {"id": 14139115, "score": 6, "vote": 0, "content": "<p>I find it much easier to \"extend\" via assigning in a bigger matrix. E.g.</p>\n<pre><code class=\"python\">import numpy as np\np = np.array([[1,2], [3,4]])\ng = np.array(range(20))\ng.shape = (4,5)\ng[0:2, 0:2] = p\n</code></pre>\n<p>Here are the arrays:</p>\n<p><code>p</code></p>\n<pre><code class=\"python\">   array([[1, 2],\n       [3, 4]])\n</code></pre>\n<p><code>g</code>:</p>\n<pre><code class=\"python\">array([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14],\n       [15, 16, 17, 18, 19]])\n</code></pre>\n<p>and the resulting <code>g</code> after assignment:</p>\n<pre><code class=\"python\">   array([[ 1,  2,  2,  3,  4],\n       [ 3,  4,  7,  8,  9],\n       [10, 11, 12, 13, 14],\n       [15, 16, 17, 18, 19]])\n</code></pre>\n", "abstract": "I find it much easier to \"extend\" via assigning in a bigger matrix. E.g. Here are the arrays: p g: and the resulting g after assignment:"}, {"id": 66439166, "score": 3, "vote": 0, "content": "<p>If you want a constant value in the new positions, you can use <code>np.pad</code>.</p>\n<p><a href=\"https://numpy.org/doc/stable/reference/generated/numpy.pad.html\" rel=\"nofollow noreferrer\">https://numpy.org/doc/stable/reference/generated/numpy.pad.html</a></p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = np.array([[1,2],[3,4]])\n&gt;&gt;&gt; np.pad(p, ((0,1),(0,1))) # Lengthen each dimension by 1.\narray([[1, 2, 0],\n       [3, 4, 0],\n       [0, 0, 0]])\n</code></pre>\n", "abstract": "If you want a constant value in the new positions, you can use np.pad. https://numpy.org/doc/stable/reference/generated/numpy.pad.html"}, {"id": 7096433, "score": 2, "vote": 0, "content": "<p>Answer to the first question:</p>\n<p>Use numpy.append.</p>\n<p><a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.append.html#numpy.append\" rel=\"nofollow\">http://docs.scipy.org/doc/numpy/reference/generated/numpy.append.html#numpy.append</a></p>\n<p>Answer to the second question:</p>\n<p>Use numpy.delete</p>\n<p><a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.delete.html\" rel=\"nofollow\">http://docs.scipy.org/doc/numpy/reference/generated/numpy.delete.html</a></p>\n", "abstract": "Answer to the first question: Use numpy.append. http://docs.scipy.org/doc/numpy/reference/generated/numpy.append.html#numpy.append Answer to the second question: Use numpy.delete http://docs.scipy.org/doc/numpy/reference/generated/numpy.delete.html"}, {"id": 17301073, "score": 0, "vote": 0, "content": "<p>maybe you need this.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = np.array([11,22])\n&gt;&gt;&gt; y = np.array([18,7,6])\n&gt;&gt;&gt; z = np.array([1,3,5])\n&gt;&gt;&gt; np.concatenate((x,y,z))\narray([11, 22, 18,  7,  6,  1,  3,  5])\n</code></pre>\n", "abstract": "maybe you need this."}]}, {"link": "https://stackoverflow.com/questions/4237914/python-max-min-builtin-functions-depend-on-parameter-order", "question": {"id": "4237914", "title": "Python: max/min builtin functions depend on parameter order", "content": "<p><code>max(float('nan'), 1)</code> evaluates to nan</p>\n<p><code>max(1, float('nan'))</code> evaluates to 1</p>\n<p>Is it the intended behavior?</p>\n<hr/>\n<p>Thanks for the answers.</p>\n<p><code>max</code> raises an exception when the iterable is empty. Why wouldn't Python's <code>max</code> raise an exception when <code>nan</code> is present? Or at least do something useful, like return <code>nan</code> or ignore <code>nan</code>. The current behavior is very unsafe and seems completely unreasonable.</p>\n<p>I found an even more surprising consequence of this behavior, so I just posted a <a href=\"https://stackoverflow.com/questions/4240050/python-sort-function-breaks-in-the-presence-of-nan\">related question</a>.</p>\n", "abstract": "max(float('nan'), 1) evaluates to nan max(1, float('nan')) evaluates to 1 Is it the intended behavior? Thanks for the answers. max raises an exception when the iterable is empty. Why wouldn't Python's max raise an exception when nan is present? Or at least do something useful, like return nan or ignore nan. The current behavior is very unsafe and seems completely unreasonable. I found an even more surprising consequence of this behavior, so I just posted a related question."}, "answers": [{"id": 4237993, "score": 49, "vote": 0, "content": "<pre><code class=\"python\">In [19]: 1&gt;float('nan')\nOut[19]: False\n\nIn [20]: float('nan')&gt;1\nOut[20]: False\n</code></pre>\n<p>The float <code>nan</code> is neither bigger nor smaller than the integer <code>1</code>.\n<code>max</code> starts by choosing the first element, and only replaces it when it finds an element which is strictly larger.</p>\n<pre><code class=\"python\">In [31]: max(1,float('nan'))\nOut[31]: 1\n</code></pre>\n<p>Since <code>nan</code> is not larger than 1, 1 is returned.</p>\n<pre><code class=\"python\">In [32]: max(float('nan'),1)\nOut[32]: nan\n</code></pre>\n<p>Since 1 is not larger than <code>nan</code>, <code>nan</code> is returned.</p>\n<hr/>\n<p>PS. Note that <code>np.max</code> treats <code>float('nan')</code> differently:</p>\n<pre><code class=\"python\">In [36]: import numpy as np\nIn [91]: np.max([1,float('nan')])\nOut[91]: nan\n\nIn [92]: np.max([float('nan'),1])\nOut[92]: nan\n</code></pre>\n<p>but if you wish to ignore <code>np.nan</code>s, you can use <code>np.nanmax</code>:</p>\n<pre><code class=\"python\">In [93]: np.nanmax([1,float('nan')])\nOut[93]: 1.0\n\nIn [94]: np.nanmax([float('nan'),1])\nOut[94]: 1.0\n</code></pre>\n", "abstract": "The float nan is neither bigger nor smaller than the integer 1.\nmax starts by choosing the first element, and only replaces it when it finds an element which is strictly larger. Since nan is not larger than 1, 1 is returned. Since 1 is not larger than nan, nan is returned. PS. Note that np.max treats float('nan') differently: but if you wish to ignore np.nans, you can use np.nanmax:"}, {"id": 4237981, "score": 9, "vote": 0, "content": "<p>I haven't seen this before, but it makes sense. Notice that <code>nan</code> is a very weird object:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = float('nan')\n&gt;&gt;&gt; x == x\nFalse\n&gt;&gt;&gt; x &gt; 1\nFalse\n&gt;&gt;&gt; x &lt; 1\nFalse\n</code></pre>\n<p>I would say that the behaviour of <code>max</code> is undefined in this case -- what answer would you expect? The only sensible behaviour is to assume that the operations are antisymmetric.</p>\n<hr/>\n<p>Notice that you can reproduce this behaviour by making a broken class:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class Broken(object):\n...     __le__ = __ge__ = __eq__ = __lt__ = __gt__ = __ne__ =\n...     lambda self, other: False\n...\n&gt;&gt;&gt; x = Broken()\n&gt;&gt;&gt; x == x\nFalse\n&gt;&gt;&gt; x &lt; 1\nFalse\n&gt;&gt;&gt; x &gt; 1\nFalse\n&gt;&gt;&gt; max(x, 1)\n&lt;__main__.Broken object at 0x024B5B50&gt;\n&gt;&gt;&gt; max(1, x)\n1\n</code></pre>\n", "abstract": "I haven't seen this before, but it makes sense. Notice that nan is a very weird object: I would say that the behaviour of max is undefined in this case -- what answer would you expect? The only sensible behaviour is to assume that the operations are antisymmetric. Notice that you can reproduce this behaviour by making a broken class:"}, {"id": 4238038, "score": 1, "vote": 0, "content": "<p>Max works the following way:</p>\n<p>The first item is set as maxval and then the next is compared to this value. The comparation will always return False:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; float('nan') &lt; 1\nFalse\n&gt;&gt;&gt; float('nan') &gt; 1\nFalse\n</code></pre>\n<p>So if the first value is nan, then (since the comparation returns false) it will not be replaced upon the next step.</p>\n<p>OTOH if 1 is the first, the same happens: but in this case, since 1 was set, it will be the maximum.</p>\n<p>You can verify this in the python code, just look up the function min_max in Python/bltinmodule.c</p>\n", "abstract": "Max works the following way: The first item is set as maxval and then the next is compared to this value. The comparation will always return False: So if the first value is nan, then (since the comparation returns false) it will not be replaced upon the next step. OTOH if 1 is the first, the same happens: but in this case, since 1 was set, it will be the maximum. You can verify this in the python code, just look up the function min_max in Python/bltinmodule.c"}]}, {"link": "https://stackoverflow.com/questions/5246856/how-did-python-implement-the-built-in-function-pow", "question": {"id": "5246856", "title": "How did Python implement the built-in function pow()?", "content": "<p>I have to write a program to calculate <code>a**b % c</code> where <code>b</code> and <code>c</code> are both very large numbers. If I just use <code>a**b % c</code>, it's really slow. Then I found that the built-in function <code>pow()</code> can do this really fast by calling <code>pow(a, b, c)</code>.<br/>\n I'm curious to know how does Python implement this? Or where could I find the source code file that implement this function?</p>\n", "abstract": "I have to write a program to calculate a**b % c where b and c are both very large numbers. If I just use a**b % c, it's really slow. Then I found that the built-in function pow() can do this really fast by calling pow(a, b, c).\n I'm curious to know how does Python implement this? Or where could I find the source code file that implement this function?"}, "answers": [{"id": 5246975, "score": 48, "vote": 0, "content": "<p>If <code>a</code>, <code>b</code> and <code>c</code> are integers, the implementation can be made more efficient by <a href=\"http://en.wikipedia.org/wiki/Exponentiation_by_squaring\" rel=\"noreferrer\">binary exponentiation</a> and reducing modulo <code>c</code> in each step, including the first one (i.e. reducing <code>a</code> modulo <code>c</code> before you even start).  This is what <a href=\"https://github.com/python/cpython/blob/109fc2792a490ee5cd8a423e17d415fbdedec5c8/Objects/longobject.c#L4244-L4447\" rel=\"noreferrer\">the implementation of <code>long_pow()</code></a> does indeed. The function has over two hundred lines of code, as it has to deal with reference counting, and it handles negative exponents and a whole bunch of special cases.</p>\n<p>At its core, the idea of the algorithm is rather simple, though. Let's say we want to compute <code>a ** b</code> for positive integers <code>a</code> and <code>b</code>, and <code>b</code> has the binary digits <code>b_i</code>. Then we can write <code>b</code> as</p>\n<pre><code class=\"python\">b = b_0 + b1 * 2 + b2 * 2**2 + ... + b_k ** 2**k\n</code></pre>\n<p>ans <code>a ** b</code> as</p>\n<pre><code class=\"python\">a ** b = a**b0 * (a**2)**b1 * (a**2**2)**b2 * ... * (a**2**k)**b_k\n</code></pre>\n<p>Each factor in this product is of the form <code>(a**2**i)**b_i</code>. If <code>b_i</code> is zero, we can simply omit the factor. If <code>b_i</code> is 1, the factor is equal to <code>a**2**i</code>, and these powers can be computed for all <code>i</code> by repeatedly squaring <code>a</code>. Overall, we need to square and multiply <code>k</code> times, where <code>k</code> is the number of binary digits of <code>b</code>.</p>\n<p>As mentioned above, for <code>pow(a, b, c)</code> we can reduce modulo <code>c</code> in each step, both after squaring and after multiplying.</p>\n", "abstract": "If a, b and c are integers, the implementation can be made more efficient by binary exponentiation and reducing modulo c in each step, including the first one (i.e. reducing a modulo c before you even start).  This is what the implementation of long_pow() does indeed. The function has over two hundred lines of code, as it has to deal with reference counting, and it handles negative exponents and a whole bunch of special cases. At its core, the idea of the algorithm is rather simple, though. Let's say we want to compute a ** b for positive integers a and b, and b has the binary digits b_i. Then we can write b as ans a ** b as Each factor in this product is of the form (a**2**i)**b_i. If b_i is zero, we can simply omit the factor. If b_i is 1, the factor is equal to a**2**i, and these powers can be computed for all i by repeatedly squaring a. Overall, we need to square and multiply k times, where k is the number of binary digits of b. As mentioned above, for pow(a, b, c) we can reduce modulo c in each step, both after squaring and after multiplying."}, {"id": 10539256, "score": 39, "vote": 0, "content": "<p>You might consider the following two implementations for computing <code>(x ** y) % z</code> quickly.</p>\n<p><strong>In Python:</strong></p>\n<pre><code class=\"python\">def pow_mod(x, y, z):\n    \"Calculate (x ** y) % z efficiently.\"\n    number = 1\n    while y:\n        if y &amp; 1:\n            number = number * x % z\n        y &gt;&gt;= 1\n        x = x * x % z\n    return number\n</code></pre>\n<p><strong>In C:</strong></p>\n<pre><code class=\"python\">#include &lt;stdio.h&gt;\n\nunsigned long pow_mod(unsigned short x, unsigned long y, unsigned short z)\n{\n    unsigned long number = 1;\n    while (y)\n    {\n        if (y &amp; 1)\n            number = number * x % z;\n        y &gt;&gt;= 1;\n        x = (unsigned long)x * x % z;\n    }\n    return number;\n}\n\nint main()\n{\n    printf(\"%d\\n\", pow_mod(63437, 3935969939, 20628));\n    return 0;\n}\n</code></pre>\n", "abstract": "You might consider the following two implementations for computing (x ** y) % z quickly. In Python: In C:"}, {"id": 5246968, "score": 1, "vote": 0, "content": "<p>I don't know about python, but if you need fast powers, you can use exponentiation by squaring:</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Exponentiation_by_squaring\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Exponentiation_by_squaring</a></p>\n<p>It's a simple recursive method that uses the commutative property of exponents.</p>\n", "abstract": "I don't know about python, but if you need fast powers, you can use exponentiation by squaring: http://en.wikipedia.org/wiki/Exponentiation_by_squaring It's a simple recursive method that uses the commutative property of exponents."}, {"id": 5246963, "score": 0, "vote": 0, "content": "<p>Python uses C math libraries for general cases and its own logic for some of its concepts (such as infinity).</p>\n", "abstract": "Python uses C math libraries for general cases and its own logic for some of its concepts (such as infinity)."}, {"id": 5246964, "score": 0, "vote": 0, "content": "<p>Line 1426 of <a href=\"http://svn.python.org/view/python/trunk/Modules/mathmodule.c?revision=82221&amp;view=markup\" rel=\"nofollow\">this file</a> shows the Python code that implements math.pow, but basically it boils down to it calling the standard C library which probably has a highly optimized version of that function.</p>\n<p>Python can be quite slow for intensive number-crunching, but <a href=\"http://psyco.sourceforge.net/\" rel=\"nofollow\">Psyco</a> can give you a quite speed boost, it won't be as good as C code calling the standard library though.</p>\n", "abstract": "Line 1426 of this file shows the Python code that implements math.pow, but basically it boils down to it calling the standard C library which probably has a highly optimized version of that function. Python can be quite slow for intensive number-crunching, but Psyco can give you a quite speed boost, it won't be as good as C code calling the standard library though."}, {"id": 51304848, "score": 0, "vote": 0, "content": "<p><strong>Implement pow(x,n) in Python</strong></p>\n<pre><code class=\"python\">def myPow(x, n):\n        p = 1\n        if n&lt;0:\n            x = 1/x\n            n = abs(n)\n\n        # Exponentiation by Squaring\n\n        while n:\n            if n%2:\n                p*= x\n            x*=x\n            n//=2\n        return p\n</code></pre>\n<p><strong>Implement pow(x,n,m) in Python</strong></p>\n<pre><code class=\"python\">def myPow(x,n,m):\n            p = 1\n            if n&lt;0:\n                x = 1/x\n                n = abs(n)\n            while n:\n                if n%2:\n                    p*= x%m\n                x*=x%m\n                n//=2\n            return p\n</code></pre>\n<p>Checkout this <a href=\"https://www.youtube.com/watch?v=-3Lt-EwR_Hw\" rel=\"nofollow noreferrer\">link</a> for explanation  </p>\n", "abstract": "Implement pow(x,n) in Python Implement pow(x,n,m) in Python Checkout this link for explanation  "}]}, {"link": "https://stackoverflow.com/questions/15686318/why-do-not-a-number-values-equal-true-when-cast-as-boolean-in-python-numpy", "question": {"id": "15686318", "title": "Why do &quot;Not a Number&quot; values equal True when cast as boolean in Python/Numpy?", "content": "<p>When casting a NumPy Not-a-Number value as a boolean, it becomes True, e.g. as follows.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; bool(np.nan)\nTrue\n</code></pre>\n<p>This is the exact opposite to what I would intuitively expect. Is there a sound principle underlying this behaviour?</p>\n<p>(I suspect there might be as the same behaviour seems to occur in Octave.)</p>\n", "abstract": "When casting a NumPy Not-a-Number value as a boolean, it becomes True, e.g. as follows. This is the exact opposite to what I would intuitively expect. Is there a sound principle underlying this behaviour? (I suspect there might be as the same behaviour seems to occur in Octave.)"}, "answers": [{"id": 15686477, "score": 38, "vote": 0, "content": "<p>This is in no way NumPy-specific, but is consistent with how Python treats NaNs:</p>\n<pre><code class=\"python\">In [1]: bool(float('nan'))\nOut[1]: True\n</code></pre>\n<p>The rules are spelled out in the <a href=\"http://docs.python.org/2/library/stdtypes.html#truth-value-testing\">documentation</a>.</p>\n<p>I think it could be reasonably argued that the truth value of NaN should be False. However, this is not how the language works right now.</p>\n", "abstract": "This is in no way NumPy-specific, but is consistent with how Python treats NaNs: The rules are spelled out in the documentation. I think it could be reasonably argued that the truth value of NaN should be False. However, this is not how the language works right now."}, {"id": 15686433, "score": 8, "vote": 0, "content": "<p>Python <a href=\"http://docs.python.org/2/library/stdtypes.html#truth-value-testing\" rel=\"noreferrer\">truth-value testing</a> states that the following values are considered <code>False</code>:</p>\n<blockquote>\n<ul>\n<li>zero of any numeric type, for example, 0, 0L, 0.0, 0j.</li>\n</ul>\n</blockquote>\n<p>Numpy probably chose to stick with this behaviour and prevent NaN from evaluating to <code>False</code> in a boolean context. Note however that you can use <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.isnan.html\" rel=\"noreferrer\"><code>numpy.isnan</code></a> to test for NaN.</p>\n", "abstract": "Python truth-value testing states that the following values are considered False: Numpy probably chose to stick with this behaviour and prevent NaN from evaluating to False in a boolean context. Note however that you can use numpy.isnan to test for NaN."}, {"id": 15686370, "score": 3, "vote": 0, "content": "<p><code>0.0</code> is the only falsy float value because that's what the language designers decided would be most useful.  Numpy simply follows along.  (It would be weird to have <code>bool(np.nan)</code> be <code>False</code> when <code>bool(float('nan'))</code> is <code>True</code>).  </p>\n<p>I think it is probably because that's how things work with integers.  Admittedly, integers have no NaN or inf types of values, but I suppose that special cases aren't special enough to break the rules.</p>\n", "abstract": "0.0 is the only falsy float value because that's what the language designers decided would be most useful.  Numpy simply follows along.  (It would be weird to have bool(np.nan) be False when bool(float('nan')) is True).   I think it is probably because that's how things work with integers.  Admittedly, integers have no NaN or inf types of values, but I suppose that special cases aren't special enough to break the rules."}, {"id": 15686472, "score": 2, "vote": 0, "content": "<p>Numpy follows the <a href=\"http://docs.python.org/2/library/stdtypes.html#truth-value-testing\" rel=\"nofollow\">python standard for truth testing</a> here, any numeric type evaluates to <code>False</code> if and only if its numerical value is zero.</p>\n<p>Note that truth testing with <code>NaN</code> values can be unintuitive in other ways as well (e.g., <code>nan == nan</code> evaluates to <code>False</code>).</p>\n", "abstract": "Numpy follows the python standard for truth testing here, any numeric type evaluates to False if and only if its numerical value is zero. Note that truth testing with NaN values can be unintuitive in other ways as well (e.g., nan == nan evaluates to False)."}, {"id": 71660081, "score": 0, "vote": 0, "content": "<p>This is usually needed when testing variables for <code>np.nan</code>. While <code>np.nan is not np.nan</code> fails (evaluates to <code>False</code>), the <code>np.isnan</code> function works  (evaluates to <code>True</code>, so can be used to test for <code>np.nan</code>):</p>\n<p><code>np.isnan(np.nan)</code></p>\n<blockquote>\n<p>True</p>\n</blockquote>\n", "abstract": "This is usually needed when testing variables for np.nan. While np.nan is not np.nan fails (evaluates to False), the np.isnan function works  (evaluates to True, so can be used to test for np.nan): np.isnan(np.nan) True"}]}, {"link": "https://stackoverflow.com/questions/9685946/math-operations-from-string", "question": {"id": "9685946", "title": "Math operations from string", "content": "<p>Let's say I have a standard Python string (such as one obtained from <code>raw_input()</code>), maybe <code>\"2 + 2\"</code> for simplicity's sake. </p>\n<p>I'd like to convert this string to standard math operations in Python, such that <code>\"2 + 2\"</code> would return <code>4</code>. </p>\n<p>Is there an easy way to do this, or would I have to split on the spaces and parse each number/symbol manually, then do the math based on what I find? </p>\n<p>Do I want Regex?</p>\n", "abstract": "Let's say I have a standard Python string (such as one obtained from raw_input()), maybe \"2 + 2\" for simplicity's sake.  I'd like to convert this string to standard math operations in Python, such that \"2 + 2\" would return 4.  Is there an easy way to do this, or would I have to split on the spaces and parse each number/symbol manually, then do the math based on what I find?  Do I want Regex?"}, "answers": [{"id": 9686074, "score": 93, "vote": 0, "content": "<p><strong>Warning: this way is not a safe way, but is very easy to use. Use it wisely.</strong></p>\n<p>Use the eval function.</p>\n<pre><code class=\"python\">print eval('2 + 4')\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">6\n</code></pre>\n<p>You can even use variables or regular python code.</p>\n<pre><code class=\"python\">a = 5\nprint eval('a + 4')\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">9\n</code></pre>\n<p>You also can get return values:</p>\n<pre><code class=\"python\">d = eval('4 + 5')\nprint d\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">9\n</code></pre>\n<p>Or call functions:</p>\n<pre><code class=\"python\">def add(a, b):\n    return a + b\n\ndef subtract(a, b):\n    return a - b\n\na = 20\nb = 10    \nprint eval('add(a, b)')\nprint eval('subtract(a, b)')\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">30\n10\n</code></pre>\n<p>In case you want to write a parser, maybe instead you can built a python code generator if that is easier and use eval to run the code. With eval you can execute any Python evalution.</p>\n<p><strong>Why eval is unsafe?</strong></p>\n<p>Since you can put literally anything in the eval, e.g. if the input argument is:</p>\n<pre><code class=\"python\">os.system(\u2018rm -rf /\u2019)\n</code></pre>\n<p>It will remove all files on your system (at least on Linux/Unix).\nSo only use eval when you trust the input.</p>\n", "abstract": "Warning: this way is not a safe way, but is very easy to use. Use it wisely. Use the eval function. Output: You can even use variables or regular python code. Output: You also can get return values: Output: Or call functions: Output: In case you want to write a parser, maybe instead you can built a python code generator if that is easier and use eval to run the code. With eval you can execute any Python evalution. Why eval is unsafe? Since you can put literally anything in the eval, e.g. if the input argument is: It will remove all files on your system (at least on Linux/Unix).\nSo only use eval when you trust the input."}, {"id": 9686094, "score": 10, "vote": 0, "content": "<p>Regex won't help much. First of all, you will want to take into account the operators precedence, and second, you need to work with parentheses which is impossible with regex. </p>\n<p>Depending on what exactly kind of expression you need to parse, you may try either Python <a href=\"http://docs.python.org/library/ast.html\">AST</a> or (more likely) <a href=\"http://pyparsing.wikispaces.com/\">pyparsing</a>.\nBut, first of all, I'd recommend to read something about <a href=\"http://en.wikipedia.org/wiki/Parsing\">syntax analysis</a> in general and the <a href=\"http://en.wikipedia.org/wiki/Shunting-yard_algorithm\">Shunting yard algorithm</a> in particular.</p>\n<p>And fight the temptation of using <code>eval</code>, that's not safe.</p>\n", "abstract": "Regex won't help much. First of all, you will want to take into account the operators precedence, and second, you need to work with parentheses which is impossible with regex.  Depending on what exactly kind of expression you need to parse, you may try either Python AST or (more likely) pyparsing.\nBut, first of all, I'd recommend to read something about syntax analysis in general and the Shunting yard algorithm in particular. And fight the temptation of using eval, that's not safe."}, {"id": 38405478, "score": 10, "vote": 0, "content": "<p>You could use this function which is doing the same as the <code>eval()</code> function, but in a simple manner, using a function.</p>\n<pre><code class=\"python\">def numeric(equation):\n    if '+' in equation:\n        y = equation.split('+')\n        x = int(y[0])+int(y[1])\n    elif '-' in equation:\n        y = equation.split('-')\n        x = int(y[0])-int(y[1])\n    return x\n</code></pre>\n", "abstract": "You could use this function which is doing the same as the eval() function, but in a simple manner, using a function."}, {"id": 9686076, "score": 8, "vote": 0, "content": "<p>The easiest way is to use <code>eval</code> as in:</p>\n<pre><code class=\"python\"> &gt;&gt;&gt; eval(\"2   +    2\")\n 4\n</code></pre>\n<p>Pay attention to the fact I included spaces in the string. <code>eval</code> will execute a string as if it was a Python code, so if you want the input to be in a syntax other than Python, you should parse the string yourself and calculate, for example <code>eval(\"2x7\")</code> would not give you 14 because Python uses <code>*</code> for multiplication operator rather than <code>x</code>. </p>\n", "abstract": "The easiest way is to use eval as in: Pay attention to the fact I included spaces in the string. eval will execute a string as if it was a Python code, so if you want the input to be in a syntax other than Python, you should parse the string yourself and calculate, for example eval(\"2x7\") would not give you 14 because Python uses * for multiplication operator rather than x. "}, {"id": 9687393, "score": 6, "vote": 0, "content": "<p>If you want to do it safely, you may want to use <a href=\"http://docs.python.org/library/ast.html#ast.literal_eval\" rel=\"nofollow noreferrer\">http://docs.python.org/library/ast.html#ast.literal_eval</a></p>\n<p>from this answer:\n<a href=\"https://stackoverflow.com/questions/4388626/python-safe-eval-string-to-bool-int-float-none-string\">Python \"safe\" eval (string to bool/int/float/None/string)</a></p>\n<p>It might not do math, but you could parse the math operators and then operate on safely evaluated terms.</p>\n", "abstract": "If you want to do it safely, you may want to use http://docs.python.org/library/ast.html#ast.literal_eval from this answer:\nPython \"safe\" eval (string to bool/int/float/None/string) It might not do math, but you could parse the math operators and then operate on safely evaluated terms."}, {"id": 9686238, "score": 4, "vote": 0, "content": "<p>A simple way but dangerous way to do this would be to use <code>eval()</code>. <code>eval()</code> executes the string passed to it as code. The dangerous thing about this is that if this string is gained from user input, they could maliciously execute code that could break the computer. I would get the input, check it with a regex, and then execute it if you determine if it's OK. If it's only going to be in the format \"number operation number\", then you could use a simple regex:</p>\n<pre><code class=\"python\">import re\ns = raw_input('What is your math problem? ')\nif re.findall('\\d+? *?\\+ *?\\d+?', s):\n  print eval(s)\nelse:\n  print \"Try entering a math problem\"\n</code></pre>\n<p>Otherwise, you would have to come up with something a bit stricter than this. You could also do it conversely, using a regex to find if certain things are not in it, such as numbers and operations. Also you could check to see if the input contains certain commands.</p>\n", "abstract": "A simple way but dangerous way to do this would be to use eval(). eval() executes the string passed to it as code. The dangerous thing about this is that if this string is gained from user input, they could maliciously execute code that could break the computer. I would get the input, check it with a regex, and then execute it if you determine if it's OK. If it's only going to be in the format \"number operation number\", then you could use a simple regex: Otherwise, you would have to come up with something a bit stricter than this. You could also do it conversely, using a regex to find if certain things are not in it, such as numbers and operations. Also you could check to see if the input contains certain commands."}, {"id": 9686696, "score": 4, "vote": 0, "content": "<p>The asker commented:</p>\n<blockquote>\n<p>I figure that if I understand a problem well enough to write a program that can figure it out, I don't need to do the work manually.</p>\n</blockquote>\n<p>If he's writing a math expression solver as a learning exercise, using <code>eval()</code> isn't going to help.  Plus it's terrible design.</p>\n<p>You might consider making a calculator using <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\" rel=\"noreferrer\">Reverse Polish Notation</a> instead of standard math notation.  It simplifies the parsing considerably.  It would still be a good exercise</p>\n", "abstract": "The asker commented: I figure that if I understand a problem well enough to write a program that can figure it out, I don't need to do the work manually. If he's writing a math expression solver as a learning exercise, using eval() isn't going to help.  Plus it's terrible design. You might consider making a calculator using Reverse Polish Notation instead of standard math notation.  It simplifies the parsing considerably.  It would still be a good exercise"}, {"id": 25169146, "score": 2, "vote": 0, "content": "<p>The best way would be to do:</p>\n<p><code>print eval(\"2 + 2\")</code></p>\n<p>If you wanted to you could use a variable:</p>\n<p><code>addition = eval(\"2 + 2\")\n print addition</code></p>\n<p>If you really wanted to, you could use a function:</p>\n<p><code>def add(num1, num2):\n     eval(\"num1 + num2\")</code></p>\n", "abstract": "The best way would be to do: print eval(\"2 + 2\") If you wanted to you could use a variable: addition = eval(\"2 + 2\")\n print addition If you really wanted to, you could use a function: def add(num1, num2):\n     eval(\"num1 + num2\")"}]}, {"link": "https://stackoverflow.com/questions/2922532/obtain-latitude-and-longitude-from-a-geotiff-file", "question": {"id": "2922532", "title": "Obtain Latitude and Longitude from a GeoTIFF File", "content": "<p>Using GDAL in Python, how do you get the latitude and longitude of a GeoTIFF file?</p>\n<p>GeoTIFF's do not appear to store any coordinate information.  Instead, they store the XY Origin coordinates.  However, the XY coordinates do not provide the latitude and longitude of the top left corner and bottom left corner.</p>\n<p>It appears I will need to do some math to solve this problem, but I don't have a clue on where to start.</p>\n<p>What procedure is required to have this performed?</p>\n<p>I know that the <code>GetGeoTransform()</code> method is important for this, however, I don't know what to do with it from there.</p>\n", "abstract": "Using GDAL in Python, how do you get the latitude and longitude of a GeoTIFF file? GeoTIFF's do not appear to store any coordinate information.  Instead, they store the XY Origin coordinates.  However, the XY coordinates do not provide the latitude and longitude of the top left corner and bottom left corner. It appears I will need to do some math to solve this problem, but I don't have a clue on where to start. What procedure is required to have this performed? I know that the GetGeoTransform() method is important for this, however, I don't know what to do with it from there."}, "answers": [{"id": 2926097, "score": 102, "vote": 0, "content": "<p>To get the coordinates of the corners of your geotiff do the following:</p>\n<pre><code class=\"python\">from osgeo import gdal\nds = gdal.Open('path/to/file')\nwidth = ds.RasterXSize\nheight = ds.RasterYSize\ngt = ds.GetGeoTransform()\nminx = gt[0]\nminy = gt[3] + width*gt[4] + height*gt[5] \nmaxx = gt[0] + width*gt[1] + height*gt[2]\nmaxy = gt[3] \n</code></pre>\n<p>However, these might not be in latitude/longitude format.  As Justin noted, your geotiff will be stored with some kind of coordinate system.  If you don't know what coordinate system it is, you can find out by running <code>gdalinfo</code>:</p>\n<pre><code class=\"python\">gdalinfo ~/somedir/somefile.tif \n</code></pre>\n<p>Which outputs:</p>\n<pre><code class=\"python\">Driver: GTiff/GeoTIFF\nSize is 512, 512\nCoordinate System is:\nPROJCS[\"NAD27 / UTM zone 11N\",\n    GEOGCS[\"NAD27\",\n        DATUM[\"North_American_Datum_1927\",\n            SPHEROID[\"Clarke 1866\",6378206.4,294.978698213901]],\n        PRIMEM[\"Greenwich\",0],\n        UNIT[\"degree\",0.0174532925199433]],\n    PROJECTION[\"Transverse_Mercator\"],\n    PARAMETER[\"latitude_of_origin\",0],\n    PARAMETER[\"central_meridian\",-117],\n    PARAMETER[\"scale_factor\",0.9996],\n    PARAMETER[\"false_easting\",500000],\n    PARAMETER[\"false_northing\",0],\n    UNIT[\"metre\",1]]\nOrigin = (440720.000000,3751320.000000)\nPixel Size = (60.000000,-60.000000)\nCorner Coordinates:\nUpper Left  (  440720.000, 3751320.000) (117d38'28.21\"W, 33d54'8.47\"N)\nLower Left  (  440720.000, 3720600.000) (117d38'20.79\"W, 33d37'31.04\"N)\nUpper Right (  471440.000, 3751320.000) (117d18'32.07\"W, 33d54'13.08\"N)\nLower Right (  471440.000, 3720600.000) (117d18'28.50\"W, 33d37'35.61\"N)\nCenter      (  456080.000, 3735960.000) (117d28'27.39\"W, 33d45'52.46\"N)\nBand 1 Block=512x16 Type=Byte, ColorInterp=Gray\n</code></pre>\n<p>This output may be all you need.  If you want to do this programmaticly in python however, this is how you get the same info.</p>\n<p>If the coordinate system is a <code>PROJCS</code> like the example above you are dealing with a projected coordinate system.  A projected coordiante system is a <a href=\"http://en.wikipedia.org/wiki/Map_projection\" rel=\"noreferrer\">representation of the spheroidal earth's surface, but flattened and distorted onto a plane</a>.  If you want the latitude and longitude, you need to convert the coordinates to the geographic coordinate system that you want.</p>\n<p>Sadly, not all latitude/longitude pairs are created equal, being based upon different spheroidal models of the earth. In this example, I am converting to <a href=\"http://en.wikipedia.org/wiki/World_Geodetic_System\" rel=\"noreferrer\">WGS84</a>, the geographic coordinate system favoured in GPSs and used by all the popular web mapping sites.  The coordinate system is defined by a well defined string.  A catalogue of them is available from <a href=\"http://spatialreference.org/\" rel=\"noreferrer\">spatial ref</a>, see for example <a href=\"http://spatialreference.org/ref/epsg/4326/\" rel=\"noreferrer\">WGS84</a>.</p>\n<pre><code class=\"python\">from osgeo import osr, gdal\n\n# get the existing coordinate system\nds = gdal.Open('path/to/file')\nold_cs= osr.SpatialReference()\nold_cs.ImportFromWkt(ds.GetProjectionRef())\n\n# create the new coordinate system\nwgs84_wkt = \"\"\"\nGEOGCS[\"WGS 84\",\n    DATUM[\"WGS_1984\",\n        SPHEROID[\"WGS 84\",6378137,298.257223563,\n            AUTHORITY[\"EPSG\",\"7030\"]],\n        AUTHORITY[\"EPSG\",\"6326\"]],\n    PRIMEM[\"Greenwich\",0,\n        AUTHORITY[\"EPSG\",\"8901\"]],\n    UNIT[\"degree\",0.01745329251994328,\n        AUTHORITY[\"EPSG\",\"9122\"]],\n    AUTHORITY[\"EPSG\",\"4326\"]]\"\"\"\nnew_cs = osr.SpatialReference()\nnew_cs .ImportFromWkt(wgs84_wkt)\n\n# create a transform object to convert between coordinate systems\ntransform = osr.CoordinateTransformation(old_cs,new_cs) \n\n#get the point to transform, pixel (0,0) in this case\nwidth = ds.RasterXSize\nheight = ds.RasterYSize\ngt = ds.GetGeoTransform()\nminx = gt[0]\nminy = gt[3] + width*gt[4] + height*gt[5] \n\n#get the coordinates in lat long\nlatlong = transform.TransformPoint(minx,miny) \n</code></pre>\n<p>Hopefully this will do what you want.</p>\n", "abstract": "To get the coordinates of the corners of your geotiff do the following: However, these might not be in latitude/longitude format.  As Justin noted, your geotiff will be stored with some kind of coordinate system.  If you don't know what coordinate system it is, you can find out by running gdalinfo: Which outputs: This output may be all you need.  If you want to do this programmaticly in python however, this is how you get the same info. If the coordinate system is a PROJCS like the example above you are dealing with a projected coordinate system.  A projected coordiante system is a representation of the spheroidal earth's surface, but flattened and distorted onto a plane.  If you want the latitude and longitude, you need to convert the coordinates to the geographic coordinate system that you want. Sadly, not all latitude/longitude pairs are created equal, being based upon different spheroidal models of the earth. In this example, I am converting to WGS84, the geographic coordinate system favoured in GPSs and used by all the popular web mapping sites.  The coordinate system is defined by a well defined string.  A catalogue of them is available from spatial ref, see for example WGS84. Hopefully this will do what you want."}, {"id": 2923066, "score": 19, "vote": 0, "content": "<p>I don't know if this is a full answer, but <a href=\"http://home.gdal.org/~warmerda/gdal_opendap_design.html\" rel=\"noreferrer\">this site</a> says:</p>\n<blockquote>\n<p>The x/y map dimensions are called easting and northing. For datasets in a geographic coordinate system these would hold the longitude and latitude. For projected coordinate systems they would normally be the easting and northing in the projected coordinate system. For ungeoreferenced images the easting and northing would just be the pixel/line offsets of each pixel (as implied by a unity geotransform).</p>\n</blockquote>\n<p>so they may actually be longitude and latitude.</p>\n", "abstract": "I don't know if this is a full answer, but this site says: The x/y map dimensions are called easting and northing. For datasets in a geographic coordinate system these would hold the longitude and latitude. For projected coordinate systems they would normally be the easting and northing in the projected coordinate system. For ungeoreferenced images the easting and northing would just be the pixel/line offsets of each pixel (as implied by a unity geotransform). so they may actually be longitude and latitude."}]}, {"link": "https://stackoverflow.com/questions/6745464/inverse-cosine-in-python", "question": {"id": "6745464", "title": "Inverse Cosine in Python", "content": "<p>Apologies if this is straight forward, but I have not found any help in the python manual or google.</p>\n<p>I am trying to find the inverse cosine for a value using python.</p>\n<p>i.e. cos\u207b\u00b9(x)</p>\n<p>Does anyone know how to do this?</p>\n<p>Thanks</p>\n", "abstract": "Apologies if this is straight forward, but I have not found any help in the python manual or google. I am trying to find the inverse cosine for a value using python. i.e. cos\u207b\u00b9(x) Does anyone know how to do this? Thanks"}, "answers": [{"id": 6745479, "score": 70, "vote": 0, "content": "<p>We have the <a href=\"http://docs.python.org/library/math.html#math.acos\" rel=\"noreferrer\"><code>acos</code> function</a>, which returns the angle in radians.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.acos(0)\n1.5707963267948966\n&gt;&gt;&gt; _ * 2 - math.pi\n0.0\n</code></pre>\n", "abstract": "We have the acos function, which returns the angle in radians."}, {"id": 6746308, "score": 9, "vote": 0, "content": "<p>To augment the correct answers to use <code>math.acos</code>, it is also worth knowing that there are math functions suitable for complex numbers in <code>cmath</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import cmath\n&gt;&gt;&gt; cmath.acos(1j)\n(1.5707963267948966-0.88137358701954294j)\n</code></pre>\n<p>Stick with <code>math.acos</code> if you're only interested in real numbers, </p>\n", "abstract": "To augment the correct answers to use math.acos, it is also worth knowing that there are math functions suitable for complex numbers in cmath: Stick with math.acos if you're only interested in real numbers, "}, {"id": 57241954, "score": 8, "vote": 0, "content": "<p>The result of <code>math.acos()</code> is in radians. So you need to convert that to degrees.</p>\n<p>Here is how you can do:</p>\n<pre><code class=\"python\">import math\nres = math.degrees (math.acos (value))\n</code></pre>\n", "abstract": "The result of math.acos() is in radians. So you need to convert that to degrees. Here is how you can do:"}, {"id": 32549077, "score": 5, "vote": 0, "content": "<p>In response to using inverse cosine to find return angles via math.acos,  it's all fine and dandy so long as the angle is &lt;=90*  once you go past that, python will have no way of differentiating which angle you wanted.</p>\n<p>Observe. </p>\n<pre><code class=\"python\">&gt;&gt;&gt; math.cos(5)\n0.28366218546322625\n</code></pre>\n<p>Above, I asked python to fetch me the cosine of a 5 radian angle, and it gave me .28~ Great, below I'll ask python to give me the radian which has a .28~ cosine. Should be 5, right? It literally just told me it was.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; math.acos(0.28366218546322625)\n1.2831853071795865\n</code></pre>\n<p>Wrong! Python returns 1.28~ radians. The reason is obvious when plotted visually, 1.28rad has the same cosine as 5rad, they're inverse angles. Every angle shares the same sine with another angle (and -sine with two others).\ni.e. 5/175* share an equivalent sine. They share inversely proportional cosines .99~/-.99 respectively.  Their -sine cousins would be 185 and 355.  The relationship meme here is that all these angles share the same angular deflection from the horizontal axis. 5*.</p>\n<p>The reason python returns 1.28 and not 5 is that all computers/calculators are based on an abacus-like data table of an angle/radian, its sine, cos, tan etc etc.  So when i math.acos(x), python asks the kernal to look through that data table for whichever angle has a cosine of x, and when it finds it, it returns the first entry it appears with. and then python gives that angle to me.</p>\n<p>Due to this shared, proportional symmetry, sin/cos ratios repeat frequently. And you are likely to see the same figure, multiple times. There's no way for python, or the OS, to determine the difference of which of the two angles you actually require without doing additional logic that takes into account the -/+ value of the angle's sine.  Or, the angle's tangent.</p>\n<pre><code class=\"python\">1.28 Rad has  x cosine, y sine, z tan  (72*)\n1.88 Rad has -x cosine, y sine, -z tan (108*)\n4.39 Rad has -x cosine, -y sine, z tan (252*)\n   5 Rad has  x cosine, -y sine, -z tan (288*)\n</code></pre>\n<p>or, viewed Cartesianly,</p>\n<pre><code class=\"python\">                       negX,posY | posX,posY\n                            -----+-----\n                       negX,negY |  posX,negY\n\n1.88 Rad has -x cosine, y sine (108) | 1.28 Rad has  x cosine, y sine (72*)\n                                -----+-----\n4.39 Rad has -x cosine, -y sine (252)|    5 Rad has  x cosine, -y sine (288)\n</code></pre>\n<p>So if, for whatever reason, i need 5 radians to be chosen (say for a vector drawing or game to determine the various vectors enemies are from the player), i would have to do some type of if/then logic comparing the sines/tangents.</p>\n", "abstract": "In response to using inverse cosine to find return angles via math.acos,  it's all fine and dandy so long as the angle is <=90*  once you go past that, python will have no way of differentiating which angle you wanted. Observe.  Above, I asked python to fetch me the cosine of a 5 radian angle, and it gave me .28~ Great, below I'll ask python to give me the radian which has a .28~ cosine. Should be 5, right? It literally just told me it was. Wrong! Python returns 1.28~ radians. The reason is obvious when plotted visually, 1.28rad has the same cosine as 5rad, they're inverse angles. Every angle shares the same sine with another angle (and -sine with two others).\ni.e. 5/175* share an equivalent sine. They share inversely proportional cosines .99~/-.99 respectively.  Their -sine cousins would be 185 and 355.  The relationship meme here is that all these angles share the same angular deflection from the horizontal axis. 5*. The reason python returns 1.28 and not 5 is that all computers/calculators are based on an abacus-like data table of an angle/radian, its sine, cos, tan etc etc.  So when i math.acos(x), python asks the kernal to look through that data table for whichever angle has a cosine of x, and when it finds it, it returns the first entry it appears with. and then python gives that angle to me. Due to this shared, proportional symmetry, sin/cos ratios repeat frequently. And you are likely to see the same figure, multiple times. There's no way for python, or the OS, to determine the difference of which of the two angles you actually require without doing additional logic that takes into account the -/+ value of the angle's sine.  Or, the angle's tangent. or, viewed Cartesianly, So if, for whatever reason, i need 5 radians to be chosen (say for a vector drawing or game to determine the various vectors enemies are from the player), i would have to do some type of if/then logic comparing the sines/tangents."}, {"id": 6745509, "score": 3, "vote": 0, "content": "<p>You're looking for the <code>math.acos()</code> function.</p>\n", "abstract": "You're looking for the math.acos() function."}, {"id": 50638127, "score": 1, "vote": 0, "content": "<p>You may also use <code>arccos</code> from the module <code>numpy</code></p>\n<pre><code class=\"python\">&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; numpy.arccos(0.5)\n1.0471975511965979\n</code></pre>\n<p><strong>WARNING</strong>: For scalars the <code>numpy.arccos()</code> function is much slower (~ 10x) than <code>math.acos</code>.  <a href=\"https://stackoverflow.com/questions/35183787/in-python-is-math-acos-faster-than-numpy-arccos-for-scalars\">See post here</a></p>\n<p>Nevertheless, the <code>numpy.arccos()</code> is suitable for sequences, while <code>math.acos</code> is not. :)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; numpy.arccos([0.5, 0.3])\narray([ 1.04719755,  1.26610367])\n</code></pre>\n<p>but</p>\n<pre><code class=\"python\">&gt;&gt;&gt; math.acos([0.5, 0.3])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: a float is required\n</code></pre>\n", "abstract": "You may also use arccos from the module numpy WARNING: For scalars the numpy.arccos() function is much slower (~ 10x) than math.acos.  See post here Nevertheless, the numpy.arccos() is suitable for sequences, while math.acos is not. :) but"}, {"id": 6745542, "score": -4, "vote": 0, "content": "<p>or just write a function of your own for the <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" rel=\"nofollow\">taylor expansion</a> of cos^{-1}</p>\n<p>this would be more time consuming (and maybe slower to run) but is the more general approach</p>\n", "abstract": "or just write a function of your own for the taylor expansion of cos^{-1} this would be more time consuming (and maybe slower to run) but is the more general approach"}]}, {"link": "https://stackoverflow.com/questions/3420937/algorithm-to-find-which-number-in-a-list-sum-up-to-a-certain-number", "question": {"id": "3420937", "title": "Algorithm to find which number in a list sum up to a certain number", "content": "<p>I have a list of numbers. I also have a certain sum. The sum is made from a few numbers from my list (I may/may not know how many numbers it's made from). Is there a fast algorithm to get a list of possible numbers? Written in Python would be great, but pseudo-code's good too. (I can't yet read anything other than Python :P )</p>\n<p>Example</p>\n<pre><code class=\"python\">list = [1,2,3,10]\nsum = 12\nresult = [2,10]\n</code></pre>\n<p><strong>NOTE:</strong> I do know of <a href=\"https://stackoverflow.com/questions/83547/algorithm-to-find-which-numbers-from-a-list-of-size-n-sum-to-another-number\">Algorithm to find which numbers from a list of size n sum to another number</a> (but I cannot read C# and I'm unable to check if it works for my needs. I'm on Linux and I tried using Mono but I get errors and I can't figure out how to work C# :(<br/>\n<em>AND</em> I do know of <a href=\"https://stackoverflow.com/questions/403865\">algorithm to sum up a list of numbers for all combinations</a> (but it seems to be fairly inefficient. I don't need all combinations.)</p>\n", "abstract": "I have a list of numbers. I also have a certain sum. The sum is made from a few numbers from my list (I may/may not know how many numbers it's made from). Is there a fast algorithm to get a list of possible numbers? Written in Python would be great, but pseudo-code's good too. (I can't yet read anything other than Python :P ) Example NOTE: I do know of Algorithm to find which numbers from a list of size n sum to another number (but I cannot read C# and I'm unable to check if it works for my needs. I'm on Linux and I tried using Mono but I get errors and I can't figure out how to work C# :(\nAND I do know of algorithm to sum up a list of numbers for all combinations (but it seems to be fairly inefficient. I don't need all combinations.)"}, "answers": [{"id": 3421173, "score": 65, "vote": 0, "content": "<p>This problem reduces to the <a href=\"http://en.wikipedia.org/wiki/Knapsack_problem\" rel=\"noreferrer\">0-1 Knapsack Problem</a>, where you are trying to find a set with an exact sum. The solution depends on the constraints, in the general case this problem is NP-Complete.</p>\n<p>However, if the maximum search sum (let's call it <code>S</code>) is not too high, then you can solve the problem using dynamic programming. I will explain it using a recursive function and <a href=\"http://en.wikipedia.org/wiki/Memoization\" rel=\"noreferrer\">memoization</a>, which is easier to understand than a bottom-up approach.</p>\n<p>Let's code a function <code>f(v, i, S)</code>, such that it returns the number of subsets in <code>v[i:]</code> that sums exactly to <code>S</code>. To solve it recursively, first we have to analyze the base (i.e.: <code>v[i:]</code> is empty):</p>\n<ul>\n<li><p>S == 0: The only subset of <code>[]</code> has sum 0, so it is a valid subset. Because of this, the function should return 1.</p></li>\n<li><p>S != 0: As the only subset of <code>[]</code> has sum 0, there is not a valid subset. Because of this, the function should return 0.</p></li>\n</ul>\n<p>Then, let's analyze the recursive case (i.e.: <code>v[i:]</code> is not empty). There are two choices: include the number <code>v[i]</code> in the current subset, or not include it. If we include <code>v[i]</code>, then we are looking subsets that have sum <code>S - v[i]</code>, otherwise, we are still looking for subsets with sum <code>S</code>. The function <code>f</code> might be implemented in the following way:</p>\n<pre><code class=\"python\">def f(v, i, S):\n  if i &gt;= len(v): return 1 if S == 0 else 0\n  count = f(v, i + 1, S)\n  count += f(v, i + 1, S - v[i])\n  return count\n\nv = [1, 2, 3, 10]\nsum = 12\nprint(f(v, 0, sum))\n</code></pre>\n<p>By checking <code>f(v, 0, S) &gt; 0</code>, you can know if there is a solution to your problem. However, this code is too slow, each recursive call spawns two new calls, which leads to an O(2^n) algorithm. Now, we can apply <a href=\"http://en.wikipedia.org/wiki/Memoization\" rel=\"noreferrer\">memoization</a> to make it run in time O(n*S), which is faster if <code>S</code> is not too big:</p>\n<pre><code class=\"python\">def f(v, i, S, memo):\n  if i &gt;= len(v): return 1 if S == 0 else 0\n  if (i, S) not in memo:  # &lt;-- Check if value has not been calculated.\n    count = f(v, i + 1, S, memo)\n    count += f(v, i + 1, S - v[i], memo)\n    memo[(i, S)] = count  # &lt;-- Memoize calculated result.\n  return memo[(i, S)]     # &lt;-- Return memoized value.\n\nv = [1, 2, 3, 10]\nsum = 12\nmemo = dict()\nprint(f(v, 0, sum, memo))\n</code></pre>\n<p>Now, it is possible to code a function <code>g</code> that returns one subset that sums <code>S</code>. To do this, it is enough to add elements only if there is at least one solution including them:</p>\n<pre><code class=\"python\">def f(v, i, S, memo):\n  # ... same as before ...\n\ndef g(v, S, memo):\n  subset = []\n  for i, x in enumerate(v):\n    # Check if there is still a solution if we include v[i]\n    if f(v, i + 1, S - x, memo) &gt; 0:\n      subset.append(x)\n      S -= x\n  return subset\n\nv = [1, 2, 3, 10]\nsum = 12\nmemo = dict()\nif f(v, 0, sum, memo) == 0: print(\"There are no valid subsets.\")\nelse: print(g(v, sum, memo))\n</code></pre>\n<p>Disclaimer: This solution says there are two subsets of [10, 10] that sums 10. This is because it assumes that the first ten is different to the second ten. The algorithm can be fixed to assume that both tens are equal (and thus answer one), but that is a bit more complicated.</p>\n", "abstract": "This problem reduces to the 0-1 Knapsack Problem, where you are trying to find a set with an exact sum. The solution depends on the constraints, in the general case this problem is NP-Complete. However, if the maximum search sum (let's call it S) is not too high, then you can solve the problem using dynamic programming. I will explain it using a recursive function and memoization, which is easier to understand than a bottom-up approach. Let's code a function f(v, i, S), such that it returns the number of subsets in v[i:] that sums exactly to S. To solve it recursively, first we have to analyze the base (i.e.: v[i:] is empty): S == 0: The only subset of [] has sum 0, so it is a valid subset. Because of this, the function should return 1. S != 0: As the only subset of [] has sum 0, there is not a valid subset. Because of this, the function should return 0. Then, let's analyze the recursive case (i.e.: v[i:] is not empty). There are two choices: include the number v[i] in the current subset, or not include it. If we include v[i], then we are looking subsets that have sum S - v[i], otherwise, we are still looking for subsets with sum S. The function f might be implemented in the following way: By checking f(v, 0, S) > 0, you can know if there is a solution to your problem. However, this code is too slow, each recursive call spawns two new calls, which leads to an O(2^n) algorithm. Now, we can apply memoization to make it run in time O(n*S), which is faster if S is not too big: Now, it is possible to code a function g that returns one subset that sums S. To do this, it is enough to add elements only if there is at least one solution including them: Disclaimer: This solution says there are two subsets of [10, 10] that sums 10. This is because it assumes that the first ten is different to the second ten. The algorithm can be fixed to assume that both tens are equal (and thus answer one), but that is a bit more complicated."}, {"id": 62119154, "score": 12, "vote": 0, "content": "<p>I know I'm giving an answer 10 years later since you asked this, but i really needed to know how to do this an the way jbernadas did it was too hard for me, so i googled it for an hour and I found a python library <code>itertools</code> that gets the job done!</p>\n<p>I hope this help to future newbie programmers.\nYou just have to import the library and use the <code>.combinations()</code> method, it is that simple, it returns all the subsets in a set with order, I mean:</p>\n<p>For the set <code>[1, 2, 3, 4]</code> and a subset with length 3 it will not return <code>[1, 2, 3][1, 3, 2][2, 3, 1]</code> it will return just [1, 2, 3]</p>\n<p>As you want ALL the subsets of a set you can iterate it:</p>\n<pre><code class=\"python\">import itertools\n\nsequence = [1, 2, 3, 4]\nfor i in range(len(sequence)):\n    for j in itertools.combinations(sequence, i):\n        print(j)\n</code></pre>\n<p>The output will be</p>\n<blockquote>\n<p>()\n  (1,)\n  (2,)\n  (3,)\n  (4,)\n  (1, 2)\n  (1, 3)\n  (1, 4)\n  (2, 3)\n  (2, 4)\n  (3, 4)\n  (1, 2, 3)\n  (1, 2, 4)\n  (1, 3, 4)\n  (2, 3, 4)</p>\n</blockquote>\n<p>Hope this help!</p>\n", "abstract": "I know I'm giving an answer 10 years later since you asked this, but i really needed to know how to do this an the way jbernadas did it was too hard for me, so i googled it for an hour and I found a python library itertools that gets the job done! I hope this help to future newbie programmers.\nYou just have to import the library and use the .combinations() method, it is that simple, it returns all the subsets in a set with order, I mean: For the set [1, 2, 3, 4] and a subset with length 3 it will not return [1, 2, 3][1, 3, 2][2, 3, 1] it will return just [1, 2, 3] As you want ALL the subsets of a set you can iterate it: The output will be ()\n  (1,)\n  (2,)\n  (3,)\n  (4,)\n  (1, 2)\n  (1, 3)\n  (1, 4)\n  (2, 3)\n  (2, 4)\n  (3, 4)\n  (1, 2, 3)\n  (1, 2, 4)\n  (1, 3, 4)\n  (2, 3, 4) Hope this help!"}, {"id": 34457153, "score": 4, "vote": 0, "content": "<p>So, the logic  is to reverse sort the numbers,and suppose  the list of numbers is <strong>l</strong> and sum to be formed  is <strong>s</strong>.</p>\n<pre><code class=\"python\">   for i in b:\n            if(a(round(n-i,2),b[b.index(i)+1:])):\n                r.append(i)    \n                return True\n        return False\n</code></pre>\n<p>then, we go through this loop and a number is  selected from <strong>l</strong> in order and let say it is <strong>i</strong> .\nthere are 2 possible cases either <strong>i</strong> is the part of sum or not.\nSo, we assume that <strong>i</strong> is part of solution and then the problem reduces to <strong>l</strong> being <code>l[l.index(i+1):]</code> and <strong>s</strong> being <strong>s-i</strong> so, if our function is a(l,s) then we call <code>a(l[l.index(i+1):] ,s-i)</code>. and if <strong>i</strong> is not a part of <strong>s</strong> then we have to form <strong>s</strong> from <code>l[l.index(i+1):]</code> list. \nSo it is similar in both the cases , only change is if i is part of s, then s=s-i and otherwise  s=s only.    </p>\n<p>now to reduce the problem such that in case numbers in l are greater than s we remove them to reduce the complexity until l is empty and in that case the numbers which are selected are not a part of our solution and we return false.  </p>\n<pre><code class=\"python\">if(len(b)==0):\n    return False    \nwhile(b[0]&gt;n):\n    b.remove(b[0])\n    if(len(b)==0):\n        return False    \n</code></pre>\n<p>and in case l has only 1 element left then either it can be part of s then we return true or it is not then we return false and loop will go through other number.</p>\n<pre><code class=\"python\">if(b[0]==n):\n    r.append(b[0])\n    return True\nif(len(b)==1):\n    return False\n</code></pre>\n<p>note in the loop if have used b..but b is our list only.and i have rounded wherever it is possible, so that we should not get wrong answer due to floating point calculations in python.</p>\n<pre><code class=\"python\">r=[]\nlist_of_numbers=[61.12,13.11,100.12,12.32,200,60.00,145.34,14.22,100.21,14.77,214.35,200.32,65.43,0.49,132.13,143.21,156.34,11.32,12.34,15.67,17.89,21.23,14.21,12,122,134]\nlist_of_numbers=sorted(list_of_numbers)\nlist_of_numbers.reverse()\nsum_to_be_formed=401.54\ndef a(n,b):\n    global r\n    if(len(b)==0):\n        return False    \n    while(b[0]&gt;n):\n        b.remove(b[0])\n        if(len(b)==0):\n            return False    \n    if(b[0]==n):\n        r.append(b[0])\n        return True\n    if(len(b)==1):\n        return False\n    for i in b:\n        if(a(round(n-i,2),b[b.index(i)+1:])):\n            r.append(i)    \n            return True\n    return False\nif(a(sum_to_be_formed,list_of_numbers)):\n    print(r)\n</code></pre>\n<p>this solution works fast.more fast than one explained above.\nHowever this works for positive numbers only.\nHowever also it works good if there is a solution only otherwise it takes to much time to get out of loops.</p>\n<p>an example run is like this lets say</p>\n<pre><code class=\"python\">    l=[1,6,7,8,10]\n\nand s=22 i.e. s=1+6+7+8\nso it goes through like this \n\n1.) [10, 8, 7, 6, 1] 22\ni.e. 10  is selected to be part of 22..so s=22-10=12 and l=l.remove(10)\n2.) [8, 7, 6, 1] 12\ni.e. 8  is selected to be part of 12..so s=12-8=4 and l=l.remove(8)\n3.) [7, 6, 1] 4  \nnow 7,6 are removed and 1!=4 so it will return false for this execution where 8 is selected.\n4.)[6, 1] 5\ni.e. 7  is selected to be part of 12..so s=12-7=5 and l=l.remove(7)\nnow 6 are removed and 1!=5 so it will return false for this execution where 7 is selected.\n5.)[1] 6\ni.e. 6  is selected to be part of 12..so s=12-6=6 and l=l.remove(6)\nnow 1!=6 so it will return false for this execution where 6 is selected.\n6.)[] 11\ni.e. 1 is selected to be part of 12..so s=12-1=1 and l=l.remove(1)\nnow l is empty so all the cases for which 10 was a part of s are false and so 10 is not a part of s and we now start with 8 and same cases follow.\n7.)[7, 6, 1] 14\n8.)[6, 1] 7\n9.)[1] 1\n</code></pre>\n<p>just to give a comparison which i ran on my computer which is not so good.\nusing </p>\n<pre><code class=\"python\">l=[61.12,13.11,100.12,12.32,200,60.00,145.34,14.22,100.21,14.77,214.35,145.21,123.56,11.90,200.32,65.43,0.49,132.13,143.21,156.34,11.32,12.34,15.67,17.89,21.23,14.21,12,122,134]\n</code></pre>\n<p>and</p>\n<p><strong>s=2000</strong></p>\n<p>my loop ran 1018 times and 31 ms.</p>\n<p>and previous code loop ran 3415587 times and took somewhere near 16 seconds.</p>\n<p>however in case a solution does not  exist my code ran more than few minutes so i stopped it and previous code ran near around 17 ms only and previous code works with negative numbers also.</p>\n<p>so i thing some improvements can be done.</p>\n", "abstract": "So, the logic  is to reverse sort the numbers,and suppose  the list of numbers is l and sum to be formed  is s. then, we go through this loop and a number is  selected from l in order and let say it is i .\nthere are 2 possible cases either i is the part of sum or not.\nSo, we assume that i is part of solution and then the problem reduces to l being l[l.index(i+1):] and s being s-i so, if our function is a(l,s) then we call a(l[l.index(i+1):] ,s-i). and if i is not a part of s then we have to form s from l[l.index(i+1):] list. \nSo it is similar in both the cases , only change is if i is part of s, then s=s-i and otherwise  s=s only.     now to reduce the problem such that in case numbers in l are greater than s we remove them to reduce the complexity until l is empty and in that case the numbers which are selected are not a part of our solution and we return false.   and in case l has only 1 element left then either it can be part of s then we return true or it is not then we return false and loop will go through other number. note in the loop if have used b..but b is our list only.and i have rounded wherever it is possible, so that we should not get wrong answer due to floating point calculations in python. this solution works fast.more fast than one explained above.\nHowever this works for positive numbers only.\nHowever also it works good if there is a solution only otherwise it takes to much time to get out of loops. an example run is like this lets say just to give a comparison which i ran on my computer which is not so good.\nusing  and s=2000 my loop ran 1018 times and 31 ms. and previous code loop ran 3415587 times and took somewhere near 16 seconds. however in case a solution does not  exist my code ran more than few minutes so i stopped it and previous code ran near around 17 ms only and previous code works with negative numbers also. so i thing some improvements can be done."}, {"id": 42104836, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">#!/usr/bin/python2\n\nylist = [1, 2, 3, 4, 5, 6, 7, 9, 2, 5, 3, -1]\nprint ylist \ntarget = int(raw_input(\"enter the target number\")) \nfor i in xrange(len(ylist)):\n    sno = target-ylist[i]\n    for j in xrange(i+1, len(ylist)):\n        if ylist[j] == sno:\n            print ylist[i], ylist[j]\n</code></pre>\n<p>This python code do what you asked, it will print the unique pair of numbers whose sum is equal to the target variable.</p>\n<pre>\nif target number is 8, it will print: \n1 7\n2 6\n3 5\n3 5\n5 3\n6 2\n9 -1\n5 3\n</pre>\n", "abstract": "This python code do what you asked, it will print the unique pair of numbers whose sum is equal to the target variable."}, {"id": 46629577, "score": 0, "vote": 0, "content": "<p>I have found an answer which has run-time complexity O(n) and space complexity about O(2n), where n is the length of the list.</p>\n<p>The answer satisfies the following constraints:</p>\n<ol>\n<li><p>List can contain duplicates, e.g. [1,1,1,2,3] and you want to find pairs sum to 2</p></li>\n<li><p>List can contain both positive and negative integers</p></li>\n</ol>\n<p>The code is as below, and followed by the explanation: </p>\n<pre><code class=\"python\">def countPairs(k, a):\n    # List a, sum is k\n    temp = dict()\n    count = 0\n    for iter1 in a:\n        temp[iter1] = 0\n        temp[k-iter1] = 0\n    for iter2 in a:\n        temp[iter2] += 1\n    for iter3 in list(temp.keys()):\n        if iter3 == k / 2 and temp[iter3] &gt; 1:\n            count += temp[iter3] * (temp[k-iter3] - 1) / 2\n        elif iter3 == k / 2 and temp[iter3] &lt;= 1:\n            continue\n        else:\n            count += temp[iter3] * temp[k-iter3] / 2\n    return int(count)\n</code></pre>\n<ol>\n<li>Create an empty dictionary, iterate through the list and put all the possible keys in the dict with initial value 0. \nNote that the key (k-iter1) is necessary to specify, e.g. if the list contains 1 but not contains 4, and the sum is 5. Then when we look at 1, we would like to find how many 4 do we have, but if 4 is not in the dict, then it will raise an error.</li>\n<li>Iterate through the list again, and count how many times that each integer occurs and store the results to the dict.</li>\n<li><p>Iterate through through the dict, this time is to find how many pairs do we have. We need to consider 3 conditions:</p>\n<p>3.1 The key is just half of the sum and this key occurs more than once in the list, e.g. list is [1,1,1], sum is 2. We treat this special condition as what the code does.</p>\n<p>3.2 The key is just half of the sum and this key occurs only once in the list, we skip this condition.</p>\n<p>3.3 For other cases that key is not half of the sum, just multiply the its value with another key's value where these two keys sum to the given value. E.g. If sum is 6, we multiply temp[1] and temp[5], temp[2] and temp[4], etc... (I didn't list cases where numbers are negative, but idea is the same.)</p></li>\n</ol>\n<p>The most complex step is step 3, which involves searching the dictionary, but as searching the dictionary is usually fast, nearly constant complexity. (Although worst case is O(n), but should not happen for integer keys.) Thus, with assuming the searching is constant complexity, the total complexity is O(n) as we only iterate the list many times separately.</p>\n<p>Advice for a better solution is welcomed :) </p>\n", "abstract": "I have found an answer which has run-time complexity O(n) and space complexity about O(2n), where n is the length of the list. The answer satisfies the following constraints: List can contain duplicates, e.g. [1,1,1,2,3] and you want to find pairs sum to 2 List can contain both positive and negative integers The code is as below, and followed by the explanation:  Iterate through through the dict, this time is to find how many pairs do we have. We need to consider 3 conditions: 3.1 The key is just half of the sum and this key occurs more than once in the list, e.g. list is [1,1,1], sum is 2. We treat this special condition as what the code does. 3.2 The key is just half of the sum and this key occurs only once in the list, we skip this condition. 3.3 For other cases that key is not half of the sum, just multiply the its value with another key's value where these two keys sum to the given value. E.g. If sum is 6, we multiply temp[1] and temp[5], temp[2] and temp[4], etc... (I didn't list cases where numbers are negative, but idea is the same.) The most complex step is step 3, which involves searching the dictionary, but as searching the dictionary is usually fast, nearly constant complexity. (Although worst case is O(n), but should not happen for integer keys.) Thus, with assuming the searching is constant complexity, the total complexity is O(n) as we only iterate the list many times separately. Advice for a better solution is welcomed :) "}]}, {"link": "https://stackoverflow.com/questions/39154611/how-can-i-use-e-eulers-number-and-power-operation-in-python-2-7", "question": {"id": "39154611", "title": "How can I use &quot;e&quot; (Euler&#39;s number) and power operation in python 2.7", "content": "<p>How can i write <code>x.append(1-e^(-value1^2/2*value2^2))</code> in python 2.7?</p>\n<p>I don't know how to use power operator and e.</p>\n", "abstract": "How can i write x.append(1-e^(-value1^2/2*value2^2)) in python 2.7? I don't know how to use power operator and e."}, "answers": [{"id": 39154677, "score": 60, "vote": 0, "content": "<p>You can use <a href=\"https://docs.python.org/2/library/math.html#math.exp\" rel=\"noreferrer\"><strong><code>exp(x)</code></strong></a> function of <a href=\"https://docs.python.org/2/library/math.html\" rel=\"noreferrer\">math</a> library, which is same as <code>e^x</code>. Hence you may write your code as:</p>\n<pre><code class=\"python\">import math\nx.append(1 - math.exp( -0.5 * (value1*value2)**2))\n</code></pre>\n<p>I have modified the equation by replacing <code>1/2</code> as <code>0.5</code>. Else for Python <em>&lt;2.7</em>, we'll have to explicitly type cast the division value to <code>float</code> because Python round of the result of division of two <code>int</code> as integer. For example: <code>1/2</code> gives <code>0</code> in python 2.7 and below.</p>\n", "abstract": "You can use exp(x) function of math library, which is same as e^x. Hence you may write your code as: I have modified the equation by replacing 1/2 as 0.5. Else for Python <2.7, we'll have to explicitly type cast the division value to float because Python round of the result of division of two int as integer. For example: 1/2 gives 0 in python 2.7 and below."}, {"id": 39154643, "score": 21, "vote": 0, "content": "<p>Python's power operator is <code>**</code> and Euler's number is <code>math.e</code>, so:</p>\n<pre><code class=\"python\"> from math import e\n x.append(1-e**(-value1**2/2*value2**2))\n</code></pre>\n", "abstract": "Python's power operator is ** and Euler's number is math.e, so:"}, {"id": 57821730, "score": 15, "vote": 0, "content": "<p>Just saying: <code>numpy</code> has this too. So no need to import <code>math</code> if you already did <code>import numpy as np</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; np.exp(1)\n2.718281828459045\n</code></pre>\n", "abstract": "Just saying: numpy has this too. So no need to import math if you already did import numpy as np:"}, {"id": 39154642, "score": 6, "vote": 0, "content": "<p>Power is <code>**</code> and <code>e^</code> is <code>math.exp</code>:</p>\n<pre><code class=\"python\">x.append(1 - math.exp(-0.5 * (value1*value2)**2))\n</code></pre>\n", "abstract": "Power is ** and e^ is math.exp:"}, {"id": 55772781, "score": 3, "vote": 0, "content": "<p><code>math.e</code>      or <code>from math import e</code>  (= 2.718281\u2026)</p>\n<p>The two expressions <code>math.exp(x)</code> and <code>e**x</code> are equivalent\nhowever:<br/>\nReturn e raised to the power x, where e = 2.718281\u2026 is the base of natural logarithms. This is usually more accurate than <code>math.e ** x</code> or <code>pow(math.e, x)</code>. <a href=\"https://docs.python.org/3/library/math.html\" rel=\"nofollow noreferrer\">docs.python</a></p>\n<p>for power use <code>**</code> (<code>3**2</code> = 9),  not \" ^ \"<br/>\n\" ^ \" is a bitwise XOR operator (&amp; and, | or), it works logicaly with bits.\nSo for example <code>10^4</code>=14 (maybe unexpectedly) \u2192 consider the bitwise depiction:</p>\n<p>(0000 1010 ^ 0000 0100 = 0000 1110)  <a href=\"https://www.programiz.com/python-programming/operators\" rel=\"nofollow noreferrer\">programiz</a></p>\n", "abstract": "math.e      or from math import e  (= 2.718281\u2026) The two expressions math.exp(x) and e**x are equivalent\nhowever:\nReturn e raised to the power x, where e = 2.718281\u2026 is the base of natural logarithms. This is usually more accurate than math.e ** x or pow(math.e, x). docs.python for power use ** (3**2 = 9),  not \" ^ \"\n\" ^ \" is a bitwise XOR operator (& and, | or), it works logicaly with bits.\nSo for example 10^4=14 (maybe unexpectedly) \u2192 consider the bitwise depiction: (0000 1010 ^ 0000 0100 = 0000 1110)  programiz"}, {"id": 71583338, "score": 1, "vote": 0, "content": "<p>Just to add, <code>numpy</code> also has <code>np.e</code></p>\n", "abstract": "Just to add, numpy also has np.e"}, {"id": 73361181, "score": 1, "vote": 0, "content": "<p>In my case, the exponent happens to be angle expressed in <em>radians</em>. So my approach was:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import cmath \ntheta = cmath.pi/4\noutput = cmath.exp(theta*1j)   # LaTeX: $e^{i\\theta}$ \nprint(output)                  # (0.7071067811865476+0.7071067811865476j)\n</code></pre>\n<p>Note: Use <code>1j</code> instead of <code>j</code> since python throws <code>NameError</code> for <code>j</code>.</p>\n", "abstract": "In my case, the exponent happens to be angle expressed in radians. So my approach was: Note: Use 1j instead of j since python throws NameError for j."}]}, {"link": "https://stackoverflow.com/questions/4479463/using-fourier-analysis-for-time-series-prediction", "question": {"id": "4479463", "title": "Using fourier analysis for time series prediction", "content": "<p>For data that is known to have seasonal, or daily patterns I'd like to use fourier analysis be used to make predictions. After running fft on time series data, I obtain coefficients. How can I use these coefficients for prediction? </p>\n<p>I believe FFT assumes all data it receives constitute one period, then, if I simply regenerate data using ifft, I am also regenerating the continuation of my function, so can I use these values for future values? </p>\n<p>Simply put: I run fft for t=0,1,2,..10 then using ifft on coef, can I use regenerated time series for t=11,12,..20 ?  </p>\n", "abstract": "For data that is known to have seasonal, or daily patterns I'd like to use fourier analysis be used to make predictions. After running fft on time series data, I obtain coefficients. How can I use these coefficients for prediction?  I believe FFT assumes all data it receives constitute one period, then, if I simply regenerate data using ifft, I am also regenerating the continuation of my function, so can I use these values for future values?  Simply put: I run fft for t=0,1,2,..10 then using ifft on coef, can I use regenerated time series for t=11,12,..20 ?  "}, "answers": [{"id": 28163549, "score": 60, "vote": 0, "content": "<p>I'm aware that this question may be not actual for you anymore, but for others that are looking for answers I wrote a very simple example of fourier extrapolation in Python <a href=\"https://gist.github.com/tartakynov/83f3cd8f44208a1856ce\" rel=\"noreferrer\">https://gist.github.com/tartakynov/83f3cd8f44208a1856ce</a></p>\n<p>Before you run the script make sure that you have all dependencies installed (numpy, matplotlib). Feel free to experiment with it.\n<img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/9ztB6.png\"/>\nP.S. Locally Stationary Wavelet may be better than fourier extrapolation. LSW is commonly used in predicting time series. The main disadvantage of fourier extrapolation is that it just repeats your series with period N, where N - length of your time series.</p>\n", "abstract": "I'm aware that this question may be not actual for you anymore, but for others that are looking for answers I wrote a very simple example of fourier extrapolation in Python https://gist.github.com/tartakynov/83f3cd8f44208a1856ce Before you run the script make sure that you have all dependencies installed (numpy, matplotlib). Feel free to experiment with it.\n\nP.S. Locally Stationary Wavelet may be better than fourier extrapolation. LSW is commonly used in predicting time series. The main disadvantage of fourier extrapolation is that it just repeats your series with period N, where N - length of your time series."}, {"id": 4479849, "score": 29, "vote": 0, "content": "<p>It sounds like you want a combination of extrapolation <em>and</em> denoising.</p>\n<p>You say you want to repeat the observed data over multiple periods. Well, then just repeat the observed data. No need for Fourier analysis.</p>\n<p>But you also want to find \"patterns\". I assume that means finding the dominant frequency components in the observed data. Then yes, take the Fourier transform, preserve the largest coefficients, and eliminate the rest.</p>\n<pre><code class=\"python\">X = scipy.fft(x)\nY = scipy.zeros(len(X))\nY[important frequencies] = X[important frequencies]\n</code></pre>\n<p>As for periodic repetition: Let <code>z = [x, x]</code>, i.e., two periods of the signal <code>x</code>. Then <code>Z[2k] = X[k]</code> for all <code>k</code> in {0, 1, ..., N-1}, and zeros otherwise.</p>\n<pre><code class=\"python\">Z = scipy.zeros(2*len(X))\nZ[::2] = X\n</code></pre>\n", "abstract": "It sounds like you want a combination of extrapolation and denoising. You say you want to repeat the observed data over multiple periods. Well, then just repeat the observed data. No need for Fourier analysis. But you also want to find \"patterns\". I assume that means finding the dominant frequency components in the observed data. Then yes, take the Fourier transform, preserve the largest coefficients, and eliminate the rest. As for periodic repetition: Let z = [x, x], i.e., two periods of the signal x. Then Z[2k] = X[k] for all k in {0, 1, ..., N-1}, and zeros otherwise."}, {"id": 4479491, "score": 11, "vote": 0, "content": "<p>When you run an FFT on time series data, you transform it into the frequency domain.  The coefficients multiply the terms in the series (sines and cosines or complex exponentials), each with a different frequency.</p>\n<p>Extrapolation is always a dangerous thing, but you're welcome to try it.  You're using past information to predict the future when you do this: \"Predict tomorrow's weather by looking at today.\"  Just be aware of the risks.  </p>\n<p>I'd recommend reading <a href=\"https://rads.stackoverflow.com/amzn/click/com/081297381X\" rel=\"nofollow noreferrer\">\"Black Swan\"</a>. </p>\n", "abstract": "When you run an FFT on time series data, you transform it into the frequency domain.  The coefficients multiply the terms in the series (sines and cosines or complex exponentials), each with a different frequency. Extrapolation is always a dangerous thing, but you're welcome to try it.  You're using past information to predict the future when you do this: \"Predict tomorrow's weather by looking at today.\"  Just be aware of the risks.   I'd recommend reading \"Black Swan\". "}, {"id": 32488561, "score": 3, "vote": 0, "content": "<p>you can use the library that @tartakynov posted and, to not repeat exactly the same time series in the forcast (overfitting), you can add a new parameter to the function called <code>n_param</code> and fix a lower bound <code>h</code> for the amplitudes of the frequencies.</p>\n<pre><code class=\"python\">def fourierExtrapolation(x, n_predict,n_param):\n</code></pre>\n<p>usually you will find that, in a signal, there are some frequencies that have significantly higher amplitude than others, so, if you select this frequencies you will be able to isolate the periodic nature of the signal</p>\n<p>you can add this two lines who are determinated by certain number <code>n_param</code></p>\n<pre><code class=\"python\">h=np.sort(x_freqdom)[-n_param]\nx_freqdom=[ x_freqdom[i] if np.absolute(x_freqdom[i])&gt;=h else 0 for i in range(len(x_freqdom)) ]\n</code></pre>\n<p>just adding this you will be able to forecast nice and smooth</p>\n<p>another useful article about FFt:\n<a href=\"https://mran.microsoft.com/posts/timeseries\" rel=\"nofollow noreferrer\">forecast FFt in R</a> </p>\n", "abstract": "you can use the library that @tartakynov posted and, to not repeat exactly the same time series in the forcast (overfitting), you can add a new parameter to the function called n_param and fix a lower bound h for the amplitudes of the frequencies. usually you will find that, in a signal, there are some frequencies that have significantly higher amplitude than others, so, if you select this frequencies you will be able to isolate the periodic nature of the signal you can add this two lines who are determinated by certain number n_param just adding this you will be able to forecast nice and smooth another useful article about FFt:\nforecast FFt in R "}]}, {"link": "https://stackoverflow.com/questions/31547657/how-can-i-solve-system-of-linear-equations-in-sympy", "question": {"id": "31547657", "title": "How can I solve system of linear equations in SymPy?", "content": "<p>Sorry, I am pretty new to sympy and python in general.</p>\n<p>I want to solve the following underdetermined linear system of equations:</p>\n<pre><code class=\"python\">x + y + z = 1 \nx + y + 2z = 3\n</code></pre>\n", "abstract": "Sorry, I am pretty new to sympy and python in general. I want to solve the following underdetermined linear system of equations:"}, "answers": [{"id": 31547816, "score": 47, "vote": 0, "content": "<p>SymPy recently got a new Linear system solver: <code>linsolve</code> in <code>sympy.solvers.solveset</code>, you can use that as follows:</p>\n<pre><code class=\"python\">In [38]: from sympy import *\n\nIn [39]: from sympy.solvers.solveset import linsolve\n\nIn [40]: x, y, z = symbols('x, y, z')\n</code></pre>\n<p><strong>List of Equations Form:</strong> </p>\n<pre><code class=\"python\">In [41]: linsolve([x + y + z - 1, x + y + 2*z - 3 ], (x, y, z))\nOut[41]: {(-y - 1, y, 2)}\n</code></pre>\n<p><strong>Augmented Matrix Form:</strong></p>\n<pre><code class=\"python\">In [59]: linsolve(Matrix(([1, 1, 1, 1], [1, 1, 2, 3])), (x, y, z))\nOut[59]: {(-y - 1, y, 2)}\n</code></pre>\n<p><strong>A*x = b Form</strong></p>\n<pre><code class=\"python\">In [59]: M = Matrix(((1, 1, 1, 1), (1, 1, 2, 3)))\n\nIn [60]: system = A, b = M[:, :-1], M[:, -1]\n\nIn [61]: linsolve(system, x, y, z)\nOut[61]: {(-y - 1, y, 2)}\n</code></pre>\n<p><strong>Note</strong>: Order of solution corresponds the order of given symbols.</p>\n", "abstract": "SymPy recently got a new Linear system solver: linsolve in sympy.solvers.solveset, you can use that as follows: List of Equations Form:  Augmented Matrix Form: A*x = b Form Note: Order of solution corresponds the order of given symbols."}, {"id": 54696340, "score": 18, "vote": 0, "content": "<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import sympy as sp\nx, y, z = sp.symbols('x, y, z')\neq1 = sp.Eq(x + y + z, 1)             # x + y + z  = 1\neq2 = sp.Eq(x + y + 2 * z, 3)         # x + y + 2z = 3\nans = sp.solve((eq1, eq2), (x, y, z))\n</code></pre>\n<p>this is similar to @PaulDong answer with some minor changes</p>\n<ol>\n<li>its a good practice getting used to not using <code>import *</code> (numpy has many similar functions)</li>\n<li>defining equations with <code>sp.Eq()</code> results in cleaner code later on</li>\n</ol>\n", "abstract": "this is similar to @PaulDong answer with some minor changes"}, {"id": 39848155, "score": 15, "vote": 0, "content": "<p>In addition to the great answers given by @AMiT Kumar and @Scott, SymPy 1.0 has added even further functionalities. For the underdetermined linear system of equations, I tried below and get it to work without going deeper into <code>sympy.solvers.solveset</code>. That being said, do go there if curiosity leads you.</p>\n<pre><code class=\"python\">from sympy import *\nx, y, z = symbols('x, y, z')\neq1 = x + y + z\neq2 = x + y + 2*z\nsolve([eq1-1, eq2-3], (x, y,z))\n</code></pre>\n<p>That gives me <code>{z: 2, x: -y - 1}</code>. \nAgain, great package, SymPy developers!</p>\n", "abstract": "In addition to the great answers given by @AMiT Kumar and @Scott, SymPy 1.0 has added even further functionalities. For the underdetermined linear system of equations, I tried below and get it to work without going deeper into sympy.solvers.solveset. That being said, do go there if curiosity leads you. That gives me {z: 2, x: -y - 1}. \nAgain, great package, SymPy developers!"}, {"id": 40121906, "score": 4, "vote": 0, "content": "<p>Another example on matrix linear system equations, lets assume we are solving for this system:</p>\n<p><a href=\"https://i.stack.imgur.com/wWNog.png\" rel=\"nofollow\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/wWNog.png\"/></a></p>\n<p>In <code>SymPy</code> we could do something like:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import sympy as sy\n... sy.init_printing()\n\n&gt;&gt;&gt; a, b, c, d = sy.symbols('a b c d')\n... A = sy.Matrix([[a-b, b+c],[3*d + c, 2*a - 4*d]])\n... A\n\n\u23a1 a - b     b + c  \u23a4\n\u23a2                  \u23a5\n\u23a3c + 3\u22c5d  2\u22c5a - 4\u22c5d\u23a6\n\n\n&gt;&gt;&gt; B = sy.Matrix([[8, 1],[7, 6]])\n... B\n\n\u23a18  1\u23a4\n\u23a2    \u23a5\n\u23a37  6\u23a6\n\n\n&gt;&gt;&gt; A - B\n\n\u23a1 a - b - 8     b + c - 1  \u23a4\n\u23a2                          \u23a5\n\u23a3c + 3\u22c5d - 7  2\u22c5a - 4\u22c5d - 6\u23a6\n\n\n&gt;&gt;&gt; sy.solve(A - B, (a, b, c, d))\n{a: 5, b: -3, c: 4, d: 1}\n</code></pre>\n", "abstract": "Another example on matrix linear system equations, lets assume we are solving for this system:  In SymPy we could do something like:"}, {"id": 31548073, "score": 2, "vote": 0, "content": "<p>You can solve in matrix form <code>Ax=b</code> (in this case an underdetermined system but we can use <a href=\"http://docs.sympy.org/dev/modules/solvers/solvers.html#sympy.solvers.solvers.solve_linear_system\" rel=\"nofollow\"><code>solve_linear_system</code></a>):</p>\n<pre><code class=\"python\">from sympy import Matrix, solve_linear_system\n\nx, y, z = symbols('x, y, z')\nA = Matrix(( (1, 1, 1, 1), (1, 1, 2, 3) ))\nsolve_linear_system(A, x, y, z)\n\n{x: -y - 1, z: 2}\n</code></pre>\n<p>Or rewrite as (my editing, not sympy):</p>\n<pre><code class=\"python\">[x]=  [-1]   [-1]\n[y]= y[1]  + [0]\n[z]=  [0]    [2]\n</code></pre>\n<p>In the case of a square <code>A</code> we could define <code>b</code> and use <code>A.LUsolve(b)</code>.</p>\n", "abstract": "You can solve in matrix form Ax=b (in this case an underdetermined system but we can use solve_linear_system): Or rewrite as (my editing, not sympy): In the case of a square A we could define b and use A.LUsolve(b)."}]}, {"link": "https://stackoverflow.com/questions/17847902/what-is-the-difference-between-sympy-and-sage", "question": {"id": "17847902", "title": "What is the difference between SymPy and Sage?", "content": "<p>What is the difference between <a href=\"http://www.sympy.org/\" rel=\"noreferrer\">SymPy</a> and <a href=\"https://www.sagemath.org/\" rel=\"noreferrer\">Sage</a> a.k.a. SageMath?</p>\n", "abstract": "What is the difference between SymPy and Sage a.k.a. SageMath?"}, "answers": [{"id": 17865186, "score": 85, "vote": 0, "content": "<p>(Full disclosure: I am the lead developer of SymPy)</p>\n<p>The first thing you should understand is that SymPy and Sage are not quite the same thing. SymPy is a pure Python library, that does computer algebra. Sage is a collection of open source mathematical software. Sage tries to gather together all the major open source mathematics software, and glue it together into a useful system. In fact, <em>Sage includes SymPy</em> as one of its systems.</p>\n<p>Here is a short list of (biased) facts for each (I won't call them pros or cons, just facts):</p>\n<h2>SymPy</h2>\n<ul>\n<li>SymPy is completely standalone. It has no dependencies other than Python.</li>\n<li>Despite being standalone, it is full featured <em>as a computer algebra system</em>. If you want to do numerics, you are encouraged to use other libraries in the <a href=\"http://www.scipy.org/about.html\" rel=\"noreferrer\">scientific Python ecosystem</a>.</li>\n<li>SymPy is BSD licensed. For many people, this doesn't matter, but if you want to include SymPy in something else, it's nice to know that you can pretty much do whatever you want with the code.</li>\n<li>SymPy does not try to change Python. SymPy takes the philosophy that Python is doing things well, so it should do things the Python way. For example, the operator for exponentiation is <code>**</code> as it is in Python, not <code>^</code> as it is in many other systems.</li>\n<li>SymPy can be used as a library. Since SymPy is just a Python module, you can just import it and use it in any place that uses Python. There are a lot of really cool apps and libraries out there that use SymPy in the background to do symbolics (in many cases, in places where you might not even realize that symbolics are being used).</li>\n</ul>\n<h2>Sage</h2>\n<ul>\n<li>Sage includes everything (including SymPy) from the open source world that you might want to do mathematics. This includes many libraries that are useful for numerics, like octave.</li>\n<li>Sage is GPL. If you like the whole FSF software freedom shpel, then more power to you. You can't reuse the source code in your own application without licensing your application under the GPL as well.</li>\n<li>Sage is hard to use as a library. On the other hand, it has a very nice notebook interface. If you want to do the same with SymPy, the recommended way is to use the IPython notebook and run <code>from sympy import init_session; init_session()</code> at the top (replace <code>init_session</code> with <code>init_printing</code> if you just want printing and not to import everything).</li>\n<li>Sage includes a bit of a DSL on top of Python. For example, you can type <code>1/2</code> without wrapping the integer literals, and it will return a rational. <code>x^2</code> gives x squared, not <code>Xor(x, 2)</code>. I'm not sure if it automatically defines variables for you by default. This means that things that you do in an interactive Sage session might not translate directly to a Python script. On the other hand, this can be useful for interactive use (btw, SymPy also has <code>isympy -I</code> that does some similar things).</li>\n</ul>\n<p>Maybe that's not what you were looking for. You probably wanted some actual mathematical features. But as I said, Sage includes SymPy, so by definition, every feature of SymPy will be a feature of Sage. In practice, this is not necessarily the case because Sage doesn't always use SymPy by default (I'm not sure what the current status of this is actually), so you may have to call to SymPy manually if you want to use it from within Sage.</p>\n", "abstract": "(Full disclosure: I am the lead developer of SymPy) The first thing you should understand is that SymPy and Sage are not quite the same thing. SymPy is a pure Python library, that does computer algebra. Sage is a collection of open source mathematical software. Sage tries to gather together all the major open source mathematics software, and glue it together into a useful system. In fact, Sage includes SymPy as one of its systems. Here is a short list of (biased) facts for each (I won't call them pros or cons, just facts): Maybe that's not what you were looking for. You probably wanted some actual mathematical features. But as I said, Sage includes SymPy, so by definition, every feature of SymPy will be a feature of Sage. In practice, this is not necessarily the case because Sage doesn't always use SymPy by default (I'm not sure what the current status of this is actually), so you may have to call to SymPy manually if you want to use it from within Sage."}]}, {"link": "https://stackoverflow.com/questions/9404967/taking-the-floor-of-a-float", "question": {"id": "9404967", "title": "Taking the floor of a float", "content": "<p>I have found two ways of taking floors in Python:</p>\n<pre><code class=\"python\">3.1415 // 1\n</code></pre>\n<p>and </p>\n<pre><code class=\"python\">import math\nmath.floor(3.1415)\n</code></pre>\n<p>The problem with the first approach is that it return a float (namely <code>3.0</code>). The second approach feels clumsy and too long.</p>\n<p>Are there alternative solutions for taking floors in Python?</p>\n", "abstract": "I have found two ways of taking floors in Python: and  The problem with the first approach is that it return a float (namely 3.0). The second approach feels clumsy and too long. Are there alternative solutions for taking floors in Python?"}, "answers": [{"id": 9405029, "score": 72, "vote": 0, "content": "<p>As long as your numbers are positive, you can simply convert to an <code>int</code> to round down to the next integer:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; int(3.1415)\n3\n</code></pre>\n<p>For negative integers, this will round up, though.</p>\n", "abstract": "As long as your numbers are positive, you can simply convert to an int to round down to the next integer: For negative integers, this will round up, though."}, {"id": 9405045, "score": 14, "vote": 0, "content": "<p>You can call int() on the float to cast to the lower int (not obviously the floor but more elegant)</p>\n<pre><code class=\"python\">int(3.745)  #3\n</code></pre>\n<p>Alternatively call int on the floor result.</p>\n<pre><code class=\"python\">from math import floor\n\nf1 = 3.1415\nf2 = 3.7415\n\nprint floor(f1)       # 3.0\nprint int(floor(f1))  # 3\nprint int(f1)         # 3\nprint int(f2)         # 3 (some people may expect 4 here)\nprint int(floor(f2))  # 3\n</code></pre>\n<p><a href=\"http://docs.python.org/library/functions.html#int\">http://docs.python.org/library/functions.html#int</a></p>\n", "abstract": "You can call int() on the float to cast to the lower int (not obviously the floor but more elegant) Alternatively call int on the floor result. http://docs.python.org/library/functions.html#int"}, {"id": 9404986, "score": 6, "vote": 0, "content": "<p>The second approach is the way to go, but there's a way to shorten it.</p>\n<pre><code class=\"python\">from math import floor\nfloor(3.1415)\n</code></pre>\n", "abstract": "The second approach is the way to go, but there's a way to shorten it."}, {"id": 16801861, "score": 5, "vote": 0, "content": "<p>Beware that taking the floor and casting to an int are not the same thing with negative numbers. If you really want the floor as an integer, you should cast to an int after calling math.floor().</p>\n<pre><code class=\"python\">&gt;&gt;&gt; int(-0.5)\n0\n&gt;&gt;&gt; math.floor(-0.5)\n-1.0\n&gt;&gt;&gt; int(math.floor(-0.5))\n-1\n</code></pre>\n", "abstract": "Beware that taking the floor and casting to an int are not the same thing with negative numbers. If you really want the floor as an integer, you should cast to an int after calling math.floor()."}, {"id": 9405016, "score": 4, "vote": 0, "content": "<p>Cast it to <code>int</code> if you don't want a <code>float</code></p>\n<pre><code class=\"python\">int(3.1415 // 1)\n</code></pre>\n", "abstract": "Cast it to int if you don't want a float"}, {"id": 56823106, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">from math import floor\n\n\ndef ff(num, step=0):\n    if not step:\n        return floor(num)\n    if step &lt; 0:\n        mplr = 10 ** (step * -1)\n        return floor(num / mplr) * mplr\n    ncnt = step\n    if 1 &gt; step &gt; 0:\n        ndec, ncnt = .0101, 1\n        while ndec &gt; step:\n            ndec *= .1\n            ncnt += 1\n    mplr = 10 ** ncnt\n    return round(floor(num * mplr) / mplr, ncnt)\n</code></pre>\n<p>You can use positive/negative numbers and float points .1, .01, .001...</p>\n", "abstract": "You can use positive/negative numbers and float points .1, .01, .001..."}]}, {"link": "https://stackoverflow.com/questions/4240050/python-sort-function-breaks-in-the-presence-of-nan", "question": {"id": "4240050", "title": "Python: sort function breaks in the presence of nan", "content": "<p><code>sorted([2, float('nan'), 1])</code> returns <code>[2, nan, 1]</code></p>\n<p>(At least on Activestate Python 3.1 implementation.)</p>\n<p>I understand <code>nan</code> is a weird object, so I wouldn't be surprised if it shows up in random places in the sort result. But it also messes up the sort for the non-nan numbers in the container, which is really unexpected.</p>\n<p>I asked a <a href=\"https://stackoverflow.com/questions/4237914/python-max-min-builtin-functions-depend-on-parameter-order\">related question</a> about <code>max</code>, and based on that I understand why <code>sort</code> works like this. But should this be considered a bug?</p>\n<p>Documentation just says \"Return a new sorted list [...]\" without specifying any details.</p>\n<p>EDIT: \nI now agree that this isn't in violation of the IEEE standard. However, it's a bug from any common sense viewpoint, I think. Even  Microsoft, which isn't known to admit their mistakes often, has recognized this one as a bug, and fixed it in the latest version: <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/363379/bug-in-list-double-sort-in-list-which-contains-double-nan\" rel=\"noreferrer\">http://connect.microsoft.com/VisualStudio/feedback/details/363379/bug-in-list-double-sort-in-list-which-contains-double-nan</a>.</p>\n<p>Anyway, I ended up following @khachik's answer:</p>\n<pre><code class=\"python\">sorted(list_, key = lambda x : float('-inf') if math.isnan(x) else x)\n</code></pre>\n<p>I suspect it results in a performance hit compared to the language doing that by default, but at least it works (barring any bugs that I introduced).</p>\n", "abstract": "sorted([2, float('nan'), 1]) returns [2, nan, 1] (At least on Activestate Python 3.1 implementation.) I understand nan is a weird object, so I wouldn't be surprised if it shows up in random places in the sort result. But it also messes up the sort for the non-nan numbers in the container, which is really unexpected. I asked a related question about max, and based on that I understand why sort works like this. But should this be considered a bug? Documentation just says \"Return a new sorted list [...]\" without specifying any details. EDIT: \nI now agree that this isn't in violation of the IEEE standard. However, it's a bug from any common sense viewpoint, I think. Even  Microsoft, which isn't known to admit their mistakes often, has recognized this one as a bug, and fixed it in the latest version: http://connect.microsoft.com/VisualStudio/feedback/details/363379/bug-in-list-double-sort-in-list-which-contains-double-nan. Anyway, I ended up following @khachik's answer: I suspect it results in a performance hit compared to the language doing that by default, but at least it works (barring any bugs that I introduced)."}, "answers": [{"id": 7165183, "score": 17, "vote": 0, "content": "<p>The previous answers are useful, but perhaps not clear regarding the root of the problem.</p>\n<p>In any language, sort applies a given ordering, defined by a comparison function or in some other way, over the domain of the input values.  For example, less-than, a.k.a. <code>operator &lt;,</code> could be used throughout if and only if less than defines a suitable ordering over the input values.</p>\n<p>But this is specifically NOT true for floating point values and less-than:\n\"NaN is unordered: it is not equal to, greater than, or less than anything, including itself.\" (<strong>Clear prose from GNU C manual,</strong> but applies to all modern <code>IEEE754</code> based <strong>floating point</strong>)</p>\n<p>So the possible solutions are:</p>\n<blockquote>\n<ol>\n<li>remove the NaNs first, making the input domain well defined via &lt;\n  (or the other sorting function being used)</li>\n<li>define a custom comparison function (a.k.a. predicate) that does\n  define an ordering for NaN, such as less than any number, or greater\n  than any number.</li>\n</ol>\n</blockquote>\n<p>Either approach can be used, in any language.</p>\n<p>Practically, considering python, I would prefer to remove the NaNs if you either don't care much about fastest performance or if removing NaNs is a desired behavior in context. </p>\n<p>Otherwise you could use a suitable predicate function via \"cmp\" in older python versions, or via this and  <code>functools.cmp_to_key()</code>.  The latter is a bit more awkward, naturally, than removing the NaNs first. And care will be required to avoid <em>worse</em> performance, when defining this predicate function.</p>\n", "abstract": "The previous answers are useful, but perhaps not clear regarding the root of the problem. In any language, sort applies a given ordering, defined by a comparison function or in some other way, over the domain of the input values.  For example, less-than, a.k.a. operator <, could be used throughout if and only if less than defines a suitable ordering over the input values. But this is specifically NOT true for floating point values and less-than:\n\"NaN is unordered: it is not equal to, greater than, or less than anything, including itself.\" (Clear prose from GNU C manual, but applies to all modern IEEE754 based floating point) So the possible solutions are: Either approach can be used, in any language. Practically, considering python, I would prefer to remove the NaNs if you either don't care much about fastest performance or if removing NaNs is a desired behavior in context.  Otherwise you could use a suitable predicate function via \"cmp\" in older python versions, or via this and  functools.cmp_to_key().  The latter is a bit more awkward, naturally, than removing the NaNs first. And care will be required to avoid worse performance, when defining this predicate function."}, {"id": 4240088, "score": 10, "vote": 0, "content": "<p>I'm not sure about the bug, but the workaround may be the following:</p>\n<pre><code class=\"python\">sorted(\n    (2, 1, float('nan')),\n    lambda x,y: x is float('nan') and -1 \n                or (y is float('nan') and 1\n                or cmp(x,y)))\n</code></pre>\n<p>which results in:</p>\n<pre><code class=\"python\">('nan', 1, 2)\n</code></pre>\n<p>Or remove <code>nan</code>s before sorting or anything else.</p>\n", "abstract": "I'm not sure about the bug, but the workaround may be the following: which results in: Or remove nans before sorting or anything else."}, {"id": 4240561, "score": 8, "vote": 0, "content": "<p>The problem is that there's no correct order if the <code>list</code> contains a <code>NAN</code>, since a sequence <code>a1, a2, a3, ..., an</code> is sorted if <code>a1 &lt;= a2 &lt;= a3 &lt;= ... &lt;= an</code>. If any of these a values is a <code>NAN</code> then the sorted property breaks, since for all <code>a, a &lt;= NAN and NAN &lt;= a</code> are both <code>false</code>.</p>\n", "abstract": "The problem is that there's no correct order if the list contains a NAN, since a sequence a1, a2, a3, ..., an is sorted if a1 <= a2 <= a3 <= ... <= an. If any of these a values is a NAN then the sorted property breaks, since for all a, a <= NAN and NAN <= a are both false."}, {"id": 44154301, "score": 7, "vote": 0, "content": "<p>Assuming you want to keep the NaNs and order them as the lowest \"values\", here is a workaround working both with <em>non-unique nan</em>, <em>unique numpy nan</em>, <em>numerical</em> and <em>non numerical</em> objects:</p>\n<pre><code class=\"python\">def is_nan(x):\n    return (x is np.nan or x != x)\n\nlist_ = [2, float('nan'), 'z', 1, 'a', np.nan, 4, float('nan')]\nsorted(list_, key = lambda x : float('-inf') if is_nan(x) else x)\n# [nan, nan, nan, 1, 2, 4, 'a', 'z']\n</code></pre>\n", "abstract": "Assuming you want to keep the NaNs and order them as the lowest \"values\", here is a workaround working both with non-unique nan, unique numpy nan, numerical and non numerical objects:"}, {"id": 4240071, "score": 5, "vote": 0, "content": "<p>IEEE754 is the standard that defines floating point operations in this instance. This standard defines the compare operation of operands, at least one of which is a NaN, to be an error.  Hence, this is not a bug.  You need to deal with the NaNs before operating on your array.</p>\n", "abstract": "IEEE754 is the standard that defines floating point operations in this instance. This standard defines the compare operation of operands, at least one of which is a NaN, to be an error.  Hence, this is not a bug.  You need to deal with the NaNs before operating on your array."}, {"id": 70016420, "score": 2, "vote": 0, "content": "<p>To recap the problems:</p>\n<h3><code>NaN</code></h3>\n<p>This always returns <code>False</code> for every comparison, so it stays where it is in the list:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; sorted([float('nan'), 0])\n[nan, 0]\n&gt;&gt;&gt; sorted([0, float('nan')])\n[0, nan]\n</code></pre>\n<h3><code>-0.0</code></h3>\n<p>This is == to <code>0.0</code>, but has a different repr, a different json representation, and <em>slightly</em> different numerical properties. It has the same problem that the positive and negative zeros will stay in the same order they were in the original list:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; sorted([0.0, -0.0])\n[0.0, -0.0]\n&gt;&gt;&gt; sorted([-0.0, 0.0])\n[-0.0, 0.0]\n</code></pre>\n<h3>Other solution?</h3>\n<p>@khachik's solution has inconsistent sorting behavior for <code>NaN</code> and <code>-inf</code></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; key=lambda x: float('-inf') if math.isnan(x) else x\n&gt;&gt;&gt; sorted([float('nan'), float('-inf')], key=key)\n[nan, -inf]\n&gt;&gt;&gt; sorted([float('-inf'), float('nan')], key=key)\n[-inf, nan]\n</code></pre>\n<h3>Solution: more complex key function.</h3>\n<p>So there are problems with signs and nans. We can just include those in a key function:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def stable_float_sort_key(x: float):\n    return math.copysign(1, x), math.isnan(x), x\n</code></pre>\n<p>That works on all the examples above:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; sorted([float('nan'), 0.0], key=stable_float_sort_key)\n[0.0, nan]\n&gt;&gt;&gt; sorted([0.0, float('nan')], key=stable_float_sort_key)\n[0.0, nan]\n&gt;&gt;&gt; sorted([float('nan'), float('-inf')], key=stable_float_sort_key)\n[-inf, nan]\n&gt;&gt;&gt; sorted([float('-inf'), float('nan')], key=stable_float_sort_key)\n[-inf, nan]\n&gt;&gt;&gt; sorted([0.0, -0.0], key=stable_float_sort_key)\n[-0.0, 0.0]\n&gt;&gt;&gt; sorted([-0.0, 0.0], key=stable_float_sort_key)\n[-0.0, 0.0]\n</code></pre>\n<p>Indeed, you can write a hypothesis test showing it's consistent across all floating point numbers:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import json\nfrom hypothesis import given, settings\nfrom hypothesis import strategies as st\n\n@given(nums=st.lists(st.floats()), random=st.randoms())\n@settings(max_examples=10000)\ndef test_stable_json_sorting(nums, random):\n    shuffled = list(nums)\n    random.shuffle(shuffled)\n    l1 = sorted(nums, key=stable_float_sort_key)\n    l2 = sorted(shuffled, key=stable_float_sort_key)\n    assert json.dumps(l1) == json.dumps(l2)\n</code></pre>\n<p>It does have some oddities however, since some NaN's are negative! For example:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; sorted([float('nan'), -0.0, 0.0, float('-nan')], key=stable_float_sort_key)\n[-0.0, nan, 0.0, nan]\n</code></pre>\n<p>If that bothers you, you can fix this by switching the ordering:</p>\n<pre><code class=\"python\">def stable_float_sort_key(x: float):\n    return math.isnan(x), math.copysign(1, x), x\n</code></pre>\n<p>That sorts negative numbers first, followed by positive numbers, followed by NaNs.</p>\n<h3>Does any of this make sense?</h3>\n<p>Of course other answerers are correct that in some sense none of this makes sense. Comparison of NaNs is a conceptual error of some kind. However, even in cases where the question doesn't \"make sense\", you may want to have invariants like serializing sets of floating point numbers generated by the same code to exactly the same JSON representation, despite hash randomization (my use case). That's more of a formal property of python code, rather than something where there's a \"right answer\" per an IEEE standard.</p>\n", "abstract": "To recap the problems: This always returns False for every comparison, so it stays where it is in the list: This is == to 0.0, but has a different repr, a different json representation, and slightly different numerical properties. It has the same problem that the positive and negative zeros will stay in the same order they were in the original list: @khachik's solution has inconsistent sorting behavior for NaN and -inf So there are problems with signs and nans. We can just include those in a key function: That works on all the examples above: Indeed, you can write a hypothesis test showing it's consistent across all floating point numbers: It does have some oddities however, since some NaN's are negative! For example: If that bothers you, you can fix this by switching the ordering: That sorts negative numbers first, followed by positive numbers, followed by NaNs. Of course other answerers are correct that in some sense none of this makes sense. Comparison of NaNs is a conceptual error of some kind. However, even in cases where the question doesn't \"make sense\", you may want to have invariants like serializing sets of floating point numbers generated by the same code to exactly the same JSON representation, despite hash randomization (my use case). That's more of a formal property of python code, rather than something where there's a \"right answer\" per an IEEE standard."}, {"id": 64945218, "score": 0, "vote": 0, "content": "<p>Regardless of standards, there are many cases where a user-defined ordering of float and <code>NA</code> values is useful. For instance, I was sorting stock returns and wanted highest to lowest with <code>NA</code> last (since those were irrelevant). There are 4 possible combinations</p>\n<ol>\n<li>Ascending float values, <code>NA</code> values last</li>\n<li>Ascending float values, <code>NA</code> values first</li>\n<li>Descending float values, <code>NA</code> values last</li>\n<li>Descending float values, <code>NA</code> values first</li>\n</ol>\n<p>Here is a function that covers all scenarios by conditionally replacing <code>NA</code> values with <code>+/- inf</code></p>\n<pre><code class=\"python\">import math \n\ndef sort_with_na(x, reverse=False, na_last=True):\n    \"\"\"Intelligently sort iterable with NA values\n\n    For reliable behavior with NA values, we should change the NAs to +/- inf\n    to guarantee their order rather than relying on the built-in\n    ``sorted(reverse=True)`` which will have no effect. To use the ``reverse``\n    parameter or other kwargs, use functools.partial in your lambda i.e.\n\n        sorted(iterable, key=partial(sort_with_na, reverse=True, na_last=False))\n\n    :param x: Element to be sorted\n    :param bool na_last: Whether NA values should come last or first\n    :param bool reverse: Return ascending if ``False`` else descending\n    :return bool:\n    \"\"\"\n    if not math.isnan(x):\n        return -x if reverse else x\n    else:\n        return float('inf') if na_last else float('-inf')\n</code></pre>\n<p>Testing out each of the 4 combinations</p>\n<pre><code class=\"python\">from functools import partial\n\na = [2, float('nan'), 1]\nsorted(a, key=sort_with_na)                                         # Default\nsorted(a, key=partial(sort_with_na, reverse=False, na_last=True))   # Ascend, NA last\nsorted(a, key=partial(sort_with_na, reverse=False, na_last=False))  # Ascend, NA first\nsorted(a, key=partial(sort_with_na, reverse=True, na_last=True))    # Descend, NA last\nsorted(a, key=partial(sort_with_na, reverse=True, na_last=False))   # Descend, NA first\n</code></pre>\n", "abstract": "Regardless of standards, there are many cases where a user-defined ordering of float and NA values is useful. For instance, I was sorting stock returns and wanted highest to lowest with NA last (since those were irrelevant). There are 4 possible combinations Here is a function that covers all scenarios by conditionally replacing NA values with +/- inf Testing out each of the 4 combinations"}, {"id": 66706732, "score": 0, "vote": 0, "content": "<p>A resilient sort involves a compare of 2 items and returning: less, equal, greater.</p>\n<p>If <code>cmp(a,b)</code> is \"greater\", then <code>cmp(b,a)</code> must be \"less\".</p>\n<p>If <code>cmp(a,b)</code> is \"zero\", then <code>cmp(b,a)</code> must be \"zero\".</p>\n<p>What is missing in answers to date is the case of comparing 2 <code>float</code>s which are both <a href=\"https://en.wikipedia.org/wiki/NaN\" rel=\"nofollow noreferrer\">NAN</a>s and preserving the above properties.  2 NANs should compare as equal or perhaps based on some consistent interpretation of their payloads.</p>\n<p>Alternate compare <em>algorithm</em> to put all NAN &gt; +inf</p>\n<pre><code class=\"python\">if isnan(a)\n  if isnan(b)\n    return 0 (or maybe compare payloads/bit patterns)\n  return 1\nif isnan(b) return 1\nif a &gt; b return 1\nif a &lt; b return -1\nreturn 0\n</code></pre>\n", "abstract": "A resilient sort involves a compare of 2 items and returning: less, equal, greater. If cmp(a,b) is \"greater\", then cmp(b,a) must be \"less\". If cmp(a,b) is \"zero\", then cmp(b,a) must be \"zero\". What is missing in answers to date is the case of comparing 2 floats which are both NANs and preserving the above properties.  2 NANs should compare as equal or perhaps based on some consistent interpretation of their payloads. Alternate compare algorithm to put all NAN > +inf"}]}, {"link": "https://stackoverflow.com/questions/14931769/how-to-get-all-combination-of-n-binary-value", "question": {"id": "14931769", "title": "How to get all combination of n binary value?", "content": "<p>In Python, how can I get all combinations of <code>n</code> binary values <code>0</code> and <code>1</code>?</p>\n<p>For example, if <code>n = 3</code>, I want to have</p>\n<pre><code class=\"python\">[ [0,0,0], [0,0,1], [0,1,0], [0,1,1], ... [1,1,1] ]  #total 2^3 combinations\n</code></pre>\n<p>How can I do this?</p>\n", "abstract": "In Python, how can I get all combinations of n binary values 0 and 1? For example, if n = 3, I want to have How can I do this?"}, "answers": [{"id": 14931808, "score": 89, "vote": 0, "content": "<p>Use <a href=\"http://docs.python.org/2/library/itertools.html#itertools.product\"><code>itertools.product</code></a></p>\n<pre><code class=\"python\">import itertools\nlst = list(itertools.product([0, 1], repeat=3))\n</code></pre>\n<p>This will yield a list of tuples (see <a href=\"http://ideone.com/rXZsIG\">here</a>)</p>\n<p>You can easily change this to use a variable <code>repeat</code>:</p>\n<pre><code class=\"python\">n = 3\nlst = list(itertools.product([0, 1], repeat=n))\n</code></pre>\n<p>If you need a list of lists, then you can use the <code>map</code> function (thanks @Aesthete).</p>\n<pre><code class=\"python\">lst = map(list, itertools.product([0, 1], repeat=n))\n</code></pre>\n<p>Or in Python 3:</p>\n<pre><code class=\"python\">lst = list(map(list, itertools.product([0, 1], repeat=n)))\n# OR\nlst = [list(i) for i in itertools.product([0, 1], repeat=n)]\n</code></pre>\n<p>Note that using <code>map</code> or a list comprehension means you don't need to convert the product into a list, as it will iterate through the <code>itertools.product</code> object and produce a list.</p>\n", "abstract": "Use itertools.product This will yield a list of tuples (see here) You can easily change this to use a variable repeat: If you need a list of lists, then you can use the map function (thanks @Aesthete). Or in Python 3: Note that using map or a list comprehension means you don't need to convert the product into a list, as it will iterate through the itertools.product object and produce a list."}, {"id": 14932354, "score": 16, "vote": 0, "content": "<p>Without using any in-build functions or smart techniques we can get like this.</p>\n<pre><code class=\"python\">def per(n):\n    for i in range(1&lt;&lt;n):\n        s=bin(i)[2:]\n        s='0'*(n-len(s))+s\n        print (map(int,list(s)))\nper(3)       \n</code></pre>\n<p>output</p>\n<pre><code class=\"python\">[0, 0, 0]\n[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]\n[1, 1, 1]\n</code></pre>\n", "abstract": "Without using any in-build functions or smart techniques we can get like this. output"}, {"id": 14931812, "score": 3, "vote": 0, "content": "<p>Following will give you all such combinations</p>\n<pre><code class=\"python\">bin = [0,1]\n[ (x,y,z) for x in bin for y in bin for z in bin ]\n</code></pre>\n", "abstract": "Following will give you all such combinations"}]}, {"link": "https://stackoverflow.com/questions/2993214/log2-in-python-math-module", "question": {"id": "2993214", "title": "log2 in python math module", "content": "<p>why doesn't it exist?</p>\n<pre><code class=\"python\">import math\n[x for x in dir(math) if 'log' in x]\n&gt;&gt;&gt; ['log', 'log10', 'log1p']\n</code></pre>\n<p>I know I can do log(x,2), but log2 is really common, so I'm kind of baffled.</p>\n<p>Oh, it looks like it's only defined in C99, not C90, I guess that answers my question. Still seems kind of silly.</p>\n", "abstract": "why doesn't it exist? I know I can do log(x,2), but log2 is really common, so I'm kind of baffled. Oh, it looks like it's only defined in C99, not C90, I guess that answers my question. Still seems kind of silly."}, "answers": [{"id": 2993288, "score": 55, "vote": 0, "content": "<p>I think you've answered your own question.  :-) There's no <code>log2(x)</code> because you can do <code>log(x, 2)</code>.  As The Zen of Python (<a href=\"http://www.python.org/dev/peps/pep-0020/\" rel=\"noreferrer\">PEP 20</a>) says, \"There should be one-- and preferably only one --obvious way to do it.\"</p>\n<p>That said, <code>log2</code> was considered in <a href=\"http://bugs.python.org/issue3366\" rel=\"noreferrer\">Issue3366</a> (scroll down to the last 3 messages) which added several other C99 math functions to the <code>math</code> module for Python 2.7 and 3.2.</p>\n<p><strong>Edit</strong>: log2 was reconsidered in <a href=\"http://bugs.python.org/issue11888\" rel=\"noreferrer\">Issue11888</a> and added in Python 3.3.</p>\n", "abstract": "I think you've answered your own question.  :-) There's no log2(x) because you can do log(x, 2).  As The Zen of Python (PEP 20) says, \"There should be one-- and preferably only one --obvious way to do it.\" That said, log2 was considered in Issue3366 (scroll down to the last 3 messages) which added several other C99 math functions to the math module for Python 2.7 and 3.2. Edit: log2 was reconsidered in Issue11888 and added in Python 3.3."}, {"id": 22356859, "score": 6, "vote": 0, "content": "<p>I'm not sure that there is that you want, but:</p>\n<p>-- From math point of view you can do for example math.log(x)/math.log(2).</p>\n<p>-- If input X has an integral type and you are waiting for the integral rounded result - you can do it rather faster with right shifting. This works with SHR command and without Taylor series + local interpolation, which is under the hood of libc log() calls.</p>\n", "abstract": "I'm not sure that there is that you want, but: -- From math point of view you can do for example math.log(x)/math.log(2). -- If input X has an integral type and you are waiting for the integral rounded result - you can do it rather faster with right shifting. This works with SHR command and without Taylor series + local interpolation, which is under the hood of libc log() calls."}, {"id": 66403482, "score": 0, "vote": 0, "content": "<p>For anyone else arriving this late, Python 3.3 and later has math.log2.  It's \"usually more accurate than log(x, 2),\" or log(x)/log(2), I would guess.  There is also int.bit_length().</p>\n<p><a href=\"https://stackoverflow.com/questions/3719631/log-to-the-base-2-in-python/28033134\">Log to the base 2 in python</a></p>\n<p><a href=\"https://docs.python.org/3/library/math.html\" rel=\"nofollow noreferrer\">https://docs.python.org/3/library/math.html</a></p>\n", "abstract": "For anyone else arriving this late, Python 3.3 and later has math.log2.  It's \"usually more accurate than log(x, 2),\" or log(x)/log(2), I would guess.  There is also int.bit_length(). Log to the base 2 in python https://docs.python.org/3/library/math.html"}]}, {"link": "https://stackoverflow.com/questions/70793490/how-do-i-calculate-square-root-in-python", "question": {"id": "70793490", "title": "How do I calculate square root in Python?", "content": "<p>I need to calculate the square root of some numbers, for example <code>\u221a9 = 3</code> and <code>\u221a2 = 1.4142</code>. How can I do it in Python?</p>\n<p>The inputs will probably be all positive integers, and relatively small (say less than a billion), but just in case they're not, is there anything that might break?</p>\n<hr/>\n<p><strong>Related</strong></p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/15390807/integer-square-root-in-python\">Integer square root in python</a>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/15978781/how-to-find-integer-nth-roots\">How to find integer nth roots?</a></li>\n</ul>\n</li>\n<li><a href=\"https://stackoverflow.com/questions/19255120/is-there-a-short-hand-for-nth-root-of-x-in-python\">Is there a short-hand for nth root of x in Python?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/33684948/difference-between-1-2-math-sqrt-and-cmath-sqrt\">Difference between **(1/2), math.sqrt and cmath.sqrt?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/41551529/why-is-math-sqrt-incorrect-for-large-numbers\">Why is math.sqrt() incorrect for large numbers?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/28239978/python-sqrt-limit\">Python sqrt limit for very large numbers?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/327002/which-is-faster-in-python-x-5-or-math-sqrtx\">Which is faster in Python: x**.5 or math.sqrt(x)?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9595135/why-does-python-give-the-wrong-answer-for-square-root\">Why does Python give the \"wrong\" answer for square root?</a> (specific to Python 2)</li>\n<li><a href=\"https://stackoverflow.com/questions/15424123/calculating-n-th-roots-using-python-3s-decimal-module\">calculating n-th roots using Python 3's decimal module</a></li>\n<li><a href=\"https://stackoverflow.com/questions/17766774/how-can-i-take-the-square-root-of-1-using-python\">How can I take the square root of -1 using python?</a> (focused on NumPy)</li>\n<li><a href=\"https://stackoverflow.com/questions/10725522/arbitrary-precision-of-square-roots\">Arbitrary precision of square roots</a></li>\n</ul>\n<p><em><sub><strong>Note</strong>: This is an attempt at a <a href=\"https://meta.stackoverflow.com/q/291992/4518341\">canonical question</a> after <a href=\"https://meta.stackoverflow.com/questions/415385/how-can-we-handle-a-question-where-the-problem-in-the-title-is-different-from-th\">a discussion on Meta</a> about <a href=\"https://stackoverflow.com/questions/9595135/why-does-python-give-the-wrong-answer-for-square-root\">an existing question with the same title</a>.</sub></em></p>\n", "abstract": "I need to calculate the square root of some numbers, for example \u221a9 = 3 and \u221a2 = 1.4142. How can I do it in Python? The inputs will probably be all positive integers, and relatively small (say less than a billion), but just in case they're not, is there anything that might break? Related Note: This is an attempt at a canonical question after a discussion on Meta about an existing question with the same title."}, "answers": [{"id": 70793491, "score": 71, "vote": 0, "content": "<h2>Option 1: <code>math.sqrt()</code></h2>\n<p>The <code>math</code> module from the standard library has <a href=\"https://docs.python.org/3/library/math.html#math.sqrt\" rel=\"noreferrer\">a <code>sqrt</code> function</a> to calculate the square root of a number. It takes any type that <a href=\"https://stackoverflow.com/questions/10034097/how-to-overload-float-for-a-custom-class-in-python\">can be converted to <code>float</code></a> (which includes <code>int</code>) as an argument and returns a <code>float</code>.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.sqrt(9)\n3.0\n</code></pre>\n<h2>Option 2: Fractional exponent</h2>\n<p><a href=\"https://docs.python.org/3/reference/expressions.html#the-power-operator\" rel=\"noreferrer\">The power operator (<code>**</code>)</a> or the built-in <a href=\"https://docs.python.org/3/library/functions.html#pow\" rel=\"noreferrer\"><code>pow()</code></a> function can also be used to calculate a square root. Mathematically speaking, <a href=\"https://math.stackexchange.com/questions/537383/why-is-x-frac12-the-same-as-sqrt-x\">the square root of <code>a</code> equals <code>a</code> to the power of <code>1/2</code>.</a></p>\n<p>The power operator requires numeric types and matches <a href=\"https://docs.python.org/3/reference/expressions.html#arithmetic-conversions\" rel=\"noreferrer\">the conversion rules for binary arithmetic operators</a>, so in this case it will return either a <code>float</code> or a <code>complex</code> number.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 9 ** (1/2)\n3.0\n&gt;&gt;&gt; 9 ** .5  # Same thing\n3.0\n&gt;&gt;&gt; 2 ** .5\n1.4142135623730951\n</code></pre>\n<p>(Note: in Python 2, <code>1/2</code> is truncated to <code>0</code>, so you have to force floating point arithmetic with <code>1.0/2</code> or similar. See <a href=\"https://stackoverflow.com/questions/9595135/why-does-python-give-the-wrong-answer-for-square-root\">Why does Python give the \"wrong\" answer for square root?</a>)</p>\n<p>This method can be generalized to <a href=\"https://stackoverflow.com/questions/19255120/is-there-a-short-hand-for-nth-root-of-x-in-python\">nth root</a>, though fractions that can't be exactly represented as a <code>float</code> (like 1/3 or any denominator that's not a power of 2) may cause some inaccuracy:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 8 ** (1/3)\n2.0\n&gt;&gt;&gt; 125 ** (1/3)\n4.999999999999999\n</code></pre>\n<h2>Edge cases</h2>\n<h3>Negative and complex</h3>\n<p>Exponentiation works with negative numbers and complex numbers, though the results have some slight inaccuracy:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; (-25) ** .5  # Should be 5j\n(3.061616997868383e-16+5j)\n&gt;&gt;&gt; 8j ** .5  # Should be 2+2j\n(2.0000000000000004+2j)\n</code></pre>\n<p>Note the parentheses on <code>-25</code>! Otherwise it's parsed as <code>-(25**.5)</code> because <a href=\"https://docs.python.org/3/reference/expressions.html#operator-precedence\" rel=\"noreferrer\">exponentiation is more tightly binding than unary negation</a>.</p>\n<p>Meanwhile, <code>math</code> is only built for floats, so for <code>x&lt;0</code>, <code>math.sqrt(x)</code> will raise <code>ValueError: math domain error</code> and for complex <code>x</code>, it'll raise <code>TypeError: can't convert complex to float</code>. Instead, you can use <a href=\"https://docs.python.org/3/library/cmath.html#cmath.sqrt\" rel=\"noreferrer\"><code>cmath.sqrt(x)</code></a>, which is more more accurate than exponentiation (and will likely be faster too):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import cmath\n&gt;&gt;&gt; cmath.sqrt(-25)\n5j\n&gt;&gt;&gt; cmath.sqrt(8j)\n(2+2j)\n</code></pre>\n<h3>Precision</h3>\n<p>Both options involve an implicit conversion to <code>float</code>, so <a href=\"https://stackoverflow.com/q/41551529/4518341\">floating point precision is a factor</a>. For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; n = 10**30\n&gt;&gt;&gt; x = n**2\n&gt;&gt;&gt; root = x**.5\n&gt;&gt;&gt; n == root\nFalse\n&gt;&gt;&gt; n - root  # how far off are they?\n0.0\n&gt;&gt;&gt; int(root) - n  # how far off is the float from the int?\n19884624838656\n</code></pre>\n<p>Very large numbers might not even fit in a float and you'll get <code>OverflowError: int too large to convert to float</code>. See <a href=\"https://stackoverflow.com/questions/28239978/python-sqrt-limit\">Python sqrt limit for very large numbers?</a></p>\n<h3>Other types</h3>\n<p>Let's look at <a href=\"https://docs.python.org/3/library/decimal.html#decimal.Decimal\" rel=\"noreferrer\"><code>Decimal</code></a> for example:</p>\n<p>Exponentiation fails unless the exponent is also <code>Decimal</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; decimal.Decimal('9') ** .5\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for ** or pow(): 'decimal.Decimal' and 'float'\n&gt;&gt;&gt; decimal.Decimal('9') ** decimal.Decimal('.5')\nDecimal('3.000000000000000000000000000')\n</code></pre>\n<p>Meanwhile, <code>math</code> and <code>cmath</code> will silently convert their arguments to <code>float</code> and <code>complex</code> respectively, which could mean loss of precision.</p>\n<p><code>decimal</code> also has its own <a href=\"https://docs.python.org/3/library/decimal.html#decimal.Decimal.sqrt\" rel=\"noreferrer\"><code>.sqrt()</code></a>. See also <a href=\"https://stackoverflow.com/questions/15424123/calculating-n-th-roots-using-python-3s-decimal-module\">calculating n-th roots using Python 3's decimal module</a></p>\n", "abstract": "The math module from the standard library has a sqrt function to calculate the square root of a number. It takes any type that can be converted to float (which includes int) as an argument and returns a float. The power operator (**) or the built-in pow() function can also be used to calculate a square root. Mathematically speaking, the square root of a equals a to the power of 1/2. The power operator requires numeric types and matches the conversion rules for binary arithmetic operators, so in this case it will return either a float or a complex number. (Note: in Python 2, 1/2 is truncated to 0, so you have to force floating point arithmetic with 1.0/2 or similar. See Why does Python give the \"wrong\" answer for square root?) This method can be generalized to nth root, though fractions that can't be exactly represented as a float (like 1/3 or any denominator that's not a power of 2) may cause some inaccuracy: Exponentiation works with negative numbers and complex numbers, though the results have some slight inaccuracy: Note the parentheses on -25! Otherwise it's parsed as -(25**.5) because exponentiation is more tightly binding than unary negation. Meanwhile, math is only built for floats, so for x<0, math.sqrt(x) will raise ValueError: math domain error and for complex x, it'll raise TypeError: can't convert complex to float. Instead, you can use cmath.sqrt(x), which is more more accurate than exponentiation (and will likely be faster too): Both options involve an implicit conversion to float, so floating point precision is a factor. For example: Very large numbers might not even fit in a float and you'll get OverflowError: int too large to convert to float. See Python sqrt limit for very large numbers? Let's look at Decimal for example: Exponentiation fails unless the exponent is also Decimal: Meanwhile, math and cmath will silently convert their arguments to float and complex respectively, which could mean loss of precision. decimal also has its own .sqrt(). See also calculating n-th roots using Python 3's decimal module"}, {"id": 70803034, "score": 23, "vote": 0, "content": "<h2>SymPy</h2>\n<p>Depending on your goal, it might be a good idea to delay the calculation of square roots for as long as possible. <a href=\"https://www.sympy.org/en/index.html\" rel=\"noreferrer\">SymPy</a> might help.</p>\n<blockquote>\n<p>SymPy is a Python library for symbolic mathematics.</p>\n</blockquote>\n<pre><code class=\"python\">import sympy\nsympy.sqrt(2)\n# =&gt; sqrt(2)\n</code></pre>\n<p>This doesn't seem very useful at first.</p>\n<p>But sympy can give more information than floats or Decimals:</p>\n<pre><code class=\"python\">sympy.sqrt(8) / sympy.sqrt(27)\n# =&gt; 2*sqrt(6)/9\n</code></pre>\n<p>Also, no precision is lost. (\u221a2)\u00b2 is still an integer:</p>\n<pre><code class=\"python\">s = sympy.sqrt(2)\ns**2\n# =&gt; 2\ntype(s**2)\n#=&gt; &lt;class 'sympy.core.numbers.Integer'&gt;\n</code></pre>\n<p>In comparison, floats and Decimals would return a number which is very close to 2 but not equal to 2:</p>\n<pre><code class=\"python\">(2**0.5)**2\n# =&gt; 2.0000000000000004\n\nfrom decimal import Decimal\n(Decimal('2')**Decimal('0.5'))**Decimal('2')\n# =&gt; Decimal('1.999999999999999999999999999')\n</code></pre>\n<p>Sympy also understands more complex examples like <a href=\"https://en.wikipedia.org/wiki/Gaussian_integral\" rel=\"noreferrer\">the Gaussian integral</a>:</p>\n<pre><code class=\"python\">from sympy import Symbol, integrate, pi, sqrt, exp, oo\nx = Symbol('x')\nintegrate(exp(-x**2), (x, -oo, oo))\n# =&gt; sqrt(pi)\nintegrate(exp(-x**2), (x, -oo, oo)) == sqrt(pi)\n# =&gt; True\n</code></pre>\n<p>Finally, if a decimal representation is desired, it's possible to ask for more digits than will ever be needed:</p>\n<pre><code class=\"python\">sympy.N(sympy.sqrt(2), 1_000_000)\n# =&gt; 1.4142135623730950488016...........2044193016904841204\n</code></pre>\n", "abstract": "Depending on your goal, it might be a good idea to delay the calculation of square roots for as long as possible. SymPy might help. SymPy is a Python library for symbolic mathematics. This doesn't seem very useful at first. But sympy can give more information than floats or Decimals: Also, no precision is lost. (\u221a2)\u00b2 is still an integer: In comparison, floats and Decimals would return a number which is very close to 2 but not equal to 2: Sympy also understands more complex examples like the Gaussian integral: Finally, if a decimal representation is desired, it's possible to ask for more digits than will ever be needed:"}, {"id": 70794500, "score": 15, "vote": 0, "content": "<h2>NumPy</h2>\n<pre><code class=\"python\">&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; np.sqrt(25)\n5.0\n&gt;&gt;&gt; np.sqrt([2, 3, 4])\narray([1.41421356, 1.73205081, 2.        ])\n</code></pre>\n<p><a href=\"https://numpy.org/doc/stable/reference/generated/numpy.sqrt\" rel=\"nofollow noreferrer\">docs</a></p>\n<h3>Negative</h3>\n<p>For negative reals, it'll return <code>nan</code>, so <a href=\"https://numpy.org/doc/stable/reference/generated/numpy.emath.sqrt\" rel=\"nofollow noreferrer\"><code>np.emath.sqrt()</code></a> is available for that case.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = np.array([4, -1, np.inf])\n&gt;&gt;&gt; np.sqrt(a)\n&lt;stdin&gt;:1: RuntimeWarning: invalid value encountered in sqrt\narray([ 2., nan, inf])\n&gt;&gt;&gt; np.emath.sqrt(a)\narray([ 2.+0.j,  0.+1.j, inf+0.j])\n</code></pre>\n<p>Another option, of course, is to convert to complex first:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = a.astype(complex)\n&gt;&gt;&gt; np.sqrt(a)\narray([ 2.+0.j,  0.+1.j, inf+0.j])\n</code></pre>\n", "abstract": "docs For negative reals, it'll return nan, so np.emath.sqrt() is available for that case. Another option, of course, is to convert to complex first:"}, {"id": 70806866, "score": 4, "vote": 0, "content": "<p>Python's <a href=\"https://docs.python.org/3/library/fractions.html\" rel=\"nofollow noreferrer\"><code>fractions</code></a> module and its class, <code>Fraction</code>, implement arithmetic with rational numbers. The <code>Fraction</code> class doesn't implement a square root operation, because most square roots are irrational numbers. However, it can be used to approximate a square root with arbitrary accuracy, because a <code>Fraction</code>'s numerator and denominator are arbitrary-precision integers.</p>\n<p>The following method takes a positive number <code>x</code> and a number of iterations, and returns upper and lower bounds for the square root of <code>x</code>.</p>\n<pre><code class=\"python\">from fractions import Fraction\n\ndef sqrt(x, n):\n    x = x if isinstance(x, Fraction) else Fraction(x)\n    upper = x + 1\n    for i in range(0, n):\n        upper = (upper + x/upper) / 2\n    lower = x / upper\n    if lower &gt; upper:\n        raise ValueError(\"Sanity check failed\")\n    return (lower, upper)\n</code></pre>\n<p>See the reference below for details on this operation's implementation. It also shows how to implement other operations with upper and lower bounds (although there is apparently at least one error with the <code>log</code> operation there).</p>\n<ul>\n<li>Daumas, M., Lester, D., Mu\u00f1oz, C., \"Verified Real Number Calculations: A Library for Interval Arithmetic\", arXiv:0708.3721 [cs.MS], 2007.</li>\n</ul>\n<p>Alternatively, using Python's <code>math.isqrt</code>, we can calculate a square root to arbitrary precision:</p>\n<ul>\n<li>Square root of <code>i</code> within 1/2<sup><em>n</em></sup> of the correct value, where <code>i</code> is an integer:<code>Fraction(math.isqrt(i * 2**(n*2)), 2**n)</code>.</li>\n<li>Square root of <code>i</code> within 1/10<sup><em>n</em></sup> of the correct value, where <code>i</code> is an integer:<code>Fraction(math.isqrt(i * 10**(n*2)), 10**n)</code>.</li>\n<li>Square root of <code>x</code> within 1/2<sup><em>n</em></sup> of the correct value, where <code>x</code> is a multiple of 1/2<sup><em>n</em></sup>:<code>Fraction(math.isqrt(x * 2**(n)), 2**n)</code>.</li>\n<li>Square root of <code>x</code> within 1/10<sup><em>n</em></sup> of the correct value, where <code>x</code> is a multiple of 1/10<sup><em>n</em></sup>:<code>Fraction(math.isqrt(x * 10**(n)), 10**n)</code>.</li>\n</ul>\n<p>In the foregoing, <code>i</code> or <code>x</code> must be 0 or greater.</p>\n", "abstract": "Python's fractions module and its class, Fraction, implement arithmetic with rational numbers. The Fraction class doesn't implement a square root operation, because most square roots are irrational numbers. However, it can be used to approximate a square root with arbitrary accuracy, because a Fraction's numerator and denominator are arbitrary-precision integers. The following method takes a positive number x and a number of iterations, and returns upper and lower bounds for the square root of x. See the reference below for details on this operation's implementation. It also shows how to implement other operations with upper and lower bounds (although there is apparently at least one error with the log operation there). Alternatively, using Python's math.isqrt, we can calculate a square root to arbitrary precision: In the foregoing, i or x must be 0 or greater."}, {"id": 70807289, "score": 4, "vote": 0, "content": "<h2>Newton's method</h2>\n<p>Most simple and accurate way to compute square root is Newton's method.</p>\n<p>You have a number which you want to compute its square root (<code>num</code>) and you have a guess of its square root (<code>estimate</code>). Estimate can be any number bigger than 0, but a number that makes sense shortens the recursive call depth significantly.</p>\n<pre><code class=\"python\">new_estimate = (estimate + num/estimate) / 2\n</code></pre>\n<p>This line computes a more accurate estimate with those 2 parameters. You can pass <code>new_estimate</code> value to the function and compute another <code>new_estimate</code> which is more accurate than the previous one or you can make a recursive function definition like this.</p>\n<pre><code class=\"python\">def newtons_method(num, estimate):\n    # Computing a new_estimate\n    new_estimate = (estimate + num/estimate) / 2\n    print(new_estimate)\n    # Base Case: Comparing our estimate with built-in functions value\n    if new_estimate == math.sqrt(num):\n        return True\n    else:\n        return newtons_method(num, new_estimate)\n</code></pre>\n<p>For example we need to find 30's square root. We know that the result is between 5 and 6.</p>\n<pre><code class=\"python\">newtons_method(30,5)\n</code></pre>\n<p>number is 30 and estimate is 5. The result from each recursive calls are:</p>\n<pre><code class=\"python\">5.5\n5.477272727272727\n5.4772255752546215\n5.477225575051661\n</code></pre>\n<p>The last result is the most accurate computation of the square root of number. It is the same value as the built-in function <code>math.sqrt()</code>.</p>\n<hr/>\n<p><em>This answer was <a href=\"https://stackoverflow.com/a/48438631/4518341\">originally posted</a> by <a href=\"https://stackoverflow.com/users/7975962/gunesevitan\">gunesevitan</a>, but is now deleted.</em></p>\n", "abstract": "Most simple and accurate way to compute square root is Newton's method. You have a number which you want to compute its square root (num) and you have a guess of its square root (estimate). Estimate can be any number bigger than 0, but a number that makes sense shortens the recursive call depth significantly. This line computes a more accurate estimate with those 2 parameters. You can pass new_estimate value to the function and compute another new_estimate which is more accurate than the previous one or you can make a recursive function definition like this. For example we need to find 30's square root. We know that the result is between 5 and 6. number is 30 and estimate is 5. The result from each recursive calls are: The last result is the most accurate computation of the square root of number. It is the same value as the built-in function math.sqrt(). This answer was originally posted by gunesevitan, but is now deleted."}, {"id": 70805096, "score": 3, "vote": 0, "content": "<h1>Binary search</h1>\n<p><strong>Disclaimer:</strong> this is for a more specialised use-case. This method might not be practical in all circumstances.</p>\n<p>Benefits:</p>\n<ul>\n<li>can find integer values (i.e. which <strong>integer</strong> is the root?)</li>\n<li>no need to convert to float, so better precision (can be done that well too)</li>\n</ul>\n<p>I personally implemented this one for a crypto CTF challenge (RSA cube root attack),where I needed a precise integer value.</p>\n<p>The general idea can be extended to any other root.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def int_squareroot(d: int) -&gt; tuple[int, bool]:\n    \"\"\"Try calculating integer squareroot and return if it's exact\"\"\"\n    left, right = 1, (d+1)//2\n    while left&lt;right-1:\n        x = (left+right)//2\n        if x**2 &gt; d:\n            left, right = left, x\n        else:\n            left, right = x, right\n    return left, left**2==d\n</code></pre>\n<h2>EDIT:</h2>\n<p>As @wjandrea have also pointed out, **this example code can NOT compute **. This is a side-effect of the fact that it does not convert anything into floats, so no precision is lost. If the root is an integer, you get that back. If it's not, you get the biggest number whose square is smaller than your number. I updated the code so that it also returns a bool indicating if the value is correct or not, and also fixed an issue causing it to loop infinitely (also pointed out by @wjandrea). This implementation of the general method still works kindof weird for smaller numbers, but above 10 I had no problems with.</p>\n<h3>Overcoming the issues and limits of this method/implementation:</h3>\n<p>For smaller numbers, you can just use all the other methods from other answers. They generally use floats, which <em>might</em> be a loss of precision, but for small integers that should mean no problem at all. All of those methods that use floats have the same (or nearly the same) limit from this.</p>\n<p>If you still want to use this method and get float results, it should be trivial to convert this to use floats too. Note that that will reintroduce precision loss, this method's unique benefit over the others, and in that case you can also just use any of the other answers. I think the newton's method version converges a bit faster, but I'm not sure.</p>\n<p>For larger numbers, where loss of precision with floats come into play, this method can give results closer to the actual answer (depending on how big is the input). If you want to work with non-integers in this range, you can use other types, for example fixed precision numbers in this method too.</p>\n<h2>Edit 2, on other answers:</h2>\n<p>Currently, and afaik, the only other answer that has similar or better precision for large numbers than this implementation is the one that suggest SymPy, by Eric Duminil. That version is also easier to use, and work for any kind of number, the only downside is that it requires SymPy. My implementation is free from any huge dependencies if that is what you are looking for.</p>\n", "abstract": "Disclaimer: this is for a more specialised use-case. This method might not be practical in all circumstances. Benefits: I personally implemented this one for a crypto CTF challenge (RSA cube root attack),where I needed a precise integer value. The general idea can be extended to any other root. As @wjandrea have also pointed out, **this example code can NOT compute **. This is a side-effect of the fact that it does not convert anything into floats, so no precision is lost. If the root is an integer, you get that back. If it's not, you get the biggest number whose square is smaller than your number. I updated the code so that it also returns a bool indicating if the value is correct or not, and also fixed an issue causing it to loop infinitely (also pointed out by @wjandrea). This implementation of the general method still works kindof weird for smaller numbers, but above 10 I had no problems with. For smaller numbers, you can just use all the other methods from other answers. They generally use floats, which might be a loss of precision, but for small integers that should mean no problem at all. All of those methods that use floats have the same (or nearly the same) limit from this. If you still want to use this method and get float results, it should be trivial to convert this to use floats too. Note that that will reintroduce precision loss, this method's unique benefit over the others, and in that case you can also just use any of the other answers. I think the newton's method version converges a bit faster, but I'm not sure. For larger numbers, where loss of precision with floats come into play, this method can give results closer to the actual answer (depending on how big is the input). If you want to work with non-integers in this range, you can use other types, for example fixed precision numbers in this method too. Currently, and afaik, the only other answer that has similar or better precision for large numbers than this implementation is the one that suggest SymPy, by Eric Duminil. That version is also easier to use, and work for any kind of number, the only downside is that it requires SymPy. My implementation is free from any huge dependencies if that is what you are looking for."}, {"id": 70850586, "score": 3, "vote": 0, "content": "<h3>Arbitrary precision square root</h3>\n<p>This variation uses string manipulations to convert a string which represents a decimal floating-point number to an <code>int</code>, calls <a href=\"https://docs.python.org/3/library/math.html#math.isqrt\" rel=\"nofollow noreferrer\"><code>math.isqrt</code></a> to do the actual square root extraction, and then formats the result as a decimal string. <code>math.isqrt</code> rounds down, so all produced digits are correct.</p>\n<p>The input string, <code>num</code>, must use plain float format: 'e' notation is not supported. The <code>num</code> string can be a plain integer, and leading zeroes are ignored.</p>\n<p>The <code>digits</code> argument specifies the number of decimal places in the result string, i.e., the number of digits after the decimal point.</p>\n<pre><code class=\"python\">from math import isqrt\n\ndef str_sqrt(num, digits):\n    \"\"\" Arbitrary precision square root\n\n        num arg must be a string\n        Return a string with `digits` after\n        the decimal point\n\n        Written by PM 2Ring 2022.01.26\n    \"\"\"\n\n    int_part , _, frac_part = num.partition('.')\n    num = int_part + frac_part\n\n    # Determine the required precision\n    width = 2 * digits - len(frac_part)\n\n    # Truncate or pad with zeroes\n    num = num[:width] if width &lt; 0 else num + '0' * width\n    s = str(isqrt(int(num)))\n\n    if digits:\n        # Pad, if necessary\n        s = '0' * (1 + digits - len(s)) + s\n        s = f\"{s[:-digits]}.{s[-digits:]}\"\n    return s\n</code></pre>\n<h4>Test</h4>\n<pre><code class=\"python\">print(str_sqrt(\"2.0\", 30))\n</code></pre>\n<h4>Output</h4>\n<pre><code class=\"python\">1.414213562373095048801688724209\n</code></pre>\n<hr/>\n<p>For small numbers of digits, it's faster to use <code>decimal.Decimal.sqrt</code>. Around 32 digits or so, <code>str_sqrt</code> is roughly the same speed as <code>Decimal.sqrt</code>. But at 128 digits, <code>str_sqrt</code> is 2.2\u00d7 faster than <code>Decimal.sqrt</code>, at 512 digits, it's 4.3\u00d7 faster, at 8192 digits, it's 7.4\u00d7 faster.</p>\n<p>Here's a <a href=\"https://sagecell.sagemath.org/?z=eJxtUsFq3DAQvfsrHs5h7WZjHBd6MDGk0GshhEIPYdlo1-ONYC17RzIhLfn3jiSvN4HqYDzSmzfvzUzHQ49euRfofhzYQdsTuyRpqYN1vPVRZqZ-jVYftLN5nUBOmqb4zjvtWPEbRqa9tnowsKdJMYGHQTgwH0mH4gP6yTrsCMoza3NYAI_kJjbLPV616HmOBZ-hOke8YN0LoZVyvTpiHLT5UOc3a-fIYPeGh5-oHj1VVVZVUd4W1bez7oiXxO2oxO8a2zU6VvsYNl5t4X-1E0PZqljlydlEc0m7vuREwiv8INHZa0NBI9Np0kztpTkB9qpb8dagwpe5o7jBkUy20OVnvl88mb1yhIExqjZ25Q_xQPaDIvk-1YF1A93N_HcoQUdLAXONVbmScuEpZFrJk1ZnYdaZePITzvO5srBEZfXS2Ss8qHbtXwztyVoZ-vLmyWKB7FZqfTJl81yu7Cdsl_61T_VNxG3eC4nmoN68pwHKcR9sktyLOJLOuLCQjmyQ2qQy0_S8ks3Xct7Kkb2X_65t_g-9X97P&amp;lang=python\" rel=\"nofollow noreferrer\">live version</a> running on the SageMathCell server.</p>\n", "abstract": "This variation uses string manipulations to convert a string which represents a decimal floating-point number to an int, calls math.isqrt to do the actual square root extraction, and then formats the result as a decimal string. math.isqrt rounds down, so all produced digits are correct. The input string, num, must use plain float format: 'e' notation is not supported. The num string can be a plain integer, and leading zeroes are ignored. The digits argument specifies the number of decimal places in the result string, i.e., the number of digits after the decimal point. For small numbers of digits, it's faster to use decimal.Decimal.sqrt. Around 32 digits or so, str_sqrt is roughly the same speed as Decimal.sqrt. But at 128 digits, str_sqrt is 2.2\u00d7 faster than Decimal.sqrt, at 512 digits, it's 4.3\u00d7 faster, at 8192 digits, it's 7.4\u00d7 faster. Here's a live version running on the SageMathCell server."}, {"id": 72154871, "score": -3, "vote": 0, "content": "<h1>find square-root of a number</h1>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">while True:\n    num = int(input(\"Enter a number:\\n&gt;&gt;\"))\n    for i in range(2, num):\n        if num % i == 0:\n            if i*i == num:\n                print(\"Square root of\", num, \"==&gt;\", i)\n                break\n    else:\n        kd = (num**0.5)  # (num**(1/2))\n        print(\"Square root of\", num, \"==&gt;\", kd)\n</code></pre>\n<p>OUTPUT:-</p>\n<blockquote>\n<p>Enter a number: 24<br/>\nSquare root of 24 ==&gt; 4.898979485566356<br/>\nEnter a number: 36<br/>\nSquare root of 36 ==&gt; 6<br/>\nEnter a number: 49<br/>\nSquare root of 49 ==&gt; 7</p>\n</blockquote>\n<h1>\u2714 Output \ud83d\udca1 CLICK BELOW &amp; SEE \u2714</h1>\n<p><a href=\"https://i.stack.imgur.com/Xd7UA.png\" rel=\"nofollow noreferrer\"><img alt=\"Output1\" src=\"https://i.stack.imgur.com/Xd7UA.png\"/></a>\n<br/><br/>\n<a href=\"https://i.stack.imgur.com/Qlwes.png\" rel=\"nofollow noreferrer\"><img alt=\"Output2\" src=\"https://i.stack.imgur.com/Qlwes.png\"/></a></p>\n", "abstract": "OUTPUT:- Enter a number: 24\nSquare root of 24 ==> 4.898979485566356\nEnter a number: 36\nSquare root of 36 ==> 6\nEnter a number: 49\nSquare root of 49 ==> 7 \n\n"}]}, {"link": "https://stackoverflow.com/questions/35902302/discarding-alpha-channel-from-images-stored-as-numpy-arrays", "question": {"id": "35902302", "title": "Discarding alpha channel from images stored as Numpy arrays", "content": "<p>I load images with numpy/scikit. I know that all images are 200x200 pixels.</p>\n<p>When the images are loaded, I notice some have an alpha channel, and therefore have shape (200, 200, 4) instead of (200, 200, 3) which I expect.</p>\n<p>Is there a way to delete that last value, discarding the alpha channel and get all images to a nice (200, 200, 3) shape?</p>\n", "abstract": "I load images with numpy/scikit. I know that all images are 200x200 pixels. When the images are loaded, I notice some have an alpha channel, and therefore have shape (200, 200, 4) instead of (200, 200, 3) which I expect. Is there a way to delete that last value, discarding the alpha channel and get all images to a nice (200, 200, 3) shape?"}, "answers": [{"id": 35902359, "score": 103, "vote": 0, "content": "<p>Just slice the array to get the first three entries of the last dimension:</p>\n<pre><code class=\"python\">image_without_alpha = image[:,:,:3]\n</code></pre>\n", "abstract": "Just slice the array to get the first three entries of the last dimension:"}, {"id": 67106088, "score": 3, "vote": 0, "content": "<p>scikit-image builtin:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from skimage.color import rgba2rgb\nfrom skimage import data\nimg_rgba = data.logo()\nimg_rgb = rgba2rgb(img_rgba)\n</code></pre>\n<p><a href=\"https://scikit-image.org/docs/dev/user_guide/transforming_image_data.html#conversion-from-rgba-to-rgb-removing-alpha-channel-through-alpha-blending\" rel=\"nofollow noreferrer\">https://scikit-image.org/docs/dev/user_guide/transforming_image_data.html#conversion-from-rgba-to-rgb-removing-alpha-channel-through-alpha-blending</a><br/>\n<a href=\"https://scikit-image.org/docs/dev/api/skimage.color.html#rgba2rgb\" rel=\"nofollow noreferrer\">https://scikit-image.org/docs/dev/api/skimage.color.html#rgba2rgb</a></p>\n", "abstract": "scikit-image builtin: https://scikit-image.org/docs/dev/user_guide/transforming_image_data.html#conversion-from-rgba-to-rgb-removing-alpha-channel-through-alpha-blending\nhttps://scikit-image.org/docs/dev/api/skimage.color.html#rgba2rgb"}]}, {"link": "https://stackoverflow.com/questions/25212181/is-the-golden-ratio-defined-in-python", "question": {"id": "25212181", "title": "Is the golden ratio defined in Python?", "content": "<p>Is there a way to get the golden ratio, <em><code>phi</code></em>, in the standard python module? I know of <em><code>e</code></em> and <em><code>pi</code></em> in the <code>math</code> module, but I might have missed <em><code>phi</code></em> defined somewhere. </p>\n", "abstract": "Is there a way to get the golden ratio, phi, in the standard python module? I know of e and pi in the math module, but I might have missed phi defined somewhere. "}, "answers": [{"id": 25212208, "score": 77, "vote": 0, "content": "<p><a href=\"http://docs.scipy.org/doc/scipy/reference/constants.html\" rel=\"noreferrer\"><code>scipy.constants</code></a> defines the golden ratio as <code>scipy.constants.golden</code>. It is nowhere defined in the standard library, presumably because it is easy to define yourself:</p>\n<pre><code class=\"python\">golden = (1 + 5 ** 0.5) / 2\n</code></pre>\n", "abstract": "scipy.constants defines the golden ratio as scipy.constants.golden. It is nowhere defined in the standard library, presumably because it is easy to define yourself:"}, {"id": 57173183, "score": 3, "vote": 0, "content": "<p>There isn't. However, since you are importing <strong>math</strong> anyway, <em>phi</em> may be calculated the same way <em>pi</em> would be calculated:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math\n&gt;&gt;&gt; pi = 4 * math.atan(1)\n&gt;&gt;&gt; pi\n3.141592653589793\n&gt;&gt;&gt; pi = math.acos(-1)\n&gt;&gt;&gt; pi\n3.141592653589793\n&gt;&gt;&gt; math.pi\n3.141592653589793\n&gt;&gt;&gt; phi = ( 1 + math.sqrt(5) ) / 2\n&gt;&gt;&gt; phi\n1.618033988749895\n</code></pre>\n<p>The reason <strong>math</strong> has <em>pi</em> and <em>e</em> defined but not <em>phi</em> may be because no one asked for it.</p>\n<hr/>\n<p>The python <strong>math</strong> docs says <a href=\"https://docs.python.org/3.3/library/math.html#math.pi\" rel=\"nofollow noreferrer\">math.pi</a> is \"The mathematical constant \u03c0 = 3.141592..., to available precision\". However, you may calculate four times the arc tangent of one and get <a href=\"https://en.wikipedia.org/wiki/Pi#Modern_quest_for_more_digits\" rel=\"nofollow noreferrer\">roughly the same result</a>: <code>pi = 4 * math.atan(1)</code>, or <code>pi = math.acos(-1)</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; math.pi == math.acos(-1) == 4 * math.atan(1)\nTrue\n</code></pre>\n<p>The same could be said about <em>phi</em>, which is not readily available as <code>math.phi</code> but you may find the nearest available precision with the <a href=\"https://en.wikipedia.org/wiki/Golden_ratio#Calculation\" rel=\"nofollow noreferrer\">solution to the quadratic equation x\u00b2 + x -1 = 0</a>: <code>phi = ( 1 + math.sqrt(5) ) / 2</code>.</p>\n", "abstract": "There isn't. However, since you are importing math anyway, phi may be calculated the same way pi would be calculated: The reason math has pi and e defined but not phi may be because no one asked for it. The python math docs says math.pi is \"The mathematical constant \u03c0 = 3.141592..., to available precision\". However, you may calculate four times the arc tangent of one and get roughly the same result: pi = 4 * math.atan(1), or pi = math.acos(-1): The same could be said about phi, which is not readily available as math.phi but you may find the nearest available precision with the solution to the quadratic equation x\u00b2 + x -1 = 0: phi = ( 1 + math.sqrt(5) ) / 2."}]}, {"link": "https://stackoverflow.com/questions/12043913/python-and-powers-math", "question": {"id": "12043913", "title": "Python and Powers Math", "content": "<p>I've been learning Python but I'm a little confused. Online instructors tell me to use the operator ** as opposed to ^ when I'm trying to raise to a certain number. Example:</p>\n<pre><code class=\"python\">print 8^3\n</code></pre>\n<p>Gives an output of 11. But what I'm look for (I'm told) is more akin to: print 8**3 which gives the correct answer of 512. But why?</p>\n<p>Can someone explain this to me? Why is it that 8^3 does not equal 512 as it is the correct answer? In what instance would 11 (the result of 8^3)? </p>\n<p>I did try to search SO but I'm only seeing information concerning getting a modulus when dividing. </p>\n", "abstract": "I've been learning Python but I'm a little confused. Online instructors tell me to use the operator ** as opposed to ^ when I'm trying to raise to a certain number. Example: Gives an output of 11. But what I'm look for (I'm told) is more akin to: print 8**3 which gives the correct answer of 512. But why? Can someone explain this to me? Why is it that 8^3 does not equal 512 as it is the correct answer? In what instance would 11 (the result of 8^3)?  I did try to search SO but I'm only seeing information concerning getting a modulus when dividing. "}, "answers": [{"id": 12043968, "score": 83, "vote": 0, "content": "<p>Operator <code>^</code> is a <a href=\"http://wiki.python.org/moin/BitwiseOperators\" rel=\"noreferrer\"><em>bitwise operator</em></a>, which does <strong>bitwise exclusive or</strong>.</p>\n<p><a href=\"http://docs.python.org/reference/expressions.html#the-power-operator\" rel=\"noreferrer\">The power operator</a> is <code>**</code>, like <strong><code>8**3</code></strong> which equals to <code>512</code>.</p>\n", "abstract": "Operator ^ is a bitwise operator, which does bitwise exclusive or. The power operator is **, like 8**3 which equals to 512."}, {"id": 12043929, "score": 16, "vote": 0, "content": "<p>The symbols represent different operators.</p>\n<p><a href=\"http://wiki.python.org/moin/BitwiseOperators\" rel=\"noreferrer\">The <code>^</code> represents the bitwise exclusive or (<code>XOR</code>)</a>.   </p>\n<blockquote>\n<p>Each bit of the output is the same as the corresponding bit in x if \n       that bit in y is 0, and it's the complement of the bit in x if that bit in y is 1.</p>\n</blockquote>\n<p><code>**</code> represents the power operator.  That's just the way that the language is structured.</p>\n", "abstract": "The symbols represent different operators. The ^ represents the bitwise exclusive or (XOR).    Each bit of the output is the same as the corresponding bit in x if \n       that bit in y is 0, and it's the complement of the bit in x if that bit in y is 1. ** represents the power operator.  That's just the way that the language is structured."}, {"id": 12043943, "score": 0, "vote": 0, "content": "<p>It's just that <code>^</code> does not mean \"exponent\" in Python.  It means \"bitwise XOR\".  See <a href=\"http://docs.python.org/reference/expressions.html#binary-bitwise-operations\" rel=\"nofollow\">the documentation</a>.</p>\n", "abstract": "It's just that ^ does not mean \"exponent\" in Python.  It means \"bitwise XOR\".  See the documentation."}]}, {"link": "https://stackoverflow.com/questions/3843017/efficiently-detect-sign-changes-in-python", "question": {"id": "3843017", "title": "Efficiently detect sign-changes in python", "content": "<p>I want to do exactly what this guy did:</p>\n<p><a href=\"https://stackoverflow.com/questions/2936834/python-counting-sign-changes\">Python - count sign changes</a></p>\n<p>However I need to optimize it to run super fast. In brief I want to take a time series and tell every time it crosses crosses zero (changes sign). I want to record the time in between zero crossings. Since this is real data (32 bit float) I doubt I'll every have a number which is exactly zero, so that is not important. I currently have a timing program in place so I'll time your results to see who wins.</p>\n<p>My solution gives (micro seconds):</p>\n<pre><code class=\"python\">open data       8384\nsign data       8123\nzcd data        415466\n</code></pre>\n<p>As you can see the zero-crossing detector is the slow part. Here's my code.</p>\n<pre><code class=\"python\">import numpy, datetime\n\nclass timer():\n    def __init__(self):\n        self.t0 = datetime.datetime.now()\n        self.t = datetime.datetime.now()\n    def __call__(self,text='unknown'):\n        print text,'\\t',(datetime.datetime.now()-self.t).microseconds\n        self.t=datetime.datetime.now()\n\ndef zcd(data,t):\n    sign_array=numpy.sign(data)\n    t('sign data')\n    out=[]\n    current = sign_array[0]\n    count=0\n    for i in sign_array[1:]:\n        if i!=current:\n            out.append(count)\n            current=i\n            count=0\n        else: count+=1\n    t('zcd data')\n    return out\n\ndef main():\n    t = timer()\n    data = numpy.fromfile('deci.dat',dtype=numpy.float32)\n    t('open data')\n    zcd(data,t)\n\nif __name__=='__main__':\n    main()\n</code></pre>\n", "abstract": "I want to do exactly what this guy did: Python - count sign changes However I need to optimize it to run super fast. In brief I want to take a time series and tell every time it crosses crosses zero (changes sign). I want to record the time in between zero crossings. Since this is real data (32 bit float) I doubt I'll every have a number which is exactly zero, so that is not important. I currently have a timing program in place so I'll time your results to see who wins. My solution gives (micro seconds): As you can see the zero-crossing detector is the slow part. Here's my code."}, "answers": [{"id": 3843124, "score": 96, "vote": 0, "content": "<p>What about:</p>\n<pre><code class=\"python\">import numpy\na = [1, 2, 1, 1, -3, -4, 7, 8, 9, 10, -2, 1, -3, 5, 6, 7, -10]\nzero_crossings = numpy.where(numpy.diff(numpy.sign(a)))[0]\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">&gt; zero_crossings\narray([ 3,  5,  9, 10, 11, 12, 15])\n</code></pre>\n<p>I.e., zero_crossings will contain the indices of elements <em>before</em> which a zero crossing occurs.  If you want the elements <em>after</em>, just add 1 to that array.</p>\n", "abstract": "What about: Output: I.e., zero_crossings will contain the indices of elements before which a zero crossing occurs.  If you want the elements after, just add 1 to that array."}, {"id": 29674950, "score": 42, "vote": 0, "content": "<p>As remarked by Jay Borseth the accepted answer does not handle arrays containing 0 correctly. </p>\n<p>I propose using:</p>\n<pre><code class=\"python\">import numpy as np\na = np.array([-2, -1, 0, 1, 2])\nzero_crossings = np.where(np.diff(np.signbit(a)))[0]\nprint(zero_crossings)\n# output: [1]\n</code></pre>\n<p>Since a) using numpy.signbit() is a little bit quicker than numpy.sign(), since it's implementation is simpler, I guess and b) it deals correctly with zeros in the input array. </p>\n<p>However there is one drawback, maybe: If your input array starts and stops with zeros, it will find a zero crossing at the beginning, but not at the end...</p>\n<pre><code class=\"python\">import numpy as np\na = np.array([0, -2, -1, 0, 1, 2, 0])\nzero_crossings = np.where(np.diff(np.signbit(a)))[0]\nprint(zero_crossings)\n# output: [0 2]\n</code></pre>\n", "abstract": "As remarked by Jay Borseth the accepted answer does not handle arrays containing 0 correctly.  I propose using: Since a) using numpy.signbit() is a little bit quicker than numpy.sign(), since it's implementation is simpler, I guess and b) it deals correctly with zeros in the input array.  However there is one drawback, maybe: If your input array starts and stops with zeros, it will find a zero crossing at the beginning, but not at the end..."}, {"id": 21468492, "score": 14, "vote": 0, "content": "<p>Another way to count zero crossings and squeeze just a few more milliseconds out of the code is to use <code>nonzero</code> and compute the signs directly. Assuming you have a one-dimensional array of <code>data</code>:</p>\n<pre><code class=\"python\">def crossings_nonzero_all(data):\n    pos = data &gt; 0\n    npos = ~pos\n    return ((pos[:-1] &amp; npos[1:]) | (npos[:-1] &amp; pos[1:])).nonzero()[0]\n</code></pre>\n<p>Alternatively, if you just want to count the zero crossings for a particular direction of crossing zero (e.g., from positive to negative), this is even faster:</p>\n<pre><code class=\"python\">def crossings_nonzero_pos2neg(data):\n    pos = data &gt; 0\n    return (pos[:-1] &amp; ~pos[1:]).nonzero()[0]\n</code></pre>\n<p>On my machine these are a bit faster than the <code>where(diff(sign))</code> method (timings for an array of 10000 sine samples containing 20 cycles, 40 crossings in all):</p>\n<pre><code class=\"python\">$ python -mtimeit 'crossings_where(data)'\n10000 loops, best of 3: 119 usec per loop\n\n$ python -mtimeit 'crossings_nonzero_all(data)'\n10000 loops, best of 3: 61.7 usec per loop\n\n$ python -mtimeit 'crossings_nonzero_pos2neg(data)'\n10000 loops, best of 3: 55.5 usec per loop\n</code></pre>\n", "abstract": "Another way to count zero crossings and squeeze just a few more milliseconds out of the code is to use nonzero and compute the signs directly. Assuming you have a one-dimensional array of data: Alternatively, if you just want to count the zero crossings for a particular direction of crossing zero (e.g., from positive to negative), this is even faster: On my machine these are a bit faster than the where(diff(sign)) method (timings for an array of 10000 sine samples containing 20 cycles, 40 crossings in all):"}, {"id": 21171725, "score": 12, "vote": 0, "content": "<p>Jim Brissom's answer fails if <strong>a</strong> contains the value 0:</p>\n<pre><code class=\"python\">import numpy  \na2 = [1, 2, 1, 1, 0, -3, -4, 7, 8, 9, 10, -2, 1, -3, 5, 6, 7, -10]  \nzero_crossings2 = numpy.where(numpy.diff(numpy.sign(a2)))[0]  \nprint zero_crossings2  \nprint len(zero_crossings2)  # should be 7\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">[ 3  4  6 10 11 12 13 16]  \n8  \n</code></pre>\n<p>The number of zero crossing should be 7, but because sign() returns 0 if 0 is passed, 1 for positive, and -1 for negative values, diff() will count the transition containing zero twice.</p>\n<p>An alternative might be:</p>\n<pre><code class=\"python\">a3 = [1, 2, 1, 1, 0, -3, -4, 7, 8, 9, 10, 0, -2, 0, 0, 1, 0, -3, 0, 5, 6, 7, -10]  \ns3= numpy.sign(a3)  \ns3[s3==0] = -1     # replace zeros with -1  \nzero_crossings3 = numpy.where(numpy.diff(s3))[0]  \nprint s3  \nprint zero_crossings3  \nprint len(zero_crossings3)   # should be 7\n</code></pre>\n<p>which give the correct answer of:</p>\n<pre><code class=\"python\">[ 3  6 10 14 15 18 21]\n7\n</code></pre>\n", "abstract": "Jim Brissom's answer fails if a contains the value 0: Output: The number of zero crossing should be 7, but because sign() returns 0 if 0 is passed, 1 for positive, and -1 for negative values, diff() will count the transition containing zero twice. An alternative might be: which give the correct answer of:"}, {"id": 39537079, "score": 3, "vote": 0, "content": "<p>I see people using diff a lot in their solutions, but xor seems to be much faster and the result is the same for bools (a good pointer to that might also be the fact that using diff gives a deprecated warning.... :) )\nHere is an example:</p>\n<pre><code class=\"python\">positive = a2 &gt; 0\nnp.where(np.bitwise_xor(positive[1:], positive[:-1]))[0]\n</code></pre>\n<p><code>timeit</code> measures it to be around one and a half faster to diff for me:)</p>\n<p>If you  do not care about edge cases it might be better to use</p>\n<pre><code class=\"python\">positive = np.signbit(a2)\n</code></pre>\n<p>but positive = a2 &gt;0 seems faster (and cleaner) than signbit AND checking for 0s (e.g. positive = np.bitwise_or(np.signbit(a2),np.logical_not(a2)) is slower...)</p>\n", "abstract": "I see people using diff a lot in their solutions, but xor seems to be much faster and the result is the same for bools (a good pointer to that might also be the fact that using diff gives a deprecated warning.... :) )\nHere is an example: timeit measures it to be around one and a half faster to diff for me:) If you  do not care about edge cases it might be better to use but positive = a2 >0 seems faster (and cleaner) than signbit AND checking for 0s (e.g. positive = np.bitwise_or(np.signbit(a2),np.logical_not(a2)) is slower...)"}, {"id": 45758422, "score": 3, "vote": 0, "content": "<p>Another way that might suit certain applications is to extend the evaluation of the expression <code>np.diff(np.sign(a))</code>. </p>\n<p>If we compare how this expression reacts to certain cases:</p>\n<ol>\n<li>Rising crossing without zero: <code>np.diff(np.sign([-10, 10]))</code> returns <code>array([2])</code></li>\n<li>Rising crossing with zero: <code>np.diff(np.sign([-10, 0, 10]))</code> returns <code>array([1, 1])</code></li>\n<li>Falling crossing without zero: <code>np.diff(np.sign([10, -10]))</code> returns <code>array([-2])</code></li>\n<li>Falling crossing with zero: <code>np.diff(np.sign([10, 0, -10]))</code> returns <code>array([-1, -1])</code></li>\n</ol>\n<p>So we have to evaluate <code>np.diff(...)</code> for the returned patterns in 1. and 2:</p>\n<pre><code class=\"python\">sdiff = np.diff(np.sign(a))\nrising_1 = (sdiff == 2)\nrising_2 = (sdiff[:-1] == 1) &amp; (sdiff[1:] == 1)\nrising_all = rising_1\nrising_all[1:] = rising_all[1:] | rising_2\n</code></pre>\n<p>and for the cases 3. and 4.:</p>\n<pre><code class=\"python\">falling_1 = (sdiff == -2) #the signs need to be the opposite\nfalling_2 = (sdiff[:-1] == -1) &amp; (sdiff[1:] == -1)\nfalling_all = falling_1\nfalling_all[1:] = falling_all[1:] | falling_2\n</code></pre>\n<p>After this we can easily find the indices with </p>\n<pre><code class=\"python\">indices_rising = np.where(rising_all)[0]\nindices_falling = np.where(falling_all)[0]\nindices_both = np.where(rising_all | falling_all)[0]\n</code></pre>\n<p>This approach should be reasonable fast because it can manage without using a \"slow\" loop.</p>\n<p>This combines the approach of several other answers.</p>\n", "abstract": "Another way that might suit certain applications is to extend the evaluation of the expression np.diff(np.sign(a)).  If we compare how this expression reacts to certain cases: So we have to evaluate np.diff(...) for the returned patterns in 1. and 2: and for the cases 3. and 4.: After this we can easily find the indices with  This approach should be reasonable fast because it can manage without using a \"slow\" loop. This combines the approach of several other answers."}]}, {"link": "https://stackoverflow.com/questions/58692476/what-is-adaptive-average-pooling-and-how-does-it-work", "question": {"id": "58692476", "title": "What is Adaptive average pooling and How does it work?", "content": "<p>I recently came across a method in Pytorch when I try to implement AlexNet. \nI don't understand how it works. Please explain the idea behind it with some examples. And how it is different from Maxpooling or Average poling in terms of Neural Network functionality</p>\n<blockquote>\n<p>nn.AdaptiveAvgPool2d((6, 6))</p>\n</blockquote>\n", "abstract": "I recently came across a method in Pytorch when I try to implement AlexNet. \nI don't understand how it works. Please explain the idea behind it with some examples. And how it is different from Maxpooling or Average poling in terms of Neural Network functionality nn.AdaptiveAvgPool2d((6, 6))"}, "answers": [{"id": 58694174, "score": 72, "vote": 0, "content": "<p>In average-pooling or max-pooling, you essentially set the stride and kernel-size by your own, setting them as hyper-parameters. You will have to re-configure them if you happen to change your input size. </p>\n<p>In Adaptive Pooling on the other hand, we specify the output size instead. And the stride and kernel-size are automatically selected to adapt to the needs. The following equations are used to calculate the value in the source code.</p>\n<pre><code class=\"python\">Stride = (input_size//output_size)  \nKernel size = input_size - (output_size-1)*stride  \nPadding = 0\n</code></pre>\n", "abstract": "In average-pooling or max-pooling, you essentially set the stride and kernel-size by your own, setting them as hyper-parameters. You will have to re-configure them if you happen to change your input size.  In Adaptive Pooling on the other hand, we specify the output size instead. And the stride and kernel-size are automatically selected to adapt to the needs. The following equations are used to calculate the value in the source code."}]}, {"link": "https://stackoverflow.com/questions/5543651/computing-standard-deviation-in-a-stream", "question": {"id": "5543651", "title": "Computing Standard Deviation in a stream", "content": "<p>Using Python, assume I'm running through a known quantity of items <code>I</code>, and have the ability to time how long it takes to process each one <code>t</code>, as well as a running total of time spent processing <code>T</code> and the number of items processed so far <code>c</code>. I'm currently calculating the average on the fly <code>A = T / c</code> but this can be skewed by say a single item taking an extraordinarily long time to process (a few seconds compared to a few milliseconds). </p>\n<p>I would like to show a running Standard Deviation. How can I do this without keeping a record of each <code>t</code>?</p>\n", "abstract": "Using Python, assume I'm running through a known quantity of items I, and have the ability to time how long it takes to process each one t, as well as a running total of time spent processing T and the number of items processed so far c. I'm currently calculating the average on the fly A = T / c but this can be skewed by say a single item taking an extraordinarily long time to process (a few seconds compared to a few milliseconds).  I would like to show a running Standard Deviation. How can I do this without keeping a record of each t?"}, "answers": [{"id": 5543790, "score": 52, "vote": 0, "content": "<p>As outlined in the <a href=\"http://en.wikipedia.org/wiki/Standard_deviation#Rapid_calculation_methods\" rel=\"noreferrer\">Wikipedia article on the standard deviation</a>, it is enough to keep track of the following three sums:</p>\n<pre><code class=\"python\">s0 = sum(1 for x in samples)\ns1 = sum(x for x in samples)\ns2 = sum(x*x for x in samples)\n</code></pre>\n<p>These sums are easily updated as new values arrive.  The standard deviation can be calculated as</p>\n<pre><code class=\"python\">std_dev = math.sqrt((s0 * s2 - s1 * s1)/(s0 * (s0 - 1)))\n</code></pre>\n<p>Note that this way of computing the standard deviation can be numerically ill-conditioned if your samples are floating point numbers and the standard deviation is small compared to the mean of the samples.  If you expect samples of this type, you should resort to Welford's method (see the accepted answer).</p>\n", "abstract": "As outlined in the Wikipedia article on the standard deviation, it is enough to keep track of the following three sums: These sums are easily updated as new values arrive.  The standard deviation can be calculated as Note that this way of computing the standard deviation can be numerically ill-conditioned if your samples are floating point numbers and the standard deviation is small compared to the mean of the samples.  If you expect samples of this type, you should resort to Welford's method (see the accepted answer)."}, {"id": 5544108, "score": 27, "vote": 0, "content": "<p>Based on <a href=\"http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#On-line_algorithm\" rel=\"noreferrer\">Welford's algorithm</a>:</p>\n<pre><code class=\"python\">import numpy as np\n\nclass OnlineVariance(object):\n    \"\"\"\n    Welford's algorithm computes the sample variance incrementally.\n    \"\"\"\n\n    def __init__(self, iterable=None, ddof=1):\n        self.ddof, self.n, self.mean, self.M2 = ddof, 0, 0.0, 0.0\n        if iterable is not None:\n            for datum in iterable:\n                self.include(datum)\n\n    def include(self, datum):\n        self.n += 1\n        self.delta = datum - self.mean\n        self.mean += self.delta / self.n\n        self.M2 += self.delta * (datum - self.mean)\n\n    @property\n    def variance(self):\n        return self.M2 / (self.n - self.ddof)\n\n    @property\n    def std(self):\n        return np.sqrt(self.variance)\n</code></pre>\n<p>Update the variance with each new piece of data:</p>\n<pre><code class=\"python\">N = 100\ndata = np.random.random(N)\nov = OnlineVariance(ddof=0)\nfor d in data:\n    ov.include(d)\nstd = ov.std\nprint(std)\n</code></pre>\n<p>Check our result against the standard deviation computed by numpy:  </p>\n<pre><code class=\"python\">assert np.allclose(std, data.std())\n</code></pre>\n", "abstract": "Based on Welford's algorithm: Update the variance with each new piece of data: Check our result against the standard deviation computed by numpy:  "}, {"id": 5543818, "score": 17, "vote": 0, "content": "<p>I use <a href=\"https://stackoverflow.com/questions/895929/how-do-i-determine-the-standard-deviation-stddev-of-a-set-of-values\">Welford's Method</a>, which gives more accurate results. This link points to <a href=\"http://www.johndcook.com/standard_deviation.html\" rel=\"noreferrer\">John D. Cook's overview</a>. Here's a paragraph from it that summarizes why it is a preferred approach:</p>\n<blockquote>\n<p>This better way of computing variance goes back to a 1962 paper by B. P. Welford and is presented in Donald Knuth\u2019s Art of Computer Programming, Vol 2, page 232, 3rd edition. Although this solution has been known for decades, not enough people know about it. Most people are probably unaware that computing sample variance can be difficult until the first time they compute a standard deviation and get an exception for taking the square root of a negative number.</p>\n</blockquote>\n", "abstract": "I use Welford's Method, which gives more accurate results. This link points to John D. Cook's overview. Here's a paragraph from it that summarizes why it is a preferred approach: This better way of computing variance goes back to a 1962 paper by B. P. Welford and is presented in Donald Knuth\u2019s Art of Computer Programming, Vol 2, page 232, 3rd edition. Although this solution has been known for decades, not enough people know about it. Most people are probably unaware that computing sample variance can be difficult until the first time they compute a standard deviation and get an exception for taking the square root of a negative number."}]}, {"link": "https://stackoverflow.com/questions/43099542/python-easy-way-to-do-geometric-mean-in-python", "question": {"id": "43099542", "title": "Python : easy way to do geometric mean in python?", "content": "<p>I wonder is there any easy way to do geometric mean using python but without using python package. If there is not, is there any simple package to do geometric mean?</p>\n", "abstract": "I wonder is there any easy way to do geometric mean using python but without using python package. If there is not, is there any simple package to do geometric mean?"}, "answers": [{"id": 43099751, "score": 58, "vote": 0, "content": "<p>The formula of the gemetric mean is:</p>\n<p><img alt=\"geometrical mean\" src=\"https://wikimedia.org/api/rest_v1/media/math/render/svg/026cae6801f672b9858d55935ec7397183dc3a36\"/></p>\n<p>So you can easily write an algorithm like:</p>\n<pre><code class=\"python\"><b>import numpy as np</b>\n\ndef geo_mean(iterable):\n    a = <b>np.array(iterable)</b>\n    return a.<b>prod()</b>**(1.0/len(a))</code></pre>\n<p>You do not have to use numpy for that, but it tends to perform operations on arrays faster than Python.  See <a href=\"https://stackoverflow.com/a/8385745/34935\">this answer for why</a>.</p>\n<p>In case the chances of <em>overflow</em> are high, you can map the numbers to a <em>log</em> domain first, calculate the sum of these logs, then multiply by 1/n and finally calculate the exponent, like:</p>\n<pre><code class=\"python\">import numpy as np\n\ndef geo_mean<b>_overflow</b>(iterable):\n    return np.exp(<b>np.log(iterable)</b>.<b>mean()</b>)</code></pre>\n", "abstract": "The formula of the gemetric mean is:  So you can easily write an algorithm like: You do not have to use numpy for that, but it tends to perform operations on arrays faster than Python.  See this answer for why. In case the chances of overflow are high, you can map the numbers to a log domain first, calculate the sum of these logs, then multiply by 1/n and finally calculate the exponent, like:"}, {"id": 53526354, "score": 37, "vote": 0, "content": "<p>In case someone is looking here for a library implementation, there is <a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gmean.html\" rel=\"nofollow noreferrer\">gmean()</a> in scipy, possibly faster and numerically more stable than a custom implementation:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from scipy.stats import gmean\n&gt;&gt;&gt; gmean([1.0, 0.00001, 10000000000.])\n46.415888336127786\n</code></pre>\n<p>Compatible with both Python 2 and 3.*</p>\n", "abstract": "In case someone is looking here for a library implementation, there is gmean() in scipy, possibly faster and numerically more stable than a custom implementation: Compatible with both Python 2 and 3.*"}, {"id": 55562016, "score": 30, "vote": 0, "content": "<p>Starting <code>Python 3.8</code>, the standard library comes with the <a href=\"https://docs.python.org/3.8/library/statistics.html#statistics.geometric_mean\" rel=\"nofollow noreferrer\"><code>geometric_mean</code></a> function  as part of the <a href=\"https://docs.python.org/3.8/library/statistics.html\" rel=\"nofollow noreferrer\"><code>statistics</code></a> module:</p>\n<pre><code class=\"python\">from statistics import geometric_mean\n\ngeometric_mean([1.0, 0.00001, 10000000000.]) # 46.415888336127786\n</code></pre>\n", "abstract": "Starting Python 3.8, the standard library comes with the geometric_mean function  as part of the statistics module:"}, {"id": 43099583, "score": 5, "vote": 0, "content": "<p>just do this:</p>\n<pre><code class=\"python\">numbers = [1, 3, 5, 7, 10]\n\n\nprint reduce(lambda x, y: x*y, numbers)**(1.0/len(numbers))\n</code></pre>\n", "abstract": "just do this:"}, {"id": 56229050, "score": 5, "vote": 0, "content": "<p>Here's an overflow-resistant version in pure Python, basically the same as <a href=\"https://stackoverflow.com/a/43099751/3694\">the accepted answer</a>. </p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import math\n\ndef geomean(xs):\n    return math.exp(math.fsum(math.log(x) for x in xs) / len(xs))\n</code></pre>\n", "abstract": "Here's an overflow-resistant version in pure Python, basically the same as the accepted answer. "}, {"id": 61762156, "score": 2, "vote": 0, "content": "<p>You can also calculate the geometrical mean with numpy:</p>\n<pre><code class=\"python\">import numpy as np\nnp.exp(np.mean(np.log([1, 2, 3])))\n</code></pre>\n<p>result:</p>\n<pre><code class=\"python\">1.8171205928321397\n</code></pre>\n", "abstract": "You can also calculate the geometrical mean with numpy: result:"}, {"id": 65447711, "score": 2, "vote": 0, "content": "<p>you can use pow function, as follows :</p>\n<pre><code class=\"python\">def p(*args):\n    k=1\n    for i in args:\n        k*=i\n    return pow(k, 1/len(args))]\n\n&gt;&gt;&gt; p(2,3)\n2.449489742783178\n</code></pre>\n", "abstract": "you can use pow function, as follows :"}, {"id": 58620109, "score": 0, "vote": 0, "content": "<h5>Geometric mean</h5>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import pandas as pd\ngeomean=Variable.product()**(1/len(Variable))\nprint(geomean)\n</code></pre>\n<h5>Geometric mean with Scipy</h5>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from scipy import stats\nprint(stats.gmean(Variable))\n</code></pre>\n", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/10057854/inverse-of-tan-in-python-tan-1", "question": {"id": "10057854", "title": "Inverse of Tan in python (tan-1)", "content": "<p>I am trying to calculate the inverse of tan in python, but it does not give me the correct value, for example, if I were to do the inverse tan of 1.18, <code>math.atan(1.18)</code></p>\n<pre><code class=\"python\">&gt;&gt;&gt;math.atan(1.18)\n0.8677\n</code></pre>\n<p>However, the correct answer is 49.720136931. What is the correct way to do than?</p>\n", "abstract": "I am trying to calculate the inverse of tan in python, but it does not give me the correct value, for example, if I were to do the inverse tan of 1.18, math.atan(1.18) However, the correct answer is 49.720136931. What is the correct way to do than?"}, "answers": [{"id": 10057866, "score": 123, "vote": 0, "content": "<p><a href=\"http://docs.python.org/library/math.html#math.atan\"><code>math.atan(x)</code></a> returned in radian, if you want degree, convert it using <a href=\"http://docs.python.org/library/math.html#math.degrees\"><code>math.degrees(x)</code></a></p>\n<pre><code class=\"python\">Converts angle x from radians to degrees.\n\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.degrees(math.atan(1.18))\n49.720136931043555\n</code></pre>\n", "abstract": "math.atan(x) returned in radian, if you want degree, convert it using math.degrees(x)"}, {"id": 52746984, "score": 9, "vote": 0, "content": "<p>you can simply multiply the radians by 180/pi.\nNo need of importing ;)</p>\n", "abstract": "you can simply multiply the radians by 180/pi.\nNo need of importing ;)"}, {"id": 50541187, "score": 7, "vote": 0, "content": "<pre><code class=\"python\">&gt;&gt;&gt;from math import *\n&gt;&gt;&gt;degrees(atan(1.18))\n&gt;&gt;&gt;49.720136931043555\n</code></pre>\n", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/2096573/counting-combinations-and-permutations-efficiently", "question": {"id": "2096573", "title": "counting combinations and permutations efficiently", "content": "<p>I have some code to count permutations and combinations, and I'm trying to make it work better for large numbers.</p>\n<p>I've found a better algorithm for permutations that avoids large intermediate results, but I still think I can do better for combinations.</p>\n<p>So far, I've put in a special case to reflect the symmetry of nCr, but I'd still like to find a better algorithm that avoids the call to factorial(r), which is an unnecessarily large intermediate result. Without this optimization, the last doctest takes too long trying to calculate factorial(99000).</p>\n<p>Can anyone suggest a more efficient way to count combinations?</p>\n<pre><code class=\"python\">from math import factorial\n\ndef product(iterable):\n    prod = 1\n    for n in iterable:\n        prod *= n\n    return prod\n\ndef npr(n, r):\n    \"\"\"\n    Calculate the number of ordered permutations of r items taken from a\n    population of size n.\n\n    &gt;&gt;&gt; npr(3, 2)\n    6\n    &gt;&gt;&gt; npr(100, 20)\n    1303995018204712451095685346159820800000\n    \"\"\"\n    assert 0 &lt;= r &lt;= n\n    return product(range(n - r + 1, n + 1))\n\ndef ncr(n, r):\n    \"\"\"\n    Calculate the number of unordered combinations of r items taken from a\n    population of size n.\n\n    &gt;&gt;&gt; ncr(3, 2)\n    3\n    &gt;&gt;&gt; ncr(100, 20)\n    535983370403809682970\n    &gt;&gt;&gt; ncr(100000, 1000) == ncr(100000, 99000)\n    True\n    \"\"\"\n    assert 0 &lt;= r &lt;= n\n    if r &gt; n // 2:\n        r = n - r\n    return npr(n, r) // factorial(r)\n</code></pre>\n", "abstract": "I have some code to count permutations and combinations, and I'm trying to make it work better for large numbers. I've found a better algorithm for permutations that avoids large intermediate results, but I still think I can do better for combinations. So far, I've put in a special case to reflect the symmetry of nCr, but I'd still like to find a better algorithm that avoids the call to factorial(r), which is an unnecessarily large intermediate result. Without this optimization, the last doctest takes too long trying to calculate factorial(99000). Can anyone suggest a more efficient way to count combinations?"}, "answers": [{"id": 2096714, "score": 27, "vote": 0, "content": "<p>if n is not far from r then using the recursive definition of combination is probably better, since xC0 == 1 you will only have a few iterations:</p>\n<p>The relevant recursive definition here is:</p>\n<p>nCr = (n-1)C(r-1) * n/r</p>\n<p>This can be nicely computed using tail recursion with the following list:</p>\n<p>[(n - r, 0), (n - r + 1, 1), (n - r + 2, 2), ..., (n - 1, r - 1), (n, r)]</p>\n<p>which is of course easily generated in Python (we omit the first entry since nC0 = 1) by <code>izip(xrange(n - r + 1, n+1), xrange(1, r+1))</code> Note that this assumes r &lt;= n you need to check for that and swap them if they are not. Also to optimize use if r &lt; n/2  then r = n - r.</p>\n<p>Now we simply need to apply the recursion step using tail recursion with reduce. We start with 1 since nC0 is 1 and then multiply the current value with the next entry from the list as below.</p>\n<pre><code class=\"python\">from itertools import izip\n\nreduce(lambda x, y: x * y[0] / y[1], izip(xrange(n - r + 1, n+1), xrange(1, r+1)), 1)\n</code></pre>\n", "abstract": "if n is not far from r then using the recursive definition of combination is probably better, since xC0 == 1 you will only have a few iterations: The relevant recursive definition here is: nCr = (n-1)C(r-1) * n/r This can be nicely computed using tail recursion with the following list: [(n - r, 0), (n - r + 1, 1), (n - r + 2, 2), ..., (n - 1, r - 1), (n, r)] which is of course easily generated in Python (we omit the first entry since nC0 = 1) by izip(xrange(n - r + 1, n+1), xrange(1, r+1)) Note that this assumes r <= n you need to check for that and swap them if they are not. Also to optimize use if r < n/2  then r = n - r. Now we simply need to apply the recursion step using tail recursion with reduce. We start with 1 since nC0 is 1 and then multiply the current value with the next entry from the list as below."}, {"id": 2096894, "score": 20, "vote": 0, "content": "<p>Two fairly simple suggestions:</p>\n<ol>\n<li><p>To avoid overflow, do everything in log space.  Use the fact that log(a * b) = log(a) + log(b), and log(a / b) = log(a) - log(b).  This makes it easy to work with very large factorials:  log(n! / m!) = log(n!) - log(m!), etc.</p></li>\n<li><p>Use the gamma function instead of factorial.  You can find one in <code>scipy.stats.loggamma</code>.  It's a much more efficient way to calculate log-factorials than direct summation.  <code>loggamma(n) == log(factorial(n - 1))</code>, and similarly, <code>gamma(n) == factorial(n - 1)</code>.</p></li>\n</ol>\n", "abstract": "Two fairly simple suggestions: To avoid overflow, do everything in log space.  Use the fact that log(a * b) = log(a) + log(b), and log(a / b) = log(a) - log(b).  This makes it easy to work with very large factorials:  log(n! / m!) = log(n!) - log(m!), etc. Use the gamma function instead of factorial.  You can find one in scipy.stats.loggamma.  It's a much more efficient way to calculate log-factorials than direct summation.  loggamma(n) == log(factorial(n - 1)), and similarly, gamma(n) == factorial(n - 1)."}, {"id": 18443221, "score": 10, "vote": 0, "content": "<p>There's a function for this in scipy which hasn't been mentioned yet: <a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.comb.html#scipy.special.comb\" rel=\"noreferrer\">scipy.special.comb</a>. It seems efficient based on some quick timing results for your doctest (~0.004 seconds for <code>comb(100000, 1000, 1) == comb(100000, 99000, 1)</code>).</p>\n<p>[While this specific question seems to be about algorithms the question <a href=\"https://stackoverflow.com/questions/4941753/is-there-a-math-ncr-function-in-python?lq=1\">is there a math ncr function in python</a> is marked as a duplicate of this...]</p>\n", "abstract": "There's a function for this in scipy which hasn't been mentioned yet: scipy.special.comb. It seems efficient based on some quick timing results for your doctest (~0.004 seconds for comb(100000, 1000, 1) == comb(100000, 99000, 1)). [While this specific question seems to be about algorithms the question is there a math ncr function in python is marked as a duplicate of this...]"}, {"id": 2097660, "score": 8, "vote": 0, "content": "<p>If you don't need a pure-python solution, <a href=\"https://pypi.python.org/pypi/gmpy2\" rel=\"nofollow noreferrer\">gmpy2</a> might help (<code>gmpy2.comb</code> is very fast).</p>\n", "abstract": "If you don't need a pure-python solution, gmpy2 might help (gmpy2.comb is very fast)."}, {"id": 59898512, "score": 8, "vote": 0, "content": "<p>For Python until 3.7:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def prod(items, start=1):\n    for item in items:\n        start *= item\n    return start\n\n\ndef perm(n, k):\n    if not 0 &lt;= k &lt;= n:\n        raise ValueError(\n            'Values must be non-negative and n &gt;= k in perm(n, k)')\n    else:\n        return prod(range(n - k + 1, n + 1))\n\n\ndef comb(n, k):\n    if not 0 &lt;= k &lt;= n:\n        raise ValueError(\n            'Values must be non-negative and n &gt;= k in comb(n, k)')\n    else:\n        k = k if k &lt; n - k else n - k\n        return prod(range(n - k + 1, n + 1)) // math.factorial(k)\n</code></pre>\n<hr/>\n<p>For Python 3.8+:</p>\n<ul>\n<li><a href=\"https://docs.python.org/3/library/math.html#math.perm\" rel=\"nofollow noreferrer\"><code>math.perm()</code></a></li>\n<li><a href=\"https://docs.python.org/3/library/math.html#math.comb\" rel=\"nofollow noreferrer\"><code>math.comb()</code></a></li>\n</ul>\n<hr/>\n<p>Interestingly enough, some manual implementation of the combination function may be faster than <code>math.comb()</code>:</p>\n<pre><code class=\"python\">def math_comb(n, k):\n    return math.comb(n, k)\n\n\ndef comb_perm(n, k):\n    k = k if k &lt; n - k else n - k\n    return math.perm(n, k) // math.factorial(k)\n\n\ndef comb(n, k):\n    k = k if k &lt; n - k else n - k\n    return prod(range(n - k + 1, n + 1)) // math.factorial(k)\n\n\ndef comb_other(n, k):\n    k = k if k &gt; n - k else n - k\n    return prod(range(n - k + 1, n + 1)) // math.factorial(k)\n\n\ndef comb_reduce(n, k):\n    k = k if k &lt; n - k else n - k\n    return functools.reduce(\n        lambda x, y: x * y[0] // y[1],\n        zip(range(n - k + 1, n + 1), range(1, k + 1)),\n        1)\n\n\ndef comb_iter(n, k):\n    k = k if k &lt; n - k else n - k\n    result = 1\n    for i in range(1, k + 1):\n        result = result * (n - i + 1) // i\n    return result\n\n\ndef comb_iterdiv(n, k):\n    k = k if k &lt; n - k else n - k\n    result = divider = 1\n    for i in range(1, k + 1):\n        result *= (n - i + 1)\n        divider *= i\n    return result // divider\n\n\ndef comb_fact(n, k):\n    k = k if k &lt; n - k else n - k\n    return math.factorial(n) // math.factorial(n - k) // math.factorial(k)\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/bh2A3.png\" rel=\"nofollow noreferrer\"><img alt=\"bm\" src=\"https://i.stack.imgur.com/bh2A3.png\"/></a></p>\n<p>so that actually <code>comb_perm()</code> (implemented with <code>math.perm()</code> and <code>math.factorial()</code>) is actually faster than <code>math.comb()</code> most of the times for these benchamarks, which show the computation time for fixed <code>n=256</code> and increasing <code>k</code> (up until <code>k = n // 2</code>).</p>\n<p>Note that <code>comb_reduce()</code>, which is quite slow, is essentially the same approach as from <a href=\"https://stackoverflow.com/a/2096714/5218354\">@wich's answer</a>, while <code>comb_iter()</code>, also relatively slow, is essentially the same approach as <a href=\"https://stackoverflow.com/a/44600243/5218354\">@ZXX's answer</a>.</p>\n<p>Partial analysis <a href=\"https://colab.research.google.com/drive/1v4AYjaX_TAaOKDP_yztLksv--WSIMdSF?usp=sharing\" rel=\"nofollow noreferrer\">here</a> (without <code>comb_math()</code> and <code>comb_perm()</code> since they are not supported in Python's version of Colab -- 3.7 -- as of last edit).</p>\n", "abstract": "For Python until 3.7: For Python 3.8+: Interestingly enough, some manual implementation of the combination function may be faster than math.comb():  so that actually comb_perm() (implemented with math.perm() and math.factorial()) is actually faster than math.comb() most of the times for these benchamarks, which show the computation time for fixed n=256 and increasing k (up until k = n // 2). Note that comb_reduce(), which is quite slow, is essentially the same approach as from @wich's answer, while comb_iter(), also relatively slow, is essentially the same approach as @ZXX's answer. Partial analysis here (without comb_math() and comb_perm() since they are not supported in Python's version of Colab -- 3.7 -- as of last edit)."}, {"id": 42060415, "score": 6, "vote": 0, "content": "<pre><code class=\"python\">from scipy import misc\nmisc.comb(n, k)\n</code></pre>\n<p>should allow you to count combinations</p>\n", "abstract": "should allow you to count combinations"}, {"id": 44600243, "score": 6, "vote": 0, "content": "<p>More efficient solution for nCr - space wise and precision wise. </p>\n<p>The intermediary (res) is guaranteed to always be int and never larger than the result. Space complexity is O(1) (no lists, no zips, no stack), time complexity is O(r) - exactly r multiplications and r divisions.</p>\n<pre><code class=\"python\">def ncr(n, r):\n    r = min(r, n-r)\n    if r == 0: return 1\n    res = 1\n    for k in range(1,r+1):\n        res = res*(n-k+1)/k\n    return res\n</code></pre>\n", "abstract": "More efficient solution for nCr - space wise and precision wise.  The intermediary (res) is guaranteed to always be int and never larger than the result. Space complexity is O(1) (no lists, no zips, no stack), time complexity is O(r) - exactly r multiplications and r divisions."}, {"id": 2096751, "score": 5, "vote": 0, "content": "<p>If you are computing N choose K (which is what I think you're doing with ncr), there is a dynamic programming solution that may be a lot faster. This will avoid factorial, plus you can keep the table if you want for later use.</p>\n<p>Here is a teaching link for it:</p>\n<p><a href=\"http://www.csc.liv.ac.uk/~ped/teachadmin/algor/dyprog.html\" rel=\"nofollow noreferrer\">http://www.csc.liv.ac.uk/~ped/teachadmin/algor/dyprog.html</a></p>\n<p>I am unsure of how to better solve your first problem, though, sorry.</p>\n<p>Edit: Here is the mock-up. There are some pretty hilarious off-by-one errors, so it can certainly stand some more clean up.</p>\n<pre><code class=\"python\">import sys\nn = int(sys.argv[1])+2#100\nk = int(sys.argv[2])+1#20\ntable = [[0]*(n+2)]*(n+2)\n\nfor i in range(1,n):\n    table[i][i] = 1\nfor i in range(1,n):\n    for j in range(1,n-i):\n        x = i+j\n        if j == 1: table[x][j] = 1\n        else: table[x][j] = table[x-1][j-1] + table[x-1][j]\n\nprint table[n][k]\n</code></pre>\n", "abstract": "If you are computing N choose K (which is what I think you're doing with ncr), there is a dynamic programming solution that may be a lot faster. This will avoid factorial, plus you can keep the table if you want for later use. Here is a teaching link for it: http://www.csc.liv.ac.uk/~ped/teachadmin/algor/dyprog.html I am unsure of how to better solve your first problem, though, sorry. Edit: Here is the mock-up. There are some pretty hilarious off-by-one errors, so it can certainly stand some more clean up."}, {"id": 2097030, "score": 4, "vote": 0, "content": "<p>If your problem does not require knowing the exact number of permutations or combinations, then you could use <a href=\"http://en.wikipedia.org/wiki/Stirling%27s_approximation\" rel=\"nofollow noreferrer\">Stirling's approximation</a> for the factorial.</p>\n<p>That would lead to code like this:</p>\n<pre><code class=\"python\">import math\n\ndef stirling(n):\n    # http://en.wikipedia.org/wiki/Stirling%27s_approximation\n    return math.sqrt(2*math.pi*n)*(n/math.e)**n\n\ndef npr(n,r):\n    return (stirling(n)/stirling(n-r) if n&gt;20 else\n            math.factorial(n)/math.factorial(n-r))\n\ndef ncr(n,r):    \n    return (stirling(n)/stirling(r)/stirling(n-r) if n&gt;20 else\n            math.factorial(n)/math.factorial(r)/math.factorial(n-r))\n\nprint(npr(3,2))\n# 6\nprint(npr(100,20))\n# 1.30426670868e+39\nprint(ncr(3,2))\n# 3\nprint(ncr(100,20))\n# 5.38333246453e+20\n</code></pre>\n", "abstract": "If your problem does not require knowing the exact number of permutations or combinations, then you could use Stirling's approximation for the factorial. That would lead to code like this:"}, {"id": 54568959, "score": 1, "vote": 0, "content": "<pre><code class=\"python\">from numpy import prod\n\ndef nCr(n,r):\n    numerator = range(n, max(n-r,r),-1)\n    denominator = range(1, min(n-r,r) +1,1)\n    return int(prod(numerator)/prod(denominator))\n</code></pre>\n", "abstract": ""}, {"id": 2096735, "score": 0, "vote": 0, "content": "<p>Using <code>xrange()</code> instead of <code>range()</code> will speed things up slightly due to the fact that no intermediate list is created, populated, iterated through, and then destroyed. Also, <code>reduce()</code> with <code>operator.mul</code>.</p>\n", "abstract": "Using xrange() instead of range() will speed things up slightly due to the fact that no intermediate list is created, populated, iterated through, and then destroyed. Also, reduce() with operator.mul."}, {"id": 2096937, "score": 0, "vote": 0, "content": "<p>For N choose K you could use Pascals triangle. Basically you would need to keep array of size N around to compute all the N choose K values. Only additions would be required.</p>\n", "abstract": "For N choose K you could use Pascals triangle. Basically you would need to keep array of size N around to compute all the N choose K values. Only additions would be required."}, {"id": 15738101, "score": 0, "vote": 0, "content": "<p>You could input two integers and import math library to find the factorial and then apply the nCr formula</p>\n<pre><code class=\"python\">import math\nn,r=[int(_)for _ in raw_input().split()]\nf=math.factorial\nprint f(n)/f(r)/f(n-r)\n</code></pre>\n", "abstract": "You could input two integers and import math library to find the factorial and then apply the nCr formula"}]}, {"link": "https://stackoverflow.com/questions/5122372/angle-between-points", "question": {"id": "5122372", "title": "Angle between points?", "content": "<p>I have a triangle (A, B, C) and am trying to find the angle between each pair of the three points.</p>\n<p>The problem is that the algorithms I can find online are for determining the angle between vectors. Using the vectors I would compute the angle between the vector that goes from (0, 0) to the point I have, and that doesn't give me the angles inside the triangle.</p>\n<p>OK, here's some code in Python after the method on the Wikipedia page and after subtracting the values:</p>\n<pre><code class=\"python\">import numpy as np\npoints = np.array([[343.8998, 168.1526], [351.2377, 173.7503], [353.531, 182.72]])\n\nA = points[2] - points[0]\nB = points[1] - points[0]\nC = points[2] - points[1]\n\nfor e1, e2 in ((A, B), (A, C), (B, C)):\n    num = np.dot(e1, e2)\n    denom = np.linalg.norm(e1) * np.linalg.norm(e2)\n    print np.arccos(num/denom) * 180\n</code></pre>\n<p>That gives me 60.2912487814, 60.0951900475 and 120.386438829, so what am I doing wrong?</p>\n", "abstract": "I have a triangle (A, B, C) and am trying to find the angle between each pair of the three points. The problem is that the algorithms I can find online are for determining the angle between vectors. Using the vectors I would compute the angle between the vector that goes from (0, 0) to the point I have, and that doesn't give me the angles inside the triangle. OK, here's some code in Python after the method on the Wikipedia page and after subtracting the values: That gives me 60.2912487814, 60.0951900475 and 120.386438829, so what am I doing wrong?"}, "answers": [{"id": 28530929, "score": 38, "vote": 0, "content": "<p>There are two errors here.</p>\n<ul>\n<li><p>You missed a factor of \u03c0 when translating from radians to degrees (it's \u00d7 180 / \u03c0)</p></li>\n<li><p>You have to be careful about the signs of vectors, since they are directed line segments.</p></li>\n</ul>\n<p>If I make these modifications I get a result that makes sense:</p>\n<pre><code class=\"python\">import numpy as np\npoints = np.array([[343.8998, 168.1526], [351.2377, 173.7503], [353.531, 182.72]])\n\nA = points[2] - points[0]\nB = points[1] - points[0]\nC = points[2] - points[1]\n\nangles = []\nfor e1, e2 in ((A, B), (A, C), (B, -C)):\n    num = np.dot(e1, e2)\n    denom = np.linalg.norm(e1) * np.linalg.norm(e2)\n    angles.append(np.arccos(num/denom) * 180 / np.pi)\nprint angles\nprint sum(angles)\n</code></pre>\n<p>which prints out</p>\n<pre><code class=\"python\">[19.191300537488704, 19.12889310421054, 141.67980635830079]\n180.0\n</code></pre>\n<p>I'd probably make things more symmetrical and use A, B, C vectors that are cyclic and sum to zero:</p>\n<pre><code class=\"python\">import numpy as np\npoints = np.array([[343.8998, 168.1526], [351.2377, 173.7503], [353.531, 182.72]])\n\nA = points[1] - points[0]\nB = points[2] - points[1]\nC = points[0] - points[2]\n\nangles = []\nfor e1, e2 in ((A, -B), (B, -C), (C, -A)):\n    num = np.dot(e1, e2)\n    denom = np.linalg.norm(e1) * np.linalg.norm(e2)\n    angles.append(np.arccos(num/denom) * 180 / np.pi)\nprint angles\nprint sum(angles)\n</code></pre>\n<p>which prints out</p>\n<pre><code class=\"python\">[141.67980635830079, 19.12889310421054, 19.191300537488704]\n180.0\n</code></pre>\n<p>The minus signs in the dot product come because we're trying to get the inside angles.</p>\n<p>I'm sorry we drove you away in your time of need, by closing the question.</p>\n", "abstract": "There are two errors here. You missed a factor of \u03c0 when translating from radians to degrees (it's \u00d7 180 / \u03c0) You have to be careful about the signs of vectors, since they are directed line segments. If I make these modifications I get a result that makes sense: which prints out I'd probably make things more symmetrical and use A, B, C vectors that are cyclic and sum to zero: which prints out The minus signs in the dot product come because we're trying to get the inside angles. I'm sorry we drove you away in your time of need, by closing the question."}, {"id": 5122422, "score": 4, "vote": 0, "content": "<p>I would use the <a href=\"http://en.wikipedia.org/wiki/Law_of_cosines\" rel=\"nofollow\">law of cosines</a>, since you can easily calculate the length of each side of the triangle and then solve for each angles individually.</p>\n", "abstract": "I would use the law of cosines, since you can easily calculate the length of each side of the triangle and then solve for each angles individually."}, {"id": 5122421, "score": 0, "vote": 0, "content": "<p>Alternatively, if you only know the length of the sides of the triangle, you can use the <a href=\"http://en.wikipedia.org/wiki/Law_of_cosines\" rel=\"nofollow\">Law of cosines</a>.</p>\n", "abstract": "Alternatively, if you only know the length of the sides of the triangle, you can use the Law of cosines."}, {"id": 5122431, "score": 0, "vote": 0, "content": "<p>Suppose that you want the angle at A.  Then you need to find the angle between the vector from A to B and the vector from A to C.  The vector from A to B is just B-A.  (Subtract the coordinates.)</p>\n", "abstract": "Suppose that you want the angle at A.  Then you need to find the angle between the vector from A to B and the vector from A to C.  The vector from A to B is just B-A.  (Subtract the coordinates.)"}, {"id": 5122443, "score": 0, "vote": 0, "content": "<p>Create three vectors, one from v2 to v1 (v2-v1), one from v3 to v1 (v3-v1), and one from v3 to v2 (v3-v2). Once you have these three vectors, you can use the algorithms you already found along with the fact that all the angles will add to 180 degrees.</p>\n", "abstract": "Create three vectors, one from v2 to v1 (v2-v1), one from v3 to v1 (v3-v1), and one from v3 to v2 (v3-v2). Once you have these three vectors, you can use the algorithms you already found along with the fact that all the angles will add to 180 degrees."}, {"id": 73398290, "score": 0, "vote": 0, "content": "<p>Only need to calculate two angles, the third can calculated from the first two.</p>\n<p>First angle, take two vectors B-A, C-A, for the second C-B, A-B</p>\n<pre><code class=\"python\">points = np.array([[343.8998, 168.1526], [351.2377, 173.7503], [353.531, 182.72]])\nA,B,C = points[0], points[1], points[2]\n\ne1 = B-A; e2 = C-A\ndenom = np.linalg.norm(e1) * np.linalg.norm(e2)\nd1 = np.rad2deg(np.arccos(np.dot(e1, e2)/denom))\n\ne1 = C-B; e2 = A-B\ndenom = np.linalg.norm(e1) * np.linalg.norm(e2)\nd2 = np.rad2deg(np.arccos(np.dot(e1, e2)/denom))\n\nd3 = 180-d1-d2\n\nprint (d1,d2,d3)\n</code></pre>\n<p>The output is</p>\n<pre><code class=\"python\">19.191300537488704 141.6798063583008 19.128893104210505\n</code></pre>\n", "abstract": "Only need to calculate two angles, the third can calculated from the first two. First angle, take two vectors B-A, C-A, for the second C-B, A-B The output is"}]}, {"link": "https://stackoverflow.com/questions/4870393/rotating-coordinate-system-via-a-quaternion", "question": {"id": "4870393", "title": "rotating coordinate system via a quaternion", "content": "<p>We have a gazillion spatial coordinates (x, y and z) representing atoms in 3d space, and I'm  constructing a function that will translate these points to a new coordinate system.  Shifting the coordinates to an arbitrary origin is simple, but I can't wrap my head around the next step: 3d point rotation calculations. In other words, I'm trying to translate the points from (x, y, z) to (x', y', z'), where x', y' and z' are in terms of i', j' and k', the new axis vectors I'm making with the help of the <a href=\"http://pypi.python.org/pypi/euclid/0.01\" rel=\"noreferrer\">euclid python module</a>.</p>\n<p>I <em>think</em> all I need is a euclid quaternion to do this, i.e.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; q * Vector3(x, y, z)\nVector3(x', y', z')\n</code></pre>\n<p>but to make THAT i believe I need a rotation axis vector and an angle of rotation. But I have no idea how to calculate these from i', j' and k'. This seems like a simple procedure to code from scratch, but I suspect something like this requires linear algebra to figure out on my own. Many thanks for a nudge in the right direction.</p>\n", "abstract": "We have a gazillion spatial coordinates (x, y and z) representing atoms in 3d space, and I'm  constructing a function that will translate these points to a new coordinate system.  Shifting the coordinates to an arbitrary origin is simple, but I can't wrap my head around the next step: 3d point rotation calculations. In other words, I'm trying to translate the points from (x, y, z) to (x', y', z'), where x', y' and z' are in terms of i', j' and k', the new axis vectors I'm making with the help of the euclid python module. I think all I need is a euclid quaternion to do this, i.e. but to make THAT i believe I need a rotation axis vector and an angle of rotation. But I have no idea how to calculate these from i', j' and k'. This seems like a simple procedure to code from scratch, but I suspect something like this requires linear algebra to figure out on my own. Many thanks for a nudge in the right direction."}, "answers": [{"id": 4870905, "score": 86, "vote": 0, "content": "<p>Using quaternions to represent rotation isn't difficult from an algebraic point of view. Personally, I find it hard to reason <em>visually</em> about quaternions, but the formulas involved in using them for rotations are not overly complicated. I'll provide a basic set of reference functions here.<sup>1</sup> (See also this lovely answer by <a href=\"https://stackoverflow.com/a/42180896/577088\">hosolmaz</a>, in which he packages these together to create a handy Quaternion class.)</p>\n<p>You can think of a quaternion (for our purposes) as a scalar plus a 3-d vector -- abstractly, <code>w + xi + yj + zk</code>, here represented by an ordinary tuple <code>(w, x, y, z)</code>. The space of 3-d rotations is represented in full by a sub-space of the quaternions, the space of <em>unit</em> quaternions, so you want to make sure that your quaternions are normalized. You can do so in just the way you would normalize any 4-vector (i.e. magnitude should be close to 1; if it isn't, scale down the values by the magnitude):</p>\n<pre><code class=\"python\">def normalize(v, tolerance=0.00001):\n    mag2 = sum(n * n for n in v)\n    if abs(mag2 - 1.0) &gt; tolerance:\n        mag = sqrt(mag2)\n        v = tuple(n / mag for n in v)\n    return v\n</code></pre>\n<p>Please note that for simplicity, the following functions assume that quaternion values are <em>already normalized</em>. In practice, you'll need to renormalize them from time to time, but the best way to deal with that will depend on the problem domain. These functions provide just the very basics, for reference purposes only.</p>\n<p>Every rotation is represented by a unit quaternion, and concatenations of rotations correspond to <em>multiplications</em> of unit quaternions. The formula<sup>2</sup> for this is as follows:</p>\n<pre><code class=\"python\">def q_mult(q1, q2):\n    w1, x1, y1, z1 = q1\n    w2, x2, y2, z2 = q2\n    w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n    x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n    y = w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2\n    z = w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2\n    return w, x, y, z\n</code></pre>\n<p>To rotate a <em>vector</em> by a quaternion, you need the quaternion's conjugate too:</p>\n<pre><code class=\"python\">def q_conjugate(q):\n    w, x, y, z = q\n    return (w, -x, -y, -z)\n</code></pre>\n<p>Quaternion-vector multiplication is then a matter of converting your vector into a quaternion (by setting <code>w = 0</code> and leaving <code>x</code>, <code>y</code>, and <code>z</code> the same) and then multiplying <code>q * v * q_conjugate(q)</code>:</p>\n<pre><code class=\"python\">def qv_mult(q1, v1):\n    q2 = (0.0,) + v1\n    return q_mult(q_mult(q1, q2), q_conjugate(q1))[1:]\n    \n</code></pre>\n<p>Finally, you need to know how to convert from axis-angle rotations to quaternions and back. This is also surprisingly straightforward. It makes sense to \"sanitize\" input and output here by calling <code>normalize</code>.</p>\n<pre><code class=\"python\">def axisangle_to_q(v, theta):\n    v = normalize(v)\n    x, y, z = v\n    theta /= 2\n    w = cos(theta)\n    x = x * sin(theta)\n    y = y * sin(theta)\n    z = z * sin(theta)\n    return w, x, y, z\n</code></pre>\n<p>And back:</p>\n<pre><code class=\"python\">def q_to_axisangle(q):\n    w, v = q[0], q[1:]\n    theta = acos(w) * 2.0\n    return normalize(v), theta\n</code></pre>\n<p>Here's a quick usage example. A sequence of 90-degree rotations about the x, y, and z axes will return a vector on the y axis to its original position. This code performs those rotations:</p>\n<pre><code class=\"python\">x_axis_unit = (1, 0, 0)\ny_axis_unit = (0, 1, 0)\nz_axis_unit = (0, 0, 1)\nr1 = axisangle_to_q(x_axis_unit, numpy.pi / 2)\nr2 = axisangle_to_q(y_axis_unit, numpy.pi / 2)\nr3 = axisangle_to_q(z_axis_unit, numpy.pi / 2)\n\nv = qv_mult(r1, y_axis_unit)\nv = qv_mult(r2, v)\nv = qv_mult(r3, v)\n\nprint v\n# output: (0.0, 1.0, 2.220446049250313e-16)\n</code></pre>\n<p>Keep in mind that this sequence of rotations won't return <em>all</em> vectors to the same position; for example, for a vector on the x axis, it will correspond to a 90 degree rotation about the y axis. (Think of the <a href=\"https://en.wikipedia.org/wiki/Right-hand_rule\" rel=\"noreferrer\">right-hand-rule</a> here; a positive rotation about the y axis pushes a vector on the x axis into the <em>negative</em> z region.)</p>\n<pre><code class=\"python\">v = qv_mult(r1, x_axis_unit)\nv = qv_mult(r2, v)\nv = qv_mult(r3, v)\n\nprint v\n# output: (4.930380657631324e-32, 2.220446049250313e-16, -1.0)\n</code></pre>\n<p>As always, please let me know if you find any problems here.</p>\n<hr/>\n<p><sup>1. These are adapted from an OpenGL tutorial <a href=\"https://web.archive.org/web/20150515143824/http://content.gpwiki.org/index.php/OpenGL:Tutorials:Using_Quaternions_to_represent_rotation\" rel=\"noreferrer\">archived here</a>.</sup></p>\n<p><sup>2. The quaternion multiplication formula looks like a horrible rat's nest at first, but the derivation is easy, albeit tedious. Working with pencil and paper, you can represent the two quaternions like so: <code>w + xi + yj + zk</code>.  Then note that <code>ii = jj = kk = -1</code>; that <code>ij = k</code>, <code>jk = i</code>, <code>ki = j</code>; and that <code>ji = -k</code>, <code>kj = -i</code>, <code>ik = -j</code>. Finally, multiply the two quaternions, distributing out the terms and rearranging them based on the results of each of the 16 multiplications. This helps to illustrate <em>why</em> you can use quaternions to represent rotation; the last six identities follow the right-hand rule, creating bijections between rotations <em>from</em> <code>i</code> to <code>j</code> and rotations <em>around</em> <code>k</code>, and so on.</sup></p>\n<p><sup>If you do this, you'll see that the identity <code>ii = jj = kk = -1</code> explains the last three terms in the <code>w</code> formula; that <code>jk = i</code> explains the third term in the <code>x</code> formula; and that <code>kj = -i</code> explains the fourth term in the <code>x</code> formula. The <code>y</code> and <code>z</code> formulas work the same way. The remaining terms are all examples of ordinary scalar multiplication.</sup></p>\n", "abstract": "Using quaternions to represent rotation isn't difficult from an algebraic point of view. Personally, I find it hard to reason visually about quaternions, but the formulas involved in using them for rotations are not overly complicated. I'll provide a basic set of reference functions here.1 (See also this lovely answer by hosolmaz, in which he packages these together to create a handy Quaternion class.) You can think of a quaternion (for our purposes) as a scalar plus a 3-d vector -- abstractly, w + xi + yj + zk, here represented by an ordinary tuple (w, x, y, z). The space of 3-d rotations is represented in full by a sub-space of the quaternions, the space of unit quaternions, so you want to make sure that your quaternions are normalized. You can do so in just the way you would normalize any 4-vector (i.e. magnitude should be close to 1; if it isn't, scale down the values by the magnitude): Please note that for simplicity, the following functions assume that quaternion values are already normalized. In practice, you'll need to renormalize them from time to time, but the best way to deal with that will depend on the problem domain. These functions provide just the very basics, for reference purposes only. Every rotation is represented by a unit quaternion, and concatenations of rotations correspond to multiplications of unit quaternions. The formula2 for this is as follows: To rotate a vector by a quaternion, you need the quaternion's conjugate too: Quaternion-vector multiplication is then a matter of converting your vector into a quaternion (by setting w = 0 and leaving x, y, and z the same) and then multiplying q * v * q_conjugate(q): Finally, you need to know how to convert from axis-angle rotations to quaternions and back. This is also surprisingly straightforward. It makes sense to \"sanitize\" input and output here by calling normalize. And back: Here's a quick usage example. A sequence of 90-degree rotations about the x, y, and z axes will return a vector on the y axis to its original position. This code performs those rotations: Keep in mind that this sequence of rotations won't return all vectors to the same position; for example, for a vector on the x axis, it will correspond to a 90 degree rotation about the y axis. (Think of the right-hand-rule here; a positive rotation about the y axis pushes a vector on the x axis into the negative z region.) As always, please let me know if you find any problems here. 1. These are adapted from an OpenGL tutorial archived here. 2. The quaternion multiplication formula looks like a horrible rat's nest at first, but the derivation is easy, albeit tedious. Working with pencil and paper, you can represent the two quaternions like so: w + xi + yj + zk.  Then note that ii = jj = kk = -1; that ij = k, jk = i, ki = j; and that ji = -k, kj = -i, ik = -j. Finally, multiply the two quaternions, distributing out the terms and rearranging them based on the results of each of the 16 multiplications. This helps to illustrate why you can use quaternions to represent rotation; the last six identities follow the right-hand rule, creating bijections between rotations from i to j and rotations around k, and so on. If you do this, you'll see that the identity ii = jj = kk = -1 explains the last three terms in the w formula; that jk = i explains the third term in the x formula; and that kj = -i explains the fourth term in the x formula. The y and z formulas work the same way. The remaining terms are all examples of ordinary scalar multiplication."}, {"id": 42180896, "score": 8, "vote": 0, "content": "<p>This question and the answer given by @senderle really helped me with one of my projects. The answer is minimal and covers the core of most quaternion computations that one might need to perform. </p>\n<p>For my own project, I found it tedious to have separate functions for all the operations and import them one by one every time I need one, so I implemented an object oriented version.</p>\n<p>quaternion.py:</p>\n<pre><code class=\"python\">import numpy as np\nfrom math import sin, cos, acos, sqrt\n\ndef normalize(v, tolerance=0.00001):\n    mag2 = sum(n * n for n in v)\n    if abs(mag2 - 1.0) &gt; tolerance:\n        mag = sqrt(mag2)\n        v = tuple(n / mag for n in v)\n    return np.array(v)\n\nclass Quaternion:\n\n    def from_axisangle(theta, v):\n        theta = theta\n        v = normalize(v)\n\n        new_quaternion = Quaternion()\n        new_quaternion._axisangle_to_q(theta, v)\n        return new_quaternion\n\n    def from_value(value):\n        new_quaternion = Quaternion()\n        new_quaternion._val = value\n        return new_quaternion\n\n    def _axisangle_to_q(self, theta, v):\n        x = v[0]\n        y = v[1]\n        z = v[2]\n\n        w = cos(theta/2.)\n        x = x * sin(theta/2.)\n        y = y * sin(theta/2.)\n        z = z * sin(theta/2.)\n\n        self._val = np.array([w, x, y, z])\n\n    def __mul__(self, b):\n\n        if isinstance(b, Quaternion):\n            return self._multiply_with_quaternion(b)\n        elif isinstance(b, (list, tuple, np.ndarray)):\n            if len(b) != 3:\n                raise Exception(f\"Input vector has invalid length {len(b)}\")\n            return self._multiply_with_vector(b)\n        else:\n            raise Exception(f\"Multiplication with unknown type {type(b)}\")\n\n    def _multiply_with_quaternion(self, q2):\n        w1, x1, y1, z1 = self._val\n        w2, x2, y2, z2 = q2._val\n        w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n        x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n        y = w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2\n        z = w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2\n\n        result = Quaternion.from_value(np.array((w, x, y, z)))\n        return result\n\n    def _multiply_with_vector(self, v):\n        q2 = Quaternion.from_value(np.append((0.0), v))\n        return (self * q2 * self.get_conjugate())._val[1:]\n\n    def get_conjugate(self):\n        w, x, y, z = self._val\n        result = Quaternion.from_value(np.array((w, -x, -y, -z)))\n        return result\n\n    def __repr__(self):\n        theta, v = self.get_axisangle()\n        return f\"((%.6f; %.6f, %.6f, %.6f))\"%(theta, v[0], v[1], v[2])\n\n    def get_axisangle(self):\n        w, v = self._val[0], self._val[1:]\n        theta = acos(w) * 2.0\n\n        return theta, normalize(v)\n\n    def tolist(self):\n        return self._val.tolist()\n\n    def vector_norm(self):\n        w, v = self.get_axisangle()\n        return np.linalg.norm(v)\n</code></pre>\n<p>In this version, one can just use the overloaded operators for quaternion-quaternion and quaternion-vector multiplication</p>\n<pre><code class=\"python\">from quaternion import Quaternion\nimport numpy as np\n\nx_axis_unit = (1, 0, 0)\ny_axis_unit = (0, 1, 0)\nz_axis_unit = (0, 0, 1)\n\nr1 = Quaternion.from_axisangle(np.pi / 2, x_axis_unit)\nr2 = Quaternion.from_axisangle(np.pi / 2, y_axis_unit)\nr3 = Quaternion.from_axisangle(np.pi / 2, z_axis_unit)\n\n# Quaternion - vector multiplication\nv = r1 * y_axis_unit\nv = r2 * v\nv = r3 * v\n\nprint(v)\n\n# Quaternion - quaternion multiplication\nr_total = r3 * r2 * r1\nv = r_total * y_axis_unit\n\nprint(v)\n</code></pre>\n<p>I did not intend to implement a full-fledged quaternion module, so this is again for instructional purposes, as in @senderle's great answer. I hope this helps out to those who want to understand and try out new  things with quaternions.</p>\n", "abstract": "This question and the answer given by @senderle really helped me with one of my projects. The answer is minimal and covers the core of most quaternion computations that one might need to perform.  For my own project, I found it tedious to have separate functions for all the operations and import them one by one every time I need one, so I implemented an object oriented version. quaternion.py: In this version, one can just use the overloaded operators for quaternion-quaternion and quaternion-vector multiplication I did not intend to implement a full-fledged quaternion module, so this is again for instructional purposes, as in @senderle's great answer. I hope this helps out to those who want to understand and try out new  things with quaternions."}, {"id": 4872821, "score": 2, "vote": 0, "content": "<p>Note that the inversion of matrix is not that trivial at all! Firstly, all n (where n is the dimension of your space) points must be in general position (i.e. no individual point can be expressed as a linear combination of rest of the points [caveat: this may seem to be a simple requirement indeed, but in the realm of numerical linear algebra, it's nontrivial; final decison wheter such configuration really exist or not, will eventually be based on the 'actual domain' specific knowledge]).  </p>\n<p>Also the 'correspondence' of the new and old points may not be exact (and then you should utilize the best possible approximator of the 'true correspondence', i.e.:). Pseudo inverse (instead of trying to utilize the plain inverse) is recommend allways when your lib provides it. </p>\n<p>The pseudo inverse has the advantage that you'll be able to use more points for your transformation, hence increasing the probability that at least n points will be in general position. </p>\n<p>Here is an example, rotation of unit square 90 deg. ccw in 2D (but obviously this determination works in any dim), with <code>numpy</code>:</p>\n<pre><code class=\"python\">In []: P=  matrix([[0, 0, 1, 1],\n                   [0, 1, 1, 0]])\nIn []: Pn= matrix([[0, -1, -1, 0],\n                   [0,  0,  1, 1]])\nIn []: T= Pn* pinv(P)\nIn []: (T* P).round()\nOut[]:\nmatrix([[ 0., -1., -1.,  0.],\n        [ 0.,  0.,  1.,  1.]])\n</code></pre>\n<p>P.S. <code>numpy</code> is also fast. Transformation of 1 million points in my modest computer:</p>\n<pre><code class=\"python\">In []: P= matrix(rand(2, 1e6))\nIn []: %timeit T* P\n10 loops, best of 3: 37.7 ms per loop\n</code></pre>\n", "abstract": "Note that the inversion of matrix is not that trivial at all! Firstly, all n (where n is the dimension of your space) points must be in general position (i.e. no individual point can be expressed as a linear combination of rest of the points [caveat: this may seem to be a simple requirement indeed, but in the realm of numerical linear algebra, it's nontrivial; final decison wheter such configuration really exist or not, will eventually be based on the 'actual domain' specific knowledge]).   Also the 'correspondence' of the new and old points may not be exact (and then you should utilize the best possible approximator of the 'true correspondence', i.e.:). Pseudo inverse (instead of trying to utilize the plain inverse) is recommend allways when your lib provides it.  The pseudo inverse has the advantage that you'll be able to use more points for your transformation, hence increasing the probability that at least n points will be in general position.  Here is an example, rotation of unit square 90 deg. ccw in 2D (but obviously this determination works in any dim), with numpy: P.S. numpy is also fast. Transformation of 1 million points in my modest computer:"}]}, {"link": "https://stackoverflow.com/questions/4050907/python-overflowerror-math-range-error", "question": {"id": "4050907", "title": "Python: OverflowError: math range error", "content": "<p>I get a Overflow error when i try this calculation, but i cant figure out why.</p>\n<pre><code class=\"python\">1-math.exp(-4*1000000*-0.0641515994108)\n</code></pre>\n", "abstract": "I get a Overflow error when i try this calculation, but i cant figure out why."}, "answers": [{"id": 4050933, "score": 40, "vote": 0, "content": "<p>The number you're asking math.exp to calculate has, in decimal, over 110,000 digits.  That's slightly outside of the range of a double, so it causes an overflow.</p>\n", "abstract": "The number you're asking math.exp to calculate has, in decimal, over 110,000 digits.  That's slightly outside of the range of a double, so it causes an overflow."}, {"id": 36980229, "score": 28, "vote": 0, "content": "<p>To fix it use:</p>\n<pre><code class=\"python\">try:\n    ans = math.exp(200000)\nexcept OverflowError:\n    ans = float('inf')\n</code></pre>\n", "abstract": "To fix it use:"}, {"id": 4050994, "score": 5, "vote": 0, "content": "<p>I think the value gets too large to fit into a <code>double</code> in python which is why you get the <code>OverflowError</code>. The largest value I can compute the <code>exp</code> of on my machine in Python is just sligthly larger than 709.78271.</p>\n", "abstract": "I think the value gets too large to fit into a double in python which is why you get the OverflowError. The largest value I can compute the exp of on my machine in Python is just sligthly larger than 709.78271."}, {"id": 4050935, "score": 4, "vote": 0, "content": "<p>This may give you a clue why:</p>\n<pre><code class=\"python\">http://www.wolframalpha.com/input/?i=math.exp%28-4*1000000*-0.0641515994108%29\n</code></pre>\n<p><em>Notice the 111442 exponent.</em></p>\n", "abstract": "This may give you a clue why: Notice the 111442 exponent."}, {"id": 61537621, "score": 4, "vote": 0, "content": "<p>Unfortunately, no one explained what the real solution was. I solved the problem using:</p>\n<p>from mpmath import *</p>\n<p>You can find the documentation below:</p>\n<p><a href=\"http://mpmath.org/\" rel=\"nofollow noreferrer\">http://mpmath.org/</a></p>\n", "abstract": "Unfortunately, no one explained what the real solution was. I solved the problem using: from mpmath import * You can find the documentation below: http://mpmath.org/"}, {"id": 58449159, "score": 3, "vote": 0, "content": "<p>Try np.exp() instead of math.exp()</p>\n<blockquote>\n<p>Numpy handles overflows more gracefully, np.exp(999) results in inf\n  and 1. / (1. + np.exp(999)) therefore simply results in zero</p>\n</blockquote>\n<pre><code class=\"python\">import math \nimport numpy as np\n\nprint(1-np.exp(-4*1000000*-0.0641515994108))\n</code></pre>\n", "abstract": "Try np.exp() instead of math.exp() Numpy handles overflows more gracefully, np.exp(999) results in inf\n  and 1. / (1. + np.exp(999)) therefore simply results in zero"}]}, {"link": "https://stackoverflow.com/questions/10048571/python-finding-a-trend-in-a-set-of-numbers", "question": {"id": "10048571", "title": "Python: Finding a trend in a set of numbers", "content": "<p>I have a list of numbers in Python, like this:</p>\n<pre><code class=\"python\">x = [12, 34, 29, 38, 34, 51, 29, 34, 47, 34, 55, 94, 68, 81]\n</code></pre>\n<p>What's the best way to find the trend in these numbers? I'm not interested in predicting what the next number will be, I just want to output the trend for many sets of numbers so that I can compare the trends.</p>\n<p><strong>Edit:</strong> By trend, I mean that I'd like a numerical representation of whether the numbers are increasing or decreasing and at what rate. I'm not massively mathematical, so there's probably a proper name for this!</p>\n<p><strong>Edit 2:</strong> It looks like what I really want is the co-efficient of the linear best fit. What's the best way to get this in Python?</p>\n", "abstract": "I have a list of numbers in Python, like this: What's the best way to find the trend in these numbers? I'm not interested in predicting what the next number will be, I just want to output the trend for many sets of numbers so that I can compare the trends. Edit: By trend, I mean that I'd like a numerical representation of whether the numbers are increasing or decreasing and at what rate. I'm not massively mathematical, so there's probably a proper name for this! Edit 2: It looks like what I really want is the co-efficient of the linear best fit. What's the best way to get this in Python?"}, "answers": [{"id": 10048844, "score": 31, "vote": 0, "content": "<p>Possibly you mean you want to plot these numbers on a graph and find a straight line through them where the overall distance between the line and the numbers is minimized? This is called a linear regression </p>\n<pre><code class=\"python\">def linreg(X, Y):\n    \"\"\"\n    return a,b in solution to y = ax + b such that root mean square distance between trend line and original points is minimized\n    \"\"\"\n    N = len(X)\n    Sx = Sy = Sxx = Syy = Sxy = 0.0\n    for x, y in zip(X, Y):\n        Sx = Sx + x\n        Sy = Sy + y\n        Sxx = Sxx + x*x\n        Syy = Syy + y*y\n        Sxy = Sxy + x*y\n    det = Sxx * N - Sx * Sx\n    return (Sxy * N - Sy * Sx)/det, (Sxx * Sy - Sx * Sxy)/det\n\n\nx = [12, 34, 29, 38, 34, 51, 29, 34, 47, 34, 55, 94, 68, 81]\na,b = linreg(range(len(x)),x)  //your x,y are switched from standard notation\n</code></pre>\n<p>The trend line is unlikely to pass through your original points, but it will be as close as possible to the original points that a straight line can get. Using the gradient and intercept values of this trend line (a,b) you will be able to extrapolate the line past the end of the array:</p>\n<pre><code class=\"python\">extrapolatedtrendline=[a*index + b for index in range(20)] //replace 20 with desired trend length\n</code></pre>\n", "abstract": "Possibly you mean you want to plot these numbers on a graph and find a straight line through them where the overall distance between the line and the numbers is minimized? This is called a linear regression  The trend line is unlikely to pass through your original points, but it will be as close as possible to the original points that a straight line can get. Using the gradient and intercept values of this trend line (a,b) you will be able to extrapolate the line past the end of the array:"}, {"id": 10048928, "score": 26, "vote": 0, "content": "<p>The Link provided by Keith or probably the answer from Riaz might help you to get the poly fit, but it is always recommended to use libraries if available, and for the problem in your hand, <a href=\"http://docs.scipy.org/doc/numpy-1.3.x/contents.html\" rel=\"noreferrer\">numpy</a> provides a wonderful polynomial fit function called <a href=\"http://docs.scipy.org/doc/numpy-1.3.x/reference/generated/numpy.polyfit.html\" rel=\"noreferrer\">polyfit</a> . You can use polyfit to fit the data over any degree of equation.</p>\n<p>Here is an example using numpy to fit the data in a linear equation of the form y=ax+b</p>\n<pre><code class=\"python\">&gt;&gt;&gt; data = [12, 34, 29, 38, 34, 51, 29, 34, 47, 34, 55, 94, 68, 81]\n&gt;&gt;&gt; x = np.arange(0,len(data))\n&gt;&gt;&gt; y=np.array(data)\n&gt;&gt;&gt; z = np.polyfit(x,y,1)\n&gt;&gt;&gt; print \"{0}x + {1}\".format(*z)\n4.32527472527x + 17.6\n&gt;&gt;&gt; \n</code></pre>\n<p>similarly a quadratic fit would be</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print \"{0}x^2 + {1}x + {2}\".format(*z)\n0.311126373626x^2 + 0.280631868132x + 25.6892857143\n&gt;&gt;&gt; \n</code></pre>\n", "abstract": "The Link provided by Keith or probably the answer from Riaz might help you to get the poly fit, but it is always recommended to use libraries if available, and for the problem in your hand, numpy provides a wonderful polynomial fit function called polyfit . You can use polyfit to fit the data over any degree of equation. Here is an example using numpy to fit the data in a linear equation of the form y=ax+b similarly a quadratic fit would be"}, {"id": 10048672, "score": 7, "vote": 0, "content": "<p>Here is one way to get an increasing/decreasing trend:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [12, 34, 29, 38, 34, 51, 29, 34, 47, 34, 55, 94, 68, 81]\n&gt;&gt;&gt; trend = [b - a for a, b in zip(x[::1], x[1::1])]\n&gt;&gt;&gt; trend\n[22, -5, 9, -4, 17, -22, 5, 13, -13, 21, 39, -26, 13]\n</code></pre>\n<p>In the resulting list <code>trend</code>, <code>trend[0]</code> can be interpreted as the increase from <code>x[0]</code> to <code>x[1]</code>, <code>trend[1]</code> would be the increase from <code>x[1]</code> to <code>x[2]</code> etc.  Negative values in <code>trend</code> mean that value in <code>x</code> decreased from one index to the next.</p>\n", "abstract": "Here is one way to get an increasing/decreasing trend: In the resulting list trend, trend[0] can be interpreted as the increase from x[0] to x[1], trend[1] would be the increase from x[1] to x[2] etc.  Negative values in trend mean that value in x decreased from one index to the next."}, {"id": 10048610, "score": 6, "vote": 0, "content": "<p>You could do a <a href=\"http://en.wikipedia.org/wiki/Least_squares\">least squares fit</a> of the data.</p>\n<p>Using the formula from <a href=\"http://en.wikipedia.org/wiki/Ordinary_least_squares#Simple_regression_model\">this page</a>:</p>\n<pre><code class=\"python\">y = [12, 34, 29, 38, 34, 51, 29, 34, 47, 34, 55, 94, 68, 81]\nN = len(y)\nx = range(N)\nB = (sum(x[i] * y[i] for i in xrange(N)) - 1./N*sum(x)*sum(y)) / (sum(x[i]**2 for i in xrange(N)) - 1./N*sum(x)**2)\nA = 1.*sum(y)/N - B * 1.*sum(x)/N\nprint \"%f + %f * x\" % (A, B)\n</code></pre>\n<p>Which prints the starting value and delta of the best fit line.</p>\n", "abstract": "You could do a least squares fit of the data. Using the formula from this page: Which prints the starting value and delta of the best fit line."}, {"id": 10048681, "score": 4, "vote": 0, "content": "<p>I agree with Keith, I think you're probably looking for a linear least squares fit (if all you want to know is if the numbers are generally increasing or decreasing, and at what rate).  The slope of the fit will tell you at what rate they're increasing.  If you want a visual representation of a linear least squares fit, try Wolfram Alpha:</p>\n<p><a href=\"http://www.wolframalpha.com/input/?i=linear+fit+%5B12%2C+34%2C+29%2C+38%2C+34%2C+51%2C+29%2C+34%2C+47%2C+34%2C+55%2C+94%2C+68%2C+81%5D\" rel=\"nofollow\">http://www.wolframalpha.com/input/?i=linear+fit+%5B12%2C+34%2C+29%2C+38%2C+34%2C+51%2C+29%2C+34%2C+47%2C+34%2C+55%2C+94%2C+68%2C+81%5D</a></p>\n<p><strong>Update:</strong>  If you want to implement a linear regression in Python, I recommend starting with the explanation at Mathworld:</p>\n<p><a href=\"http://mathworld.wolfram.com/LeastSquaresFitting.html\" rel=\"nofollow\">http://mathworld.wolfram.com/LeastSquaresFitting.html</a></p>\n<p>It's a very straightforward explanation of the algorithm, and it practically writes itself.  In particular, you want to pay close attention to equations 16-21, 27, and 28.</p>\n<p>Try writing the algorithm yourself, and if you have problems, you should open another question.</p>\n", "abstract": "I agree with Keith, I think you're probably looking for a linear least squares fit (if all you want to know is if the numbers are generally increasing or decreasing, and at what rate).  The slope of the fit will tell you at what rate they're increasing.  If you want a visual representation of a linear least squares fit, try Wolfram Alpha: http://www.wolframalpha.com/input/?i=linear+fit+%5B12%2C+34%2C+29%2C+38%2C+34%2C+51%2C+29%2C+34%2C+47%2C+34%2C+55%2C+94%2C+68%2C+81%5D Update:  If you want to implement a linear regression in Python, I recommend starting with the explanation at Mathworld: http://mathworld.wolfram.com/LeastSquaresFitting.html It's a very straightforward explanation of the algorithm, and it practically writes itself.  In particular, you want to pay close attention to equations 16-21, 27, and 28. Try writing the algorithm yourself, and if you have problems, you should open another question."}, {"id": 10049947, "score": 2, "vote": 0, "content": "<p>You can find the OLS coefficient using numpy:</p>\n<pre><code class=\"python\">import numpy as np\n\ny = [12, 34, 29, 38, 34, 51, 29, 34, 47, 34, 55, 94, 68, 81]\n\nx = []\nx.append(range(len(y)))                 #Time variable\nx.append([1 for ele in xrange(len(y))]) #This adds the intercept, use range in Python3\n\ny = np.matrix(y).T\nx = np.matrix(x).T\n\nbetas = ((x.T*x).I*x.T*y)\n</code></pre>\n<p>Results:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; betas\nmatrix([[  4.32527473],  #coefficient on the time variable\n        [ 17.6       ]]) #coefficient on the intercept\n</code></pre>\n<p>Since the coefficient on the trend variable is positive, observations in your variable are increasing over time.</p>\n", "abstract": "You can find the OLS coefficient using numpy: Results: Since the coefficient on the trend variable is positive, observations in your variable are increasing over time."}, {"id": 73743554, "score": 0, "vote": 0, "content": "<p>You can use simply scipy library</p>\n<pre><code class=\"python\">from scipy.stats import linregress\ndata = [12, 34, 29, 38, 34, 51, 29, 34, 47, 34, 55, 94, 68, 81]\nx = np.arange(1,len(data)+1)\ny=np.array(data)\nres = linregress(x, y)\nprint(f'Equation: {res[0]:.3f} * t + {res[1]:.3f}, R^2: {res[2] ** 2:.2f} ')\nres\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">Equation: 4.325 * t + 13.275, R^2: 0.66 \nLinregressResult(slope=4.325274725274725, intercept=13.274725274725277, rvalue=0.8096297800892154, pvalue=0.0004497809466484867, stderr=0.9051717124425395, intercept_stderr=7.707259409345618)\n</code></pre>\n", "abstract": "You can use simply scipy library Output:"}, {"id": 10049110, "score": -2, "vote": 0, "content": "<p>Compute the beta coefficient.</p>\n<pre><code class=\"python\">y = [12, 34, 29, 38, 34, 51, 29, 34, 47, 34, 55, 94, 68, 81]\nx = range(1,len(y)+1)\n\ndef var(X):\n    S = 0.0\n    SS = 0.0\n    for x in X:\n        S += x\n        SS += x*x\n    xbar = S/float(len(X))\n    return (SS - len(X) * xbar * xbar) / (len(X) -1.0)\n\ndef cov(X,Y):\n    n = len(X)\n    xbar = sum(X) / n\n    ybar = sum(Y) / n\n    return sum([(x-xbar)*(y-ybar) for x,y in zip(X,Y)])/(n-1)\n\n\ndef beta(x,y):\n    return cov(x,y)/var(x)\n\nprint beta(x,y) #4.34285714286\n</code></pre>\n", "abstract": "Compute the beta coefficient."}]}, {"link": "https://stackoverflow.com/questions/7545015/can-someone-explain-this-0-2-0-1-0-30000000000000004", "question": {"id": "7545015", "title": "Can someone explain this: 0.2 + 0.1 = 0.30000000000000004?", "content": "<blockquote>\n<p><strong>Duplicates:</strong><br/>\n<a href=\"https://stackoverflow.com/questions/56947/how-is-floating-point-stored-when-does-it-matter\">How is floating point stored? When does it matter?</a></p>\n<p><a href=\"https://stackoverflow.com/questions/588004/is-floating-point-math-broken\">Is floating point math broken?</a></p>\n</blockquote>\n<p>Why does the following occur in the Python Interpreter?</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 0.1+0.1+0.1-0.3\n5.551115123125783e-17\n&gt;&gt;&gt; 0.1+0.1\n0.2\n&gt;&gt;&gt; 0.2+0.1\n0.30000000000000004\n&gt;&gt;&gt; 0.3-0.3\n0.0\n&gt;&gt;&gt; 0.2+0.1\n0.30000000000000004\n&gt;&gt;&gt; \n</code></pre>\n<p>Why doesn't <code>0.2 + 0.1 = 0.3</code>?</p>\n", "abstract": "Duplicates:\nHow is floating point stored? When does it matter? Is floating point math broken? Why does the following occur in the Python Interpreter? Why doesn't 0.2 + 0.1 = 0.3?"}, "answers": [{"id": 7545025, "score": 29, "vote": 0, "content": "<p>That's because <code>.1</code> cannot be represented exactly in a binary floating point representation. If you try</p>\n<pre><code class=\"python\">&gt;&gt;&gt; .1\n</code></pre>\n<p>Python will respond with <code>.1</code> because it only prints up to a certain precision, but there's already a small round-off error. The same happens with <code>.3</code>, but when you issue</p>\n<pre><code class=\"python\">&gt;&gt;&gt; .2 + .1\n0.30000000000000004\n</code></pre>\n<p>then the round-off errors in <code>.2</code> and <code>.1</code> accumulate. Also note:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; .2 + .1 == .3\nFalse\n</code></pre>\n", "abstract": "That's because .1 cannot be represented exactly in a binary floating point representation. If you try Python will respond with .1 because it only prints up to a certain precision, but there's already a small round-off error. The same happens with .3, but when you issue then the round-off errors in .2 and .1 accumulate. Also note:"}, {"id": 7545038, "score": 15, "vote": 0, "content": "<p>Not all floating point numbers are exactly representable on a finite machine. Neither 0.1 nor 0.2 are exactly representable in binary floating point. And nor is 0.3.</p>\n<p>A number is exactly representable if it is of the form a/b where a and b are an integers and b  is a power of 2. Obviously, the data type needs to have a large enough significand to store the number also.</p>\n<p>I recommend <a href=\"http://pages.cs.wisc.edu/~rkennedy/exact-float\" rel=\"noreferrer\">Rob Kennedy's useful webpage</a> as a nice tool to explore representability.</p>\n", "abstract": "Not all floating point numbers are exactly representable on a finite machine. Neither 0.1 nor 0.2 are exactly representable in binary floating point. And nor is 0.3. A number is exactly representable if it is of the form a/b where a and b are an integers and b  is a power of 2. Obviously, the data type needs to have a large enough significand to store the number also. I recommend Rob Kennedy's useful webpage as a nice tool to explore representability."}]}, {"link": "https://stackoverflow.com/questions/210629/python-unsigned-32-bit-bitwise-arithmetic", "question": {"id": "210629", "title": "Python: unsigned 32 bit bitwise arithmetic", "content": "<p>Trying to answer to another post whose solution deals with IP addresses and netmasks, I got stuck with plain bitwise arithmetic.</p>\n<p>Is there a standard way, in Python, to carry on bitwise AND, OR, XOR, NOT operations assuming that the inputs are \"32 bit\" (maybe negative) integers or longs, and that the result must be a long in the range [0, 2**32]?</p>\n<p>In other words, I need a working Python counterpart to the C bitwise operations between  unsigned longs.</p>\n<p>EDIT: the specific issue is this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; m = 0xFFFFFF00   # netmask 255.255.255.0\n&gt;&gt;&gt; ~m\n-4294967041L         # wtf?! I want 255\n</code></pre>\n", "abstract": "Trying to answer to another post whose solution deals with IP addresses and netmasks, I got stuck with plain bitwise arithmetic. Is there a standard way, in Python, to carry on bitwise AND, OR, XOR, NOT operations assuming that the inputs are \"32 bit\" (maybe negative) integers or longs, and that the result must be a long in the range [0, 2**32]? In other words, I need a working Python counterpart to the C bitwise operations between  unsigned longs. EDIT: the specific issue is this:"}, "answers": [{"id": 210740, "score": 59, "vote": 0, "content": "<p>You can use <a href=\"http://docs.python.org/lib/module-ctypes.html\" rel=\"noreferrer\">ctypes</a> and its <code>c_uint32</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import ctypes\n&gt;&gt;&gt; m = 0xFFFFFF00\n&gt;&gt;&gt; ctypes.c_uint32(~m).value\n255L\n</code></pre>\n<p>So what I did here was casting <code>~m</code> to a C 32-bit unsigned integer and retrieving its value back in Python format.</p>\n", "abstract": "You can use ctypes and its c_uint32: So what I did here was casting ~m to a C 32-bit unsigned integer and retrieving its value back in Python format."}, {"id": 210747, "score": 50, "vote": 0, "content": "<p>You can mask everything by <code>0xFFFFFFFF</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; m = 0xFFFFFF00\n&gt;&gt;&gt; allf = 0xFFFFFFFF\n&gt;&gt;&gt; ~m &amp; allf\n255L\n</code></pre>\n", "abstract": "You can mask everything by 0xFFFFFFFF:"}, {"id": 210707, "score": 12, "vote": 0, "content": "<pre><code class=\"python\">from numpy import uint32\n</code></pre>\n", "abstract": ""}, {"id": 34951075, "score": 5, "vote": 0, "content": "<p>You could also xor with 0xFFFFFFFF, which is equivalent to the \"unsigned complement\".</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 0xFFFFFF00 ^ 0xFFFFFFFF\n255\n</code></pre>\n", "abstract": "You could also xor with 0xFFFFFFFF, which is equivalent to the \"unsigned complement\"."}, {"id": 211342, "score": 1, "vote": 0, "content": "<p>This is a module that I created a long time ago, and it might be of help to you:</p>\n<p><a href=\"http://pypi.python.org/pypi/IPv4_Utils/0.35\" rel=\"nofollow noreferrer\">IPv4Utils</a></p>\n<p>It provides at least a <code>CIDR</code> class with subnet arithmetic. Check the test cases at the end of the module for examples.</p>\n", "abstract": "This is a module that I created a long time ago, and it might be of help to you: IPv4Utils It provides at least a CIDR class with subnet arithmetic. Check the test cases at the end of the module for examples."}]}, {"link": "https://stackoverflow.com/questions/2150050/finding-signed-angle-between-vectors", "question": {"id": "2150050", "title": "Finding Signed Angle Between Vectors", "content": "<p>How would you find the signed angle theta from vector a to b?</p>\n<p>And yes, I know that theta = arccos((a.b)/(|a||b|)).</p>\n<p>However, this does not contain a sign (i.e. it doesn't distinguish between a clockwise or counterclockwise rotation).</p>\n<p>I need something that can tell me the minimum angle to rotate from a to b. A positive sign indicates a rotation from +x-axis towards +y-axis. Conversely, a negative sign indicates a rotation from +x-axis towards -y-axis.</p>\n<pre><code class=\"python\">assert angle((1,0),(0,1)) == pi/2.\nassert angle((0,1),(1,0)) == -pi/2.\n</code></pre>\n", "abstract": "How would you find the signed angle theta from vector a to b? And yes, I know that theta = arccos((a.b)/(|a||b|)). However, this does not contain a sign (i.e. it doesn't distinguish between a clockwise or counterclockwise rotation). I need something that can tell me the minimum angle to rotate from a to b. A positive sign indicates a rotation from +x-axis towards +y-axis. Conversely, a negative sign indicates a rotation from +x-axis towards -y-axis."}, "answers": [{"id": 2150475, "score": 71, "vote": 0, "content": "<p>What you want to use is often called the \u201cperp dot product\u201d, that is, find the vector perpendicular to one of the vectors, and then find the dot product with the other vector.</p>\n<pre><code class=\"python\">if(a.x*b.y - a.y*b.x &lt; 0)\n    angle = -angle;\n</code></pre>\n<p>You can also do this:</p>\n<pre><code class=\"python\">angle = atan2( a.x*b.y - a.y*b.x, a.x*b.x + a.y*b.y );\n</code></pre>\n", "abstract": "What you want to use is often called the \u201cperp dot product\u201d, that is, find the vector perpendicular to one of the vectors, and then find the dot product with the other vector. You can also do this:"}, {"id": 2150111, "score": 38, "vote": 0, "content": "<p>If you have an atan2() function in your math library of choice:</p>\n<pre><code class=\"python\">signed_angle = atan2(b.y,b.x) - atan2(a.y,a.x)\n</code></pre>\n", "abstract": "If you have an atan2() function in your math library of choice:"}]}, {"link": "https://stackoverflow.com/questions/30148740/how-do-i-do-exponentiation-in-python", "question": {"id": "30148740", "title": "How do I do exponentiation in python?", "content": "<pre><code class=\"python\">def cube(number):\n  return number^3\nprint cube(2)\n</code></pre>\n<p>I would expect <code>cube(2) = 8</code>, but instead I'm getting <code>cube(2) = 1</code></p>\n<p>What am I doing wrong?</p>\n", "abstract": "I would expect cube(2) = 8, but instead I'm getting cube(2) = 1 What am I doing wrong?"}, "answers": [{"id": 30148765, "score": 88, "vote": 0, "content": "<p><code>^</code> is the <a href=\"http://en.wikipedia.org/wiki/Exclusive_or\">xor</a> operator.</p>\n<p><code>**</code> is exponentiation.</p>\n<p><code>2**3 = 8</code></p>\n", "abstract": "^ is the xor operator. ** is exponentiation. 2**3 = 8"}, {"id": 30149434, "score": 14, "vote": 0, "content": "<p>You can also use the <code>math</code> library. For example:</p>\n<pre><code class=\"python\">import math\nx = math.pow(2,3) # x = 2 to the power of 3\n</code></pre>\n", "abstract": "You can also use the math library. For example:"}, {"id": 30149471, "score": 2, "vote": 0, "content": "<p>if you want to repeat it multiple times - you should consider using numpy:</p>\n<pre><code class=\"python\">import numpy as np\n\ndef cube(number):\n    # can be also called with a list\n    return np.power(number, 3)\n\nprint(cube(2))\nprint(cube([2, 8]))\n</code></pre>\n", "abstract": "if you want to repeat it multiple times - you should consider using numpy:"}]}, {"link": "https://stackoverflow.com/questions/35749246/python-atan-or-atan2-what-should-i-use", "question": {"id": "35749246", "title": "Python atan or atan2, what should I use?", "content": "<p>My formula\nf=arctan(ImZ/ReZ)</p>\n<p>There are two options:</p>\n<p>Option 1 (atan):</p>\n<pre><code class=\"python\">ImZ=-4.593172163003\nImR=-4.297336384845\n\n&gt;&gt;&gt; z=y/x\n&gt;&gt;&gt; f1=math.atan(z)\n&gt;&gt;&gt; f1\n0.8186613519278327\n</code></pre>\n<p>Option 2 (atan2)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; f=math.atan2(y,x)\n&gt;&gt;&gt; f\n-2.3229313016619604\n</code></pre>\n<p>Why are these two results different?</p>\n", "abstract": "My formula\nf=arctan(ImZ/ReZ) There are two options: Option 1 (atan): Option 2 (atan2) Why are these two results different?"}, "answers": [{"id": 35749495, "score": 70, "vote": 0, "content": "<p>Atan takes single argument and Atan2 takes two arguments.The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument Atan</p>\n<p><a href=\"https://i.stack.imgur.com/mKPZw.png\" rel=\"noreferrer\"><img alt=\"atan2 results for each x,y\" src=\"https://i.stack.imgur.com/mKPZw.png\"/></a></p>\n<p>Atan2 result is always between -pi and pi.</p>\n<p>Reference:\n<a href=\"https://en.wikipedia.org/wiki/Atan2\" rel=\"noreferrer\">https://en.wikipedia.org/wiki/Atan2</a></p>\n", "abstract": "Atan takes single argument and Atan2 takes two arguments.The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument Atan  Atan2 result is always between -pi and pi. Reference:\nhttps://en.wikipedia.org/wiki/Atan2"}, {"id": 35749562, "score": 14, "vote": 0, "content": "<p>docstring for math.atan:</p>\n<blockquote>\n<p>atan(x)\n  Return the arc tangent (measured in radians) of x.</p>\n</blockquote>\n<p>docstring for math.atan2:</p>\n<blockquote>\n<p>atan2(y, x)\n  Return the arc tangent (measured in radians) of y/x. Unlike atan(y/x),\n  the signs of both x and y are considered.</p>\n</blockquote>\n<p>To be very complete, here's what the doc says about atan2:</p>\n<blockquote>\n<p>math.atan2(y, x) Return atan(y / x), in radians. The result is between\n  -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is\n  that the signs of both inputs are known to it, so it can compute the\n  correct quadrant for the angle. For example, atan(1) and atan2(1, 1)\n  are both pi/4, but atan2(-1, -1) is -3*pi/4.</p>\n</blockquote>\n<p>So it's pretty clear: the outputs are different because of the signs of <code>ImZ</code> and <code>ImR</code>. <code>atan2</code> returns the appropriate quadrant, unlike <code>atan</code>.</p>\n", "abstract": "docstring for math.atan: atan(x)\n  Return the arc tangent (measured in radians) of x. docstring for math.atan2: atan2(y, x)\n  Return the arc tangent (measured in radians) of y/x. Unlike atan(y/x),\n  the signs of both x and y are considered. To be very complete, here's what the doc says about atan2: math.atan2(y, x) Return atan(y / x), in radians. The result is between\n  -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is\n  that the signs of both inputs are known to it, so it can compute the\n  correct quadrant for the angle. For example, atan(1) and atan2(1, 1)\n  are both pi/4, but atan2(-1, -1) is -3*pi/4. So it's pretty clear: the outputs are different because of the signs of ImZ and ImR. atan2 returns the appropriate quadrant, unlike atan."}, {"id": 65460223, "score": 1, "vote": 0, "content": "<p>As others said, the atan2 takes two arguments to be able to determine the quadrant of the output angle properly...</p>\n<p>However, it still outputs an angle between <code>[-pi,pi]</code>, which is not always useful (positive <code>[0,pi]</code> for 1st and 2nd quadrants; and negative <code>[-pi,0]</code> for 3rd and 4th).</p>\n<p>It's possible to define an <code>atan</code> function that returns an angle in <code>[0,2pi]</code>, as theodore panagos showed.</p>\n<p>Improving on theodore panagos' answer, here is a python version using numpy</p>\n<pre><code class=\"python\">import numpy\n\n# defining the atan function\nmyatan = lambda x,y: numpy.pi*(1.0-0.5*(1+numpy.sign(x))*(1-numpy.sign(y**2))\\\n         -0.25*(2+numpy.sign(x))*numpy.sign(y))\\\n         -numpy.sign(x*y)*numpy.arctan((numpy.abs(x)-numpy.abs(y))/(numpy.abs(x)+numpy.abs(y)))\n\n#testing\nu = numpy.array([[numpy.sqrt(3.0)/2.0,0.5],   # expected: 30\n                 [0.5,numpy.sqrt(3.0)/2.0],   # expected: 60\n                 [0.0,1.0],                   # expected: 90\n                 [-0.5,numpy.sqrt(3.0)/2.0],  # expected: 120\n                 [-numpy.sqrt(3.0)/2.0,0.5],  # expected: 150\n                 [-1.0,0.0],                  # expected: 180\n                 [-numpy.sqrt(3.0)/2.0,-0.5], # expected: 210\n                 [-0.5,-numpy.sqrt(3.0)/2.0], # expected: 240\n                 [0.0,-1.0],                  # expected: 270\n                 [0.5,-numpy.sqrt(3.0)/2.0],  # expected: 300\n                 [numpy.sqrt(3.0)/2.0,-0.5],  # expected: 330\n                 [1.0,0.0]])                  # expected: 0 or 360\ntheta = myatan(u[:,0],u[:,1])\nprint(theta * 180.0/numpy.pi) # converting to degrees\n</code></pre>\n<p>output:</p>\n<pre><code class=\"python\">[ 30.  60.  90. 120. 150. 180. 210. 240. 270. 300. 330.   0.]\n</code></pre>\n<p>it does not output 360 exactly, but it goes through up to it, then it cycles, as expected</p>\n", "abstract": "As others said, the atan2 takes two arguments to be able to determine the quadrant of the output angle properly... However, it still outputs an angle between [-pi,pi], which is not always useful (positive [0,pi] for 1st and 2nd quadrants; and negative [-pi,0] for 3rd and 4th). It's possible to define an atan function that returns an angle in [0,2pi], as theodore panagos showed. Improving on theodore panagos' answer, here is a python version using numpy output: it does not output 360 exactly, but it goes through up to it, then it cycles, as expected"}, {"id": 54220152, "score": 0, "vote": 0, "content": "<p>A formula to have an angle counter clockwise from 0,that is the positive axis of x,</p>\n<p>to 2pi for any value of x and y. For x=y=0 the result is undefined.</p>\n<pre><code class=\"python\">f(x,y)=pi-pi/2*(1+sign(x))*(1-sign(y^2))-pi/4*(2+sign(x))*sign(y)\n       -sign(x*y)*atan((abs(x)-abs(y))/(abs(x)+abs(y)))\n</code></pre>\n", "abstract": "A formula to have an angle counter clockwise from 0,that is the positive axis of x, to 2pi for any value of x and y. For x=y=0 the result is undefined."}]}, {"link": "https://stackoverflow.com/questions/42258637/how-to-know-the-angle-between-two-vectors", "question": {"id": "42258637", "title": "How to know the angle between two vectors?", "content": "<p>I am making small game with pygame and I have made a gun that rotates around its center.\nMy problem is that I want the gun to rotate by itself to the enemy direction, but I couldn't do that because I can't find the angle between the gun and the enemy to make the gun rotate to it \nI have searched and I found that I have to use the <code>atan2</code> but I didn't find any working code so I hope someone could help me.</p>\n<p>Here is my code:</p>\n<pre><code class=\"python\">import pygame\nfrom pygame.locals import*\npygame.init()\nheight=650\nwidth=650\nscreen=pygame.display.set_mode((height,width))\nclock=pygame.time.Clock()\ngun=pygame.image.load(\"m2.png\").convert_alpha() \ngun=pygame.transform.smoothscale(gun,(200,200)).convert_alpha()\nangle=0\nangle_change=0\nRED=(255,0,0)\nx=525\ny=155\nwhile True :\n    screen.fill((150,150,150))\n    for event in pygame.event.get():\n        if event.type==QUIT:\n            pygame.quit()\n            quit()\n        if event.type==KEYDOWN:\n            if event.key==K_a:\n                angle_change=+1\n            if event.key==K_d:\n                angle_change=-1\n        elif event.type==KEYUP:\n            angle_change=0\n    angle+=angle_change\n    if angle&gt;360:\n        angle=0\n    if angle&lt;0:\n        angle=360\n    pygame.draw.rect(screen,RED,(x,y,64,64))\n    position = (height/2,width/2)\n    gun_rotate=pygame.transform.rotate(gun,angle) \n    rotate_rect = gun_rotate.get_rect()\n    rotate_rect.center = position\n    screen.blit(gun_rotate, rotate_rect)\n    pygame.display.update()\n    clock.tick(60) \n</code></pre>\n<p>And here is a picture trying to make it clear:</p>\n<p><a href=\"https://i.stack.imgur.com/b8cGG.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/b8cGG.png\"/></a></p>\n<p>How do I solve the problem?</p>\n", "abstract": "I am making small game with pygame and I have made a gun that rotates around its center.\nMy problem is that I want the gun to rotate by itself to the enemy direction, but I couldn't do that because I can't find the angle between the gun and the enemy to make the gun rotate to it \nI have searched and I found that I have to use the atan2 but I didn't find any working code so I hope someone could help me. Here is my code: And here is a picture trying to make it clear:  How do I solve the problem?"}, "answers": [{"id": 42258870, "score": 63, "vote": 0, "content": "<p>The tangent of the angle between two points is defined as delta y / delta x\nThat is (y2 - y1)/(x2-x1). This means that <code>math.atan2(dy, dx)</code> give the angle between the two points <strong>assuming</strong> that you know the base axis that defines the co-ordinates.</p>\n<p>Your gun is assumed to be the (0, 0) point of the axes in order to calculate the angle in radians. Once you have that angle, then you can use the angle for the remainder of your calculations.</p>\n<p>Note that since the angle is in radians, you need to use the math.pi instead of 180 degrees within your code. Also your test for more than 360 degrees (2*math.pi) is not needed. The test for negative (&lt; 0) is incorrect as you then force it to 0, which forces the target to be on the x axis in the positive direction.</p>\n<p>Your code to calculate the angle between the gun and the target is thus</p>\n<pre><code class=\"python\">myradians = math.atan2(targetY-gunY, targetX-gunX)\n</code></pre>\n<p>If you want to convert radians to degrees</p>\n<pre><code class=\"python\">mydegrees = math.degrees(myradians)\n</code></pre>\n<p>To convert from degrees to radians</p>\n<pre><code class=\"python\">myradians = math.radians(mydegrees)\n</code></pre>\n<p><a href=\"http://www.tutorialgateway.org/python-atan2/\" rel=\"noreferrer\">Python ATAN2</a></p>\n<blockquote>\n<p>The Python ATAN2 function is one of the Python Math function which is\n  used to returns the angle (in radians) from the X -Axis to the\n  specified point (y, x).</p>\n</blockquote>\n<p><a href=\"https://sites.google.com/a/pythontkinter.com/tkinter/mathatan2\" rel=\"noreferrer\">math.atan2()</a></p>\n<blockquote>\n<p><strong>Definition</strong>   Returns the tangent(y,x) in radius.</p>\n<p><strong>Syntax</strong><br/>\n  math.atan2(y,x)</p>\n<p><strong>Parameters</strong><br/>\n  y,x=numbers</p>\n<p><strong>Examples</strong><br/>\n  The return is:  </p>\n<pre><code class=\"python\">&gt;&gt;&gt; import math  \n&gt;&gt;&gt; math.atan2(88,34)  \n1.202100424136847  \n&gt;&gt;&gt;\n</code></pre>\n</blockquote>\n", "abstract": "The tangent of the angle between two points is defined as delta y / delta x\nThat is (y2 - y1)/(x2-x1). This means that math.atan2(dy, dx) give the angle between the two points assuming that you know the base axis that defines the co-ordinates. Your gun is assumed to be the (0, 0) point of the axes in order to calculate the angle in radians. Once you have that angle, then you can use the angle for the remainder of your calculations. Note that since the angle is in radians, you need to use the math.pi instead of 180 degrees within your code. Also your test for more than 360 degrees (2*math.pi) is not needed. The test for negative (< 0) is incorrect as you then force it to 0, which forces the target to be on the x axis in the positive direction. Your code to calculate the angle between the gun and the target is thus If you want to convert radians to degrees To convert from degrees to radians Python ATAN2 The Python ATAN2 function is one of the Python Math function which is\n  used to returns the angle (in radians) from the X -Axis to the\n  specified point (y, x). math.atan2() Definition   Returns the tangent(y,x) in radius. Syntax\n  math.atan2(y,x) Parameters\n  y,x=numbers Examples\n  The return is:  "}, {"id": 51635888, "score": 6, "vote": 0, "content": "<p>Specifically for working with <code>shapely linestring</code> objects, assuming your object (two points) is of the form <code>(min long, min lat, max long, max lat)</code></p>\n<pre><code class=\"python\">from math import atan2,degrees\nline = #Your-LineString-Object\nlineList = list(line.coords)\n\ndef AngleBtw2Points(pointA, pointB):\n  changeInX = pointB[0] - pointA[0]\n  changeInY = pointB[1] - pointA[1]\n  return degrees(atan2(changeInY,changeInX)) #remove degrees if you want your answer in radians\n\nAngleBtw2Points(lineList[0],lineList[1]) \n</code></pre>\n", "abstract": "Specifically for working with shapely linestring objects, assuming your object (two points) is of the form (min long, min lat, max long, max lat)"}, {"id": 64563327, "score": 5, "vote": 0, "content": "<p>In general, the angle of a vector <em>(x, y)</em> can be calculated by <code>math.atan2(y, x)</code>. The vector can be defined by 2 points <em>(x1, y1)</em> and <em>(x2, y2)</em> on a line. Therefore the angle of the line is <code>math.atan2(y2-y1, x2-x1)</code>.\nBe aware that the y-axis needs to be reversed (<code>-y</code> respectively <code>y1-y2</code>) because the y-axis is generally pointing up but in the PyGame coordinate system the y-axis is pointing down. The unit of the angle in the Python <code>math</code> module is <a href=\"https://en.wikipedia.org/wiki/Radian\" rel=\"nofollow noreferrer\">Radian</a>, but the unit of the angle in PyGame functions like <a href=\"https://www.pygame.org/docs/ref/transform.html#pygame.transform.rotate\" rel=\"nofollow noreferrer\"><code>pygame.transform.rotate()</code></a> is <a href=\"https://en.wikipedia.org/wiki/Degree\" rel=\"nofollow noreferrer\">Degree</a>. Hence the angle has to be converted from Radians to Degrees by <code>math.degrees</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import math\n\ndef angle_of_vector(x, y):\n    return math.degrees(math.atan2(-y, x))\n\ndef angle_of_line(x1, y1, x2, y2):\n    return math.degrees(math.atan2(-(y2-y1), x2-x1))\n</code></pre>\n<p>This can be simplified by using the <a href=\"https://www.pygame.org/docs/ref/math.html#pygame.math.Vector2.angle_to\" rel=\"nofollow noreferrer\"><code>angle_to</code></a> method of the <code>pygame.math.Vector2</code> object. This method computes the angle between 2 vectors in the PyGame coordinate system in degrees. Therefore it is not necessary to reverse the y-axis and convert from radians to degrees. Just calculate the angle between the vector and <em>(1, 0)</em>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def angle_of_vector(x, y):\n    return pygame.math.Vector2(x, y).angle_to((1, 0))\n\ndef angle_of_line(x1, y1, x2, y2):\n    return angle_of_vector(x2-x1, y2-y1)\n</code></pre>\n<p>Minimale example:</p>\n<p><a href=\"https://i.stack.imgur.com/Sb5p3.gif\" rel=\"nofollow noreferrer\"><img alt=\"\" src=\"https://i.stack.imgur.com/Sb5p3.gif\"/></a></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import pygame\nimport math\n\ndef angle_of_vector(x, y):\n    #return math.degrees(math.atan2(-y, x))            # 1: with math.atan\n    return pygame.math.Vector2(x, y).angle_to((1, 0))  # 2: with pygame.math.Vector2.angle_to\n    \ndef angle_of_line(x1, y1, x2, y2):\n    #return math.degrees(math.atan2(-y1-y2, x2-x1))    # 1: math.atan\n    return angle_of_vector(x2-x1, y2-y1)               # 2: pygame.math.Vector2.angle_to\n    \npygame.init()\nwindow = pygame.display.set_mode((400, 400))\nclock = pygame.time.Clock()\nfont = pygame.font.SysFont(None, 50)\n\nangle = 0\nradius = 150\nvec = (radius, 0)\n\nrun = True\nwhile run:\n    clock.tick(60)\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            run = False\n\n    cpt = window.get_rect().center\n    pt = cpt[0] + vec[0], cpt[1] + vec[1]\n    angle = angle_of_vector(*vec)\n\n    window.fill((255, 255, 255))\n    pygame.draw.circle(window, (0, 0, 0), cpt, radius, 1)\n    pygame.draw.line(window, (0, 255, 0), cpt, (cpt[0] + radius, cpt[1]), 3)\n    pygame.draw.line(window, (255, 0, 0), cpt, pt, 3)\n    text_surf = font.render(str(round(angle/5)*5) + \"\u00b0\", True, (255, 0, 0))\n    text_surf.set_alpha(127)\n    window.blit(text_surf, text_surf.get_rect(bottomleft = (cpt[0]+20, cpt[1]-20)))\n    pygame.display.flip()\n\n    angle = (angle + 1) % 360\n    vec = radius * math.cos(angle*math.pi/180), radius * -math.sin(angle*math.pi/180)\n\npygame.quit()\nexit()\n</code></pre>\n<hr/>\n<p><a href=\"https://www.pygame.org/docs/ref/math.html#pygame.math.Vector2.angle_to\" rel=\"nofollow noreferrer\"><code>angle_to</code></a> can be used to calculate the angle between 2 vectors or lines:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def angle_between_vectors(x1, y1, x2, y2):\n    return pygame.math.Vector2(x1, y1).angle_to((x2, y2))\n</code></pre>\n<p>Minimal example:</p>\n<p><a href=\"https://i.stack.imgur.com/fW3WH.gif\" rel=\"nofollow noreferrer\"><img alt=\"\" src=\"https://i.stack.imgur.com/fW3WH.gif\"/></a></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import pygame\nimport math\n\ndef angle_between_vectors(x1, y1, x2, y2):\n    return pygame.math.Vector2(x1, y1).angle_to((x2, y2))\n\ndef angle_of_vector(x, y):\n    return pygame.math.Vector2(x, y).angle_to((1, 0))    \n    \npygame.init()\nwindow = pygame.display.set_mode((400, 400))\nclock = pygame.time.Clock()\nfont = pygame.font.SysFont(None, 50)\n\nangle = 0\nradius = 150\nvec1 = (radius, 0)\nvec2 = (radius, 0)\n\nrun = True\nwhile run:\n    clock.tick(60)\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            run = False\n\n    cpt = window.get_rect().center\n    pt1 = cpt[0] + vec1[0], cpt[1] + vec1[1]\n    pt2 = cpt[0] + vec2[0], cpt[1] + vec2[1]\n    angle = angle_between_vectors(*vec2, *vec1)\n\n    window.fill((255, 255, 255))\n    pygame.draw.circle(window, (0, 0, 0), cpt, radius, 1)\n    pygame.draw.line(window, (0, 255, 0), cpt, pt1, 3)\n    pygame.draw.line(window, (255, 0, 0), cpt, pt2, 3)\n    text_surf = font.render(str(round(angle/5)*5) + \"\u00b0\", True, (255, 0, 0))\n    text_surf.set_alpha(127)\n    window.blit(text_surf, text_surf.get_rect(bottomleft = (cpt[0]+20, cpt[1]-20)))\n    pygame.display.flip()\n\n    angle1 = (angle_of_vector(*vec1) + 1/3) % 360\n    vec1 = radius * math.cos(angle1*math.pi/180), radius * -math.sin(angle1*math.pi/180)\n    angle2 = (angle_of_vector(*vec2) + 1) % 360\n    vec2 = radius * math.cos(angle2*math.pi/180), radius * -math.sin(angle2*math.pi/180)\n\npygame.quit()\nexit()\n</code></pre>\n", "abstract": "In general, the angle of a vector (x, y) can be calculated by math.atan2(y, x). The vector can be defined by 2 points (x1, y1) and (x2, y2) on a line. Therefore the angle of the line is math.atan2(y2-y1, x2-x1).\nBe aware that the y-axis needs to be reversed (-y respectively y1-y2) because the y-axis is generally pointing up but in the PyGame coordinate system the y-axis is pointing down. The unit of the angle in the Python math module is Radian, but the unit of the angle in PyGame functions like pygame.transform.rotate() is Degree. Hence the angle has to be converted from Radians to Degrees by math.degrees: This can be simplified by using the angle_to method of the pygame.math.Vector2 object. This method computes the angle between 2 vectors in the PyGame coordinate system in degrees. Therefore it is not necessary to reverse the y-axis and convert from radians to degrees. Just calculate the angle between the vector and (1, 0): Minimale example:  angle_to can be used to calculate the angle between 2 vectors or lines: Minimal example: "}, {"id": 70070428, "score": 3, "vote": 0, "content": "<p>I used following code.</p>\n<pre><code class=\"python\">import math\n\ndef get_angle(x1,y1,x2,y2):\n    myradians = math.atan2(y1-y2, x1-x2)\n    mydegrees = math.degrees(myradians)\n    return mydegrees\n\n# it should return -90 degree\nprint(get_angle(0,0,0,100))\n</code></pre>\n", "abstract": "I used following code."}, {"id": 42258820, "score": 1, "vote": 0, "content": "<p>As one commenter already said, there is only an angle between three points or between two intersecting vectors, that can be derived from this threee points. I assume you want the angle, that the gun and the target (vector 1) and the X-Axis (vector 2) has. Here is a link to a page, that explains how to calculate that angle. <a href=\"http://www.euclideanspace.com/maths/algebra/vectors/angleBetween/index.htm\" rel=\"nofollow noreferrer\">http://www.euclideanspace.com/maths/algebra/vectors/angleBetween/index.htm</a></p>\n<p>Python example:</p>\n<pre><code class=\"python\">import math\n\ndef angle(vector1, vector2):\n    length1 = math.sqrt(vector1[0] * vector1[0] + vector1[1] * vector1[1])\n    length2 = math.sqrt(vector2[0] * vector2[0] + vector2[1] * vector2[1])\n    return math.acos((vector1[0] * vector2[0] + vector1[1] * vector2[1])/ (length1 * length2))\n\nvector1 = [targetX - gunX, targetY - gunY] # Vector of aiming of the gun at the target\nvector2 = [1,0] #vector of X-axis\nprint(angle(vector1, vector2))\n</code></pre>\n", "abstract": "As one commenter already said, there is only an angle between three points or between two intersecting vectors, that can be derived from this threee points. I assume you want the angle, that the gun and the target (vector 1) and the X-Axis (vector 2) has. Here is a link to a page, that explains how to calculate that angle. http://www.euclideanspace.com/maths/algebra/vectors/angleBetween/index.htm Python example:"}, {"id": 51647228, "score": 0, "vote": 0, "content": "<p>You can just use the <code>as_polar</code> method of Pygame's <a href=\"http://www.pygame.org/docs/ref/math.html#pygame.math.Vector2\" rel=\"nofollow noreferrer\">Vector2</a> class which returns the <a href=\"https://en.wikipedia.org/wiki/Polar_coordinates\" rel=\"nofollow noreferrer\">polar coordinates</a> of the vector (radius and polar angle (in degrees)).</p>\n<p>So just subtract the first point vector from the second and call the <code>as_polar</code> method of the resulting vector.</p>\n<pre><code class=\"python\">import pygame as pg\nfrom pygame.math import Vector2\n\n\npg.init()\nscreen = pg.display.set_mode((640, 480))\nclock = pg.time.Clock()\nBG_COLOR = pg.Color('gray12')\n\npoint = Vector2(320, 240)\nmouse_pos = Vector2(0, 0)\nradius, angle = (mouse_pos - point).as_polar()\n\ndone = False\nwhile not done:\n    for event in pg.event.get():\n        if event.type == pg.QUIT:\n            done = True\n        elif event.type == pg.MOUSEMOTION:\n            mouse_pos = event.pos\n            radius, angle = (mouse_pos - point).as_polar()\n\n    screen.fill(BG_COLOR)\n    pg.draw.line(screen, (0, 100, 255), point, mouse_pos)\n    pg.display.set_caption(f'radius: {radius:.2f} angle: {angle:.2f}')\n    pg.display.flip()\n    clock.tick(60)\n</code></pre>\n", "abstract": "You can just use the as_polar method of Pygame's Vector2 class which returns the polar coordinates of the vector (radius and polar angle (in degrees)). So just subtract the first point vector from the second and call the as_polar method of the resulting vector."}, {"id": 72807359, "score": 0, "vote": 0, "content": "<p>For anyone wanting a bit more information on this subject check out omnicalculator's break down of the subject:\n<a href=\"https://www.omnicalculator.com/math/angle-between-two-vectors\" rel=\"nofollow noreferrer\">https://www.omnicalculator.com/math/angle-between-two-vectors</a></p>\n<p>Extracted relevant information:</p>\n<pre><code class=\"python\">from math import acos, sqrt, degrees\n\n# returns angle in radians between two points pt1, pt2 where pt1=(x1, y1) and pt2=(x2, y2)\nangle = acos((x1 * x2 + y1 * y2)/(sqrt(x1**2 + y1**2) * sqrt(x2**2 + y2**2)))\n\n# convert to degrees\ndeg_angle = degrees(angle)\n</code></pre>\n", "abstract": "For anyone wanting a bit more information on this subject check out omnicalculator's break down of the subject:\nhttps://www.omnicalculator.com/math/angle-between-two-vectors Extracted relevant information:"}]}, {"link": "https://stackoverflow.com/questions/19517868/integer-division-by-negative-number", "question": {"id": "19517868", "title": "Integer division by negative number", "content": "<p>What should integer division -1 / 5 return? I am totally confused by this behaviour. I think mathematically it should be 0, but python and ruby are returning -1.</p>\n<p>Why are different languages behaving differently here? Please someone explain. Thanks.</p>\n<pre><code class=\"python\">| Language  | Code           | Result |\n|-----------+----------------+--------|\n| ruby      | -1 / 5         |     -1 |\n| python    | -1 / 5         |     -1 |\n| c         | -1 / 5         |      0 |\n| clojure   | (int (/ -1 5)) |      0 |\n| emacslisp | (/ -1 5)       |      0 |\n| bash      | expr -1 / 5    |      0 |\n</code></pre>\n", "abstract": "What should integer division -1 / 5 return? I am totally confused by this behaviour. I think mathematically it should be 0, but python and ruby are returning -1. Why are different languages behaving differently here? Please someone explain. Thanks."}, "answers": [{"id": 19518866, "score": 49, "vote": 0, "content": "<p><strong>Short answer:</strong> Language designers get to choose if their language will round towards zero, negative infinity, or positive infinity when doing integer division. Different languages have made different choices.</p>\n<p><strong>Long answer:</strong> The language authors of Python and Ruby both decided that rounding towards negative infinity makes more sense than rounding towards zero (like C does). The creator of python wrote a blog post about his reasoning <a href=\"http://python-history.blogspot.com/2010/08/why-pythons-integer-division-floors.html\">here</a>. I've excerpted much of it below.</p>\n<blockquote>\n<p>I was asked (again) today to explain why integer division in Python returns the floor of the result instead of truncating towards zero like C.</p>\n<p>For positive numbers, there's no surprise:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 5//2\n2\n</code></pre>\n<p>But if one of the operands is negative, the result is floored, i.e., rounded away from zero (towards negative infinity):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; -5//2\n-3\n&gt;&gt;&gt; 5//-2\n-3\n</code></pre>\n<p>This disturbs some people, but there is a good mathematical reason.\n  The integer division operation (//) and its sibling, the modulo\n  operation (%), go together and satisfy a nice mathematical\n  relationship (all variables are integers):</p>\n<pre><code class=\"python\">a/b = q with remainder r\n</code></pre>\n<p>such that</p>\n<pre><code class=\"python\">b*q + r = a and 0 &lt;= r &lt; b\n(assuming a and b are &gt;= 0).\n</code></pre>\n<p>If you want the relationship to extend for negative a (keeping b\n  positive), you have two choices: if you truncate q towards zero, r\n  will become negative, so that the invariant changes to 0 &lt;= abs(r) &lt;\n  otherwise, you can floor q towards negative infinity, and the\n  invariant remains 0 &lt;= r &lt; b. [update: fixed this para]</p>\n<p>In mathematical number theory, mathematicians always prefer the latter\n  choice (see e.g. <a href=\"http://en.wikipedia.org/wiki/Modulo_operation\">Wikipedia</a>). For Python, I made the same choice\n  because there are some interesting applications of the modulo\n  operation where the sign of a is uninteresting. Consider taking a\n  POSIX timestamp (seconds since the start of 1970) and turning it into\n  the time of day. Since there are 24*3600 = 86400 seconds in a day,\n  this calculation is simply t % 86400. But if we were to express times\n  before 1970 using negative numbers, the \"truncate towards zero\" rule\n  would give a meaningless result! Using the floor rule it all works out\n  fine.</p>\n</blockquote>\n", "abstract": "Short answer: Language designers get to choose if their language will round towards zero, negative infinity, or positive infinity when doing integer division. Different languages have made different choices. Long answer: The language authors of Python and Ruby both decided that rounding towards negative infinity makes more sense than rounding towards zero (like C does). The creator of python wrote a blog post about his reasoning here. I've excerpted much of it below. I was asked (again) today to explain why integer division in Python returns the floor of the result instead of truncating towards zero like C. For positive numbers, there's no surprise: But if one of the operands is negative, the result is floored, i.e., rounded away from zero (towards negative infinity): This disturbs some people, but there is a good mathematical reason.\n  The integer division operation (//) and its sibling, the modulo\n  operation (%), go together and satisfy a nice mathematical\n  relationship (all variables are integers): such that If you want the relationship to extend for negative a (keeping b\n  positive), you have two choices: if you truncate q towards zero, r\n  will become negative, so that the invariant changes to 0 <= abs(r) <\n  otherwise, you can floor q towards negative infinity, and the\n  invariant remains 0 <= r < b. [update: fixed this para] In mathematical number theory, mathematicians always prefer the latter\n  choice (see e.g. Wikipedia). For Python, I made the same choice\n  because there are some interesting applications of the modulo\n  operation where the sign of a is uninteresting. Consider taking a\n  POSIX timestamp (seconds since the start of 1970) and turning it into\n  the time of day. Since there are 24*3600 = 86400 seconds in a day,\n  this calculation is simply t % 86400. But if we were to express times\n  before 1970 using negative numbers, the \"truncate towards zero\" rule\n  would give a meaningless result! Using the floor rule it all works out\n  fine."}, {"id": 19519244, "score": 6, "vote": 0, "content": "<p>Integer division is implementation specific. From Wikipedia's <a href=\"http://en.wikipedia.org/wiki/Modulo_operation\" rel=\"nofollow noreferrer\">Modulo operation</a>:</p>\n<blockquote>\n<p>Many implementations use <b>truncated division</b> where the quotient is defined by <a href=\"http://en.wikipedia.org/wiki/Truncation\" rel=\"nofollow noreferrer\" title=\"Truncation\">truncation</a> <i>q</i> = trunc(<i>a</i>/<i>n</i>), in other words it is the first integer in the direction of 0 from the exact rational quotient, and the remainder by <i>r</i>=<i>a</i> \u2212 <i>n</i> <i>q</i>. Informally speaking the quotient is \"rounded towards zero\", and the remainder therefore has the same sign as the dividend.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Donald_Knuth\" rel=\"nofollow noreferrer\" title=\"Donald Knuth\">Knuth</a> described <b>floored division</b> where the quotient is defined by the <a href=\"http://en.wikipedia.org/wiki/Floor_function\" rel=\"nofollow noreferrer\" title=\"Floor function\">floor function</a> <i>q</i>=floor(<i>a</i>/<i>n</i>) and the remainder <i>r</i> is</p>\n<p><img alt=\"r = a - nq = a - n \\left\\lfloor {a \\over n} \\right\\rfloor.\" height=\"39\" src=\"https://i.stack.imgur.com/k0z6Q.png\" width=\"214\"/></p>\n<p>Here the quotient is always rounded downwards (even if it is already negative) and the remainder has the same sign as the divisor.</p>\n</blockquote>\n", "abstract": "Integer division is implementation specific. From Wikipedia's Modulo operation: Many implementations use truncated division where the quotient is defined by truncation q = trunc(a/n), in other words it is the first integer in the direction of 0 from the exact rational quotient, and the remainder by r=a \u2212 n q. Informally speaking the quotient is \"rounded towards zero\", and the remainder therefore has the same sign as the dividend. Knuth described floored division where the quotient is defined by the floor function q=floor(a/n) and the remainder r is  Here the quotient is always rounded downwards (even if it is already negative) and the remainder has the same sign as the divisor."}]}, {"link": "https://stackoverflow.com/questions/9775731/clamping-floating-numbers-in-python", "question": {"id": "9775731", "title": "Clamping floating numbers in Python?", "content": "<p>Is there a built-in function for this in Python 2.6?</p>\n<p>Something like:</p>\n<pre><code class=\"python\">clamp(myValue, min, max)\n</code></pre>\n", "abstract": "Is there a built-in function for this in Python 2.6? Something like:"}, "answers": [{"id": 13232356, "score": 61, "vote": 0, "content": "<p>Numpy's <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html\"><code>clip</code></a> function will do this.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; numpy.clip(10,0,3)\n3\n&gt;&gt;&gt; numpy.clip(-4,0,3)\n0\n&gt;&gt;&gt; numpy.clip(2,0,3)\n2\n</code></pre>\n", "abstract": "Numpy's clip function will do this."}, {"id": 9775761, "score": 55, "vote": 0, "content": "<p>There's no such function, but</p>\n<pre><code class=\"python\">max(min(my_value, max_value), min_value)\n</code></pre>\n<p>will do the trick.</p>\n", "abstract": "There's no such function, but will do the trick."}, {"id": 58470178, "score": 10, "vote": 0, "content": "<p>I think the question is answered but here's an alternative DIY solution if anyone needs it:</p>\n<pre><code class=\"python\">def clip(value, lower, upper):\n    return lower if value &lt; lower else upper if value &gt; upper else value\n</code></pre>\n<p>(Slightly faster than @Sven Marnach's answer - even when in bounds).</p>\n", "abstract": "I think the question is answered but here's an alternative DIY solution if anyone needs it: (Slightly faster than @Sven Marnach's answer - even when in bounds)."}]}, {"link": "https://stackoverflow.com/questions/3867028/converting-a-python-numeric-expression-to-latex", "question": {"id": "3867028", "title": "Converting a Python numeric expression to LaTeX", "content": "<p>I need to  convert strings with valid Python syntax such as:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">'1+2**(x+y)'\n</code></pre>\n<p>and get the equivalent LaTeX:</p>\n<pre class=\"lang-latex prettyprint-override\"><code class=\"python\">$1+2^{x+y}$\n</code></pre>\n<p>I have tried SymPy's <code>latex</code> function but it processes actual expression, rather than the string form of it:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; latex(1+2**(x+y))\n'$1 + 2^{x + y}$'\n&gt;&gt;&gt; latex('1+2**(x+y)')\n'$1+2**(x+y)$'\n</code></pre>\n<p>but to even do this, it requires <code>x</code> and <code>y</code> to be declared as type \"symbols\".</p>\n<p>I want something more straightforward, preferably doable with the parser from the compiler module.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; compiler.parse('1+2**(x+y)')\nModule(None, Stmt([Discard(Add((Const(1), Power((Const(2), Add((Name('x'), Name('y'))))))))]))\n</code></pre>\n<p>Last but not least, the why: I need to generate those LaTeX snippets so that I can show them in a webpage with MathJax.</p>\n", "abstract": "I need to  convert strings with valid Python syntax such as: and get the equivalent LaTeX: I have tried SymPy's latex function but it processes actual expression, rather than the string form of it: but to even do this, it requires x and y to be declared as type \"symbols\". I want something more straightforward, preferably doable with the parser from the compiler module. Last but not least, the why: I need to generate those LaTeX snippets so that I can show them in a webpage with MathJax."}, "answers": [{"id": 3874621, "score": 28, "vote": 0, "content": "<p>Here's a rather long but still incomplete method that doesn't involve sympy in any way. It's enough to cover the example of <code>(-b-sqrt(b**2-4*a*c))/(2*a)</code> which gets translated to <code>\\frac{- b - \\sqrt{b^{2} - 4 \\; a \\; c}}{2 \\; a}</code> and renders as</p>\n<p><img alt=\"alt text\" src=\"https://i.stack.imgur.com/bVJLe.png\"/></p>\n<p>It basically creates the AST and walks it producing the latex math the corresponds to the AST nodes. What's there should give enough of an idea how to extend it in the places it's lacking.</p>\n<pre><code class=\"python\">\nimport ast\n\nclass LatexVisitor(ast.NodeVisitor):\n\n    def prec(self, n):\n        return getattr(self, 'prec_'+n.__class__.__name__, getattr(self, 'generic_prec'))(n)\n\n    def visit_Call(self, n):\n        func = self.visit(n.func)\n        args = ', '.join(map(self.visit, n.args))\n        if func == 'sqrt':\n            return '\\sqrt{%s}' % args\n        else:\n            return r'\\operatorname{%s}\\left(%s\\right)' % (func, args)\n\n    def prec_Call(self, n):\n        return 1000\n\n    def visit_Name(self, n):\n        return n.id\n\n    def prec_Name(self, n):\n        return 1000\n\n    def visit_UnaryOp(self, n):\n        if self.prec(n.op) &gt; self.prec(n.operand):\n            return r'%s \\left(%s\\right)' % (self.visit(n.op), self.visit(n.operand))\n        else:\n            return r'%s %s' % (self.visit(n.op), self.visit(n.operand))\n\n    def prec_UnaryOp(self, n):\n        return self.prec(n.op)\n\n    def visit_BinOp(self, n):\n        if self.prec(n.op) &gt; self.prec(n.left):\n            left = r'\\left(%s\\right)' % self.visit(n.left)\n        else:\n            left = self.visit(n.left)\n        if self.prec(n.op) &gt; self.prec(n.right):\n            right = r'\\left(%s\\right)' % self.visit(n.right)\n        else:\n            right = self.visit(n.right)\n        if isinstance(n.op, ast.Div):\n            return r'\\frac{%s}{%s}' % (self.visit(n.left), self.visit(n.right))\n        elif isinstance(n.op, ast.FloorDiv):\n            return r'\\left\\lfloor\\frac{%s}{%s}\\right\\rfloor' % (self.visit(n.left), self.visit(n.right))\n        elif isinstance(n.op, ast.Pow):\n            return r'%s^{%s}' % (left, self.visit(n.right))\n        else:\n            return r'%s %s %s' % (left, self.visit(n.op), right)\n\n    def prec_BinOp(self, n):\n        return self.prec(n.op)\n\n    def visit_Sub(self, n):\n        return '-'\n\n    def prec_Sub(self, n):\n        return 300\n\n    def visit_Add(self, n):\n        return '+'\n\n    def prec_Add(self, n):\n        return 300\n\n    def visit_Mult(self, n):\n        return '\\\\;'\n\n    def prec_Mult(self, n):\n        return 400\n\n    def visit_Mod(self, n):\n        return '\\\\bmod'\n\n    def prec_Mod(self, n):\n        return 500\n\n    def prec_Pow(self, n):\n        return 700\n\n    def prec_Div(self, n):\n        return 400\n\n    def prec_FloorDiv(self, n):\n        return 400\n\n    def visit_LShift(self, n):\n        return '\\\\operatorname{shiftLeft}'\n\n    def visit_RShift(self, n):\n        return '\\\\operatorname{shiftRight}'\n\n    def visit_BitOr(self, n):\n        return '\\\\operatorname{or}'\n\n    def visit_BitXor(self, n):\n        return '\\\\operatorname{xor}'\n\n    def visit_BitAnd(self, n):\n        return '\\\\operatorname{and}'\n\n    def visit_Invert(self, n):\n        return '\\\\operatorname{invert}'\n\n    def prec_Invert(self, n):\n        return 800\n\n    def visit_Not(self, n):\n        return '\\\\neg'\n\n    def prec_Not(self, n):\n        return 800\n\n    def visit_UAdd(self, n):\n        return '+'\n\n    def prec_UAdd(self, n):\n        return 800\n\n    def visit_USub(self, n):\n        return '-'\n\n    def prec_USub(self, n):\n        return 800\n    def visit_Num(self, n):\n        return str(n.n)\n\n    def prec_Num(self, n):\n        return 1000\n\n    def generic_visit(self, n):\n        if isinstance(n, ast.AST):\n            return r'' % (n.__class__.__name__, ', '.join(map(self.visit, [getattr(n, f) for f in n._fields])))\n        else:\n            return str(n)\n\n    def generic_prec(self, n):\n        return 0\n\ndef py2tex(expr):\n    pt = ast.parse(expr)\n    return LatexVisitor().visit(pt.body[0].value)\n\n</code></pre>\n", "abstract": "Here's a rather long but still incomplete method that doesn't involve sympy in any way. It's enough to cover the example of (-b-sqrt(b**2-4*a*c))/(2*a) which gets translated to \\frac{- b - \\sqrt{b^{2} - 4 \\; a \\; c}}{2 \\; a} and renders as  It basically creates the AST and walks it producing the latex math the corresponds to the AST nodes. What's there should give enough of an idea how to extend it in the places it's lacking."}, {"id": 3868121, "score": 22, "vote": 0, "content": "<p>You can use <code>sympy.latex</code> with <code>eval</code>:</p>\n<pre><code class=\"python\">s = \"1+2**(x+y)\"\nsympy.latex(eval(s))   # prints '$1 + {2}^{x + y}$'\n</code></pre>\n<p>You still have to declare the variables as symbols, but if this is really a problem, it's much easier to write a parser to do this than to parse everything and generate the latex from scratch.</p>\n", "abstract": "You can use sympy.latex with eval: You still have to declare the variables as symbols, but if this is really a problem, it's much easier to write a parser to do this than to parse everything and generate the latex from scratch."}, {"id": 4308411, "score": 17, "vote": 0, "content": "<p>You can use SymPy.  Just pass the string to the <code>sympify()</code> function first, which will convert it to a valid SymPy expression (i.e., create the Symbols for you, etc.).  So you could do</p>\n<pre><code class=\"python\">&gt;&gt;&gt; latex(sympify('1+2**(x+y)'))\n1 + 2^{x + y}\n</code></pre>\n<p><code>S()</code> is also a shortcut to <code>sympify()</code>, i.e., <code>latex(S('1+2**(x+y)'))</code> also works.</p>\n", "abstract": "You can use SymPy.  Just pass the string to the sympify() function first, which will convert it to a valid SymPy expression (i.e., create the Symbols for you, etc.).  So you could do S() is also a shortcut to sympify(), i.e., latex(S('1+2**(x+y)')) also works."}, {"id": 3868373, "score": 6, "vote": 0, "content": "<p>To build on tom10's answer you can define a dictionary that will generate symbols and use that when calling eval:</p>\n<pre><code class=\"python\">from collections import defaultdict\nclass GenerateSymbols(defaultdict):\n  def __missing__(self, key):\n    return sympy.Symbol(key)\n</code></pre>\n<p>Then if you use</p>\n<pre><code class=\"python\">sympy.latex(eval('1+2**(x+y)',GenerateSymbols()))\n</code></pre>\n<p>you shouldn't have to worry about pre-creating Symbols for the variables.</p>\n", "abstract": "To build on tom10's answer you can define a dictionary that will generate symbols and use that when calling eval: Then if you use you shouldn't have to worry about pre-creating Symbols for the variables."}, {"id": 3871872, "score": 6, "vote": 0, "content": "<p>Just a little fix to Geoff Reedy excellent answer:</p>\n<pre><code class=\"python\">class GenerateSymbols(defaultdict):\n    def __missing__(self, key):\n        self[key] = sympy.Symbol(key)\n        return self[key]\n</code></pre>\n<p>Before it would not add the new item to the dict. Now you can use this with your expression:</p>\n<pre><code class=\"python\">d= GenerateSymbols()    \neq = '(-b-sqrt(b**2-4*a*c))/(2*a)'\n</code></pre>\n<p>and you can further simplify it before converting it to LaTeX:</p>\n<pre><code class=\"python\">sympy.latex(sympy.simplify(eval(eq,d)))\n</code></pre>\n<p>and you get this:</p>\n<pre><code class=\"python\">'$- \\\\frac{b + \\\\operatorname{sqrt}\\\\left(- 4 a c + b^{2}\\\\right)}{2 a}$'\n</code></pre>\n", "abstract": "Just a little fix to Geoff Reedy excellent answer: Before it would not add the new item to the dict. Now you can use this with your expression: and you can further simplify it before converting it to LaTeX: and you get this:"}, {"id": 72485564, "score": 0, "vote": 0, "content": "<p>To render @Geoff Reedy latex format text. We could use matplotlib.</p>\n<pre><code class=\"python\">exp = py2tex('1**x+y')\nimport matplotlib.pyplot as plt\ntext = exp\n\nplt.text(0.36, 0.5, r\"$%s$\" %text, fontsize=24)\nax = plt.gca()\nax.axes.get_xaxis().set_visible(False)\nax.axes.get_yaxis().set_visible(False)\n\nplt.show()\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/f9CjJ.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/f9CjJ.png\"/></a></p>\n", "abstract": "To render @Geoff Reedy latex format text. We could use matplotlib. "}]}, {"link": "https://stackoverflow.com/questions/16628088/euclidean-algorithm-gcd-with-multiple-numbers", "question": {"id": "16628088", "title": "Euclidean algorithm (GCD) with multiple numbers?", "content": "<p>So I'm writing a program in Python to get the GCD of any amount of numbers.</p>\n<pre><code class=\"python\">def GCD(numbers):\n\n    if numbers[-1] == 0:\n        return numbers[0]\n\n\n    # i'm stuck here, this is wrong\n    for i in range(len(numbers)-1):\n        print GCD([numbers[i+1], numbers[i] % numbers[i+1]])\n\n\nprint GCD(30, 40, 36)\n</code></pre>\n<p>The function takes a list of numbers. \nThis should print 2. However, I don't understand how to use the the algorithm recursively so it can handle multiple numbers. Can someone explain? </p>\n<p>updated, still not working:</p>\n<pre><code class=\"python\">def GCD(numbers):\n\n    if numbers[-1] == 0:\n        return numbers[0]\n\n    gcd = 0\n\n    for i in range(len(numbers)):\n        gcd = GCD([numbers[i+1], numbers[i] % numbers[i+1]])\n        gcdtemp = GCD([gcd, numbers[i+2]])\n        gcd = gcdtemp\n\n    return gcd\n</code></pre>\n<hr/>\n<p>Ok, solved it</p>\n<pre><code class=\"python\">def GCD(a, b):\n\n    if b == 0:\n        return a\n    else:\n        return GCD(b, a % b)\n</code></pre>\n<p>and then use reduce, like</p>\n<pre><code class=\"python\">reduce(GCD, (30, 40, 36))\n</code></pre>\n", "abstract": "So I'm writing a program in Python to get the GCD of any amount of numbers. The function takes a list of numbers. \nThis should print 2. However, I don't understand how to use the the algorithm recursively so it can handle multiple numbers. Can someone explain?  updated, still not working: Ok, solved it and then use reduce, like"}, "answers": [{"id": 16628379, "score": 40, "vote": 0, "content": "<p>Since GCD is associative, <code>GCD(a,b,c,d)</code> is the same as <code>GCD(GCD(GCD(a,b),c),d)</code>. In this case, Python's <a href=\"http://docs.python.org/2/library/functions.html#reduce\" rel=\"noreferrer\"><code>reduce</code></a> function would be a good candidate for reducing the cases for which <code>len(numbers) &gt; 2</code> to a simple 2-number comparison. The code would look something like this:</p>\n<pre><code class=\"python\">if len(numbers) &gt; 2:\n    return reduce(lambda x,y: GCD([x,y]), numbers)\n</code></pre>\n<p>Reduce applies the given function to each element in the list, so that something like</p>\n<pre><code class=\"python\">gcd = reduce(lambda x,y:GCD([x,y]),[a,b,c,d])\n</code></pre>\n<p>is the same as doing</p>\n<pre><code class=\"python\">gcd = GCD(a,b)\ngcd = GCD(gcd,c)\ngcd = GCD(gcd,d)\n</code></pre>\n<p>Now the only thing left is to code for when <code>len(numbers) &lt;= 2</code>. Passing only two arguments to <code>GCD</code> in <code>reduce</code> ensures that your function recurses at most once (since <code>len(numbers) &gt; 2</code> only in the original call), which has the additional benefit of never overflowing the stack.</p>\n", "abstract": "Since GCD is associative, GCD(a,b,c,d) is the same as GCD(GCD(GCD(a,b),c),d). In this case, Python's reduce function would be a good candidate for reducing the cases for which len(numbers) > 2 to a simple 2-number comparison. The code would look something like this: Reduce applies the given function to each element in the list, so that something like is the same as doing Now the only thing left is to code for when len(numbers) <= 2. Passing only two arguments to GCD in reduce ensures that your function recurses at most once (since len(numbers) > 2 only in the original call), which has the additional benefit of never overflowing the stack."}, {"id": 16628166, "score": 28, "vote": 0, "content": "<p>You can use <code>reduce</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from fractions import gcd\n&gt;&gt;&gt; reduce(gcd,(30,40,60))\n10\n</code></pre>\n<p>which is equivalent to;</p>\n<pre><code class=\"python\">&gt;&gt;&gt; lis = (30,40,60,70)\n&gt;&gt;&gt; res = gcd(*lis[:2])  #get the gcd of first two numbers\n&gt;&gt;&gt; for x in lis[2:]:    #now iterate over the list starting from the 3rd element\n...    res = gcd(res,x)\n\n&gt;&gt;&gt; res\n10\n</code></pre>\n<p><strong>help</strong> on <code>reduce</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; reduce?\nType:       builtin_function_or_method\nreduce(function, sequence[, initial]) -&gt; value\n\nApply a function of two arguments cumulatively to the items of a sequence,\nfrom left to right, so as to reduce the sequence to a single value.\nFor example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\nof the sequence in the calculation, and serves as a default when the\nsequence is empty.\n</code></pre>\n", "abstract": "You can use reduce: which is equivalent to; help on reduce:"}, {"id": 61779475, "score": 6, "vote": 0, "content": "<p>Python 3.9 <a href=\"https://docs.python.org/3.9/library/math.html#math.gcd\" rel=\"noreferrer\">introduced</a> multiple arguments version of <code>math.gcd</code>, so you can use:</p>\n<pre><code class=\"python\">import math\nmath.gcd(30, 40, 36)\n</code></pre>\n<hr/>\n<p>3.5 &lt;= Python &lt;= 3.8.x:</p>\n<pre><code class=\"python\">import functools\nimport math\nfunctools.reduce(math.gcd, (30, 40, 36))\n</code></pre>\n<hr/>\n<p>3 &lt;= Python &lt; 3.5:</p>\n<pre><code class=\"python\">import fractions\nimport functools\nfunctools.reduce(fractions.gcd, (30, 40, 36))\n</code></pre>\n", "abstract": "Python 3.9 introduced multiple arguments version of math.gcd, so you can use: 3.5 <= Python <= 3.8.x: 3 <= Python < 3.5:"}, {"id": 30498673, "score": 5, "vote": 0, "content": "<p>A solution to finding out the <strong>LCM</strong> of more than two numbers in <strong>PYTHON</strong> is as follow:</p>\n<pre><code class=\"python\">#finding LCM (Least Common Multiple) of a series of numbers\n\ndef GCD(a, b):\n    #Gives greatest common divisor using Euclid's Algorithm.\n    while b:      \n        a, b = b, a % b\n    return a\n\ndef LCM(a, b):\n    #gives lowest common multiple of two numbers\n    return a * b // GCD(a, b)\n\ndef LCMM(*args):\n    #gives LCM of a list of numbers passed as argument \n    return reduce(LCM, args)\n</code></pre>\n<p>Here I've added +1 in the last argument of <strong>range()</strong> function because the function itself starts from zero (0) to n-1. Click the hyperlink to know more about <a href=\"https://docs.python.org/2/library/functions.html#range\" rel=\"noreferrer\">range()</a> function : </p>\n<pre><code class=\"python\">print (\"LCM of numbers (1 to 5) : \" + str(LCMM(*range(1, 5+1))))\nprint (\"LCM of numbers (1 to 10) : \" + str(LCMM(*range(1, 10+1))))\nprint (reduce(LCMM,(1,2,3,4,5)))\n</code></pre>\n<p>those who are new to python can read more about <a href=\"https://docs.python.org/2/library/functions.html#reduce\" rel=\"noreferrer\">reduce()</a> function by the given link.</p>\n", "abstract": "A solution to finding out the LCM of more than two numbers in PYTHON is as follow: Here I've added +1 in the last argument of range() function because the function itself starts from zero (0) to n-1. Click the hyperlink to know more about range() function :  those who are new to python can read more about reduce() function by the given link."}, {"id": 16628117, "score": 3, "vote": 0, "content": "<p>The GCD operator is commutative and associative.  This means that</p>\n<pre><code class=\"python\">gcd(a,b,c) = gcd(gcd(a,b),c) = gcd(a,gcd(b,c))\n</code></pre>\n<p>So once you know how to do it for 2 numbers, you can do it for any number</p>\n<hr/>\n<p>To do it for two numbers, you simply need to implement Euclid's formula, which is simply:</p>\n<pre><code class=\"python\">// Ensure a &gt;= b &gt;= 1, flip a and b if necessary\nwhile b &gt; 0\n  t = a % b\n  a = b\n  b = t\nend\nreturn a\n</code></pre>\n<p>Define that function as, say <code>euclid(a,b)</code>.  Then, you can define <code>gcd(nums)</code> as:</p>\n<pre><code class=\"python\">if (len(nums) == 1)\n  return nums[1]\nelse\n  return euclid(nums[1], gcd(nums[:2]))\n</code></pre>\n<p>This uses the associative property of gcd() to compute the answer</p>\n", "abstract": "The GCD operator is commutative and associative.  This means that So once you know how to do it for 2 numbers, you can do it for any number To do it for two numbers, you simply need to implement Euclid's formula, which is simply: Define that function as, say euclid(a,b).  Then, you can define gcd(nums) as: This uses the associative property of gcd() to compute the answer"}, {"id": 16628173, "score": 0, "vote": 0, "content": "<p>Try calling the <code>GCD()</code> as follows,</p>\n<pre><code class=\"python\">i = 0\ntemp = numbers[i]\nfor i in range(len(numbers)-1):\n        temp = GCD(numbers[i+1], temp)\n</code></pre>\n", "abstract": "Try calling the GCD() as follows,"}, {"id": 51489445, "score": 0, "vote": 0, "content": "<p>My way of solving it in Python. Hope it helps.</p>\n<pre><code class=\"python\">def find_gcd(arr):\n    if len(arr) &lt;= 1:\n        return arr\n    else:\n        for i in range(len(arr)-1):\n            a = arr[i]\n            b = arr[i+1]\n            while b:\n                a, b = b, a%b\n            arr[i+1] = a\n        return a\ndef main(array):\n    print(find_gcd(array))\n\nmain(array=[8, 18, 22, 24]) # 2\nmain(array=[8, 24]) # 8\nmain(array=[5]) # [5]\nmain(array=[]) # []\n</code></pre>\n<p>Some dynamics how I understand it:</p>\n<p>ex.[8, 18] -&gt; [18, 8] -&gt; [8, 2] -&gt; [2, 0]</p>\n<p>18 = 8x + 2 = (2y)x + 2 = 2z where z = xy + 1</p>\n<p>ex.[18, 22] -&gt; [22, 18] -&gt; [18, 4] -&gt; [4, 2] -&gt; [2, 0]</p>\n<p>22 = 18w + 4 = (4x+2)w + 4 = ((2y)x + 2)w + 2 = 2z</p>\n", "abstract": "My way of solving it in Python. Hope it helps. Some dynamics how I understand it: ex.[8, 18] -> [18, 8] -> [8, 2] -> [2, 0] 18 = 8x + 2 = (2y)x + 2 = 2z where z = xy + 1 ex.[18, 22] -> [22, 18] -> [18, 4] -> [4, 2] -> [2, 0] 22 = 18w + 4 = (4x+2)w + 4 = ((2y)x + 2)w + 2 = 2z"}, {"id": 63257541, "score": 0, "vote": 0, "content": "<p>As of python 3.9 beta 4, it has got built-in support for finding gcd over a list of numbers.</p>\n<pre><code class=\"python\">Python 3.9.0b4 (v3.9.0b4:69dec9c8d2, Jul  2 2020, 18:41:53)\n[Clang 6.0 (clang-600.0.57)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; A = [30, 40, 36]\n&gt;&gt;&gt; print(math.gcd(*A))\n2\n</code></pre>\n", "abstract": "As of python 3.9 beta 4, it has got built-in support for finding gcd over a list of numbers."}, {"id": 63346480, "score": 0, "vote": 0, "content": "<p>One of the issues is that many of the calculations only work with numbers greater than 1. I modified the solution found <a href=\"https://www.geeksforgeeks.org/gcd-two-array-numbers/\" rel=\"nofollow noreferrer\">here</a> so that it accepts numbers smaller than 1. Basically, we can re scale the array using the minimum value and then use that to calculate the GCD of numbers smaller than 1.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># GCD of more than two (or array) numbers - alows folating point numbers\n# Function implements the Euclidian algorithm to find H.C.F. of two number \ndef find_gcd(x, y): \n    while(y): \n        x, y = y, x % y \n    return x \n          \n# Driver Code         \nl_org = [60e-6, 20e-6, 30e-6]\nmin_val = min(l_org)\nl = [item/min_val for item in l_org]\n  \nnum1 = l[0] \nnum2 = l[1] \ngcd = find_gcd(num1, num2) \n  \nfor i in range(2, len(l)): \n    gcd = find_gcd(gcd, l[i]) \n      \ngcd = gcd * min_val\nprint(gcd) \n\n</code></pre>\n", "abstract": "One of the issues is that many of the calculations only work with numbers greater than 1. I modified the solution found here so that it accepts numbers smaller than 1. Basically, we can re scale the array using the minimum value and then use that to calculate the GCD of numbers smaller than 1."}, {"id": 64510334, "score": 0, "vote": 0, "content": "<p><strong>HERE IS A SIMPLE METHOD TO FIND GCD OF 2 NUMBERS</strong></p>\n<pre><code class=\"python\">a = int(input(\"Enter the value of first number:\"))\nb = int(input(\"Enter the value of second number:\"))\nc,d = a,b\nwhile a!=0:\n    b,a=a,b%a\nprint(\"GCD of \",c,\"and\",d,\"is\",b)\n</code></pre>\n", "abstract": "HERE IS A SIMPLE METHOD TO FIND GCD OF 2 NUMBERS"}]}, {"link": "https://stackoverflow.com/questions/14414430/why-0-0-equals-1-in-python", "question": {"id": "14414430", "title": "Why 0 ** 0 equals 1 in python", "content": "<p>Why does <code>0 ** 0</code> equal <code>1</code> in Python? Shouldn't it throw an exception, like <code>0 / 0</code> does?</p>\n", "abstract": "Why does 0 ** 0 equal 1 in Python? Shouldn't it throw an exception, like 0 / 0 does?"}, "answers": [{"id": 14414488, "score": 39, "vote": 0, "content": "<p>Wikipedia has interesting coverage of the <a href=\"https://en.wikipedia.org/wiki/Zero_to_the_power_of_zero\" rel=\"nofollow noreferrer\">history and the differing points of view on</a> the value of <code>0 ** 0</code>:</p>\n<blockquote>\n<p>The debate has been going on at least since the early 19th century. At that time, most mathematicians agreed that <code>0 ** 0 = 1</code>, until in 1821 Cauchy listed <code>0 ** 0</code> along with expressions like <code>0\u20440</code> in a table of undefined forms. In the 1830s Libri published an unconvincing argument for <code>0 ** 0 = 1</code>, and M\u00f6bius sided with him...</p>\n</blockquote>\n<p>As applied to computers, <a href=\"http://en.wikipedia.org/wiki/IEEE_754-2008\" rel=\"nofollow noreferrer\">IEEE 754</a> recommends several functions for computing a power. It defines <code>pow(0, 0)</code> and <code>pown(0, 0)</code> as returning <code>1</code>, and <code>powr(0, 0)</code> as returning <code>NaN</code>.</p>\n<p>Most programming languages follow the convention that <code>0 ** 0 == 1</code>. Python is no exception, both for integer and floating-point arguments.</p>\n", "abstract": "Wikipedia has interesting coverage of the history and the differing points of view on the value of 0 ** 0: The debate has been going on at least since the early 19th century. At that time, most mathematicians agreed that 0 ** 0 = 1, until in 1821 Cauchy listed 0 ** 0 along with expressions like 0\u20440 in a table of undefined forms. In the 1830s Libri published an unconvincing argument for 0 ** 0 = 1, and M\u00f6bius sided with him... As applied to computers, IEEE 754 recommends several functions for computing a power. It defines pow(0, 0) and pown(0, 0) as returning 1, and powr(0, 0) as returning NaN. Most programming languages follow the convention that 0 ** 0 == 1. Python is no exception, both for integer and floating-point arguments."}, {"id": 14414635, "score": 9, "vote": 0, "content": "<p>consider <code>x^x</code>:</p>\n<p>Using limits we can easily get to our solution and rearranging <code>x^x</code> we get :</p>\n<pre><code class=\"python\">x^x= exp(log(x^x))\n</code></pre>\n<p>Now , we have from:</p>\n<pre><code class=\"python\">lim x-&gt;0 exp(log(x^x))= exp(lim x-&gt;0 xlog(x)) = exp(lim x-&gt;0 log(x)/(x^-1))\n</code></pre>\n<p>Applying <code>L'H\u00f4pital</code> rule , we get :</p>\n<pre><code class=\"python\">exp(lim x^-1/(-x^-2)) = exp(lim x-&gt;0 -x) = exp(0) = 1=x^x\n</code></pre>\n<p>But according to Wolfram Alpha <code>0**0</code> is indeterminate and following explanations were obtained by them :</p>\n<blockquote>\n<p>0^0 itself is undefined. The lack of a well-defined meaning for this\n  quantity follows from the mutually contradictory facts that a^0 is\n  always 1, so 0^0 should equal 1, but 0^a is always 0 (for a&gt;0), so 0^0\n  should equal 0. It could be argued that 0^0=1 is a natural definition\n  since lim_(n-&gt;0)n^n=lim_(n-&gt;0^+)n^n=lim_(n-&gt;0^-)n^n=1.\n  However, the limit does not exist for general complex values of n. Therefore, the choice of\n  definition for 0^0 is usually defined to be indeterminate.\"</p>\n</blockquote>\n", "abstract": "consider x^x: Using limits we can easily get to our solution and rearranging x^x we get : Now , we have from: Applying L'H\u00f4pital rule , we get : But according to Wolfram Alpha 0**0 is indeterminate and following explanations were obtained by them : 0^0 itself is undefined. The lack of a well-defined meaning for this\n  quantity follows from the mutually contradictory facts that a^0 is\n  always 1, so 0^0 should equal 1, but 0^a is always 0 (for a>0), so 0^0\n  should equal 0. It could be argued that 0^0=1 is a natural definition\n  since lim_(n->0)n^n=lim_(n->0^+)n^n=lim_(n->0^-)n^n=1.\n  However, the limit does not exist for general complex values of n. Therefore, the choice of\n  definition for 0^0 is usually defined to be indeterminate.\""}, {"id": 57742048, "score": -4, "vote": 0, "content": "<p>2^2 = (1+1)*(1+1) = 4 (two objects occured two times)</p>\n<p>2^1 = (1+1)*1     = 2 (two objects occured one time)</p>\n<p>2^0 = (1+1)*0     = 0 (two objects did not occur)</p>\n<p>1^2 = 1    *(1+1) = 2 (one object occured two times)</p>\n<p>1^1 = 1    *1     = 1 (one object occured one time)</p>\n<p>1^0 = 1    *0     = 0 (one object did not occur)</p>\n<p>0^2 = 0    *(1+1) = 0 (zero objects occured twice)</p>\n<p>0^1 = 0    *1     = 0 (zero objects occured once)</p>\n<p>0^0 = 0    *0     = 0 (zero objects did not occur)</p>\n<p>Therefore you cannot make something from nothing! </p>\n", "abstract": "2^2 = (1+1)*(1+1) = 4 (two objects occured two times) 2^1 = (1+1)*1     = 2 (two objects occured one time) 2^0 = (1+1)*0     = 0 (two objects did not occur) 1^2 = 1    *(1+1) = 2 (one object occured two times) 1^1 = 1    *1     = 1 (one object occured one time) 1^0 = 1    *0     = 0 (one object did not occur) 0^2 = 0    *(1+1) = 0 (zero objects occured twice) 0^1 = 0    *1     = 0 (zero objects occured once) 0^0 = 0    *0     = 0 (zero objects did not occur) Therefore you cannot make something from nothing! "}]}, {"link": "https://stackoverflow.com/questions/356090/how-to-compute-the-nth-root-of-a-very-big-integer", "question": {"id": "356090", "title": "How to compute the nth root of a very big integer", "content": "<p>I need a way to compute the nth root of a long integer in Python. </p>\n<p>I tried <code>pow(m, 1.0/n)</code>, but it doesn't work:</p>\n<blockquote>\n<p>OverflowError: long int too large to convert to float</p>\n</blockquote>\n<p>Any ideas?</p>\n<p>By long integer I mean REALLY long integers like:</p>\n<blockquote>\n<p>11968003966030964356885611480383408833172346450467339251\n  196093144141045683463085291115677488411620264826942334897996389\n  485046262847265769280883237649461122479734279424416861834396522\n  819159219215308460065265520143082728303864638821979329804885526\n  557893649662037092457130509980883789368448042961108430809620626\n  059287437887495827369474189818588006905358793385574832590121472\n  680866521970802708379837148646191567765584039175249171110593159\n  305029014037881475265618958103073425958633163441030267478942720\n  703134493880117805010891574606323700178176718412858948243785754\n  898788359757528163558061136758276299059029113119763557411729353\n  915848889261125855717014320045292143759177464380434854573300054\n  940683350937992500211758727939459249163046465047204851616590276\n  724564411037216844005877918224201569391107769029955591465502737\n  961776799311859881060956465198859727495735498887960494256488224\n  613682478900505821893815926193600121890632</p>\n</blockquote>\n", "abstract": "I need a way to compute the nth root of a long integer in Python.  I tried pow(m, 1.0/n), but it doesn't work: OverflowError: long int too large to convert to float Any ideas? By long integer I mean REALLY long integers like: 11968003966030964356885611480383408833172346450467339251\n  196093144141045683463085291115677488411620264826942334897996389\n  485046262847265769280883237649461122479734279424416861834396522\n  819159219215308460065265520143082728303864638821979329804885526\n  557893649662037092457130509980883789368448042961108430809620626\n  059287437887495827369474189818588006905358793385574832590121472\n  680866521970802708379837148646191567765584039175249171110593159\n  305029014037881475265618958103073425958633163441030267478942720\n  703134493880117805010891574606323700178176718412858948243785754\n  898788359757528163558061136758276299059029113119763557411729353\n  915848889261125855717014320045292143759177464380434854573300054\n  940683350937992500211758727939459249163046465047204851616590276\n  724564411037216844005877918224201569391107769029955591465502737\n  961776799311859881060956465198859727495735498887960494256488224\n  613682478900505821893815926193600121890632"}, "answers": [{"id": 356206, "score": 29, "vote": 0, "content": "<p>If it's a REALLY big number. You could use a binary search.</p>\n<pre><code class=\"python\">def find_invpow(x,n):\n    \"\"\"Finds the integer component of the n'th root of x,\n    an integer such that y ** n &lt;= x &lt; (y + 1) ** n.\n    \"\"\"\n    high = 1\n    while high ** n &lt;= x:\n        high *= 2\n    low = high/2\n    while low &lt; high:\n        mid = (low + high) // 2\n        if low &lt; mid and mid**n &lt; x:\n            low = mid\n        elif high &gt; mid and mid**n &gt; x:\n            high = mid\n        else:\n            return mid\n    return mid + 1\n</code></pre>\n<p>For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = 237734537465873465\n&gt;&gt;&gt; n = 5\n&gt;&gt;&gt; y = find_invpow(x,n)\n&gt;&gt;&gt; y\n2986\n&gt;&gt;&gt; y**n &lt;= x &lt;= (y+1)**n\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; x = 119680039660309643568856114803834088331723464504673392511960931441&gt;\n&gt;&gt;&gt; n = 45\n&gt;&gt;&gt; y = find_invpow(x,n)\n&gt;&gt;&gt; y\n227661383982863143360L\n&gt;&gt;&gt; y**n &lt;= x &lt; (y+1)**n\nTrue\n&gt;&gt;&gt; find_invpow(y**n,n) == y\nTrue\n&gt;&gt;&gt;\n</code></pre>\n", "abstract": "If it's a REALLY big number. You could use a binary search. For example:"}, {"id": 356187, "score": 16, "vote": 0, "content": "<p><a href=\"http://code.google.com/p/gmpy/\" rel=\"noreferrer\">Gmpy</a> is a C-coded Python extension module that wraps the GMP library to provide to Python code fast multiprecision arithmetic (integer, rational, and float), random number generation, advanced number-theoretical functions, and more.</p>\n<p>Includes a <code>root</code> function:</p>\n<blockquote>\n<p>x.root(n): returns a 2-element tuple (y,m), such that y is the\n  (possibly truncated) n-th root of x; m, an ordinary Python int,\n  is 1 if the root is exact (x==y**n), else 0.  n must be an ordinary\n  Python int, &gt;=0.</p>\n</blockquote>\n<p>For example, 20th root:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import gmpy\n&gt;&gt;&gt; i0=11968003966030964356885611480383408833172346450467339251 \n&gt;&gt;&gt; m0=gmpy.mpz(i0)\n&gt;&gt;&gt; m0\nmpz(11968003966030964356885611480383408833172346450467339251L)\n&gt;&gt;&gt; m0.root(20)\n(mpz(567), 0)\n</code></pre>\n", "abstract": "Gmpy is a C-coded Python extension module that wraps the GMP library to provide to Python code fast multiprecision arithmetic (integer, rational, and float), random number generation, advanced number-theoretical functions, and more. Includes a root function: x.root(n): returns a 2-element tuple (y,m), such that y is the\n  (possibly truncated) n-th root of x; m, an ordinary Python int,\n  is 1 if the root is exact (x==y**n), else 0.  n must be an ordinary\n  Python int, >=0. For example, 20th root:"}, {"id": 358134, "score": 7, "vote": 0, "content": "<p>You can make it run slightly faster by avoiding the while loops in favor of setting low to 10 ** (len(str(x)) / n) and high to low * 10.  Probably better is to replace the len(str(x)) with the bitwise length and using a bit shift.  Based on my tests, I estimate a 5% speedup from the first and a 25% speedup from the second.  If the ints are big enough, this might matter (and the speedups may vary).  Don't trust my code without testing it carefully.  I did some basic testing but may have missed an edge case.  Also, these speedups vary with the number chosen.</p>\n<p>If the actual data you're using is much bigger than what you posted here, this change may be worthwhile.</p>\n<pre><code class=\"python\">from timeit import Timer\n\ndef find_invpow(x,n):\n    \"\"\"Finds the integer component of the n'th root of x,\n    an integer such that y ** n &lt;= x &lt; (y + 1) ** n.\n    \"\"\"\n    high = 1\n    while high ** n &lt; x:\n        high *= 2\n    low = high/2\n    while low &lt; high:\n        mid = (low + high) // 2\n        if low &lt; mid and mid**n &lt; x:\n            low = mid\n        elif high &gt; mid and mid**n &gt; x:\n            high = mid\n        else:\n            return mid\n    return mid + 1\n\ndef find_invpowAlt(x,n):\n    \"\"\"Finds the integer component of the n'th root of x,\n    an integer such that y ** n &lt;= x &lt; (y + 1) ** n.\n    \"\"\"\n    low = 10 ** (len(str(x)) / n)\n    high = low * 10\n\n    while low &lt; high:\n        mid = (low + high) // 2\n        if low &lt; mid and mid**n &lt; x:\n            low = mid\n        elif high &gt; mid and mid**n &gt; x:\n            high = mid\n        else:\n            return mid\n    return mid + 1\n\nx = 237734537465873465\nn = 5\ntests = 10000\n\nprint \"Norm\", Timer('find_invpow(x,n)', 'from __main__ import find_invpow, x,n').timeit(number=tests)\nprint \"Alt\", Timer('find_invpowAlt(x,n)', 'from __main__ import find_invpowAlt, x,n').timeit(number=tests)\n</code></pre>\n<p>Norm 0.626754999161</p>\n<p>Alt 0.566340923309</p>\n", "abstract": "You can make it run slightly faster by avoiding the while loops in favor of setting low to 10 ** (len(str(x)) / n) and high to low * 10.  Probably better is to replace the len(str(x)) with the bitwise length and using a bit shift.  Based on my tests, I estimate a 5% speedup from the first and a 25% speedup from the second.  If the ints are big enough, this might matter (and the speedups may vary).  Don't trust my code without testing it carefully.  I did some basic testing but may have missed an edge case.  Also, these speedups vary with the number chosen. If the actual data you're using is much bigger than what you posted here, this change may be worthwhile. Norm 0.626754999161 Alt 0.566340923309"}, {"id": 637321, "score": 7, "vote": 0, "content": "<p>If you are looking for something standard, fast to write with high precision. I would use decimal and adjust the precision (getcontext().prec) to at least the length of x.</p>\n<h2>Code (Python 3.0)</h2>\n<pre><code class=\"python\">from decimal import *\n\nx =   '11968003966030964356885611480383408833172346450467339251\\\n196093144141045683463085291115677488411620264826942334897996389\\\n485046262847265769280883237649461122479734279424416861834396522\\\n819159219215308460065265520143082728303864638821979329804885526\\\n557893649662037092457130509980883789368448042961108430809620626\\\n059287437887495827369474189818588006905358793385574832590121472\\\n680866521970802708379837148646191567765584039175249171110593159\\\n305029014037881475265618958103073425958633163441030267478942720\\\n703134493880117805010891574606323700178176718412858948243785754\\\n898788359757528163558061136758276299059029113119763557411729353\\\n915848889261125855717014320045292143759177464380434854573300054\\\n940683350937992500211758727939459249163046465047204851616590276\\\n724564411037216844005877918224201569391107769029955591465502737\\\n961776799311859881060956465198859727495735498887960494256488224\\\n613682478900505821893815926193600121890632'\n\nminprec = 27\nif len(x) &gt; minprec: getcontext().prec = len(x)\nelse:                getcontext().prec = minprec\n\nx = Decimal(x)\npower = Decimal(1)/Decimal(3)\n\nanswer = x**power\nranswer = answer.quantize(Decimal('1.'), rounding=ROUND_UP)\n\ndiff = x - ranswer**Decimal(3)\nif diff == Decimal(0):\n    print(\"x is the cubic number of\", ranswer)\nelse:\n    print(\"x has a cubic root of \", answer)\n</code></pre>\n<h2>Answer</h2>\n<p>x is the cubic number of 22873918786185635329056863961725521583023133411\n451452349318109627653540670761962215971994403670045614485973722724603798\n107719978813658857014190047742680490088532895666963698551709978502745901\n704433723567548799463129652706705873694274209728785041817619032774248488\n2965377218610139128882473918261696612098418</p>\n", "abstract": "If you are looking for something standard, fast to write with high precision. I would use decimal and adjust the precision (getcontext().prec) to at least the length of x. x is the cubic number of 22873918786185635329056863961725521583023133411\n451452349318109627653540670761962215971994403670045614485973722724603798\n107719978813658857014190047742680490088532895666963698551709978502745901\n704433723567548799463129652706705873694274209728785041817619032774248488\n2965377218610139128882473918261696612098418"}, {"id": 356235, "score": 3, "vote": 0, "content": "<p>Oh, for numbers <em>that</em> big, you would use the decimal module.</p>\n<p>ns: your number as a string</p>\n<pre><code class=\"python\">ns = \"11968003966030964356885611480383408833172346450467339251196093144141045683463085291115677488411620264826942334897996389485046262847265769280883237649461122479734279424416861834396522819159219215308460065265520143082728303864638821979329804885526557893649662037092457130509980883789368448042961108430809620626059287437887495827369474189818588006905358793385574832590121472680866521970802708379837148646191567765584039175249171110593159305029014037881475265618958103073425958633163441030267478942720703134493880117805010891574606323700178176718412858948243785754898788359757528163558061136758276299059029113119763557411729353915848889261125855717014320045292143759177464380434854573300054940683350937992500211758727939459249163046465047204851616590276724564411037216844005877918224201569391107769029955591465502737961776799311859881060956465198859727495735498887960494256488224613682478900505821893815926193600121890632\"\nfrom decimal import Decimal\nd = Decimal(ns)\none_third = Decimal(\"0.3333333333333333\")\nprint d ** one_third\n</code></pre>\n<p>and the answer is: 2.287391878618402702753613056E+305</p>\n<p>TZ pointed out that this isn't accurate... and he's right.  Here's my test.</p>\n<pre><code class=\"python\">from decimal import Decimal\n\ndef nth_root(num_decimal, n_integer):\n    exponent = Decimal(\"1.0\") / Decimal(n_integer)\n    return num_decimal ** exponent\n\ndef test():\n    ns = \"11968003966030964356885611480383408833172346450467339251196093144141045683463085291115677488411620264826942334897996389485046262847265769280883237649461122479734279424416861834396522819159219215308460065265520143082728303864638821979329804885526557893649662037092457130509980883789368448042961108430809620626059287437887495827369474189818588006905358793385574832590121472680866521970802708379837148646191567765584039175249171110593159305029014037881475265618958103073425958633163441030267478942720703134493880117805010891574606323700178176718412858948243785754898788359757528163558061136758276299059029113119763557411729353915848889261125855717014320045292143759177464380434854573300054940683350937992500211758727939459249163046465047204851616590276724564411037216844005877918224201569391107769029955591465502737961776799311859881060956465198859727495735498887960494256488224613682478900505821893815926193600121890632\"\n    nd = Decimal(ns)\n    cube_root = nth_root(nd, 3)\n    print (cube_root ** Decimal(\"3.0\")) - nd\n\nif __name__ == \"__main__\":\n    test()\n</code></pre>\n<p>It's off by about 10**891</p>\n", "abstract": "Oh, for numbers that big, you would use the decimal module. ns: your number as a string and the answer is: 2.287391878618402702753613056E+305 TZ pointed out that this isn't accurate... and he's right.  Here's my test. It's off by about 10**891"}, {"id": 358026, "score": 2, "vote": 0, "content": "<p>Possibly for your curiosity:</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Hensel_Lifting\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/Hensel_Lifting</a></p>\n<p>This could be the technique that Maple would use to actually find the nth root of large numbers.</p>\n<p>Pose the fact that <code>x^n - 11968003.... = 0 mod p</code>, and go from there...</p>\n", "abstract": "Possibly for your curiosity: http://en.wikipedia.org/wiki/Hensel_Lifting This could be the technique that Maple would use to actually find the nth root of large numbers. Pose the fact that x^n - 11968003.... = 0 mod p, and go from there..."}, {"id": 37171151, "score": 1, "vote": 0, "content": "<p>I came up with my own answer, which takes @Mahmoud Kassem's idea, simplifies the code, and makes it more reusable:</p>\n<pre><code class=\"python\">def cube_root(x):\n    return decimal.Decimal(x) ** (decimal.Decimal(1) / decimal.Decimal(3))\n</code></pre>\n<p>I tested it in Python 3.5.1 and Python 2.7.8, and it seemed to work fine.</p>\n<p>The result will have as many digits as specified by the decimal context the function is run in, which by default is 28 decimal places. According to the documentation for the <code>power</code> function in the <code>decimal</code> module, \"<a href=\"https://docs.python.org/3/library/decimal.html#decimal.Context.power\" rel=\"nofollow\">The result is well-defined but only \u201calmost always correctly-rounded\u201d.</a>\". If you need a more accurate result, it can be done as follows:</p>\n<pre><code class=\"python\">with decimal.localcontext() as context:\n    context.prec = 50\n    print(cube_root(42))\n</code></pre>\n", "abstract": "I came up with my own answer, which takes @Mahmoud Kassem's idea, simplifies the code, and makes it more reusable: I tested it in Python 3.5.1 and Python 2.7.8, and it seemed to work fine. The result will have as many digits as specified by the decimal context the function is run in, which by default is 28 decimal places. According to the documentation for the power function in the decimal module, \"The result is well-defined but only \u201calmost always correctly-rounded\u201d.\". If you need a more accurate result, it can be done as follows:"}, {"id": 71530812, "score": 1, "vote": 0, "content": "<p>I may suggest four methods for solving your task. First is based on <a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\" rel=\"nofollow noreferrer\">Binary Search</a>. Second is based on <a href=\"https://en.wikipedia.org/wiki/Newton%27s_method\" rel=\"nofollow noreferrer\">Newton's Method</a>. Third is based on <a href=\"https://en.wikipedia.org/wiki/Shifting_nth_root_algorithm\" rel=\"nofollow noreferrer\">Shifting n-th Root Algorithm</a>. Fourth is called by me Chord-Tangent method described by me in <a href=\"https://i.stack.imgur.com/et9O0.jpg\" rel=\"nofollow noreferrer\">picture here</a>.</p>\n<p>Binary Search was already implemented in many answers above. I just introduce here my own vision of it and its implementation.</p>\n<p>As alternative I also implement Optimized Binary Search method (marked <code>Opt</code>). This method just starts from range <code>[hi / 2, hi)</code> where <code>hi</code> is equal to <code>2^(num_bit_length / k)</code> if we're computing k-th root.</p>\n<p>Newton's Method is new here, as I see it wasn't implemented in other answers. It is usually considered to be faster than Binary Search, although my own timings in code below don't show any speedup. Hence this method here is just for reference/interest.</p>\n<p>Shifting Method is 30-50% faster than optimized binary search method, and should be even faster if implemented in C++, because C++ has fast 64 bit arithemtics which is partially used in this method.</p>\n<p>Chord-Tangent Method:</p>\n<p><a href=\"https://i.stack.imgur.com/s2AS9.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/s2AS9.jpg\"/></a></p>\n<p>Chord-Tangent Method is invented by me <a href=\"https://i.stack.imgur.com/et9O0.jpg\" rel=\"nofollow noreferrer\">on piece of paper</a> (see image above), it is inspired and is an improvement of Newton method. Basically I draw a <a href=\"https://en.wikipedia.org/wiki/Chord_(geometry)\" rel=\"nofollow noreferrer\">Chord</a> and a <a href=\"https://en.wikipedia.org/wiki/Tangent\" rel=\"nofollow noreferrer\">Tangent Line</a> and find intersection with horizontal line <code>y = n</code>, these two intersections form lower and upper bound approximations of location of root solution <code>(x0, n)</code> where <code>n = x0 ^ k</code>. This method appeared to be fastest of all, while all other methods do more than 2000 iterations, this method does just 8 iterations, for the case of 8192-bit numbers. So this method is <strong>200-300x</strong> times faster than previous (by speed) Shifting Method.</p>\n<p>As an example I generate really huge random integer of 8192 bits in size. And measure timings of finding cubic root with both methods.</p>\n<p>In <code>test()</code> function you can see that I passed <code>k = 3</code> as root's power (cubic root), you can pass any power instead of 3.</p>\n<p><a href=\"https://tio.run/##xRfbbqNG9N1fcaRVa4jxLanarhXnIa361t2H3beqGmEztqc2A4JJYr4@PWcOl8Hg2Km2WpQY5nDud9LC7BJ99/oayQ2slA6zQuQyzNY7byW3SgcgdRTAJoCbALQyMoMl/DX7218MAK@XnTpIsJhwT6gMpssiIyaMljCvobGKkAHzhhFR@PDw4CCoDWw8xPIbTnQxwdLSjxx0echlGxNZMp6FZtI8ZZrJB4OOkWJvdiJLEuOhpXtr5LPMVkkukccfITIv9fgAO2PSfDGdSj15UXuVykiFkyTbTuk0fWxxDQ/bJFNmFw9qT7DbSp1yPLWdPUPvkmEBHMJ4FYVASi3sL9zcwB69q5sA2Ls/KP1Vaty4Ic2UNt6QdYIvVgIQSWhUovPFMKij47teQsX6fJSk5rv4aafwMIf7e/D0ZKWMOEi9NTvPh@kUPTKGue8kIWKzo9A9l7IQce/vK0BfOBCBsjJAzP8vIp9T866oaPliEv3NQvHJsvvh9pdcxBK7ABfMBrmUBh8XcGRTx6Dty6j9dg83jOE50TgGkB4dxwRwi2h4q8LK4QpXuZcekeyIDQDmlyKGqEs41kckXGKfONpUiOjhkuvZWvjTWvqm22OlMej4@4wiPyVaBvaXvZNkoAA7URbqrfTGtwHcOZ2KKMgwVAiLWfm@29YsR5VbZoB8njGDCNZuXy3p@PTspgJxJQTOh3ynNkbp7TfLiC8VQ10yPCnQR4FVSMXy80/2zKoFUCAIG9iMkaqiZWyG7SvKkgUmVfUiDvM9jQSmYUSf0qm3J/RF4bQ7jGp5lJSUIc45gLH9d6IWHtJdSCpoKnoP@0ithw8/VjrW6I@C7C1OTCytKawthS0b37HIxclELTFrGT1iVdr8RIuCRYwcNoNmRJqw08jQ1se6gxHGAjwyYGQPft0yT0WddrY6IHQVAWQ2lhWfwDVrDF5XxJgl@INLdVrl4KVKdcui4HpY75IsEoZyQl8/sb7T1Onrs1f32KaQ1SQ34Xo/UfH2KZusk3gqzcfPs8k/6Za7sSjXuKPgxciZbBahqBCKEgF7F4P8wD7TitZU3bpYo9V16Vk/3c2cYsLQsqhxJZt8Mz/Z5jIZ7i94CxnNFmjp7wm0x2ZuZEpvtZSRjFp8j6LcLyvRI1bmZMdkuxmVTKR1s/USufP7BzeqjRS7E1cOs/QBE7Q30c5u2opI6flzHD5gGykdWWJiBoJ34lyf@9YpjnYxxg/N3BQsr/JOm/Smhz0mfUePphFYduRCB1gVoJ3YwpGi62lNj@4WXz9wCfdRtnTr6OWIb9p6nsvM1CwxC2vNAvBKcNAA/UEnRFXRdJEdF1xbP45ORVMZ2tWlZkZ/fQ6v6UnWgyXmknRUQ7o3vnH8UlMro3Kgvrg@/UYqwleWcc0WVW0swvn0MjI3XtkrVJwmaAm2kSiJUXsVS2WaEa@zJ037wp09lcvDr/OPt/wWD0w5oZvTi7x67gfcxO1kbfh2JmTLO3fukPiaPUmmXHWITj@JzhCuaX52t/Yz2JQ9vTvdGXxZZ2bfzDtDVGYQbak0qlc@JeEM0Is1bG1h8xYs6oFJhmEOWk4BWGK@RXyT5aDmLPIHZ7@FMP5oNaVRljzpyON8mPDN43G4eCtyGG/9FK94ZaHkoU5oH/jlMJfr4RsK0MfYf1GikwnvV6T9aXKdEn1Z9X7Jp8vWdbL7c/T90nt7ynUqvJH2V@oxwGYnhA5jKQQslzAUuOUrLcSQ@xP3qsHr678\" rel=\"nofollow noreferrer\" title=\"Python 3 \u2013 Try It Online\">Try it online!</a></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def binary_search(begin, end, f, *, niter = [0]):\n    while begin &lt; end:\n        niter[0] += 1\n        mid = (begin + end) &gt;&gt; 1\n        if f(mid):\n            begin = mid + 1\n        else:\n            end = mid\n    return begin\n\ndef binary_search_kth_root(n, k, *, verbose = False):\n    # https://en.wikipedia.org/wiki/Binary_search_algorithm\n    niter = [0]\n    res = binary_search(0, n + 1, lambda root: root ** k &lt; n, niter = niter)\n    if verbose:\n        print('Binary Search iterations:', niter[0])\n    return res\n\ndef binary_search_opt_kth_root(n, k, *, verbose = False):\n    # https://en.wikipedia.org/wiki/Binary_search_algorithm\n    niter = [0]\n    hi = 1 &lt;&lt; (n.bit_length() // k - 1)\n    while hi ** k &lt;= n:\n        niter[0] += 1\n        hi &lt;&lt;= 1\n    res = binary_search(hi &gt;&gt; 1, hi, lambda root: root ** k &lt; n, niter = niter)\n    if verbose:\n        print('Binary Search Opt iterations:', niter[0])\n    return res\n\ndef newton_kth_root(n, k, *, verbose = False):\n    # https://en.wikipedia.org/wiki/Newton%27s_method\n    f = lambda x: x ** k - n\n    df = lambda x: k * x ** (k - 1)\n    x, px, niter = n, 2 * n, [0]\n    while abs(px - x) &gt; 1:\n        niter[0] += 1\n        px = x\n        x -= f(x) // df(x)\n    if verbose:\n        print('Newton Method iterations:', niter[0])\n    mini, minv = None, None\n    for i in range(-2, 3):\n        v = abs(f(x + i))\n        if minv is None or v &lt; minv:\n            mini, minv = i, v\n    return x + mini\n\ndef shifting_kth_root(n, k, *, verbose = False):\n    # https://en.wikipedia.org/wiki/Shifting_nth_root_algorithm\n    B_bits = 64\n    \n    r, y = 0, 0\n    B = 1 &lt;&lt; B_bits\n    Bk_bits = B_bits * k\n    Bk_mask = (1 &lt;&lt; Bk_bits) - 1\n    niter = [0]\n    \n    for i in range((n.bit_length() + Bk_bits - 1) // Bk_bits - 1, -1, -1):\n        alpha = (n &gt;&gt; (i * Bk_bits)) &amp; Bk_mask\n        B_y = y &lt;&lt; B_bits\n        Bk_yk = (y ** k) &lt;&lt; Bk_bits\n        Bk_r_alpha = (r &lt;&lt; Bk_bits) + alpha\n        Bk_yk_Bk_r_alpha = Bk_yk + Bk_r_alpha\n        beta = binary_search(1, B, lambda beta: (B_y + beta) ** k &lt;= Bk_yk_Bk_r_alpha, niter = niter) - 1\n        y, r = B_y + beta, Bk_r_alpha - ((B_y + beta) ** k - Bk_yk)\n\n    if verbose:\n        print('Shifting Method iterations:', niter[0])\n\n    return y\n\ndef chord_tangent_kth_root(n, k, *, verbose = False):\n    niter = [0]\n    hi = 1 &lt;&lt; (n.bit_length() // k - 1)\n    while hi ** k &lt;= n:\n        niter[0] += 1\n        hi &lt;&lt;= 1\n    f = lambda x: x ** k\n    df = lambda x: k * x ** (k - 1)\n    # https://i.stack.imgur.com/et9O0.jpg\n    x_begin, x_end = hi &gt;&gt; 1, hi\n    y_begin, y_end = f(x_begin), f(x_end)\n    for icycle in range(1 &lt;&lt; 30):\n        if x_end - x_begin &lt;= 1:\n            break\n        niter[0] += 1\n        if 0: # Do Binary Search step if needed\n            x_mid = (x_begin + x_end) &gt;&gt; 1\n            y_mid = f(x_mid)\n            if y_mid &gt; n:\n                x_end, y_end = x_mid, y_mid\n            else:\n                x_begin, y_begin = x_mid, y_mid\n        # (y_end - y_begin) / (x_end - x_begin) = (n - y_begin) / (x_n - x_begin) -&gt;\n        x_n = x_begin + (n - y_begin) * (x_end - x_begin) // (y_end - y_begin)\n        y_n = f(x_n)\n        tangent_x = x_n + (n - y_n) // df(x_n) + 1\n        \n        chord_x = x_n + (n - y_n) * (x_end - x_n) // (y_end - y_n)\n        \n        assert chord_x &lt;= tangent_x, (chord_x, tangent_x)\n        x_begin, x_end = chord_x, tangent_x\n        y_begin, y_end = f(x_begin), f(x_end)\n        assert y_begin &lt;= n, (chord_x, y_begin, n, n - y_begin)\n        assert y_end &gt; n, (icycle, tangent_x - binary_search_kth_root(n, k), y_end, n, y_end - n)\n    if verbose:\n        print('Chord Tangent Method iterations:', niter[0])\n    return x_begin\n\ndef test():\n    import random, timeit\n    \n    nruns = 3\n    bits = 8192\n    n = random.randrange(1 &lt;&lt; (bits - 1), 1 &lt;&lt; bits)\n    \n    a = binary_search_kth_root(n, 3, verbose = True)\n    b = binary_search_opt_kth_root(n, 3, verbose = True)\n    c = newton_kth_root(n, 3, verbose = True)\n    d = shifting_kth_root(n, 3, verbose = True)\n    e = chord_tangent_kth_root(n, 3, verbose = True)\n    assert abs(a - b) &lt;= 0 and abs(a - c) &lt;= 1 and abs(a - d) &lt;= 1 and abs(a - e) &lt;= 1, (a - b, a - c, a - d, a - e)\n\n    print()\n    print('Binary Search timing:', round(timeit.timeit(lambda: binary_search_kth_root(n, 3), number = nruns) / nruns, 3), 'sec')\n    print('Binary Search Opt timing:', round(timeit.timeit(lambda: binary_search_opt_kth_root(n, 3), number = nruns) / nruns, 3), 'sec')\n    print('Newton Method timing:', round(timeit.timeit(lambda: newton_kth_root(n, 3), number = nruns) / nruns, 3), 'sec')\n    print('Shifting Method timing:', round(timeit.timeit(lambda: shifting_kth_root(n, 3), number = nruns) / nruns, 3), 'sec')\n    print('Chord Tangent Method timing:', round(timeit.timeit(lambda: chord_tangent_kth_root(n, 3), number = nruns) / nruns, 3), 'sec')\n\nif __name__ == '__main__':\n    test()\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">Binary Search iterations: 8192\nBinary Search Opt iterations: 2732\nNewton Method iterations: 9348\nShifting Method iterations: 2752\nChord Tangent Method iterations: 8\n\nBinary Search timing: 0.506 sec\nBinary Search Opt timing: 0.05 sec\nNewton Method timing: 2.09 sec\nShifting Method timing: 0.03 sec\nChord Tangent Method timing: 0.001 sec\n</code></pre>\n", "abstract": "I may suggest four methods for solving your task. First is based on Binary Search. Second is based on Newton's Method. Third is based on Shifting n-th Root Algorithm. Fourth is called by me Chord-Tangent method described by me in picture here. Binary Search was already implemented in many answers above. I just introduce here my own vision of it and its implementation. As alternative I also implement Optimized Binary Search method (marked Opt). This method just starts from range [hi / 2, hi) where hi is equal to 2^(num_bit_length / k) if we're computing k-th root. Newton's Method is new here, as I see it wasn't implemented in other answers. It is usually considered to be faster than Binary Search, although my own timings in code below don't show any speedup. Hence this method here is just for reference/interest. Shifting Method is 30-50% faster than optimized binary search method, and should be even faster if implemented in C++, because C++ has fast 64 bit arithemtics which is partially used in this method. Chord-Tangent Method:  Chord-Tangent Method is invented by me on piece of paper (see image above), it is inspired and is an improvement of Newton method. Basically I draw a Chord and a Tangent Line and find intersection with horizontal line y = n, these two intersections form lower and upper bound approximations of location of root solution (x0, n) where n = x0 ^ k. This method appeared to be fastest of all, while all other methods do more than 2000 iterations, this method does just 8 iterations, for the case of 8192-bit numbers. So this method is 200-300x times faster than previous (by speed) Shifting Method. As an example I generate really huge random integer of 8192 bits in size. And measure timings of finding cubic root with both methods. In test() function you can see that I passed k = 3 as root's power (cubic root), you can pass any power instead of 3. Try it online! Output:"}, {"id": 356110, "score": 0, "vote": 0, "content": "<p>In older versions of Python, <code>1/3</code> is equal to 0.  In Python 3.0, <code>1/3</code> is equal to 0.33333333333 (and <code>1//3</code> is equal to 0).</p>\n<p>So, either change your code to use <code>1/3.0</code> or switch to Python 3.0 .</p>\n", "abstract": "In older versions of Python, 1/3 is equal to 0.  In Python 3.0, 1/3 is equal to 0.33333333333 (and 1//3 is equal to 0). So, either change your code to use 1/3.0 or switch to Python 3.0 ."}, {"id": 356102, "score": -1, "vote": 0, "content": "<p>Try converting the exponent to a floating number, as the default behaviour of / in Python is integer division</p>\n<p>n**(1/float(3))</p>\n", "abstract": "Try converting the exponent to a floating number, as the default behaviour of / in Python is integer division n**(1/float(3))"}, {"id": 356213, "score": -3, "vote": 0, "content": "<p>Well, if you're not particularly worried about precision, you could convert it to a sting, chop off some digits, use the exponent function, and then multiply the result by the root of how much you chopped off.</p>\n<p>E.g. 32123 is about equal to 32 * 1000, the cubic root is about equak to cubic root of 32 * cubic root of 1000.  The latter can be calculated by dividing the number of 0s by 3.</p>\n<p>This avoids the need for the use of extension modules.</p>\n", "abstract": "Well, if you're not particularly worried about precision, you could convert it to a sting, chop off some digits, use the exponent function, and then multiply the result by the root of how much you chopped off. E.g. 32123 is about equal to 32 * 1000, the cubic root is about equak to cubic root of 32 * cubic root of 1000.  The latter can be calculated by dividing the number of 0s by 3. This avoids the need for the use of extension modules."}]}, {"link": "https://stackoverflow.com/questions/575117/generating-unique-ordered-pythagorean-triplets", "question": {"id": "575117", "title": "Generating unique, ordered Pythagorean triplets", "content": "<p>This is a program I wrote to calculate Pythagorean triplets. When I run the program it prints each set of triplets twice because of the if statement. Is there any way I can tell the program to only print a new set of triplets once? Thanks.</p>\n<pre><code class=\"python\">import math\n\ndef main():\n    for x in range (1, 1000):\n        for y in range (1, 1000):\n            for z in range(1, 1000):\n                if x*x == y*y + z*z:\n                    print y, z, x\n                    print '-'*50\n\nif __name__ == '__main__':\n    main()  \n</code></pre>\n", "abstract": "This is a program I wrote to calculate Pythagorean triplets. When I run the program it prints each set of triplets twice because of the if statement. Is there any way I can tell the program to only print a new set of triplets once? Thanks."}, "answers": [{"id": 576405, "score": 82, "vote": 0, "content": "<p>Pythagorean Triples make a good example for claiming \"<strong><code>for</code> loops considered harmful</strong>\", because <code>for</code> loops seduce us into thinking about counting, often the most irrelevant part of a task. </p>\n<p>(I'm going to stick with pseudo-code to avoid language biases, and to keep the pseudo-code streamlined, I'll not optimize away multiple calculations of e.g. <code>x * x</code> and <code>y * y</code>.)</p>\n<p><strong>Version 1</strong>:</p>\n<pre><code class=\"python\">for x in 1..N {\n    for y in 1..N {\n        for z in 1..N {\n            if x * x + y * y == z * z then {\n                // use x, y, z\n            }\n        }\n    }\n}\n</code></pre>\n<p>is the worst solution. It generates duplicates, and traverses parts of the space that aren't useful (e.g. whenever <code>z &lt; y</code>). Its time complexity is cubic on <code>N</code>.</p>\n<p><strong>Version 2</strong>, the first improvement, comes from requiring <code>x &lt; y &lt; z</code> to hold, as in:</p>\n<pre><code class=\"python\">for x in 1..N {\n    for y in x+1..N {\n        for z in y+1..N {\n            if x * x + y * y == z * z then {\n                // use x, y, z\n            }\n        }\n    }\n}\n</code></pre>\n<p>which reduces run time and eliminates duplicated solutions. However, it is still cubic on <code>N</code>; the improvement is just a reduction of the co-efficient of <code>N</code>-cubed.</p>\n<p>It is pointless to continue examining increasing values of <code>z</code> after <code>z * z &lt; x * x + y * y</code> no longer holds. That fact motivates <strong>Version 3</strong>, the first step away from brute-force iteration over <code>z</code>:</p>\n<pre><code class=\"python\">for x in 1..N {\n    for y in x+1..N {\n        z = y + 1\n        while z * z &lt; x * x + y * y {\n            z = z + 1\n        }\n        if z * z == x * x + y * y and z &lt;= N then {\n            // use x, y, z\n        }\n    }\n}\n</code></pre>\n<p>For <code>N</code> of 1000, this is about 5 times faster than Version 2, but it is <em>still</em> cubic on <code>N</code>.</p>\n<p>The next insight is that <code>x</code> and <code>y</code> are the only independent variables; <code>z</code> depends on their values, and the last <code>z</code> value considered for the previous value of <code>y</code> is a good <em>starting</em> search value for the next value of <code>y</code>. That leads to <strong>Version 4</strong>:</p>\n<pre><code class=\"python\">for x in 1..N {\n    y = x+1\n    z = y+1\n    while z &lt;= N {\n        while z * z &lt; x * x + y * y {\n            z = z + 1\n        }\n        if z * z == x * x + y * y and z &lt;= N then {\n            // use x, y, z\n        }\n        y = y + 1\n    }\n}\n</code></pre>\n<p>which allows <code>y</code> and <code>z</code> to \"sweep\" the values above <code>x</code> only once. Not only is it over 100 times faster for <code>N</code> of 1000, it is quadratic on <code>N</code>, so the speedup increases as <code>N</code> grows.</p>\n<p>I've encountered this kind of improvement often enough to be mistrustful of \"counting loops\" for any but the most trivial uses (e.g. traversing an array).</p>\n<p><strong>Update:</strong> Apparently I should have pointed out a few things about V4 that are easy to overlook.</p>\n<ol>\n<li><p><strong>Both</strong> of the <code>while</code> loops are controlled by the value of <code>z</code> (one directly, the other indirectly through the square of <code>z</code>). The inner <code>while</code> is actually speeding up the outer <code>while</code>, rather than being orthogonal to it. <em>It's important to look at what the loops are doing, not merely to count how many loops there are.</em></p></li>\n<li><p>All of the calculations in V4 are strictly integer arithmetic. Conversion to/from floating-point, as well as floating-point calculations, are costly by comparison.</p></li>\n<li><p>V4 runs in constant memory, requiring only three integer variables. There are no arrays or hash tables to allocate and initialize (and, potentially, to cause an out-of-memory error).</p></li>\n<li><p>The original question allowed all of <code>x</code>, <code>y</code>, and <code>x</code> to vary over the same range. V1..V4 followed that pattern.</p></li>\n</ol>\n<p>Below is a not-very-scientific set of timings (using Java under Eclipse on my older laptop with other stuff running...), where the \"use x, y, z\" was implemented by instantiating a Triple object with the three values and putting it in an ArrayList. (For these runs, <code>N</code> was set to 10,000, which produced 12,471 triples in each case.)</p>\n<pre><code class=\"python\">Version 4:           46 sec.\nusing square root:  134 sec.\narray and map:      400 sec.\n</code></pre>\n<p>The \"array and map\" algorithm is <em>essentially</em>:</p>\n<pre><code class=\"python\">squares = array of i*i for i in 1 .. N\nroots = map of i*i -&gt; i for i in 1 .. N\nfor x in 1 .. N\n    for y in x+1 .. N\n        z = roots[squares[x] + squares[y]]\n        if z exists use x, y, z\n</code></pre>\n<p>The \"using square root\" algorithm is <em>essentially</em>:</p>\n<pre><code class=\"python\">for x in 1 .. N\n    for y in x+1 .. N\n        z = (int) sqrt(x * x + y * y)\n        if z * z == x * x + y * y then use x, y, z\n</code></pre>\n<p>The actual code for V4 is:</p>\n<pre><code class=\"python\">public Collection&lt;Triple&gt; byBetterWhileLoop() {\n    Collection&lt;Triple&gt; result = new ArrayList&lt;Triple&gt;(limit);\n    for (int x = 1; x &lt; limit; ++x) {\n        int xx = x * x;\n        int y = x + 1;\n        int z = y + 1;\n        while (z &lt;= limit) {\n            int zz = xx + y * y;\n            while (z * z &lt; zz) {++z;}\n            if (z * z == zz &amp;&amp; z &lt;= limit) {\n                result.add(new Triple(x, y, z));\n            }\n            ++y;\n        }\n    }\n    return result;\n}\n</code></pre>\n<p>Note that <code>x * x</code> <em>is</em> calculated in the outer loop (although I didn't bother to cache <code>z * z</code>); similar optimizations are done in the other variations.</p>\n<p>I'll be glad to provide the Java source code on request for the other variations I timed, in case I've mis-implemented anything.</p>\n", "abstract": "Pythagorean Triples make a good example for claiming \"for loops considered harmful\", because for loops seduce us into thinking about counting, often the most irrelevant part of a task.  (I'm going to stick with pseudo-code to avoid language biases, and to keep the pseudo-code streamlined, I'll not optimize away multiple calculations of e.g. x * x and y * y.) Version 1: is the worst solution. It generates duplicates, and traverses parts of the space that aren't useful (e.g. whenever z < y). Its time complexity is cubic on N. Version 2, the first improvement, comes from requiring x < y < z to hold, as in: which reduces run time and eliminates duplicated solutions. However, it is still cubic on N; the improvement is just a reduction of the co-efficient of N-cubed. It is pointless to continue examining increasing values of z after z * z < x * x + y * y no longer holds. That fact motivates Version 3, the first step away from brute-force iteration over z: For N of 1000, this is about 5 times faster than Version 2, but it is still cubic on N. The next insight is that x and y are the only independent variables; z depends on their values, and the last z value considered for the previous value of y is a good starting search value for the next value of y. That leads to Version 4: which allows y and z to \"sweep\" the values above x only once. Not only is it over 100 times faster for N of 1000, it is quadratic on N, so the speedup increases as N grows. I've encountered this kind of improvement often enough to be mistrustful of \"counting loops\" for any but the most trivial uses (e.g. traversing an array). Update: Apparently I should have pointed out a few things about V4 that are easy to overlook. Both of the while loops are controlled by the value of z (one directly, the other indirectly through the square of z). The inner while is actually speeding up the outer while, rather than being orthogonal to it. It's important to look at what the loops are doing, not merely to count how many loops there are. All of the calculations in V4 are strictly integer arithmetic. Conversion to/from floating-point, as well as floating-point calculations, are costly by comparison. V4 runs in constant memory, requiring only three integer variables. There are no arrays or hash tables to allocate and initialize (and, potentially, to cause an out-of-memory error). The original question allowed all of x, y, and x to vary over the same range. V1..V4 followed that pattern. Below is a not-very-scientific set of timings (using Java under Eclipse on my older laptop with other stuff running...), where the \"use x, y, z\" was implemented by instantiating a Triple object with the three values and putting it in an ArrayList. (For these runs, N was set to 10,000, which produced 12,471 triples in each case.) The \"array and map\" algorithm is essentially: The \"using square root\" algorithm is essentially: The actual code for V4 is: Note that x * x is calculated in the outer loop (although I didn't bother to cache z * z); similar optimizations are done in the other variations. I'll be glad to provide the Java source code on request for the other variations I timed, in case I've mis-implemented anything."}, {"id": 8263898, "score": 51, "vote": 0, "content": "<p>Substantially faster than any of the solutions so far. Finds triplets via a ternary tree.</p>\n<blockquote>\n<p><a href=\"http://mathworld.wolfram.com/PythagoreanTriple.html\" rel=\"noreferrer\">Wolfram</a> says:</p>\n<p>Hall (1970) and Roberts (1977) prove that  is a primitive Pythagorean triple if and only if</p>\n<p><code>(a,b,c)=(3,4,5)M</code></p>\n<p>where M is a finite product of the matrices U,A,D.</p>\n</blockquote>\n<p>And there we have a formula to generate every primitive triple.</p>\n<p>In the above formula, the hypotenuse is ever growing so it's pretty easy to check for a max length.</p>\n<p>In Python:</p>\n<pre><code class=\"python\">import numpy as np\n\ndef gen_prim_pyth_trips(limit=None):\n    u = np.mat(' 1  2  2; -2 -1 -2; 2 2 3')\n    a = np.mat(' 1  2  2;  2  1  2; 2 2 3')\n    d = np.mat('-1 -2 -2;  2  1  2; 2 2 3')\n    uad = np.array([u, a, d])\n    m = np.array([3, 4, 5])\n    while m.size:\n        m = m.reshape(-1, 3)\n        if limit:\n            m = m[m[:, 2] &lt;= limit]\n        yield from m\n        m = np.dot(m, uad)\n</code></pre>\n<p>If you'd like all triples and not just the primitives:</p>\n<pre><code class=\"python\">def gen_all_pyth_trips(limit):\n    for prim in gen_prim_pyth_trips(limit):\n        i = prim\n        for _ in range(limit//prim[2]):\n            yield i\n            i = i + prim\n</code></pre>\n<p><code>list(gen_prim_pyth_trips(10**4))</code> took 2.81 milliseconds to come back with 1593 elements while <code>list(gen_all_pyth_trips(10**4))</code> took 19.8 milliseconds to come back with 12471 elements</p>\n<p>For reference, the <a href=\"https://stackoverflow.com/a/576405/992385\">accepted answer</a> <a href=\"https://gist.github.com/kgullion/6adc2d633038ff852923\" rel=\"noreferrer\">(in python)</a> took 38 seconds for 12471 elements.</p>\n<p>Just for fun, setting the upper limit to one million <code>list(gen_all_pyth_trips(10**6))</code> returns in 2.66 seconds with 1980642 elements (almost 2 million triples in 3 seconds). <code>list(gen_all_pyth_trips(10**7))</code> brings my computer to its knees as the list gets so large it consumes every last bit of ram. Doing something like <code>sum(1 for _ in gen_all_pyth_trips(10**7))</code> gets around that limitation and returns in 30 seconds with 23471475 elements.</p>\n<p>For more information on the algorithm used, check out the articles on <a href=\"http://mathworld.wolfram.com/PythagoreanTriple.html\" rel=\"noreferrer\">Wolfram</a> and <a href=\"http://en.wikipedia.org/wiki/Tree_of_primitive_Pythagorean_triples\" rel=\"noreferrer\">Wikipedia</a>.</p>\n", "abstract": "Substantially faster than any of the solutions so far. Finds triplets via a ternary tree. Wolfram says: Hall (1970) and Roberts (1977) prove that  is a primitive Pythagorean triple if and only if (a,b,c)=(3,4,5)M where M is a finite product of the matrices U,A,D. And there we have a formula to generate every primitive triple. In the above formula, the hypotenuse is ever growing so it's pretty easy to check for a max length. In Python: If you'd like all triples and not just the primitives: list(gen_prim_pyth_trips(10**4)) took 2.81 milliseconds to come back with 1593 elements while list(gen_all_pyth_trips(10**4)) took 19.8 milliseconds to come back with 12471 elements For reference, the accepted answer (in python) took 38 seconds for 12471 elements. Just for fun, setting the upper limit to one million list(gen_all_pyth_trips(10**6)) returns in 2.66 seconds with 1980642 elements (almost 2 million triples in 3 seconds). list(gen_all_pyth_trips(10**7)) brings my computer to its knees as the list gets so large it consumes every last bit of ram. Doing something like sum(1 for _ in gen_all_pyth_trips(10**7)) gets around that limitation and returns in 30 seconds with 23471475 elements. For more information on the algorithm used, check out the articles on Wolfram and Wikipedia."}, {"id": 575134, "score": 12, "vote": 0, "content": "<p>You should define x &lt; y &lt; z.</p>\n<pre><code class=\"python\">for x in range (1, 1000):\n    for y in range (x + 1, 1000):\n            for z in range(y + 1, 1000):\n</code></pre>\n<p>Another good optimization would be to only use x and y and calculate zsqr = x * x + y * y. If zsqr is a square number (or z = sqrt(zsqr) is a whole number), it is a triplet, else not. That way, you need only two loops instead of three (for your example, that's about 1000 times faster).</p>\n", "abstract": "You should define x < y < z. Another good optimization would be to only use x and y and calculate zsqr = x * x + y * y. If zsqr is a square number (or z = sqrt(zsqr) is a whole number), it is a triplet, else not. That way, you need only two loops instead of three (for your example, that's about 1000 times faster)."}, {"id": 578789, "score": 12, "vote": 0, "content": "<p>The previously listed algorithms for generating <a href=\"http://en.wikipedia.org/wiki/Pythagorean_triplets\" rel=\"noreferrer\">Pythagorean triplets</a> are all modifications of the naive approach derived from the basic relationship <code>a^2 + b^2 = c^2</code> where <code>(a, b, c)</code> is a triplet of positive integers. It turns out that Pythagorean triplets satisfy some fairly remarkable relationships that can be used to generate all Pythagorean triplets.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Euclid\" rel=\"noreferrer\">Euclid</a> discovered the first such relationship. He determined that for every Pythagorean triple <code>(a, b, c)</code>, possibly after a reordering of <code>a</code> and <code>b</code> there are relatively prime positive integers <code>m</code> and <code>n</code> with <code>m &gt; n</code>, at least one of which is even, and a positive integer <code>k</code> such that</p>\n<pre><code class=\"python\">a = k (2mn)\nb = k (m^2 - n^2)\nc = k (m^2 + n^2)\n</code></pre>\n<p>Then to generate Pythagorean triplets, generate relatively prime positive integers <code>m</code> and <code>n</code> of differing parity, and a positive integer <code>k</code> and apply the above formula.</p>\n<pre><code class=\"python\">struct PythagoreanTriple {\n    public int a { get; private set; }\n    public int b { get; private set; }\n    public int c { get; private set; }\n\n    public PythagoreanTriple(int a, int b, int c) : this() {\n        this.a = a &lt; b ? a : b;\n        this.b = b &lt; a ? a : b;\n        this.c = c;\n    }\n\n    public override string ToString() {\n        return String.Format(\"a = {0}, b = {1}, c = {2}\", a, b, c);\n    }\n\n    public static IEnumerable&lt;PythagoreanTriple&gt; GenerateTriples(int max) {\n        var triples = new List&lt;PythagoreanTriple&gt;();\n        for (int m = 1; m &lt;= max / 2; m++) {\n            for (int n = 1 + (m % 2); n &lt; m; n += 2) {\n                if (m.IsRelativelyPrimeTo(n)) {\n                    for (int k = 1; k &lt;= max / (m * m + n * n); k++) {\n                        triples.Add(EuclidTriple(m, n, k));\n                    }\n                }\n            }\n        }\n\n        return triples;\n    }\n\n    private static PythagoreanTriple EuclidTriple(int m, int n, int k) {\n        int msquared = m * m;\n        int nsquared = n * n;\n        return new PythagoreanTriple(k * 2 * m * n, k * (msquared - nsquared), k * (msquared + nsquared));\n    }\n}\n\npublic static class IntegerExtensions {\n    private static int GreatestCommonDivisor(int m, int n) {\n        return (n == 0 ? m : GreatestCommonDivisor(n, m % n));\n    }\n\n    public static bool IsRelativelyPrimeTo(this int m, int n) {\n        return GreatestCommonDivisor(m, n) == 1;\n    }\n}\n\nclass Program {\n    static void Main(string[] args) {\n        PythagoreanTriple.GenerateTriples(1000).ToList().ForEach(t =&gt; Console.WriteLine(t));            \n    }\n}\n</code></pre>\n<p>The Wikipedia article on <a href=\"http://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples\" rel=\"noreferrer\">Formulas for generating Pythagorean triples</a> contains other such formulae.</p>\n", "abstract": "The previously listed algorithms for generating Pythagorean triplets are all modifications of the naive approach derived from the basic relationship a^2 + b^2 = c^2 where (a, b, c) is a triplet of positive integers. It turns out that Pythagorean triplets satisfy some fairly remarkable relationships that can be used to generate all Pythagorean triplets. Euclid discovered the first such relationship. He determined that for every Pythagorean triple (a, b, c), possibly after a reordering of a and b there are relatively prime positive integers m and n with m > n, at least one of which is even, and a positive integer k such that Then to generate Pythagorean triplets, generate relatively prime positive integers m and n of differing parity, and a positive integer k and apply the above formula. The Wikipedia article on Formulas for generating Pythagorean triples contains other such formulae."}, {"id": 575849, "score": 8, "vote": 0, "content": "<p>Algorithms can be tuned for speed, memory usage, simplicity, and other things.</p>\n<p>Here is a <code>pythagore_triplets</code> algorithm tuned for speed, at the cost of memory usage and simplicity.  If all you want is speed, this could be the way to go.</p>\n<p>Calculation of <code>list(pythagore_triplets(10000))</code> takes 40 seconds on my computer, versus 63 seconds for \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5's algorithm, and possibly days of calculation for Tafkas's algorithm (and all other algorithms which use 3 embedded loops instead of just 2).</p>\n<pre><code class=\"python\">def pythagore_triplets(n=1000):\n   maxn=int(n*(2**0.5))+1 # max int whose square may be the sum of two squares\n   squares=[x*x for x in xrange(maxn+1)] # calculate all the squares once\n   reverse_squares=dict([(squares[i],i) for i in xrange(maxn+1)]) # x*x=&gt;x\n   for x in xrange(1,n):\n     x2 = squares[x]\n     for y in xrange(x,n+1):\n       y2 = squares[y]\n       z = reverse_squares.get(x2+y2)\n       if z != None:\n         yield x,y,z\n\n&gt;&gt;&gt; print list(pythagore_triplets(20))\n[(3, 4, 5), (5, 12, 13), (6, 8, 10), (8, 15, 17), (9, 12, 15), (12, 16, 20)]\n</code></pre>\n<p>Note that if you are going to calculate the first billion triplets, then this algorithm will crash before it even starts, because of an out of memory error.  So \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5's algorithm is probably a safer choice for high values of n.</p>\n<p>BTW, here is Tafkas's algorithm, translated into python for the purpose of my performance tests.  Its flaw is to require 3 loops instead of 2.</p>\n<pre><code class=\"python\">def gcd(a, b):\n  while b != 0:\n    t = b\n    b = a%b\n    a = t\n  return a\n\ndef find_triple(upper_boundary=1000):\n  for c in xrange(5,upper_boundary+1):\n    for b in xrange(4,c):\n      for a in xrange(3,b):\n        if (a*a + b*b == c*c and gcd(a,b) == 1):\n          yield a,b,c\n</code></pre>\n", "abstract": "Algorithms can be tuned for speed, memory usage, simplicity, and other things. Here is a pythagore_triplets algorithm tuned for speed, at the cost of memory usage and simplicity.  If all you want is speed, this could be the way to go. Calculation of list(pythagore_triplets(10000)) takes 40 seconds on my computer, versus 63 seconds for \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5's algorithm, and possibly days of calculation for Tafkas's algorithm (and all other algorithms which use 3 embedded loops instead of just 2). Note that if you are going to calculate the first billion triplets, then this algorithm will crash before it even starts, because of an out of memory error.  So \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5's algorithm is probably a safer choice for high values of n. BTW, here is Tafkas's algorithm, translated into python for the purpose of my performance tests.  Its flaw is to require 3 loops instead of 2."}, {"id": 575728, "score": 6, "vote": 0, "content": "<pre><code class=\"python\">def pyth_triplets(n=1000):\n    \"Version 1\"\n    for x in xrange(1, n):\n        x2= x*x # time saver\n        for y in xrange(x+1, n): # y &gt; x\n            z2= x2 + y*y\n            zs= int(z2**.5)\n            if zs*zs == z2:\n                yield x, y, zs\n\n&gt;&gt;&gt; print list(pyth_triplets(20))\n[(3, 4, 5), (5, 12, 13), (6, 8, 10), (8, 15, 17), (9, 12, 15), (12, 16, 20)]\n</code></pre>\n<p>V.1 algorithm has monotonically increasing <code>x</code> values.</p>\n<h3>EDIT</h3>\n<p>It seems this question is still alive :)<br/>\nSince I came back and revisited the code, I tried a second approach which is almost 4 times as fast (about 26% of CPU time for N=10000) as my previous suggestion since it avoids lots of unnecessary calculations:</p>\n<pre><code class=\"python\">def pyth_triplets(n=1000):\n    \"Version 2\"\n    for z in xrange(5, n+1):\n        z2= z*z # time saver\n        x= x2= 1\n        y= z - 1; y2= y*y\n        while x &lt; y:\n            x2_y2= x2 + y2\n            if x2_y2 == z2:\n                yield x, y, z\n                x+= 1; x2= x*x\n                y-= 1; y2= y*y\n            elif x2_y2 &lt; z2:\n                x+= 1; x2= x*x\n            else:\n                y-= 1; y2= y*y\n\n&gt;&gt;&gt; print list(pyth_triplets(20))\n[(3, 4, 5), (6, 8, 10), (5, 12, 13), (9, 12, 15), (8, 15, 17), (12, 16, 20)]\n</code></pre>\n<p>Note that this algorithm has increasing <code>z</code> values.</p>\n<p>If the algorithm was converted to C \u2014where, being closer to the metal, multiplications take more time than additions\u2014 one could minimalise the necessary multiplications, given the fact that the step between consecutive squares is:</p>\n<blockquote>\n<p>(x+1)\u00b2 - x\u00b2 = (x+1)(x+1) - x\u00b2 = x\u00b2 + 2x + 1 - x\u00b2 = 2x + 1</p>\n</blockquote>\n<p>so all of the inner <code>x2= x*x</code> and <code>y2= y*y</code> would be converted to additions and subtractions like this:</p>\n<pre><code class=\"python\">def pyth_triplets(n=1000):\n    \"Version 3\"\n    for z in xrange(5, n+1):\n        z2= z*z # time saver\n        x= x2= 1; xstep= 3\n        y= z - 1; y2= y*y; ystep= 2*y - 1\n        while x &lt; y:\n            x2_y2= x2 + y2\n            if x2_y2 == z2:\n                yield x, y, z\n                x+= 1; x2+= xstep; xstep+= 2\n                y-= 1; y2-= ystep; ystep-= 2\n            elif x2_y2 &lt; z2:\n                x+= 1; x2+= xstep; xstep+= 2\n            else:\n                y-= 1; y2-= ystep; ystep-= 2\n</code></pre>\n<p>Of course, in Python the extra bytecode produced actually <em>slows down</em> the algorithm compared to version 2, but I would bet (without checking :) that V.3 is faster in C.</p>\n<p>Cheers everyone :)</p>\n", "abstract": "V.1 algorithm has monotonically increasing x values. It seems this question is still alive :)\nSince I came back and revisited the code, I tried a second approach which is almost 4 times as fast (about 26% of CPU time for N=10000) as my previous suggestion since it avoids lots of unnecessary calculations: Note that this algorithm has increasing z values. If the algorithm was converted to C \u2014where, being closer to the metal, multiplications take more time than additions\u2014 one could minimalise the necessary multiplications, given the fact that the step between consecutive squares is: (x+1)\u00b2 - x\u00b2 = (x+1)(x+1) - x\u00b2 = x\u00b2 + 2x + 1 - x\u00b2 = 2x + 1 so all of the inner x2= x*x and y2= y*y would be converted to additions and subtractions like this: Of course, in Python the extra bytecode produced actually slows down the algorithm compared to version 2, but I would bet (without checking :) that V.3 is faster in C. Cheers everyone :)"}, {"id": 41146390, "score": 4, "vote": 0, "content": "<p>I juste extended Kyle Gullion 's answer so that triples are sorted by hypothenuse, then longest side.</p>\n<p>It doesn't use numpy, but requires a SortedCollection (or SortedList) such as <a href=\"http://code.activestate.com/recipes/577197-sortedcollection/\" rel=\"nofollow noreferrer\">this one</a></p>\n<pre><code class=\"python\">def primitive_triples():\n\"\"\" generates primitive Pythagorean triplets x&lt;y&lt;z\nsorted by hypotenuse z, then longest side y\nthrough Berggren's matrices and breadth first traversal of ternary tree\n:see: https://en.wikipedia.org/wiki/Tree_of_primitive_Pythagorean_triples\n\"\"\"\nkey=lambda x:(x[2],x[1])\ntriples=SortedCollection(key=key)\ntriples.insert([3,4,5])\nA = [[ 1,-2, 2], [ 2,-1, 2], [ 2,-2, 3]]\nB = [[ 1, 2, 2], [ 2, 1, 2], [ 2, 2, 3]]\nC = [[-1, 2, 2], [-2, 1, 2], [-2, 2, 3]]\n\nwhile triples:\n    (a,b,c) = triples.pop(0)\n    yield (a,b,c)\n\n    # expand this triple to 3 new triples using Berggren's matrices\n    for X in [A,B,C]:\n        triple=[sum(x*y for (x,y) in zip([a,b,c],X[i])) for i in range(3)]\n        if triple[0]&gt;triple[1]: # ensure x&lt;y&lt;z\n            triple[0],triple[1]=triple[1],triple[0]\n        triples.insert(triple)\n\ndef triples():\n\"\"\" generates all Pythagorean triplets triplets x&lt;y&lt;z \nsorted by hypotenuse z, then longest side y\n\"\"\"\nprim=[] #list of primitive triples up to now\nkey=lambda x:(x[2],x[1])\nsamez=SortedCollection(key=key) # temp triplets with same z\nbuffer=SortedCollection(key=key) # temp for triplets with smaller z\nfor pt in primitive_triples():\n    z=pt[2]\n    if samez and z!=samez[0][2]: #flush samez\n        while samez:\n            yield samez.pop(0)\n    samez.insert(pt)\n    #build buffer of smaller multiples of the primitives already found\n    for i,pm in enumerate(prim):\n        p,m=pm[0:2]\n        while True:\n            mz=m*p[2]\n            if mz &lt; z:\n                buffer.insert(tuple(m*x for x in p))\n            elif mz == z: \n                # we need another buffer because next pt might have\n                # the same z as the previous one, but a smaller y than\n                # a multiple of a previous pt ...\n                samez.insert(tuple(m*x for x in p))\n            else:\n                break\n            m+=1\n        prim[i][1]=m #update multiplier for next loops\n    while buffer: #flush buffer\n        yield buffer.pop(0)\n    prim.append([pt,2]) #add primitive to the list\n</code></pre>\n<p>the code is available in the <a href=\"https://github.com/goulu/Goulib/blob/master/Goulib/math2.py\" rel=\"nofollow noreferrer\">math2 module</a> of <a href=\"https://github.com/goulu/Goulib\" rel=\"nofollow noreferrer\">my Python library</a>. It is tested against some series of the OEIS (code <a href=\"https://github.com/goulu/Goulib/blob/master/examples/oeis.py\" rel=\"nofollow noreferrer\">here</a> at the bottom), which just enabled me to <a href=\"https://oeis.org/draft/A121727\" rel=\"nofollow noreferrer\">find a mistake in A121727</a> :-)</p>\n", "abstract": "I juste extended Kyle Gullion 's answer so that triples are sorted by hypothenuse, then longest side. It doesn't use numpy, but requires a SortedCollection (or SortedList) such as this one the code is available in the math2 module of my Python library. It is tested against some series of the OEIS (code here at the bottom), which just enabled me to find a mistake in A121727 :-)"}, {"id": 575199, "score": 2, "vote": 0, "content": "<p>I wrote that program in Ruby and it similar to the python implementation. The important line is:</p>\n<pre><code class=\"python\">if x*x == y*y + z*z &amp;&amp; gcd(y,z) == 1:\n</code></pre>\n<p>Then you have to implement a method that return the greatest common divisor (gcd) of two given numbers. A very simple example in Ruby again:</p>\n<pre><code class=\"python\">def gcd(a, b)\n    while b != 0\n      t = b\n      b = a%b\n      a = t\n    end\n    return a\nend\n</code></pre>\n<p>The full Ruby methon to find the triplets would be:</p>\n<pre><code class=\"python\">def find_triple(upper_boundary)\n\n  (5..upper_boundary).each {|c|\n    (4..c-1).each {|b|\n      (3..b-1).each {|a|\n        if (a*a + b*b == c*c &amp;&amp; gcd(a,b) == 1)\n          puts \"#{a} \\t #{b} \\t #{c}\"\n        end\n      }\n    }\n  }\nend\n</code></pre>\n", "abstract": "I wrote that program in Ruby and it similar to the python implementation. The important line is: Then you have to implement a method that return the greatest common divisor (gcd) of two given numbers. A very simple example in Ruby again: The full Ruby methon to find the triplets would be:"}, {"id": 41265342, "score": 2, "vote": 0, "content": "<p>Old Question, but i'll still input my stuff.\nThere are two general ways to generate unique pythagorean triples. One Is by Scaling, and the other is by using this archaic formula.</p>\n<p>What scaling basically does it take a constant n, then multiply a base triple, lets say 3,4,5 by n. So taking n to be 2, we get 6,8,10 our next triple.</p>\n<p><strong>Scaling</strong></p>\n<pre><code class=\"python\">def pythagoreanScaled(n):\n    triplelist = []\n    for x in range(n):\n        one = 3*x\n        two = 4*x\n        three = 5*x\n        triple = (one,two,three)\n        triplelist.append(triple)\nreturn triplelist\n</code></pre>\n<p>The formula method uses the fact the if we take a number x, calculate 2m, m^2+1, and m^2-1, those three will always be a pythagorean triplet.</p>\n<p><strong>Formula</strong></p>\n<pre><code class=\"python\">def pythagoreantriple(n):\n    triplelist = []\n    for x in range(2,n):\n        double = x*2\n        minus = x**2-1\n        plus = x**2+1\n        triple = (double,minus,plus)\n        triplelist.append(triple)\n    return triplelist\n</code></pre>\n", "abstract": "Old Question, but i'll still input my stuff.\nThere are two general ways to generate unique pythagorean triples. One Is by Scaling, and the other is by using this archaic formula. What scaling basically does it take a constant n, then multiply a base triple, lets say 3,4,5 by n. So taking n to be 2, we get 6,8,10 our next triple. Scaling The formula method uses the fact the if we take a number x, calculate 2m, m^2+1, and m^2-1, those three will always be a pythagorean triplet. Formula"}, {"id": 575124, "score": 1, "vote": 0, "content": "<p>Yes, there is.</p>\n<p>Okay, now you'll want to know why.  Why not just constrain it so that z &gt; y?  Try </p>\n<pre><code class=\"python\">for z in range (y+1, 1000)\n</code></pre>\n", "abstract": "Yes, there is. Okay, now you'll want to know why.  Why not just constrain it so that z > y?  Try "}, {"id": 44414013, "score": 1, "vote": 0, "content": "<pre><code class=\"python\">from  math import sqrt\nfrom itertools import combinations\n\n#Pythagorean triplet - a^2 + b^2 = c^2 for (a,b) &lt;= (1999,1999)\ndef gen_pyth(n):\nif n &gt;= 2000 :\n  return\nELEM =   [  [ i,j,i*i + j*j ] for i , j in list(combinations(range(1, n +   1 ), 2)) if sqrt(i*i + j*j).is_integer() ]\nprint (*ELEM , sep = \"\\n\")\n\n\ngen_pyth(200)\n</code></pre>\n", "abstract": ""}, {"id": 58320412, "score": 1, "vote": 0, "content": "<pre class=\"lang-py prettyprint-override\"><code class=\"python\">\nfor a in range(1,20):\n    for b in range(1,20):\n        for c in range(1,20):\n            if a&gt;b and c and c&gt;b:\n                if a**2==b**2+c**2:\n                    print(\"triplets are:\",a,b,c)\n\n</code></pre>\n", "abstract": ""}, {"id": 66454297, "score": 1, "vote": 0, "content": "<p>in python we can store square of all numbers in another list.\nthen find permutation of pairs of all number given\nsquare them\nfinally check if any pair sum of square matches the squared list</p>\n", "abstract": "in python we can store square of all numbers in another list.\nthen find permutation of pairs of all number given\nsquare them\nfinally check if any pair sum of square matches the squared list"}, {"id": 577110, "score": 0, "vote": 0, "content": "<p>Version 5 to Joel Neely.</p>\n<p>Since X can  be max of 'N-2' and Y can be max of 'N-1' for range of 1..N. Since Z max is N and Y max is N-1, X can be max of Sqrt ( N * N - (N-1) * (N-1) ) = Sqrt ( 2 * N - 1 ) and can start from 3.</p>\n<pre><code class=\"python\">MaxX = ( 2 * N - 1 ) ** 0.5\n\nfor x in 3..MaxX {\n  y = x+1\n  z = y+1\n  m = x*x + y*y\n  k = z * z\n  while z &lt;= N {\n     while k &lt; m {\n        z = z + 1\n        k = k + (2*z) - 1\n    }\n    if k == m and z &lt;= N then {\n        // use x, y, z\n    }\n    y = y + 1\n    m = m + (2 * y) - 1\n  }\n }\n</code></pre>\n", "abstract": "Version 5 to Joel Neely. Since X can  be max of 'N-2' and Y can be max of 'N-1' for range of 1..N. Since Z max is N and Y max is N-1, X can be max of Sqrt ( N * N - (N-1) * (N-1) ) = Sqrt ( 2 * N - 1 ) and can start from 3."}, {"id": 2241194, "score": 0, "vote": 0, "content": "<p>Just checking, but I've been using the following code to make pythagorean triples. It's very fast (and I've tried some of the examples here, though I kind of learned them and wrote my own and came back and checked here (2 years ago)). I think this code correctly finds all pythagorean triples up to (name your limit) and fairly quickly too. I used C++ to make it.</p>\n<p>ullong is unsigned long long and I created a couple of functions to square and root\nmy root function basically said if square root of given number (after making it whole number (integral)) squared not equal number give then return -1 because it is not rootable. \n_square and _root do as expected as of description above, I know of another way to optimize it but I haven't done nor tested that yet.</p>\n<pre><code class=\"python\">generate(vector&lt;Triple&gt;&amp; triplist, ullong limit) {\ncout&lt;&lt;\"Please wait as triples are being generated.\"&lt;&lt;endl;\nregister ullong a, b, c;\nregister Triple trip;\ntime_t timer = time(0);\n\nfor(a = 1; a &lt;= limit; ++a) {\n    for(b = a + 1; b &lt;= limit; ++b) {\n        c = _root(_square(a) + _square(b));\n\n        if(c != -1 &amp;&amp; c &lt;= limit) {\n            trip.a = a; trip.b = b; trip.c = c;\n\n            triplist.push_back(trip);\n\n        } else if(c &gt; limit)\n            break;\n    }\n}\n\ntimer = time(0) - timer;\ncout&lt;&lt;\"Generated \"&lt;&lt;triplist.size()&lt;&lt;\" in \"&lt;&lt;timer&lt;&lt;\" seconds.\"&lt;&lt;endl;\ncin.get();\ncin.get();\n</code></pre>\n<p>}</p>\n<p>Let me know what you all think. It generates all primitive and non-primitive triples according to the teacher I turned it in for. (she tested it up to 100 if I remember correctly).</p>\n<p>The results from the v4 supplied by a previous coder here are</p>\n<p>Below is a not-very-scientific set of timings (using Java under Eclipse on my older laptop with other stuff running...), where the \"use x, y, z\" was implemented by instantiating a Triple object with the three values and putting it in an ArrayList. (For these runs, N was set to 10,000, which produced 12,471 triples in each case.)</p>\n<p>Version 4:           46 sec.\nusing square root:  134 sec.\narray and map:      400 sec.</p>\n<p>The results from mine is\nHow many triples to generate: 10000</p>\n<p>Please wait as triples are being generated.\nGenerated 12471 in 2 seconds.</p>\n<p>That is before I even start optimizing via the compiler. (I remember previously getting 10000 down to 0 seconds with tons of special options and stuff). My code also generates all the triples with 100,000 as the limit of how high side1,2,hyp can go in 3.2 minutes (I think the 1,000,000 limit takes an hour).</p>\n<p>I modified the code a bit and got the 10,000 limit down to 1 second (no optimizations). On top of that, with careful thinking, mine could be broken down into chunks and threaded upon given ranges (for example 100,000 divide into 4 equal chunks for 3 cpu's (1 extra to hopefully consume cpu time just in case) with ranges 1 to 25,000 (start at 1 and limit it to 25,000), 25,000 to 50,000 , 50,000 to 75,000, and 75,000 to end. I may do that and see if it speeds it up any (I will have threads premade and not include them in the actual amount of time to execute the triple function. I'd need a more precise timer and a way to concatenate the vectors. I think that if 1 3.4 GHZ cpu with 8 gb ram at it's disposal can do 10,000 as lim in 1 second then 3 cpus should do that in 1/3 a second (and I round to higher second as is atm).</p>\n", "abstract": "Just checking, but I've been using the following code to make pythagorean triples. It's very fast (and I've tried some of the examples here, though I kind of learned them and wrote my own and came back and checked here (2 years ago)). I think this code correctly finds all pythagorean triples up to (name your limit) and fairly quickly too. I used C++ to make it. ullong is unsigned long long and I created a couple of functions to square and root\nmy root function basically said if square root of given number (after making it whole number (integral)) squared not equal number give then return -1 because it is not rootable. \n_square and _root do as expected as of description above, I know of another way to optimize it but I haven't done nor tested that yet. } Let me know what you all think. It generates all primitive and non-primitive triples according to the teacher I turned it in for. (she tested it up to 100 if I remember correctly). The results from the v4 supplied by a previous coder here are Below is a not-very-scientific set of timings (using Java under Eclipse on my older laptop with other stuff running...), where the \"use x, y, z\" was implemented by instantiating a Triple object with the three values and putting it in an ArrayList. (For these runs, N was set to 10,000, which produced 12,471 triples in each case.) Version 4:           46 sec.\nusing square root:  134 sec.\narray and map:      400 sec. The results from mine is\nHow many triples to generate: 10000 Please wait as triples are being generated.\nGenerated 12471 in 2 seconds. That is before I even start optimizing via the compiler. (I remember previously getting 10000 down to 0 seconds with tons of special options and stuff). My code also generates all the triples with 100,000 as the limit of how high side1,2,hyp can go in 3.2 minutes (I think the 1,000,000 limit takes an hour). I modified the code a bit and got the 10,000 limit down to 1 second (no optimizations). On top of that, with careful thinking, mine could be broken down into chunks and threaded upon given ranges (for example 100,000 divide into 4 equal chunks for 3 cpu's (1 extra to hopefully consume cpu time just in case) with ranges 1 to 25,000 (start at 1 and limit it to 25,000), 25,000 to 50,000 , 50,000 to 75,000, and 75,000 to end. I may do that and see if it speeds it up any (I will have threads premade and not include them in the actual amount of time to execute the triple function. I'd need a more precise timer and a way to concatenate the vectors. I think that if 1 3.4 GHZ cpu with 8 gb ram at it's disposal can do 10,000 as lim in 1 second then 3 cpus should do that in 1/3 a second (and I round to higher second as is atm)."}, {"id": 21654130, "score": 0, "vote": 0, "content": "<p>It should be noted that for a, b, and c you don't need to loop all the way to N.</p>\n<p>For a, you only have to loop from 1 to  <code>int(sqrt(n**2/2))+1</code>, for b, <code>a+1</code> to <code>int(sqrt(n**2-a**2))+1</code>, and for c from <code>int(sqrt(a**2+b**2)</code> to <code>int(sqrt(a**2+b**2)+2</code>.</p>\n", "abstract": "It should be noted that for a, b, and c you don't need to loop all the way to N. For a, you only have to loop from 1 to  int(sqrt(n**2/2))+1, for b, a+1 to int(sqrt(n**2-a**2))+1, and for c from int(sqrt(a**2+b**2) to int(sqrt(a**2+b**2)+2."}, {"id": 51447261, "score": 0, "vote": 0, "content": "<pre><code class=\"python\"># To find all pythagorean triplets in a range\nimport math\nn = int(input('Enter the upper range of limit'))\nfor i in range(n+1):\n    for j in range(1, i):\n        k = math.sqrt(i*i + j*j)\n        if k % 1 == 0 and k in range(n+1):\n            print(i,j,int(k))\n</code></pre>\n", "abstract": ""}, {"id": 57328931, "score": 0, "vote": 0, "content": "<p>U have to use Euclid's proof of Pythagorean triplets. Follow below...</p>\n<p>U can choose any arbitrary number greater than zero say <code>m,n</code></p>\n<p>According to Euclid the triplet will be <code>a(m*m-n*n)</code>, <code>b(2*m*n)</code>, <code>c(m*m+n*n)</code></p>\n<p>Now apply this formula to find out the triplets, say our one value of triplet is 6 then, other two? Ok let\u2019s solve...</p>\n<p><code>a(m*m-n*n)</code>, <code>b(2*m*n)</code> , <code>c(m*m+n*n)</code></p>\n<p>It is sure that <code>b(2*m*n)</code> is obviously even. So now</p>\n<p><code>(2*m*n)=6 =&gt;(m*n)=3 =&gt;m*n=3*1 =&gt;m=3,n=1</code></p>\n<p>U can take any other value rather than 3 and 1, but those two values should hold the product of two numbers which is 3 <code>(m*n=3)</code></p>\n<p>Now, when <code>m=3</code> and <code>n=1</code> Then,</p>\n<p><code>a(m*m-n*n)=(3*3-1*1)=8</code> , <code>c(m*m-n*n)=(3*3+1*1)=10</code></p>\n<p>6,8,10 is our triplet for value, this our visualization of how generating triplets.</p>\n<p>if given number is odd like <code>(9)</code> then slightly modified here, because <code>b(2*m*n)</code></p>\n<p>will never be odd. so, here we have to take</p>\n<p><code>a(m*m-n*n)=7</code>, <code>(m+n)*(m-n)=7*1</code>, So, <code>(m+n)=7</code>, <code>(m-n)=1</code></p>\n<p>Now find m and n from here, then find the other two values.</p>\n<p>If u don\u2019t understand it, read it again carefully.</p>\n<p>Do code according this, it will generate distinct triplets efficiently.</p>\n", "abstract": "U have to use Euclid's proof of Pythagorean triplets. Follow below... U can choose any arbitrary number greater than zero say m,n According to Euclid the triplet will be a(m*m-n*n), b(2*m*n), c(m*m+n*n) Now apply this formula to find out the triplets, say our one value of triplet is 6 then, other two? Ok let\u2019s solve... a(m*m-n*n), b(2*m*n) , c(m*m+n*n) It is sure that b(2*m*n) is obviously even. So now (2*m*n)=6 =>(m*n)=3 =>m*n=3*1 =>m=3,n=1 U can take any other value rather than 3 and 1, but those two values should hold the product of two numbers which is 3 (m*n=3) Now, when m=3 and n=1 Then, a(m*m-n*n)=(3*3-1*1)=8 , c(m*m-n*n)=(3*3+1*1)=10 6,8,10 is our triplet for value, this our visualization of how generating triplets. if given number is odd like (9) then slightly modified here, because b(2*m*n) will never be odd. so, here we have to take a(m*m-n*n)=7, (m+n)*(m-n)=7*1, So, (m+n)=7, (m-n)=1 Now find m and n from here, then find the other two values. If u don\u2019t understand it, read it again carefully. Do code according this, it will generate distinct triplets efficiently."}, {"id": 59955292, "score": 0, "vote": 0, "content": "<p>A non-numpy version of the Hall/Roberts approach is</p>\n<pre><code class=\"python\">def pythag3(limit=None, all=False):\n    \"\"\"generate Pythagorean triples which are primitive (default)\n    or without restriction (when ``all`` is True). The elements\n    returned in the tuples are sorted with the smallest first.\n\n    Examples\n    ========\n\n    &gt;&gt;&gt; list(pythag3(20))\n    [(3, 4, 5), (8, 15, 17), (5, 12, 13)]\n    &gt;&gt;&gt; list(pythag3(20, True))\n    [(3, 4, 5), (6, 8, 10), (9, 12, 15), (12, 16, 20), (8, 15, 17), (5, 12, 13)]\n\n    \"\"\"\n    if limit and limit &lt; 5:\n        return\n    m = [(3,4,5)]  # primitives stored here\n    while m:\n        x, y, z = m.pop()\n        if x &gt; y:\n            x, y = y, x\n        yield (x, y, z)\n        if all:\n            a, b, c = x, y, z\n            while 1:\n                c += z\n                if c &gt; limit:\n                    break\n                a += x\n                b += y\n                yield a, b, c\n        # new primitives\n        a = x - 2*y + 2*z, 2*x - y + 2*z, 2*x - 2*y + 3*z\n        b = x + 2*y + 2*z, 2*x + y + 2*z, 2*x + 2*y + 3*z\n        c = -x + 2*y + 2*z, -2*x + y + 2*z, -2*x + 2*y + 3*z\n        for d in (a, b, c):\n            if d[2] &lt;= limit:\n                m.append(d)\n</code></pre>\n<p>It's slower than the numpy-coded version but the primitives with largest element less than or equal to <code>10^6</code> are generated on my slow machine in about 1.4 seconds. (And the list <code>m</code> never grew beyond 18 elements.)</p>\n", "abstract": "A non-numpy version of the Hall/Roberts approach is It's slower than the numpy-coded version but the primitives with largest element less than or equal to 10^6 are generated on my slow machine in about 1.4 seconds. (And the list m never grew beyond 18 elements.)"}, {"id": 70462333, "score": 0, "vote": 0, "content": "<p>In c language -</p>\n<pre><code class=\"python\">#include&lt;stdio.h&gt;\nint main()\n{\n    int n;\n    printf(\"How many triplets needed : \\n\");\n    scanf(\"%d\\n\",&amp;n);\n    for(int i=1;i&lt;=2000;i++)\n    {\n        for(int j=i;j&lt;=2000;j++)\n        {\n            for(int k=j;k&lt;=2000;k++)\n            {\n                if((j*j+i*i==k*k) &amp;&amp; (n&gt;0))\n                {\n                    printf(\"%d %d %d\\n\",i,j,k);\n                    n=n-1;\n                }\n            }\n        }\n    }\n}\n</code></pre>\n", "abstract": "In c language -"}, {"id": 52171937, "score": -1, "vote": 0, "content": "<p>You can try this</p>\n<pre><code class=\"python\">  triplets=[]\n    for a in range(1,100):\n        for b in range(1,100):\n            for c in range(1,100):\n                if  a**2 + b**2==c**2:\n                    i=[a,b,c]\n                    triplets.append(i)\n                    for i in triplets:\n                          i.sort()\n                          if triplets.count(i)&gt;1:\n                              triplets.remove(i)\n    print(triplets)\n</code></pre>\n", "abstract": "You can try this"}]}, {"link": "https://stackoverflow.com/questions/32923605/is-there-a-way-to-get-the-index-of-the-median-in-python-in-one-command", "question": {"id": "32923605", "title": "Is there a way to get the index of the median in python in one command?", "content": "<p>Is there something like <code>numpy.argmin(x)</code>, but for median?</p>\n", "abstract": "Is there something like numpy.argmin(x), but for median?"}, "answers": [{"id": 38253918, "score": 29, "vote": 0, "content": "<p>a quick approximation:</p>\n<pre><code class=\"python\">numpy.argsort(data)[len(data)//2]\n</code></pre>\n", "abstract": "a quick approximation:"}, {"id": 64015677, "score": 13, "vote": 0, "content": "<p>In general, this is an ill-posed question because an array does not necessarily contain its own median for numpy's definition of the median. For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; np.median([1, 2])\n1.5\n</code></pre>\n<p>But when the length of the array is odd, the median will generally be in the array, so asking for its index does make sense:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; np.median([1, 2, 3])\n2\n</code></pre>\n<p>For odd-length arrays, an efficient way to determine the index of the median value is by using the <code>np.argpartition</code> function. For example:</p>\n<pre><code class=\"python\">import numpy as np\n\ndef argmedian(x):\n  return np.argpartition(x, len(x) // 2)[len(x) // 2]\n\n# Works for odd-length arrays, where the median is in the array:\nx = np.random.rand(101)\n\nprint(\"median in array:\", np.median(x) in x)\n# median in array: True\n\nprint(x[argmedian(x)], np.median(x))\n# 0.5819150016674371 0.5819150016674371\n\n# Doesn't work for even-length arrays, where the median is not in the array:\nx = np.random.rand(100)\n\nprint(\"median in array:\", np.median(x) in x)\n# median in array: False\n\nprint(x[argmedian(x)], np.median(x))\n# 0.6116799104572843 0.6047559243909065\n</code></pre>\n<p>This is quite a bit faster than the accepted sort-based solution as the size of the array grows:</p>\n<pre><code class=\"python\">x = np.random.rand(1000)\n%timeit np.argsort(x)[len(x)//2]\n# 10000 loops, best of 3: 25.4 \u00b5s per loop\n%timeit np.argpartition(x, len(x) // 2)[len(x) // 2]\n# 100000 loops, best of 3: 6.03 \u00b5s per loop\n</code></pre>\n", "abstract": "In general, this is an ill-posed question because an array does not necessarily contain its own median for numpy's definition of the median. For example: But when the length of the array is odd, the median will generally be in the array, so asking for its index does make sense: For odd-length arrays, an efficient way to determine the index of the median value is by using the np.argpartition function. For example: This is quite a bit faster than the accepted sort-based solution as the size of the array grows:"}, {"id": 45935420, "score": 12, "vote": 0, "content": "<p>It seems old question, but i found a nice way to make it so:</p>\n<pre><code class=\"python\">import random\nimport numpy as np\n#some random list with 20 elements\na = [random.random() for i in range(20)]\n#find the median index of a\nmedIdx = a.index(np.percentile(a,50,interpolation='nearest'))\n</code></pre>\n<p>The neat trick here is the percentile builtin option for nearest interpolation, which return a \"real\" median value from the list, so it is safe to search for it afterwards.</p>\n", "abstract": "It seems old question, but i found a nice way to make it so: The neat trick here is the percentile builtin option for nearest interpolation, which return a \"real\" median value from the list, so it is safe to search for it afterwards."}, {"id": 32923894, "score": 1, "vote": 0, "content": "<p>You can keep the indices with the elements (<code>zip</code>) and sort and return the element on the middle or two elements on the middle, however sorting will be <code>O(n.logn)</code>. The following method is <code>O(n)</code> in terms of time complexity.</p>\n<pre><code class=\"python\">import numpy as np\n\ndef arg_median(a):\n    if len(a) % 2 == 1:\n        return np.where(a == np.median(a))[0][0]\n    else:\n        l,r = len(a) // 2 - 1, len(a) // 2\n        left = np.partition(a, l)[l]\n        right = np.partition(a, r)[r]\n        return [np.where(a == left)[0][0], np.where(a == right)[0][0]]\n\nprint(arg_median(np.array([ 3,  9,  5,  1, 15])))\n# 1 3 5 9 15, median=5, index=2\nprint(arg_median(np.array([ 3,  9,  5,  1, 15, 12])))\n# 1 3 5 9 12 15, median=5,9, index=2,1\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">2\n[2, 1]\n</code></pre>\n<p>The idea is if there is only one median (array has a odd length), then it returns the index of the median. If we need to average to elements (array has even length) then it returns the indices of these two elements in an list.</p>\n", "abstract": "You can keep the indices with the elements (zip) and sort and return the element on the middle or two elements on the middle, however sorting will be O(n.logn). The following method is O(n) in terms of time complexity. Output: The idea is if there is only one median (array has a odd length), then it returns the index of the median. If we need to average to elements (array has even length) then it returns the indices of these two elements in an list."}, {"id": 56781614, "score": 1, "vote": 0, "content": "<p>The problem with the accepted answer <code>numpy.argsort(data)[len(data)//2]</code> is that it only works for 1-dimensional arrays. For n-dimensional arrays we need to use a different solution which is based on the answer proposed by @Hagay. </p>\n<pre><code class=\"python\">import numpy as np\n\n# Initialize random 2d array, a\na = np.random.randint(0, 7, size=16).reshape(4,4)\narray([[3, 1, 3, 4],\n       [5, 2, 1, 4],\n       [4, 2, 4, 2],\n       [6, 1, 0, 6]])\n\n# Get the argmedians\nnp.stack(np.nonzero(a == np.percentile(a,50,interpolation='nearest')), axis=1)  \narray([[0, 0],\n       [0, 2]])\n\n# Initialize random 3d array, a\na = np.random.randint(0, 10, size=27).reshape(3,3,3)\narray([[[3, 5, 3],\n        [7, 4, 3],\n        [8, 3, 0]],\n\n       [[2, 6, 1],\n        [7, 8, 8],\n        [0, 6, 5]],\n\n       [[0, 7, 8],\n        [3, 1, 0],\n        [9, 6, 7]]])\n\n# Get the argmedians\nnp.stack(np.nonzero(a == np.percentile(a,50,interpolation='nearest')), axis=1) \narray([[0, 0, 1],\n       [1, 2, 2]])\n</code></pre>\n", "abstract": "The problem with the accepted answer numpy.argsort(data)[len(data)//2] is that it only works for 1-dimensional arrays. For n-dimensional arrays we need to use a different solution which is based on the answer proposed by @Hagay. "}, {"id": 66541962, "score": 1, "vote": 0, "content": "<p>The accepted answer <code>numpy.argsort(data)[len(data)//2]</code> can not handle arrays with NaNs.</p>\n<p>For 2-D array, to get the median column index in the axis=1 (along row):</p>\n<pre><code class=\"python\">df = pd.DataFrame({'a': [1, 2, 3.3, 4],\n                   'b': [80, 23, np.nan, 88],\n                   'c': [75, 45, 76, 67],\n                   'd': [5, 4, 6, 7]})\ndata = df.to_numpy()\n# data\narray([[ 1. , 80. , 75. ,  5. ],\n       [ 2. , 23. , 45. ,  4. ],\n       [ 3.3,  nan, 76. ,  6. ],\n       [ 4. , 88. , 67. ,  7. ]])\n\n# median, ignoring NaNs\namedian = np.nanmedian(data, axis=1)\naabs = np.abs(data.T-amedian).T\nidx = np.nanargmin(aabs, axis=1)\nidx\narray([2, 1, 3, 2])\n\n# the accepted answer, please note the third index is 2, the correspnoding cell value is 76, which should not be the median value in row [ 3.3,  nan, 76. ,  6. ]\nidx = np.argsort(data)[:, len(data[0])//2]\nidx\narray([2, 1, 2, 2])\n\n</code></pre>\n<p>Since this is a 4*4 array with even columns, the column index of median value for row No.3 should be 6 instead of 76.</p>\n", "abstract": "The accepted answer numpy.argsort(data)[len(data)//2] can not handle arrays with NaNs. For 2-D array, to get the median column index in the axis=1 (along row): Since this is a 4*4 array with even columns, the column index of median value for row No.3 should be 6 instead of 76."}]}, {"link": "https://stackoverflow.com/questions/24767191/scipy-is-not-optimizing-and-returns-desired-error-not-necessarily-achieved-due", "question": {"id": "24767191", "title": "scipy is not optimizing and returns &quot;Desired error not necessarily achieved due to precision loss&quot;", "content": "<p>I have the following code which attempts to minimize a log likelihood function.</p>\n<pre><code class=\"python\">#!/usr/bin/python\nimport math\nimport random\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef loglikelihood(params, data):\n    (mu, alpha, beta) = params\n    tlist = np.array(data)\n    r = np.zeros(len(tlist))\n    for i in xrange(1,len(tlist)):\n        r[i] = math.exp(-beta*(tlist[i]-tlist[i-1]))*(1+r[i-1])\n    loglik  = -tlist[-1]*mu\n    loglik = loglik+alpha/beta*sum(np.exp(-beta*(tlist[-1]-tlist))-1)\n    loglik = loglik+np.sum(np.log(mu+alpha*r))\n    return -loglik\n\natimes = [ 148.98894201,  149.70253172,  151.13717804,  160.35968355,\n        160.98322609,  161.21331798,  163.60755544,  163.68994973,\n        164.26131871,  228.79436067]\na= 0.01\nalpha = 0.5\nbeta = 0.6\nprint loglikelihood((a, alpha, beta), atimes)\n\nres = minimize(loglikelihood, (0.01, 0.1,0.1), method = 'BFGS',args = (atimes,))\nprint res\n</code></pre>\n<p>It gives me </p>\n<pre><code class=\"python\">28.3136498357\n./test.py:17: RuntimeWarning: invalid value encountered in log\n  loglik = loglik+np.sum(np.log(mu+alpha*r))\n   status: 2\n  success: False\n     njev: 14\n     nfev: 72\n hess_inv: array([[1, 0, 0],\n       [0, 1, 0],\n       [0, 0, 1]])\n      fun: 32.131359359964378\n        x: array([ 0.01,  0.1 ,  0.1 ])\n  message: 'Desired error not necessarily achieved due to precision loss.'\n      jac: array([ -2.8051672 ,  13.06962156, -48.97879982])\n</code></pre>\n<p>Notice that it hasn't managed to optimize the parameters at all and the minimized value 32 is bigger than 28 which is what you get with    a= 0.01, alpha = 0.5, beta = 0.6 .   It's possible this problem could be avoided by choosing better initial guesses but if so, how can I do this automatically?</p>\n", "abstract": "I have the following code which attempts to minimize a log likelihood function. It gives me  Notice that it hasn't managed to optimize the parameters at all and the minimized value 32 is bigger than 28 which is what you get with    a= 0.01, alpha = 0.5, beta = 0.6 .   It's possible this problem could be avoided by choosing better initial guesses but if so, how can I do this automatically?"}, "answers": [{"id": 24767946, "score": 36, "vote": 0, "content": "<p>I copied your example and tried a little bit. Looks like if you stick with BFGS solver, after a few iteration the <code>mu+ alpha * r</code> will have some negative numbers, and that's how you get the RuntimeWarning.</p>\n<p>The easiest fix I can think of is to switch to Nelder Mead solver.</p>\n<pre><code class=\"python\">res = minimize(loglikelihood, (0.01, 0.1,0.1), method = 'Nelder-Mead',args = (atimes,))\n</code></pre>\n<p>And it will give you this result:</p>\n<pre><code class=\"python\">28.3136498357\n  status: 0\n    nfev: 159\n success: True\n     fun: 27.982451280648817\n       x: array([ 0.01410906,  0.68346023,  0.90837568])\n message: 'Optimization terminated successfully.'\n     nit: 92\n</code></pre>\n", "abstract": "I copied your example and tried a little bit. Looks like if you stick with BFGS solver, after a few iteration the mu+ alpha * r will have some negative numbers, and that's how you get the RuntimeWarning. The easiest fix I can think of is to switch to Nelder Mead solver. And it will give you this result:"}, {"id": 54446479, "score": 11, "vote": 0, "content": "<p>Another solution (that worked for me) is to scale your function (and gradients) to values closer to 0. For example, my problem came up when I had to evaluate a log-likelihood of 60k points. This meant that my log-likelihood was a very large number. Conceptually, the log-likelihood was a very very spikey function. </p>\n<p>The gradients started off large (to climb this spikey mountain), and then became moderately small, but never less than the default <code>gtol</code> parameter in the BGFS routine (which is the threshold that all gradients must be below for termination). Also, at this time I had essentially arrived at the correct values (I was using generated data so I knew the true values). </p>\n<p>What was happening was that my gradients were approx. 60k * <code>average individual gradient value</code>, and even if the <code>average individual gradient value</code> was small, say less than 1e-8, 60k * 1e-8 &gt; <code>gtol</code>. So I was never satisfying the threshold even though I had arrived at the solution. </p>\n<p>Conceptually, because of this very spikey mountain, the algorithm was making small steps, but stepping <em>over</em> the true minimum and never achieved <code>average individual gradient &lt;&lt; 1e-8</code> which implies my gradients never went under <code>gtol</code>. </p>\n<p>Two solutions:</p>\n<p>1) Scale your log-likelihood and gradients by a factor, like <code>1/n</code> where <code>n</code> is the number of samples.</p>\n<p>2) Scale your <code>gtol</code>: for example <code>\"gtol\": 1e-7 * n</code></p>\n", "abstract": "Another solution (that worked for me) is to scale your function (and gradients) to values closer to 0. For example, my problem came up when I had to evaluate a log-likelihood of 60k points. This meant that my log-likelihood was a very large number. Conceptually, the log-likelihood was a very very spikey function.  The gradients started off large (to climb this spikey mountain), and then became moderately small, but never less than the default gtol parameter in the BGFS routine (which is the threshold that all gradients must be below for termination). Also, at this time I had essentially arrived at the correct values (I was using generated data so I knew the true values).  What was happening was that my gradients were approx. 60k * average individual gradient value, and even if the average individual gradient value was small, say less than 1e-8, 60k * 1e-8 > gtol. So I was never satisfying the threshold even though I had arrived at the solution.  Conceptually, because of this very spikey mountain, the algorithm was making small steps, but stepping over the true minimum and never achieved average individual gradient << 1e-8 which implies my gradients never went under gtol.  Two solutions: 1) Scale your log-likelihood and gradients by a factor, like 1/n where n is the number of samples. 2) Scale your gtol: for example \"gtol\": 1e-7 * n"}, {"id": 52193965, "score": 5, "vote": 0, "content": "<p>Facing the same warning, I solved it by rewriting the log-likelihood function to get <code>log(params)</code> and <code>log(data)</code> as arguments, instead of params and data. </p>\n<p>Thus, I avoid using <code>np.log()</code> in the likelihood function or Jacobian, if possible. </p>\n", "abstract": "Facing the same warning, I solved it by rewriting the log-likelihood function to get log(params) and log(data) as arguments, instead of params and data.  Thus, I avoid using np.log() in the likelihood function or Jacobian, if possible. "}, {"id": 47244817, "score": 4, "vote": 0, "content": "<p>Watch out for negative values of the log() function, resolve them and tell the optimizer that they are bad, by adding a penalty:</p>\n<pre><code class=\"python\">#!/usr/bin/python\nimport math\nimport random\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef loglikelihood(params, data):\n    (mu, alpha, beta) = params\n    tlist = np.array(data)\n    r = np.zeros(len(tlist))\n    for i in xrange(1,len(tlist)):\n        r[i] = math.exp(-beta*(tlist[i]-tlist[i-1]))*(1+r[i-1])\n    loglik = -tlist[-1]*mu\n    loglik += alpha/beta*sum(np.exp(-beta*(tlist[-1]-tlist))-1)\n    argument = mu + alpha * r\n    limit = 1e-6\n    if np.min(argument) &lt; limit:\n        # add a penalty for too small argument of log\n        loglik += np.sum(np.minimum(0.0, argument - limit)) / limit\n        # keep argument of log above the limit\n        argument = np.maximum(argument, limit)\n    loglik += np.sum(np.log(argument))\n    return -loglik\n\natimes = [ 148.98894201,  149.70253172,  151.13717804,  160.35968355,\n        160.98322609,  161.21331798,  163.60755544,  163.68994973,\n        164.26131871,  228.79436067]\na= 0.01\nalpha = 0.5\nbeta = 0.6\nprint loglikelihood((a, alpha, beta), atimes)\n\nres = minimize(loglikelihood, (0.01, 0.1,0.1), method = 'BFGS',args = (atimes,))\nprint res\n</code></pre>\n", "abstract": "Watch out for negative values of the log() function, resolve them and tell the optimizer that they are bad, by adding a penalty:"}, {"id": 70551893, "score": 1, "vote": 0, "content": "<p>I know I am late but I do 3 optimizations in series.  First I use a Nelder-Mead to get close.  Without first getting close, I get way too many overflow errors. I then copy res.x to the starting parameters for the next optimizing routine.  I have found that Powell is most reliable and it usually does a pretty good job.  BUT, I then do another minimization using Nelder-Mead again to avoid falling in to local minimums.<br/>\nUsually, there isn't much improvement after using the Powell minimization.</p>\n", "abstract": "I know I am late but I do 3 optimizations in series.  First I use a Nelder-Mead to get close.  Without first getting close, I get way too many overflow errors. I then copy res.x to the starting parameters for the next optimizing routine.  I have found that Powell is most reliable and it usually does a pretty good job.  BUT, I then do another minimization using Nelder-Mead again to avoid falling in to local minimums.\nUsually, there isn't much improvement after using the Powell minimization."}]}, {"link": "https://stackoverflow.com/questions/33468821/is-scipy-misc-comb-faster-than-an-ad-hoc-binomial-computation", "question": {"id": "33468821", "title": "Is `scipy.misc.comb` faster than an ad-hoc binomial computation?", "content": "<p><strong>Is it conclusive that now the <code>scipy.misc.comb</code> is indeed faster than the ad-hoc implementation?</strong></p>\n<p>According to an old answer, <a href=\"https://stackoverflow.com/questions/3025162/statistics-combinations-in-python/3025547#3025547\">Statistics: combinations in Python</a>, this homebrew function is faster than <code>scipy.misc.comb</code> when calculating combinations <code>nCr</code>:</p>\n<pre><code class=\"python\">def choose(n, k):\n    \"\"\"\n    A fast way to calculate binomial coefficients by Andrew Dalke (contrib).\n    \"\"\"\n    if 0 &lt;= k &lt;= n:\n        ntok = 1\n        ktok = 1\n        for t in xrange(1, min(k, n - k) + 1):\n            ntok *= n\n            ktok *= t\n            n -= 1\n        return ntok // ktok\n    else:\n        return 0\n</code></pre>\n<p>But after running some tests on my own machine, this doesn't seem like the case, using this script:</p>\n<pre><code class=\"python\">from scipy.misc import comb\nimport random, time\n\ndef choose(n, k):\n    \"\"\"\n    A fast way to calculate binomial coefficients by Andrew Dalke (contrib).\n    \"\"\"\n    if 0 &lt;= k &lt;= n:\n        ntok = 1\n        ktok = 1\n        for t in xrange(1, min(k, n - k) + 1):\n            ntok *= n\n            ktok *= t\n            n -= 1\n        return ntok // ktok\n    else:\n        return 0\n\ndef timing(f):\n    def wrap(*args):\n        time1 = time.time()\n        ret = f(*args)\n        time2 = time.time()\n        print '%s function took %0.3f ms' % (f.__name__, (time2-time1)*1000.0)\n        return ret\n    return wrap\n\n@timing\ndef test_func(combination_func, nk):\n    for n,k in nk:\n        combination_func(n, k)\n\nnk = []\nfor _ in range(1000):\n    n = int(random.random() * 10000)\n    k = random.randint(0,n)\n    nk.append((n,k))\n\ntest_func(comb, nk)\ntest_func(choose, nk)\n</code></pre>\n<p>I get the following output:</p>\n<pre><code class=\"python\">$ python test.py\n/usr/lib/python2.7/dist-packages/scipy/misc/common.py:295: RuntimeWarning: overflow encountered in exp\n  vals = exp(lgam(N+1) - lgam(N-k+1) - lgam(k+1))\n999\ntest_func function took 32.869 ms\n999\ntest_func function took 1859.125 ms\n\n$ python test.py\n/usr/lib/python2.7/dist-packages/scipy/misc/common.py:295: RuntimeWarning: overflow encountered in exp\n  vals = exp(lgam(N+1) - lgam(N-k+1) - lgam(k+1))\n999\ntest_func function took 32.265 ms\n999\ntest_func function took 1878.550 ms\n</code></pre>\n<p><strong>Did the time profiling test show that the new <code>scipy.misc.comb</code> is faster than the ad-hoc <code>choose()</code> function?</strong> Is there any error on my test script that makes the timing inaccurate?</p>\n<p><strong>Why is it that the <code>scipy.misc.comb</code> is faster now? It is because of some <code>cython</code> / <code>c</code> wrapping tricks?</strong></p>\n<hr/>\n<h1>EDITED</h1>\n<p>After @WarrenWeckesser comment:</p>\n<p>Using the default floating point approximation when using <code>scipy.misc.comb()</code>, the computation breaks because of floating point overflow. </p>\n<p>(see <a href=\"http://docs.scipy.org/doc/scipy-0.16.0/reference/generated/scipy.misc.comb.html\" rel=\"nofollow noreferrer\">http://docs.scipy.org/doc/scipy-0.16.0/reference/generated/scipy.misc.comb.html</a> for documentation)</p>\n<p>When tested with <code>exact=True</code> which computes with long integers instead of floating point using the function below, it's a lot slower when computing 1000 combinations:</p>\n<pre><code class=\"python\">@timing\ndef test_func(combination_func, nk):\n    for i, (n,k) in enumerate(nk):\n        combination_func(n, k, exact=True)\n</code></pre>\n<p>[out]:</p>\n<pre><code class=\"python\">$ python test.py\ntest_func function took 3312.211 ms\ntest_func function took 1764.523 ms\n\n$ python test.py\ntest_func function took 3320.198 ms\ntest_func function took 1782.280 ms\n</code></pre>\n", "abstract": "Is it conclusive that now the scipy.misc.comb is indeed faster than the ad-hoc implementation? According to an old answer, Statistics: combinations in Python, this homebrew function is faster than scipy.misc.comb when calculating combinations nCr: But after running some tests on my own machine, this doesn't seem like the case, using this script: I get the following output: Did the time profiling test show that the new scipy.misc.comb is faster than the ad-hoc choose() function? Is there any error on my test script that makes the timing inaccurate? Why is it that the scipy.misc.comb is faster now? It is because of some cython / c wrapping tricks? After @WarrenWeckesser comment: Using the default floating point approximation when using scipy.misc.comb(), the computation breaks because of floating point overflow.  (see http://docs.scipy.org/doc/scipy-0.16.0/reference/generated/scipy.misc.comb.html for documentation) When tested with exact=True which computes with long integers instead of floating point using the function below, it's a lot slower when computing 1000 combinations: [out]:"}, "answers": [{"id": 35327563, "score": 1, "vote": 0, "content": "<p>Referring to the source code of <a href=\"https://github.com/scipy/scipy/blob/v0.16.1/scipy/special/basic.py#L1163\" rel=\"nofollow\">scipy.misc.comb</a>, the update routine of the result is:</p>\n<pre><code class=\"python\">    val = 1\n    for j in xrange(min(k, N-k)):\n        val = (val*(N-j))//(j+1)\n    return val\n</code></pre>\n<p>whereas the update routine you suggested is:</p>\n<pre><code class=\"python\">    ntok = 1\n    ktok = 1\n    for t in xrange(1, min(k, n - k) + 1):\n        ntok *= n\n        ktok *= t\n        n -= 1\n    return ntok // ktok\n</code></pre>\n<p>My guess of the reason why SciPy's implementation is slower is due to the fact that the subroutine involves an integer division at each iteration while yours only calls division once at the return statement.</p>\n", "abstract": "Referring to the source code of scipy.misc.comb, the update routine of the result is: whereas the update routine you suggested is: My guess of the reason why SciPy's implementation is slower is due to the fact that the subroutine involves an integer division at each iteration while yours only calls division once at the return statement."}]}, {"link": "https://stackoverflow.com/questions/8661537/how-to-perform-bilinear-interpolation-in-python", "question": {"id": "8661537", "title": "How to perform bilinear interpolation in Python", "content": "<p>I would like to perform blinear interpolation using python.<br/>\nExample gps point for which I want to interpolate height is:<br/></p>\n<pre><code class=\"python\">B = 54.4786674627\nL = 17.0470721369\n</code></pre>\n<p>using four adjacent points with known coordinates and height values:</p>\n<pre><code class=\"python\">n = [(54.5, 17.041667, 31.993), (54.5, 17.083333, 31.911), (54.458333, 17.041667, 31.945), (54.458333, 17.083333, 31.866)]\n</code></pre>\n<br/>\n<pre><code class=\"python\">z01    z11\n\n     z\nz00    z10\n</code></pre>\n<br/>\nand here's my primitive attempt:\n<pre><code class=\"python\">import math\nz00 = n[0][2]\nz01 = n[1][2]\nz10 = n[2][2]\nz11 = n[3][2]\nc = 0.016667 #grid spacing\nx0 = 56 #latitude of origin of grid\ny0 = 13 #longitude of origin of grid\ni = math.floor((L-y0)/c)\nj = math.floor((B-x0)/c)\nt = (B - x0)/c - j\nz0 = (1-t)*z00 + t*z10\nz1 = (1-t)*z01 + t*z11\ns = (L-y0)/c - i\nz = (1-s)*z0 + s*z1\n</code></pre>\n<br/>\nwhere z0 and z1<br/>\n<pre><code class=\"python\">z01  z0  z11\n\n     z\nz00  z1   z10\n</code></pre>\n<br/>\nI get 31.964 but from other software I get 31.961.<br/>\nIs my script correct?<br/>\nCan You provide another approach?\n<p><br/><br/>\n<strong>2022 Edit:</strong><br/>\nI would like to thank everyone who, even more than a decade after publication of this question, gives new answers to it.</p>\n", "abstract": "I would like to perform blinear interpolation using python.\nExample gps point for which I want to interpolate height is: using four adjacent points with known coordinates and height values: \n2022 Edit:\nI would like to thank everyone who, even more than a decade after publication of this question, gives new answers to it."}, "answers": [{"id": 8662355, "score": 51, "vote": 0, "content": "<p>Here's a reusable function you can use.  It includes doctests and data validation:</p>\n<pre><code class=\"python\">def bilinear_interpolation(x, y, points):\n    '''Interpolate (x,y) from values associated with four points.\n\n    The four points are a list of four triplets:  (x, y, value).\n    The four points can be in any order.  They should form a rectangle.\n\n        &gt;&gt;&gt; bilinear_interpolation(12, 5.5,\n        ...                        [(10, 4, 100),\n        ...                         (20, 4, 200),\n        ...                         (10, 6, 150),\n        ...                         (20, 6, 300)])\n        165.0\n\n    '''\n    # See formula at:  http://en.wikipedia.org/wiki/Bilinear_interpolation\n\n    points = sorted(points)               # order points by x, then by y\n    (x1, y1, q11), (_x1, y2, q12), (x2, _y1, q21), (_x2, _y2, q22) = points\n\n    if x1 != _x1 or x2 != _x2 or y1 != _y1 or y2 != _y2:\n        raise ValueError('points do not form a rectangle')\n    if not x1 &lt;= x &lt;= x2 or not y1 &lt;= y &lt;= y2:\n        raise ValueError('(x, y) not within the rectangle')\n\n    return (q11 * (x2 - x) * (y2 - y) +\n            q21 * (x - x1) * (y2 - y) +\n            q12 * (x2 - x) * (y - y1) +\n            q22 * (x - x1) * (y - y1)\n           ) / ((x2 - x1) * (y2 - y1) + 0.0)\n</code></pre>\n<p>You can run test code by adding:</p>\n<pre><code class=\"python\">if __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n</code></pre>\n<p>Running the interpolation on your dataset produces:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; n = [(54.5, 17.041667, 31.993),\n         (54.5, 17.083333, 31.911),\n         (54.458333, 17.041667, 31.945),\n         (54.458333, 17.083333, 31.866),\n    ]\n&gt;&gt;&gt; bilinear_interpolation(54.4786674627, 17.0470721369, n)\n31.95798688313631\n</code></pre>\n", "abstract": "Here's a reusable function you can use.  It includes doctests and data validation: You can run test code by adding: Running the interpolation on your dataset produces:"}, {"id": 8662243, "score": 10, "vote": 0, "content": "<p>Not sure if this helps much, but I get a different value when doing linear interpolation using scipy:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from scipy.interpolate import griddata\n&gt;&gt;&gt; n = np.array([(54.5, 17.041667, 31.993),\n                  (54.5, 17.083333, 31.911),\n                  (54.458333, 17.041667, 31.945),\n                  (54.458333, 17.083333, 31.866)])\n&gt;&gt;&gt; griddata(n[:,0:2], n[:,2], [(54.4786674627, 17.0470721369)], method='linear')\narray([ 31.95817681])\n</code></pre>\n", "abstract": "Not sure if this helps much, but I get a different value when doing linear interpolation using scipy:"}, {"id": 20789820, "score": 7, "vote": 0, "content": "<p>Inspired from <a href=\"https://stackoverflow.com/a/7345691/592289\">here</a>, I came up with the following snippet. The API is optimized for reusing a lot of times the same table:</p>\n<pre><code class=\"python\">from bisect import bisect_left\n\nclass BilinearInterpolation(object):\n    \"\"\" Bilinear interpolation. \"\"\"\n    def __init__(self, x_index, y_index, values):\n        self.x_index = x_index\n        self.y_index = y_index\n        self.values = values\n\n    def __call__(self, x, y):\n        # local lookups\n        x_index, y_index, values = self.x_index, self.y_index, self.values\n\n        i = bisect_left(x_index, x) - 1\n        j = bisect_left(y_index, y) - 1\n\n        x1, x2 = x_index[i:i + 2]\n        y1, y2 = y_index[j:j + 2]\n        z11, z12 = values[j][i:i + 2]\n        z21, z22 = values[j + 1][i:i + 2]\n\n        return (z11 * (x2 - x) * (y2 - y) +\n                z21 * (x - x1) * (y2 - y) +\n                z12 * (x2 - x) * (y - y1) +\n                z22 * (x - x1) * (y - y1)) / ((x2 - x1) * (y2 - y1))\n</code></pre>\n<p>You can use it like this:</p>\n<pre><code class=\"python\">table = BilinearInterpolation(\n    x_index=(54.458333, 54.5), \n    y_index=(17.041667, 17.083333), \n    values=((31.945, 31.866), (31.993, 31.911))\n)\n\nprint(table(54.4786674627, 17.0470721369))\n# 31.957986883136307\n</code></pre>\n<p>This version has no error checking and you will run into trouble if you try to use it at the boundaries of the indexes (or beyond). For the full version of the code, including error checking and optional extrapolation, look <a href=\"https://github.com/pmav99/interpolation\" rel=\"noreferrer\">here</a>. </p>\n", "abstract": "Inspired from here, I came up with the following snippet. The API is optimized for reusing a lot of times the same table: You can use it like this: This version has no error checking and you will run into trouble if you try to use it at the boundaries of the indexes (or beyond). For the full version of the code, including error checking and optional extrapolation, look here. "}, {"id": 8926597, "score": 3, "vote": 0, "content": "<p>You can also refer to the <a href=\"https://github.com/matplotlib/basemap/blob/master/lib/mpl_toolkits/basemap/__init__.py\" rel=\"nofollow\">interp function in matplotlib</a>.</p>\n", "abstract": "You can also refer to the interp function in matplotlib."}, {"id": 61501947, "score": 3, "vote": 0, "content": "<p>A numpy implementation of based on this formula:</p>\n<p><a href=\"https://i.stack.imgur.com/8i0Op.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/8i0Op.png\"/></a></p>\n<pre><code class=\"python\">def bilinear_interpolation(x,y,x_,y_,val):\n\n    a = 1 /((x_[1] - x_[0]) * (y_[1] - y_[0]))\n    xx = np.array([[x_[1]-x],[x-x_[0]]],dtype='float32')\n    f = np.array(val).reshape(2,2)\n    yy = np.array([[y_[1]-y],[y-y_[0]]],dtype='float32')\n    b = np.matmul(f,yy)\n\n    return a * np.matmul(xx.T, b)\n</code></pre>\n<p>Input:\nHere,<code>x_</code> is list of <code>[x0,x1]</code> and <code>y_</code> is list of <code>[y0,y1]</code></p>\n<pre><code class=\"python\">bilinear_interpolation(x=54.4786674627,\n                       y=17.0470721369,\n                       x_=[54.458333,54.5],\n                       y_=[17.041667,17.083333],\n                       val=[31.993,31.911,31.945,31.866])\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">array([[31.95912739]])\n</code></pre>\n", "abstract": "A numpy implementation of based on this formula:  Input:\nHere,x_ is list of [x0,x1] and y_ is list of [y0,y1] Output:"}, {"id": 8661834, "score": 2, "vote": 0, "content": "<p>I think the point of doing a <code>floor</code> function is that usually you're looking to interpolate a value whose coordinate lies between two discrete coordinates. However you seem to have the actual real coordinate values of the closest points already, which makes it simple math.</p>\n<pre><code class=\"python\">z00 = n[0][2]\nz01 = n[1][2]\nz10 = n[2][2]\nz11 = n[3][2]\n\n# Let's assume L is your x-coordinate and B is the Y-coordinate\n\ndx = n[2][0] - n[0][0] # The x-gap between your sample points\ndy = n[1][1] - n[0][1] # The Y-gap between your sample points\n\ndx1 = (L - n[0][0]) / dx # How close is your point to the left?\ndx2 = 1 - dx1              # How close is your point to the right?\ndy1 = (B - n[0][1]) / dy # How close is your point to the bottom?\ndy2 = 1 - dy1              # How close is your point to the top?\n\nleft = (z00 * dy1) + (z01 * dy2)   # First interpolate along the y-axis\nright = (z10 * dy1) + (z11 * dy2)\n\nz = (left * dx1) + (right * dx2)   # Then along the x-axis\n</code></pre>\n<p>There might be a bit of erroneous logic in translating from your example, but the gist of it is you can weight each point based on how much closer it is to the interpolation goal point than its other neighbors.</p>\n", "abstract": "I think the point of doing a floor function is that usually you're looking to interpolate a value whose coordinate lies between two discrete coordinates. However you seem to have the actual real coordinate values of the closest points already, which makes it simple math. There might be a bit of erroneous logic in translating from your example, but the gist of it is you can weight each point based on how much closer it is to the interpolation goal point than its other neighbors."}, {"id": 65052384, "score": 2, "vote": 0, "content": "<p>This is the same solution as defined <a href=\"https://stackoverflow.com/a/20789820/6814154\">here</a> but applied to some function and compared with <code>interp2d</code> available in Scipy. We use numba library to make the interpolation function even faster than Scipy implementation.</p>\n<pre><code class=\"python\">import numpy as np\nfrom scipy.interpolate import interp2d\nimport matplotlib.pyplot as plt\n\nfrom numba import jit, prange\n@jit(nopython=True, fastmath=True, nogil=True, cache=True, parallel=True)\ndef bilinear_interpolation(x_in, y_in, f_in, x_out, y_out):\n    f_out = np.zeros((y_out.size, x_out.size))\n    \n    for i in prange(f_out.shape[1]):\n        idx = np.searchsorted(x_in, x_out[i])\n        \n        x1 = x_in[idx-1]\n        x2 = x_in[idx]\n        x = x_out[i]\n        \n        for j in prange(f_out.shape[0]):\n            idy = np.searchsorted(y_in, y_out[j])\n            y1 = y_in[idy-1]\n            y2 = y_in[idy]\n            y = y_out[j]\n\n            \n            f11 = f_in[idy-1, idx-1]\n            f21 = f_in[idy-1, idx]\n            f12 = f_in[idy, idx-1]\n            f22 = f_in[idy, idx]\n            \n\n            \n            f_out[j, i] = ((f11 * (x2 - x) * (y2 - y) +\n                            f21 * (x - x1) * (y2 - y) +\n                            f12 * (x2 - x) * (y - y1) +\n                            f22 * (x - x1) * (y - y1)) /\n                           ((x2 - x1) * (y2 - y1)))\n    \n    return f_out\n</code></pre>\n<p>We make it quite a large interpolation array to assess the performance of each method.</p>\n<p>The sample function is,</p>\n<p><a href=\"https://i.stack.imgur.com/ecdLF.png\" rel=\"nofollow noreferrer\"><img alt=\"z(x, y)=\\sin \\left(\\frac{\\pi x}{2}\\right) e^{y / 2}\" src=\"https://i.stack.imgur.com/ecdLF.png\"/></a></p>\n<pre><code class=\"python\">x = np.linspace(0, 4, 13)\ny = np.array([0, 2, 3, 3.5, 3.75, 3.875, 3.9375, 4])\nX, Y = np.meshgrid(x, y)\nZ = np.sin(np.pi*X/2) * np.exp(Y/2)\n\nx2 = np.linspace(0, 4, 1000)\ny2 = np.linspace(0, 4, 1000)\nZ2 = bilinear_interpolation(x, y, Z, x2, y2)\n\nfun = interp2d(x, y, Z, kind='linear')\nZ3 = fun(x2, y2)\n\n\nfig, ax = plt.subplots(nrows=1, ncols=3, figsize=(10, 6))\nax[0].pcolormesh(X, Y, Z, shading='auto')\nax[0].set_title(\"Original function\")\nX2, Y2 = np.meshgrid(x2, y2)\nax[1].pcolormesh(X2, Y2, Z2, shading='auto')\nax[1].set_title(\"bilinear interpolation\")\n\nax[2].pcolormesh(X2, Y2, Z3, shading='auto')\nax[2].set_title(\"Scipy bilinear function\")\n\nplt.show()\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/dLXCu.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/dLXCu.png\"/></a></p>\n<h1><strong>Performance Test</strong></h1>\n<h2>Python without numba library</h2>\n<p><code>bilinear_interpolation</code> function, in this case, is the same as <code>numba</code> version except that we change <code>prange</code> with python normal <code>range</code> in the for loop, and remove function decorator <code>jit</code></p>\n<pre><code class=\"python\">%timeit bilinear_interpolation(x, y, Z, x2, y2)\n</code></pre>\n<p>Gives 7.15 s \u00b1 107 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)</p>\n<h2>Python with numba numba</h2>\n<pre><code class=\"python\">%timeit bilinear_interpolation(x, y, Z, x2, y2) \n</code></pre>\n<p>Gives 2.65 ms \u00b1 70.5 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)</p>\n<h2>Scipy implementation</h2>\n<pre><code class=\"python\">%%timeit\nf = interp2d(x, y, Z, kind='linear')\nZ2 = f(x2, y2)\n</code></pre>\n<p>Gives 6.63 ms \u00b1 145 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)</p>\n<p>Performance tests are performed on 'Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz'</p>\n", "abstract": "This is the same solution as defined here but applied to some function and compared with interp2d available in Scipy. We use numba library to make the interpolation function even faster than Scipy implementation. We make it quite a large interpolation array to assess the performance of each method. The sample function is,   bilinear_interpolation function, in this case, is the same as numba version except that we change prange with python normal range in the for loop, and remove function decorator jit Gives 7.15 s \u00b1 107 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) Gives 2.65 ms \u00b1 70.5 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) Gives 6.63 ms \u00b1 145 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) Performance tests are performed on 'Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz'"}, {"id": 60278236, "score": 0, "vote": 0, "content": "<p>I suggest the following solution:</p>\n<pre><code class=\"python\">def bilinear_interpolation(x, y, z01, z11, z00, z10):\n\n    def linear_interpolation(x, z0, z1):\n        return z0 * x + z1 * (1 - x)\n\n    return linear_interpolation(y, linear_interpolation(x, z01, z11),\n                                   linear_interpolation(x, z00, z10))\n</code></pre>\n", "abstract": "I suggest the following solution:"}]}, {"link": "https://stackoverflow.com/questions/33964913/equivalent-of-polyfit-for-a-2d-polynomial-in-python", "question": {"id": "33964913", "title": "Equivalent of `polyfit` for a 2D polynomial in Python", "content": "<p>I'd like to find a least-squares solution for the <code>a</code> coefficients in </p>\n<pre><code class=\"python\">z = (a0 + a1*x + a2*y + a3*x**2 + a4*x**2*y + a5*x**2*y**2 + a6*y**2 +\n     a7*x*y**2 + a8*x*y)\n</code></pre>\n<p>given arrays <code>x</code>, <code>y</code>, and <code>z</code> of length 20. Basically I'm looking for the equivalent of <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html\" rel=\"noreferrer\"><code>numpy.polyfit</code></a> but for a 2D polynomial.</p>\n<p><a href=\"https://stackoverflow.com/questions/25440188/polyfit-for-two-variables\">This question</a> is similar, but the solution is provided via MATLAB.</p>\n", "abstract": "I'd like to find a least-squares solution for the a coefficients in  given arrays x, y, and z of length 20. Basically I'm looking for the equivalent of numpy.polyfit but for a 2D polynomial. This question is similar, but the solution is provided via MATLAB."}, "answers": [{"id": 33966967, "score": 31, "vote": 0, "content": "<p>Here is an example showing how you can use <code>numpy.linalg.lstsq</code> for this task:</p>\n<pre><code class=\"python\">import numpy as np\n\nx = np.linspace(0, 1, 20)\ny = np.linspace(0, 1, 20)\nX, Y = np.meshgrid(x, y, copy=False)\nZ = X**2 + Y**2 + np.random.rand(*X.shape)*0.01\n\nX = X.flatten()\nY = Y.flatten()\n\nA = np.array([X*0+1, X, Y, X**2, X**2*Y, X**2*Y**2, Y**2, X*Y**2, X*Y]).T\nB = Z.flatten()\n\ncoeff, r, rank, s = np.linalg.lstsq(A, B)\n</code></pre>\n<p>the adjusting coefficients <code>coeff</code> are:</p>\n<pre><code class=\"python\">array([ 0.00423365,  0.00224748,  0.00193344,  0.9982576 , -0.00594063,\n        0.00834339,  0.99803901, -0.00536561,  0.00286598])\n</code></pre>\n<p>Note that <code>coeff[3]</code> and <code>coeff[6]</code> respectively correspond to <code>X**2</code> and <code>Y**2</code>, and they are close to <code>1.</code> because the example data was created with <code>Z = X**2 + Y**2 + small_random_component</code>.</p>\n", "abstract": "Here is an example showing how you can use numpy.linalg.lstsq for this task: the adjusting coefficients coeff are: Note that coeff[3] and coeff[6] respectively correspond to X**2 and Y**2, and they are close to 1. because the example data was created with Z = X**2 + Y**2 + small_random_component."}, {"id": 57923405, "score": 12, "vote": 0, "content": "<p>Based on the answers from @Saullo and @Francisco I have made a function which I have found helpful:</p>\n<pre><code class=\"python\">def polyfit2d(x, y, z, kx=3, ky=3, order=None):\n    '''\n    Two dimensional polynomial fitting by least squares.\n    Fits the functional form f(x,y) = z.\n\n    Notes\n    -----\n    Resultant fit can be plotted with:\n    np.polynomial.polynomial.polygrid2d(x, y, soln.reshape((kx+1, ky+1)))\n\n    Parameters\n    ----------\n    x, y: array-like, 1d\n        x and y coordinates.\n    z: np.ndarray, 2d\n        Surface to fit.\n    kx, ky: int, default is 3\n        Polynomial order in x and y, respectively.\n    order: int or None, default is None\n        If None, all coefficients up to maxiumum kx, ky, ie. up to and including x^kx*y^ky, are considered.\n        If int, coefficients up to a maximum of kx+ky &lt;= order are considered.\n\n    Returns\n    -------\n    Return paramters from np.linalg.lstsq.\n\n    soln: np.ndarray\n        Array of polynomial coefficients.\n    residuals: np.ndarray\n    rank: int\n    s: np.ndarray\n\n    '''\n\n    # grid coords\n    x, y = np.meshgrid(x, y)\n    # coefficient array, up to x^kx, y^ky\n    coeffs = np.ones((kx+1, ky+1))\n\n    # solve array\n    a = np.zeros((coeffs.size, x.size))\n\n    # for each coefficient produce array x^i, y^j\n    for index, (j, i) in enumerate(np.ndindex(coeffs.shape)):\n        # do not include powers greater than order\n        if order is not None and i + j &gt; order:\n            arr = np.zeros_like(x)\n        else:\n            arr = coeffs[i, j] * x**i * y**j\n        a[index] = arr.ravel()\n\n    # do leastsq fitting and return leastsq result\n    return np.linalg.lstsq(a.T, np.ravel(z), rcond=None)\n</code></pre>\n<p>And the resultant fit can be visualised with:</p>\n<pre><code class=\"python\">fitted_surf = np.polynomial.polynomial.polyval2d(x, y, soln.reshape((kx+1,ky+1)))\nplt.matshow(fitted_surf)\n</code></pre>\n", "abstract": "Based on the answers from @Saullo and @Francisco I have made a function which I have found helpful: And the resultant fit can be visualised with:"}, {"id": 57501198, "score": 5, "vote": 0, "content": "<p>Excellent answer by Saullo Castro. Just to add the code to reconstruct the function using the least-squares solution for the a coefficients, </p>\n<pre><code class=\"python\">def poly2Dreco(X, Y, c):\n    return (c[0] + X*c[1] + Y*c[2] + X**2*c[3] + X**2*Y*c[4] + X**2*Y**2*c[5] + \n           Y**2*c[6] + X*Y**2*c[7] + X*Y*c[8])\n</code></pre>\n", "abstract": "Excellent answer by Saullo Castro. Just to add the code to reconstruct the function using the least-squares solution for the a coefficients, "}, {"id": 71214371, "score": 2, "vote": 0, "content": "<p>You can also use scikit-learn for this.</p>\n<pre><code class=\"python\">import numpy as np\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\n\nx = np.linspace(0, 1, 20)\ny = np.linspace(0, 1, 20)\nX, Y = np.meshgrid(x, y, copy=False)\nX = X.flatten()\nY = Y.flatten()\n\n# Generate noisy data\nnp.random.seed(0)\nZ = X**2 + Y**2 + np.random.randn(*X.shape)*0.01\n\n# Process 2D inputs\npoly = PolynomialFeatures(degree=2)\ninput_pts = np.stack([X, Y]).T\nassert(input_pts.shape == (400, 2))\nin_features = poly.fit_transform(input_pts)\n\n# Linear regression\nmodel = LinearRegression()\nmodel.fit(in_features, Z)\n\n# Display coefficients\nprint(dict(zip(poly.get_feature_names_out(), model.coef_.round(4))))\n\n# Check fit\nprint(f\"R-squared: {model.score(poly.transform(input_pts), Z):.3f}\")\n\n# Make predictions\nZ_predicted = model.predict(poly.transform(input_pts))\n</code></pre>\n<p>Out:</p>\n<pre><code class=\"python\">{'1': 0.0, 'x0': 0.003, 'x1': -0.0074, 'x0^2': 0.9974, 'x0 x1': 0.0047, 'x1^2': 1.0014}\nR-squared: 1.000\n</code></pre>\n", "abstract": "You can also use scikit-learn for this. Out:"}, {"id": 67077908, "score": 1, "vote": 0, "content": "<p>Note that if <code>kx != ky</code> the code will fail because the <code>j</code> and <code>i</code> indices are inverted in the loop.</p>\n<p>You get <code>(j,i)</code> from <code>enumerate(np.ndindex(coeffs.shape))</code>, but then you address elements in <code>coeffs</code> as <code>coeffs[i,j]</code>. Since the shape of the coefficient matrix is given by the maximum polynomial order that you are asking to use, the matrix will be rectangular if <code>kx != ky</code> and you will exceed one of its dimensions.</p>\n", "abstract": "Note that if kx != ky the code will fail because the j and i indices are inverted in the loop. You get (j,i) from enumerate(np.ndindex(coeffs.shape)), but then you address elements in coeffs as coeffs[i,j]. Since the shape of the coefficient matrix is given by the maximum polynomial order that you are asking to use, the matrix will be rectangular if kx != ky and you will exceed one of its dimensions."}]}, {"link": "https://stackoverflow.com/questions/47370795/pca-on-sklearn-how-to-interpret-pca-components", "question": {"id": "47370795", "title": "PCA on sklearn - how to interpret pca.components_", "content": "<p>I ran PCA on a data frame with 10 features using this simple code:</p>\n<pre><code class=\"python\">pca = PCA()\nfit = pca.fit(dfPca)\n</code></pre>\n<p>The result of <code>pca.explained_variance_ratio_</code> shows:</p>\n<pre><code class=\"python\">array([  5.01173322e-01,   2.98421951e-01,   1.00968655e-01,\n         4.28813755e-02,   2.46887288e-02,   1.40976609e-02,\n         1.24905823e-02,   3.43255532e-03,   1.84516942e-03,\n         4.50314168e-16])\n</code></pre>\n<p>I believe that means that the first PC explains 52% of the variance, the second component explains 29% and so on...</p>\n<p>What I dont undestand is the output of <code>pca.components_</code>. If I do the following: </p>\n<pre><code class=\"python\">df = pd.DataFrame(pca.components_, columns=list(dfPca.columns))\n</code></pre>\n<p>I get the data frame bellow where each line is a principal component. \nWhat I'd like to understand is how to interpret that table. I know that if I square all the features on each component and sum them I get 1, but what does the -0.56 on PC1 mean? Dos it tell something about \"Feature E\" since it is the highest magnitude on a component that explains 52% of the variance?</p>\n<p><a href=\"https://i.stack.imgur.com/XB2Jj.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/XB2Jj.png\"/></a></p>\n<p>Thanks</p>\n", "abstract": "I ran PCA on a data frame with 10 features using this simple code: The result of pca.explained_variance_ratio_ shows: I believe that means that the first PC explains 52% of the variance, the second component explains 29% and so on... What I dont undestand is the output of pca.components_. If I do the following:  I get the data frame bellow where each line is a principal component. \nWhat I'd like to understand is how to interpret that table. I know that if I square all the features on each component and sum them I get 1, but what does the -0.56 on PC1 mean? Dos it tell something about \"Feature E\" since it is the highest magnitude on a component that explains 52% of the variance?  Thanks"}, "answers": [{"id": 47371788, "score": 35, "vote": 0, "content": "<p><strong>Terminology:</strong> First of all, the results of a PCA are usually discussed in terms of component scores, sometimes called factor scores (the transformed variable values corresponding to a particular data point), and loadings (the weight by which each standardized original variable should be multiplied to get the component score).</p>\n<p><strong>PART1</strong>: I explain how to check the importance of the features and how to plot a biplot.</p>\n<p><strong>PART2</strong>: I explain how to check the importance of the features and how to save them into a pandas dataframe using the feature names.</p>\n<p>Summary in an article: Python compact guide: <a href=\"https://towardsdatascience.com/pca-clearly-explained-how-when-why-to-use-it-and-feature-importance-a-guide-in-python-7c274582c37e?source=friends_link&amp;sk=65bf5440e444c24aff192fedf9f8b64f\" rel=\"noreferrer\">https://towardsdatascience.com/pca-clearly-explained-how-when-why-to-use-it-and-feature-importance-a-guide-in-python-7c274582c37e?source=friends_link&amp;sk=65bf5440e444c24aff192fedf9f8b64f</a></p>\n<hr/>\n<h2>PART 1:</h2>\n<p>In your case, the value -0.56 for Feature E is the score of this feature on the PC1. <strong>This value tells us 'how much' the feature influences the PC (in our case the PC1).</strong></p>\n<p>So the higher the value in absolute value, the higher the influence on the principal component.</p>\n<p>After performing the PCA analysis, people usually plot the known 'biplot' to see the transformed features in the N dimensions (2 in our case) and the original variables (features).</p>\n<p>I wrote a function to plot this.</p>\n<hr/>\n<p><strong>Example</strong> using iris data:</p>\n<pre><code class=\"python\">import numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn import datasets\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.decomposition import PCA\n\niris = datasets.load_iris()\nX = iris.data\ny = iris.target\n\n#In general it is a good idea to scale the data\nscaler = StandardScaler()\nscaler.fit(X)\nX=scaler.transform(X)\n\npca = PCA()\npca.fit(X,y)\nx_new = pca.transform(X)   \n\ndef myplot(score,coeff,labels=None):\n    xs = score[:,0]\n    ys = score[:,1]\n    n = coeff.shape[0]\n\n    plt.scatter(xs ,ys, c = y) #without scaling\n    for i in range(n):\n        plt.arrow(0, 0, coeff[i,0], coeff[i,1],color = 'r',alpha = 0.5)\n        if labels is None:\n            plt.text(coeff[i,0]* 1.15, coeff[i,1] * 1.15, \"Var\"+str(i+1), color = 'g', ha = 'center', va = 'center')\n        else:\n            plt.text(coeff[i,0]* 1.15, coeff[i,1] * 1.15, labels[i], color = 'g', ha = 'center', va = 'center')\n\nplt.xlabel(\"PC{}\".format(1))\nplt.ylabel(\"PC{}\".format(2))\nplt.grid()\n\n#Call the function. \nmyplot(x_new[:,0:2], pca. components_) \nplt.show()\n</code></pre>\n<hr/>\n<p><strong>Results</strong></p>\n<p><a href=\"https://i.stack.imgur.com/JAc4e.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/JAc4e.png\"/></a></p>\n<h2>PART 2:</h2>\n<p><strong>The important features are the ones that influence more the components and thus, have a large absolute value on the component.</strong></p>\n<p>TO  <strong>get the most important features on the PCs</strong> with names and save them into a <strong>pandas dataframe</strong> use this:</p>\n<pre><code class=\"python\">from sklearn.decomposition import PCA\nimport pandas as pd\nimport numpy as np\nnp.random.seed(0)\n\n# 10 samples with 5 features\ntrain_features = np.random.rand(10,5)\n\nmodel = PCA(n_components=2).fit(train_features)\nX_pc = model.transform(train_features)\n\n# number of components\nn_pcs= model.components_.shape[0]\n\n# get the index of the most important feature on EACH component\n# LIST COMPREHENSION HERE\nmost_important = [np.abs(model.components_[i]).argmax() for i in range(n_pcs)]\n\ninitial_feature_names = ['a','b','c','d','e']\n# get the names\nmost_important_names = [initial_feature_names[most_important[i]] for i in range(n_pcs)]\n\n# LIST COMPREHENSION HERE AGAIN\ndic = {'PC{}'.format(i): most_important_names[i] for i in range(n_pcs)}\n\n# build the dataframe\ndf = pd.DataFrame(dic.items())\n</code></pre>\n<p><strong>This prints:</strong></p>\n<pre><code class=\"python\">     0  1\n 0  PC0  e\n 1  PC1  d\n</code></pre>\n<p><strong>So on the PC1 the feature named <code>e</code> is the most important and on PC2 the <code>d</code>.</strong></p>\n<p><strong>Summary in an article:</strong> Python compact guide: <a href=\"https://towardsdatascience.com/pca-clearly-explained-how-when-why-to-use-it-and-feature-importance-a-guide-in-python-7c274582c37e?source=friends_link&amp;sk=65bf5440e444c24aff192fedf9f8b64f\" rel=\"noreferrer\">https://towardsdatascience.com/pca-clearly-explained-how-when-why-to-use-it-and-feature-importance-a-guide-in-python-7c274582c37e?source=friends_link&amp;sk=65bf5440e444c24aff192fedf9f8b64f</a></p>\n", "abstract": "Terminology: First of all, the results of a PCA are usually discussed in terms of component scores, sometimes called factor scores (the transformed variable values corresponding to a particular data point), and loadings (the weight by which each standardized original variable should be multiplied to get the component score). PART1: I explain how to check the importance of the features and how to plot a biplot. PART2: I explain how to check the importance of the features and how to save them into a pandas dataframe using the feature names. Summary in an article: Python compact guide: https://towardsdatascience.com/pca-clearly-explained-how-when-why-to-use-it-and-feature-importance-a-guide-in-python-7c274582c37e?source=friends_link&sk=65bf5440e444c24aff192fedf9f8b64f In your case, the value -0.56 for Feature E is the score of this feature on the PC1. This value tells us 'how much' the feature influences the PC (in our case the PC1). So the higher the value in absolute value, the higher the influence on the principal component. After performing the PCA analysis, people usually plot the known 'biplot' to see the transformed features in the N dimensions (2 in our case) and the original variables (features). I wrote a function to plot this. Example using iris data: Results  The important features are the ones that influence more the components and thus, have a large absolute value on the component. TO  get the most important features on the PCs with names and save them into a pandas dataframe use this: This prints: So on the PC1 the feature named e is the most important and on PC2 the d. Summary in an article: Python compact guide: https://towardsdatascience.com/pca-clearly-explained-how-when-why-to-use-it-and-feature-importance-a-guide-in-python-7c274582c37e?source=friends_link&sk=65bf5440e444c24aff192fedf9f8b64f"}, {"id": 47371133, "score": 9, "vote": 0, "content": "<p><strong>Basic Idea</strong></p>\n<p>The Principle Component breakdown by features that you have there basically tells you the \"direction\" each principle component points to in terms of the direction of the features. </p>\n<p>In each principle component, features that have a greater absolute weight \"pull\" the principle component more to that feature's direction. </p>\n<p>For example, we can say that in PC1, since Feature A, Feature B, Feature I, and Feature J have relatively low weights (in absolute value), PC1 is not as much pointing in the direction of these features in the feature space. PC1 will be pointing most to the direction of Feature E relative to other directions. </p>\n<p><strong>Visualization in Lower Dimensions</strong></p>\n<p>For a visualization of this, look at the following figures taken from <a href=\"http://www.visiondummy.com/2014/05/feature-extraction-using-pca/\" rel=\"noreferrer\">here</a> and <a href=\"https://docs.opencv.org/3.1.0/d1/dee/tutorial_introduction_to_pca.html\" rel=\"noreferrer\">here</a>:</p>\n<p>The following shows an example of running PCA on correlated data. \n<a href=\"https://i.stack.imgur.com/GCfEC.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/GCfEC.png\"/></a></p>\n<p>We can visually see that both eigenvectors derived from PCA are being \"pulled\" in both the Feature 1 and Feature 2 directions. Thus, if we were to make a principle component breakdown table like you made, we would expect to see some weightage from both Feature 1 and Feature 2 explaining PC1 and PC2. </p>\n<p>Next, we have an example with uncorrelated data.</p>\n<p><a href=\"https://i.stack.imgur.com/vc1PY.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/vc1PY.png\"/></a></p>\n<p>Let us call the green principle component as PC1 and the pink one as PC2. It's clear that PC1 is not pulled in the direction of feature x', and as isn't PC2 in the direction of feature y'. \nThus, in our table, we must have a weightage of 0 for feature x' in PC1 and a weightage of 0 for feature y' in PC2. </p>\n<p>I hope this gives an idea of what you're seeing in your table. </p>\n", "abstract": "Basic Idea The Principle Component breakdown by features that you have there basically tells you the \"direction\" each principle component points to in terms of the direction of the features.  In each principle component, features that have a greater absolute weight \"pull\" the principle component more to that feature's direction.  For example, we can say that in PC1, since Feature A, Feature B, Feature I, and Feature J have relatively low weights (in absolute value), PC1 is not as much pointing in the direction of these features in the feature space. PC1 will be pointing most to the direction of Feature E relative to other directions.  Visualization in Lower Dimensions For a visualization of this, look at the following figures taken from here and here: The following shows an example of running PCA on correlated data. \n We can visually see that both eigenvectors derived from PCA are being \"pulled\" in both the Feature 1 and Feature 2 directions. Thus, if we were to make a principle component breakdown table like you made, we would expect to see some weightage from both Feature 1 and Feature 2 explaining PC1 and PC2.  Next, we have an example with uncorrelated data.  Let us call the green principle component as PC1 and the pink one as PC2. It's clear that PC1 is not pulled in the direction of feature x', and as isn't PC2 in the direction of feature y'. \nThus, in our table, we must have a weightage of 0 for feature x' in PC1 and a weightage of 0 for feature y' in PC2.  I hope this gives an idea of what you're seeing in your table. "}]}, {"link": "https://stackoverflow.com/questions/13643363/linear-regression-of-arrays-containing-nans-in-python-numpy", "question": {"id": "13643363", "title": "Linear regression of arrays containing NANs in Python/Numpy", "content": "<p>I have two arrays, say varx and vary. Both contain NAN values at various positions. However, I would like to do a linear regression on both to show how much the two arrays correlate.\nThis was very helpful so far: <a href=\"http://glowingpython.blogspot.de/2012/03/linear-regression-with-numpy.html\">http://glowingpython.blogspot.de/2012/03/linear-regression-with-numpy.html</a></p>\n<p>However, using this:</p>\n<pre><code class=\"python\">slope, intercept, r_value, p_value, std_err = stats.linregress(varx, vary)\n</code></pre>\n<p>results in nans for every output variable. What is the most convenient way to take only valid values from both arrays as input to the linear regression? I heard about masking arrays, but am not sure how it works exactly.</p>\n", "abstract": "I have two arrays, say varx and vary. Both contain NAN values at various positions. However, I would like to do a linear regression on both to show how much the two arrays correlate.\nThis was very helpful so far: http://glowingpython.blogspot.de/2012/03/linear-regression-with-numpy.html However, using this: results in nans for every output variable. What is the most convenient way to take only valid values from both arrays as input to the linear regression? I heard about masking arrays, but am not sure how it works exactly."}, "answers": [{"id": 13643460, "score": 44, "vote": 0, "content": "<p>You can remove NaNs using a mask:</p>\n<pre><code class=\"python\">mask = ~np.isnan(varx) &amp; ~np.isnan(vary)\nslope, intercept, r_value, p_value, std_err = stats.linregress(varx[mask], vary[mask])\n</code></pre>\n", "abstract": "You can remove NaNs using a mask:"}]}]