[{"link": "https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do", "question": {"id": "231767", "title": "What does the &quot;yield&quot; keyword do?", "content": "<p>What is the use of the <code>yield</code> keyword in Python? What does it do?</p>\n<p>For example, I'm trying to understand this code<sup><strong>1</strong></sup>:</p>\n<pre><code class=\"python\">def _get_child_candidates(self, distance, min_dist, max_dist):\n    if self._leftchild and distance - max_dist &lt; self._median:\n        yield self._leftchild\n    if self._rightchild and distance + max_dist &gt;= self._median:\n        yield self._rightchild  \n</code></pre>\n<p>And this is the caller:</p>\n<pre><code class=\"python\">result, candidates = [], [self]\nwhile candidates:\n    node = candidates.pop()\n    distance = node._get_dist(obj)\n    if distance &lt;= max_dist and distance &gt;= min_dist:\n        result.extend(node._values)\n    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\nreturn result\n</code></pre>\n<p>What happens when the method <code>_get_child_candidates</code> is called?\nIs a list returned? A single element? Is it called again? When will subsequent calls stop?</p>\n<hr/>\n<sub>\n1. This piece of code was written by Jochen Schulz (jrschulz), who made a great Python library for metric spaces. This is the link to the complete source: <a href=\"https://well-adjusted.de/~jrspieker/mspace/\" rel=\"noreferrer\">Module mspace</a>.</sub>\n", "abstract": "What is the use of the yield keyword in Python? What does it do? For example, I'm trying to understand this code1: And this is the caller: What happens when the method _get_child_candidates is called?\nIs a list returned? A single element? Is it called again? When will subsequent calls stop?"}, "answers": [{"id": 231855, "score": 17276, "vote": 0, "content": "<p>To understand what <code>yield</code> does, you must understand what <em>generators</em> are. And before you can understand generators, you must understand <em>iterables</em>.</p>\n<h2>Iterables</h2>\n<p>When you create a list, you can read its items one by one. Reading its items one by one is called iteration:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; mylist = [1, 2, 3]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n1\n2\n3\n</code></pre>\n<p><code>mylist</code> is an <em>iterable</em>. When you use a list comprehension, you create a list, and so an iterable:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; mylist = [x*x for x in range(3)]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n0\n1\n4\n</code></pre>\n<p>Everything you can use \"<code>for... in...</code>\" on is an iterable; <code>lists</code>, <code>strings</code>, files...</p>\n<p>These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</p>\n<h2>Generators</h2>\n<p>Generators are iterators, a kind of iterable <strong>you can only iterate over once</strong>. Generators do not store all the values in memory, <strong>they generate the values on the fly</strong>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; mygenerator = (x*x for x in range(3))\n&gt;&gt;&gt; for i in mygenerator:\n...    print(i)\n0\n1\n4\n</code></pre>\n<p>It is just the same except you used <code>()</code> instead of <code>[]</code>. BUT, you <strong>cannot</strong> perform <code>for i in mygenerator</code> a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end calculating 4, one by one.</p>\n<h2>Yield</h2>\n<p><code>yield</code> is a keyword that is used like <code>return</code>, except the function will return a generator.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def create_generator():\n...    mylist = range(3)\n...    for i in mylist:\n...        yield i*i\n...\n&gt;&gt;&gt; mygenerator = create_generator() # create a generator\n&gt;&gt;&gt; print(mygenerator) # mygenerator is an object!\n&lt;generator object create_generator at 0xb7555c34&gt;\n&gt;&gt;&gt; for i in mygenerator:\n...     print(i)\n0\n1\n4\n</code></pre>\n<p>Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.</p>\n<p>To master <code>yield</code>, you must understand that <strong>when you call the function, the code you have written in the function body does not run.</strong> The function only returns the generator object, this is a bit tricky.</p>\n<p>Then, your code will continue from where it left off each time <code>for</code> uses the generator.</p>\n<p>Now the hard part:</p>\n<p>The first time the <code>for</code> calls the generator object created from your function, it will run the code in your function from the beginning until it hits <code>yield</code>, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting <code>yield</code>. That can be because the loop has come to an end, or because you no longer satisfy an <code>\"if/else\"</code>.</p>\n<hr/>\n<h2>Your code explained</h2>\n<p><em>Generator:</em></p>\n<pre><code class=\"python\"># Here you create the method of the node object that will return the generator\ndef _get_child_candidates(self, distance, min_dist, max_dist):\n\n    # Here is the code that will be called each time you use the generator object:\n\n    # If there is still a child of the node object on its left\n    # AND if the distance is ok, return the next child\n    if self._leftchild and distance - max_dist &lt; self._median:\n        yield self._leftchild\n\n    # If there is still a child of the node object on its right\n    # AND if the distance is ok, return the next child\n    if self._rightchild and distance + max_dist &gt;= self._median:\n        yield self._rightchild\n\n    # If the function arrives here, the generator will be considered empty\n    # there are no more than two values: the left and the right children\n</code></pre>\n<p><em>Caller:</em></p>\n<pre><code class=\"python\"># Create an empty list and a list with the current object reference\nresult, candidates = list(), [self]\n\n# Loop on candidates (they contain only one element at the beginning)\nwhile candidates:\n\n    # Get the last candidate and remove it from the list\n    node = candidates.pop()\n\n    # Get the distance between obj and the candidate\n    distance = node._get_dist(obj)\n\n    # If the distance is ok, then you can fill in the result\n    if distance &lt;= max_dist and distance &gt;= min_dist:\n        result.extend(node._values)\n\n    # Add the children of the candidate to the candidate's list\n    # so the loop will keep running until it has looked\n    # at all the children of the children of the children, etc. of the candidate\n    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\n\nreturn result\n</code></pre>\n<p>This code contains several smart parts:</p>\n<ul>\n<li><p>The loop iterates on a list, but the list expands while the loop is being iterated. It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code> exhausts all the values of the generator, but <code>while</code> keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.</p>\n</li>\n<li><p>The <code>extend()</code> method is a list object method that expects an iterable and adds its values to the list.</p>\n</li>\n</ul>\n<p>Usually, we pass a list to it:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; b = [3, 4]\n&gt;&gt;&gt; a.extend(b)\n&gt;&gt;&gt; print(a)\n[1, 2, 3, 4]\n</code></pre>\n<p>But in your code, it gets a generator, which is good because:</p>\n<ol>\n<li>You don't need to read the values twice.</li>\n<li>You may have a lot of children and you don't want them all stored in memory.</li>\n</ol>\n<p>And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...</p>\n<p>You can stop here, or read a little bit to see an advanced use of a generator:</p>\n<h2>Controlling a generator exhaustion</h2>\n<pre><code class=\"python\">&gt;&gt;&gt; class Bank(): # Let's create a bank, building ATMs\n...    crisis = False\n...    def create_atm(self):\n...        while not self.crisis:\n...            yield \"$100\"\n&gt;&gt;&gt; hsbc = Bank() # When everything's ok the ATM gives you as much as you want\n&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])\n['$100', '$100', '$100', '$100', '$100']\n&gt;&gt;&gt; hsbc.crisis = True # Crisis is coming, no more money!\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # It's even true for new ATMs\n&gt;&gt;&gt; print(wall_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; hsbc.crisis = False # The trouble is, even post-crisis the ATM remains empty\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # Build a new one to get back in business\n&gt;&gt;&gt; for cash in brand_new_atm:\n...    print cash\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n...\n</code></pre>\n<p><strong>Note:</strong> For Python 3, use<code>print(corner_street_atm.__next__())</code> or <code>print(next(corner_street_atm))</code></p>\n<p>It can be useful for various things like controlling access to a resource.</p>\n<h2>Itertools, your best friend</h2>\n<p>The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator?\nChain two generators? Group values in a nested list with a one-liner? <code>Map / Zip</code> without creating another list?</p>\n<p>Then just <code>import itertools</code>.</p>\n<p>An example? Let's see the possible orders of arrival for a four-horse race:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; horses = [1, 2, 3, 4]\n&gt;&gt;&gt; races = itertools.permutations(horses)\n&gt;&gt;&gt; print(races)\n&lt;itertools.permutations object at 0xb754f1dc&gt;\n&gt;&gt;&gt; print(list(itertools.permutations(horses)))\n[(1, 2, 3, 4),\n (1, 2, 4, 3),\n (1, 3, 2, 4),\n (1, 3, 4, 2),\n (1, 4, 2, 3),\n (1, 4, 3, 2),\n (2, 1, 3, 4),\n (2, 1, 4, 3),\n (2, 3, 1, 4),\n (2, 3, 4, 1),\n (2, 4, 1, 3),\n (2, 4, 3, 1),\n (3, 1, 2, 4),\n (3, 1, 4, 2),\n (3, 2, 1, 4),\n (3, 2, 4, 1),\n (3, 4, 1, 2),\n (3, 4, 2, 1),\n (4, 1, 2, 3),\n (4, 1, 3, 2),\n (4, 2, 1, 3),\n (4, 2, 3, 1),\n (4, 3, 1, 2),\n (4, 3, 2, 1)]\n</code></pre>\n<h2>Understanding the inner mechanisms of iteration</h2>\n<p>Iteration is a process implying iterables (implementing the <code>__iter__()</code> method) and iterators (implementing the <code>__next__()</code> method).\nIterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.</p>\n<p>There is more about it in this article about <a href=\"https://web.archive.org/web/20201109034340/http://effbot.org/zone/python-for-statement.htm\" rel=\"noreferrer\">how <code>for</code> loops work</a>.</p>\n", "abstract": "To understand what yield does, you must understand what generators are. And before you can understand generators, you must understand iterables. When you create a list, you can read its items one by one. Reading its items one by one is called iteration: mylist is an iterable. When you use a list comprehension, you create a list, and so an iterable: Everything you can use \"for... in...\" on is an iterable; lists, strings, files... These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values. Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly: It is just the same except you used () instead of []. BUT, you cannot perform for i in mygenerator a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end calculating 4, one by one. yield is a keyword that is used like return, except the function will return a generator. Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once. To master yield, you must understand that when you call the function, the code you have written in the function body does not run. The function only returns the generator object, this is a bit tricky. Then, your code will continue from where it left off each time for uses the generator. Now the hard part: The first time the for calls the generator object created from your function, it will run the code in your function from the beginning until it hits yield, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting yield. That can be because the loop has come to an end, or because you no longer satisfy an \"if/else\". Generator: Caller: This code contains several smart parts: The loop iterates on a list, but the list expands while the loop is being iterated. It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) exhausts all the values of the generator, but while keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node. The extend() method is a list object method that expects an iterable and adds its values to the list. Usually, we pass a list to it: But in your code, it gets a generator, which is good because: And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question... You can stop here, or read a little bit to see an advanced use of a generator: Note: For Python 3, useprint(corner_street_atm.__next__()) or print(next(corner_street_atm)) It can be useful for various things like controlling access to a resource. The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator?\nChain two generators? Group values in a nested list with a one-liner? Map / Zip without creating another list? Then just import itertools. An example? Let's see the possible orders of arrival for a four-horse race: Iteration is a process implying iterables (implementing the __iter__() method) and iterators (implementing the __next__() method).\nIterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables. There is more about it in this article about how for loops work."}, {"id": 237028, "score": 2403, "vote": 0, "content": "<h2>Shortcut to understanding <code>yield</code></h2>\n<p>When you see a function with <code>yield</code> statements, apply this easy trick to understand what will happen:</p>\n<ol>\n<li>Insert a line <code>result = []</code> at the start of the function.</li>\n<li>Replace each <code>yield expr</code> with <code>result.append(expr)</code>.</li>\n<li>Insert a line <code>return result</code> at the bottom of the function.</li>\n<li>Yay - no more <code>yield</code> statements! Read and figure out the code.</li>\n<li>Compare function to the original definition.</li>\n</ol>\n<p>This trick may give you an idea of the logic behind the function, but what actually happens with <code>yield</code> is significantly different than what happens in the list-based approach. In many cases, the yield approach will be a lot more memory efficient and faster too. In other cases, this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more...</p>\n<h2>Don't confuse your Iterables, Iterators, and Generators</h2>\n<p>First, the <strong>iterator protocol</strong> - when you write</p>\n<pre><code class=\"python\">for x in mylist:\n    ...loop body...\n</code></pre>\n<p>Python performs the following two steps:</p>\n<ol>\n<li><p>Gets an iterator for <code>mylist</code>:</p>\n<p>Call <code>iter(mylist)</code> -&gt; this returns an object with a <code>next()</code> method (or <code>__next__()</code> in Python 3).</p>\n<p>[This is the step most people forget to tell you about]</p>\n</li>\n<li><p>Uses the iterator to loop over items:</p>\n<p>Keep calling the <code>next()</code> method on the iterator returned from step 1. The return value from <code>next()</code> is assigned to <code>x</code> and the loop body is executed. If an exception <code>StopIteration</code> is raised from within <code>next()</code>, it means there are no more values in the iterator and the loop is exited.</p>\n</li>\n</ol>\n<p>The truth is Python performs the above two steps anytime it wants to <em>loop over</em> the contents of an object - so it could be a for loop, but it could also be code like <code>otherlist.extend(mylist)</code> (where <code>otherlist</code> is a Python list).</p>\n<p>Here <code>mylist</code> is an <em>iterable</em> because it implements the iterator protocol. In a user-defined class, you can implement the <code>__iter__()</code> method to make instances of your class iterable. This method should return an <em>iterator</em>. An iterator is an object with a <code>next()</code> method. It is possible to implement both <code>__iter__()</code> and <code>next()</code> on the same class, and have <code>__iter__()</code> return <code>self</code>. This will work for simple cases, but not when you want two iterators looping over the same object at the same time.</p>\n<p>So that's the iterator protocol, many objects implement this protocol:</p>\n<ol>\n<li>Built-in lists, dictionaries, tuples, sets, and files.</li>\n<li>User-defined classes that implement <code>__iter__()</code>.</li>\n<li>Generators.</li>\n</ol>\n<p>Note that a <code>for</code> loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls <code>next()</code>. Built-in lists return their items one by one, dictionaries return the <em>keys</em> one by one, files return the <em>lines</em> one by one, etc. And generators return... well that's where <code>yield</code> comes in:</p>\n<pre><code class=\"python\">def f123():\n    yield 1\n    yield 2\n    yield 3\n\nfor item in f123():\n    print item\n</code></pre>\n<p>Instead of <code>yield</code> statements, if you had three <code>return</code> statements in <code>f123()</code> only the first would get executed, and the function would exit. But <code>f123()</code> is no ordinary function. When <code>f123()</code> is called, it <em>does not</em> return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the <code>for</code> loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the <code>yield</code> it previously returned from, executes the next line of code, in this case, a <code>yield</code> statement, and returns that as the next item. This happens until the function exits, at which point the generator raises <code>StopIteration</code>, and the loop exits.</p>\n<p>So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing <code>__iter__()</code> and <code>next()</code> methods to keep the <code>for</code> loop happy. At the other end, however, it runs the function just enough to get the next value out of it, and puts it back in suspended mode.</p>\n<h2>Why Use Generators?</h2>\n<p>Usually, you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class SomethingIter that keeps the state in instance members and performs the next logical step in its <code>next()</code> (or <code>__next__()</code> in Python 3) method. Depending on the logic, the code inside the <code>next()</code> method may end up looking very complex and prone to bugs. Here generators provide a clean and easy solution.</p>\n", "abstract": "When you see a function with yield statements, apply this easy trick to understand what will happen: This trick may give you an idea of the logic behind the function, but what actually happens with yield is significantly different than what happens in the list-based approach. In many cases, the yield approach will be a lot more memory efficient and faster too. In other cases, this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more... First, the iterator protocol - when you write Python performs the following two steps: Gets an iterator for mylist: Call iter(mylist) -> this returns an object with a next() method (or __next__() in Python 3). [This is the step most people forget to tell you about] Uses the iterator to loop over items: Keep calling the next() method on the iterator returned from step 1. The return value from next() is assigned to x and the loop body is executed. If an exception StopIteration is raised from within next(), it means there are no more values in the iterator and the loop is exited. The truth is Python performs the above two steps anytime it wants to loop over the contents of an object - so it could be a for loop, but it could also be code like otherlist.extend(mylist) (where otherlist is a Python list). Here mylist is an iterable because it implements the iterator protocol. In a user-defined class, you can implement the __iter__() method to make instances of your class iterable. This method should return an iterator. An iterator is an object with a next() method. It is possible to implement both __iter__() and next() on the same class, and have __iter__() return self. This will work for simple cases, but not when you want two iterators looping over the same object at the same time. So that's the iterator protocol, many objects implement this protocol: Note that a for loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls next(). Built-in lists return their items one by one, dictionaries return the keys one by one, files return the lines one by one, etc. And generators return... well that's where yield comes in: Instead of yield statements, if you had three return statements in f123() only the first would get executed, and the function would exit. But f123() is no ordinary function. When f123() is called, it does not return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the for loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the yield it previously returned from, executes the next line of code, in this case, a yield statement, and returns that as the next item. This happens until the function exits, at which point the generator raises StopIteration, and the loop exits. So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing __iter__() and next() methods to keep the for loop happy. At the other end, however, it runs the function just enough to get the next value out of it, and puts it back in suspended mode. Usually, you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class SomethingIter that keeps the state in instance members and performs the next logical step in its next() (or __next__() in Python 3) method. Depending on the logic, the code inside the next() method may end up looking very complex and prone to bugs. Here generators provide a clean and easy solution."}, {"id": 231801, "score": 716, "vote": 0, "content": "<p>Think of it this way:</p>\n<p>An iterator is just a fancy sounding term for an object that has a <code>next()</code> method.  So a yield-ed function ends up being something like this:</p>\n<p>Original version:</p>\n<pre><code class=\"python\">def some_function():\n    for i in xrange(4):\n        yield i\n\nfor i in some_function():\n    print i\n</code></pre>\n<p>This is basically what the Python interpreter does with the above code:</p>\n<pre><code class=\"python\">class it:\n    def __init__(self):\n        # Start at -1 so that we get 0 when we add 1 below.\n        self.count = -1\n\n    # The __iter__ method will be called once by the 'for' loop.\n    # The rest of the magic happens on the object returned by this method.\n    # In this case it is the object itself.\n    def __iter__(self):\n        return self\n\n    # The next method will be called repeatedly by the 'for' loop\n    # until it raises StopIteration.\n    def next(self):\n        self.count += 1\n        if self.count &lt; 4:\n            return self.count\n        else:\n            # A StopIteration exception is raised\n            # to signal that the iterator is done.\n            # This is caught implicitly by the 'for' loop.\n            raise StopIteration\n\ndef some_func():\n    return it()\n\nfor i in some_func():\n    print i\n</code></pre>\n<p>For more insight as to what's happening behind the scenes, the <code>for</code> loop can be rewritten to this:</p>\n<pre><code class=\"python\">iterator = some_func()\ntry:\n    while 1:\n        print iterator.next()\nexcept StopIteration:\n    pass\n</code></pre>\n<p>Does that make more sense or just confuse you more?  :)</p>\n<p>I should note that this <em>is</em> an oversimplification for illustrative purposes. :)</p>\n", "abstract": "Think of it this way: An iterator is just a fancy sounding term for an object that has a next() method.  So a yield-ed function ends up being something like this: Original version: This is basically what the Python interpreter does with the above code: For more insight as to what's happening behind the scenes, the for loop can be rewritten to this: Does that make more sense or just confuse you more?  :) I should note that this is an oversimplification for illustrative purposes. :)"}, {"id": 6400990, "score": 606, "vote": 0, "content": "\n<p>The <code>yield</code> keyword is reduced to two simple facts:</p>\n<ol>\n<li>If the compiler detects the <code>yield</code> keyword <em>anywhere</em> inside a function, that function no longer returns via the <code>return</code> statement. <em><strong>Instead</strong></em>, it <strong>immediately</strong> returns a <strong>lazy \"pending list\" object</strong> called a generator</li>\n<li>A generator is iterable. What is an <em>iterable</em>? It's anything like a <code>list</code> or <code>set</code> or <code>range</code> or dict-view, with a <em>built-in protocol for visiting each element in a certain order</em>.</li>\n</ol>\n<p>In a nutshell: Most commonly, <strong>a generator is a lazy, incrementally-pending list</strong>, and <strong><code>yield</code> statements allow you to use function notation to program the list values</strong> the generator should incrementally spit out. <strong>Furthermore, advanced usage lets you use generators as coroutines (see below).</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">generator = myYieldingFunction(...)  # basically a list (but lazy)\nx = list(generator)  # evaluate every element into a list\n\n   generator\n       v\n[x[0], ..., ???]\n\n         generator\n             v\n[x[0], x[1], ..., ???]\n\n               generator\n                   v\n[x[0], x[1], x[2], ..., ???]\n\n                       StopIteration exception\n[x[0], x[1], x[2]]     done\n</code></pre>\n<p>Basically, whenever the <code>yield</code> statement is encountered, the function pauses and saves its state, then emits \"the next return value in the 'list'\" according to the python iterator protocol (to some syntactic construct like a for-loop that repeatedly calls <code>next()</code> and catches a <code>StopIteration</code> exception, etc.). You might have encountered generators with <a href=\"https://www.python.org/dev/peps/pep-0289/\" rel=\"nofollow noreferrer\">generator expressions</a>; generator functions are more powerful because you can pass arguments back into the paused generator function, using them to implement coroutines. More on that later.</p>\n<hr/>\n<h2>Basic Example ('list')</h2>\n<p>Let's define a function <code>makeRange</code> that's just like Python's <code>range</code>. Calling <code>makeRange(n)</code> RETURNS A GENERATOR:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def makeRange(n):\n    # return 0,1,2,...,n-1\n    i = 0\n    while i &lt; n:\n        yield i\n        i += 1\n\n&gt;&gt;&gt; makeRange(5)\n&lt;generator object makeRange at 0x19e4aa0&gt;\n</code></pre>\n<p>To force the generator to immediately return its pending values, you can pass it into <code>list()</code> (just like you could any iterable):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; list(makeRange(5))\n[0, 1, 2, 3, 4]\n</code></pre>\n<hr/>\n<h2>Comparing example to \"just returning a list\"</h2>\n<p>The above example can be thought of as merely creating a list which you append to and return:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># return a list                  #  # return a generator\ndef makeRange(n):                #  def makeRange(n):\n    \"\"\"return [0,1,2,...,n-1]\"\"\" #      \"\"\"return 0,1,2,...,n-1\"\"\"\n    TO_RETURN = []               # \n    i = 0                        #      i = 0\n    while i &lt; n:                 #      while i &lt; n:\n        TO_RETURN += [i]         #          yield i\n        i += 1                   #          i += 1\n    return TO_RETURN             # \n\n&gt;&gt;&gt; makeRange(5)\n[0, 1, 2, 3, 4]\n</code></pre>\n<p>There is one major difference, though; see the last section.</p>\n<hr/>\n<h2>How you might use generators</h2>\n<p>An iterable is the last part of a list comprehension, and all generators are iterable, so they're often used like so:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">#                  &lt; ITERABLE &gt;\n&gt;&gt;&gt; [x+10 for x in makeRange(5)]\n[10, 11, 12, 13, 14]\n</code></pre>\n<p>To get a better feel for generators, you can play around with the <code>itertools</code> module (be sure to use <code>chain.from_iterable</code> rather than <code>chain</code> when warranted). For example, you might even use generators to implement infinitely-long lazy lists like <code>itertools.count()</code>. You could implement your own <code>def enumerate(iterable): zip(count(), iterable)</code>, or alternatively do so with the <code>yield</code> keyword in a while-loop.</p>\n<p>Please note: generators can actually be used for many more things, such as <a href=\"http://www.dabeaz.com/coroutines/index.html\" rel=\"nofollow noreferrer\">implementing coroutines</a> or non-deterministic programming or other elegant things. However, the \"lazy lists\" viewpoint I present here is the most common use you will find.</p>\n<hr/>\n<h2>Behind the scenes</h2>\n<p>This is how the \"Python iteration protocol\" works. That is, what is going on when you do <code>list(makeRange(5))</code>. This is what I describe earlier as a \"lazy, incremental list\".</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; x=iter(range(5))\n&gt;&gt;&gt; next(x)  # calls x.__next__(); x.next() is deprecated\n0\n&gt;&gt;&gt; next(x)\n1\n&gt;&gt;&gt; next(x)\n2\n&gt;&gt;&gt; next(x)\n3\n&gt;&gt;&gt; next(x)\n4\n&gt;&gt;&gt; next(x)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nStopIteration\n</code></pre>\n<p>The built-in function <code>next()</code> just calls the objects <code>.__next__()</code> function, which is a part of the \"iteration protocol\" and is found on all iterators. You can manually use the <code>next()</code> function (and other parts of the iteration protocol) to implement fancy things, usually at the expense of readability, so try to avoid doing that...</p>\n<hr/>\n<h2>Coroutines</h2>\n<p><a href=\"https://www.python.org/dev/peps/pep-0342/\" rel=\"nofollow noreferrer\">Coroutine</a> example:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def interactiveProcedure():\n    userResponse = yield makeQuestionWebpage()\n    print('user response:', userResponse)\n    yield 'success'\n\ncoroutine = interactiveProcedure()\nwebFormData = next(coroutine)  # same as .send(None)\nuserResponse = serveWebForm(webFormData)\n\n# ...at some point later on web form submit...\n\nsuccessStatus = coroutine.send(userResponse)\n</code></pre>\n<p>A coroutine (generators which generally accept input via the <code>yield</code> keyword e.g. <code>nextInput = yield nextOutput</code>, as a form of two-way communication) is basically a computation which is allowed to pause itself and request input (e.g. to what it should do next). When the coroutine pauses itself (when the running coroutine eventually hits a <code>yield</code> keyword), the computation is paused and control is inverted (yielded) back to the 'calling' function (the frame which requested the <code>next</code> value of the computation). The paused generator/coroutine remains paused until another invoking function (possibly a different function/context) requests the next value to unpause it (usually passing input data to direct the paused logic interior to the coroutine's code).</p>\n<p><strong>You can think of python coroutines as lazy incrementally-pending lists, where the next element doesn't just depend on the previous computation, but also on input you may opt to inject during the generation process.</strong></p>\n<hr/>\n<h2>Minutiae</h2>\n<p>Normally, most people would not care about the following distinctions and probably want to stop reading here.</p>\n<p>In Python-speak, an <em>iterable</em> is any object which \"understands the concept of a for-loop\" like a list <code>[1,2,3]</code>, and an <em>iterator</em> is a specific instance of the requested for-loop like <code>[1,2,3].__iter__()</code>. A <em>generator</em> is exactly the same as any iterator, except for the way it was written (with function syntax).</p>\n<p>When you request an iterator from a list, it creates a new iterator. However, when you request an iterator from an iterator (which you would rarely do), it just gives you a copy of itself.</p>\n<p>Thus, in the unlikely event that you are failing to do something like this...</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt; x = myRange(5)\n&gt; list(x)\n[0, 1, 2, 3, 4]\n&gt; list(x)\n[]\n</code></pre>\n<p>... then remember that a generator is an <em>iterator</em>; that is, it is one-time-use. If you want to reuse it, you should call <code>myRange(...)</code> again. If you need to use the result twice, convert the result to a list and store it in a variable <code>x = list(myRange(5))</code>. Those who absolutely need to clone a generator (for example, who are doing terrifyingly hackish metaprogramming) can use <a href=\"https://docs.python.org/2/library/itertools.html#itertools.tee\" rel=\"nofollow noreferrer\"><code>itertools.tee</code></a> (<a href=\"https://docs.python.org/3/library/itertools.html#itertools.tee\" rel=\"nofollow noreferrer\">still works in Python 3</a>) if absolutely necessary, since the <a href=\"https://www.python.org/dev/peps/pep-0323/\" rel=\"nofollow noreferrer\">copyable iterator Python PEP standards proposal</a> has been deferred.</p>\n", "abstract": "The yield keyword is reduced to two simple facts: In a nutshell: Most commonly, a generator is a lazy, incrementally-pending list, and yield statements allow you to use function notation to program the list values the generator should incrementally spit out. Furthermore, advanced usage lets you use generators as coroutines (see below). Basically, whenever the yield statement is encountered, the function pauses and saves its state, then emits \"the next return value in the 'list'\" according to the python iterator protocol (to some syntactic construct like a for-loop that repeatedly calls next() and catches a StopIteration exception, etc.). You might have encountered generators with generator expressions; generator functions are more powerful because you can pass arguments back into the paused generator function, using them to implement coroutines. More on that later. Let's define a function makeRange that's just like Python's range. Calling makeRange(n) RETURNS A GENERATOR: To force the generator to immediately return its pending values, you can pass it into list() (just like you could any iterable): The above example can be thought of as merely creating a list which you append to and return: There is one major difference, though; see the last section. An iterable is the last part of a list comprehension, and all generators are iterable, so they're often used like so: To get a better feel for generators, you can play around with the itertools module (be sure to use chain.from_iterable rather than chain when warranted). For example, you might even use generators to implement infinitely-long lazy lists like itertools.count(). You could implement your own def enumerate(iterable): zip(count(), iterable), or alternatively do so with the yield keyword in a while-loop. Please note: generators can actually be used for many more things, such as implementing coroutines or non-deterministic programming or other elegant things. However, the \"lazy lists\" viewpoint I present here is the most common use you will find. This is how the \"Python iteration protocol\" works. That is, what is going on when you do list(makeRange(5)). This is what I describe earlier as a \"lazy, incremental list\". The built-in function next() just calls the objects .__next__() function, which is a part of the \"iteration protocol\" and is found on all iterators. You can manually use the next() function (and other parts of the iteration protocol) to implement fancy things, usually at the expense of readability, so try to avoid doing that... Coroutine example: A coroutine (generators which generally accept input via the yield keyword e.g. nextInput = yield nextOutput, as a form of two-way communication) is basically a computation which is allowed to pause itself and request input (e.g. to what it should do next). When the coroutine pauses itself (when the running coroutine eventually hits a yield keyword), the computation is paused and control is inverted (yielded) back to the 'calling' function (the frame which requested the next value of the computation). The paused generator/coroutine remains paused until another invoking function (possibly a different function/context) requests the next value to unpause it (usually passing input data to direct the paused logic interior to the coroutine's code). You can think of python coroutines as lazy incrementally-pending lists, where the next element doesn't just depend on the previous computation, but also on input you may opt to inject during the generation process. Normally, most people would not care about the following distinctions and probably want to stop reading here. In Python-speak, an iterable is any object which \"understands the concept of a for-loop\" like a list [1,2,3], and an iterator is a specific instance of the requested for-loop like [1,2,3].__iter__(). A generator is exactly the same as any iterator, except for the way it was written (with function syntax). When you request an iterator from a list, it creates a new iterator. However, when you request an iterator from an iterator (which you would rarely do), it just gives you a copy of itself. Thus, in the unlikely event that you are failing to do something like this... ... then remember that a generator is an iterator; that is, it is one-time-use. If you want to reuse it, you should call myRange(...) again. If you need to use the result twice, convert the result to a list and store it in a variable x = list(myRange(5)). Those who absolutely need to clone a generator (for example, who are doing terrifyingly hackish metaprogramming) can use itertools.tee (still works in Python 3) if absolutely necessary, since the copyable iterator Python PEP standards proposal has been deferred."}, {"id": 31042491, "score": 522, "vote": 0, "content": "<blockquote>\n<p><strong>What does the <code>yield</code> keyword do in Python?</strong></p>\n</blockquote>\n<h1>Answer Outline/Summary</h1>\n<ul>\n<li>A function with <a href=\"https://docs.python.org/reference/expressions.html#yieldexpr\" rel=\"noreferrer\"><strong><code>yield</code></strong></a>, when called, <strong>returns a <a href=\"https://docs.python.org/2/tutorial/classes.html#generators\" rel=\"noreferrer\">Generator</a>.</strong></li>\n<li>Generators are iterators because they implement the <a href=\"https://docs.python.org/2/library/stdtypes.html#iterator-types\" rel=\"noreferrer\"><strong>iterator protocol</strong></a>, so you can iterate over them.</li>\n<li>A generator can also be <strong>sent information</strong>, making it conceptually a <strong>coroutine</strong>.</li>\n<li>In Python 3, you can <strong>delegate</strong> from one generator to another in both directions with <strong><code>yield from</code></strong>.</li>\n<li>(Appendix critiques a couple of answers, including the top one, and discusses the use of <code>return</code> in a generator.)</li>\n</ul>\n<h1>Generators:</h1>\n<p><strong><code>yield</code></strong> is only legal inside of a function definition, and <strong>the inclusion of <code>yield</code> in a function definition makes it return a generator.</strong></p>\n<p>The idea for generators comes from other languages (see footnote 1) with varying implementations. In Python's Generators, the execution of the code is <a href=\"https://docs.python.org/3.5/glossary.html#term-generator-iterator\" rel=\"noreferrer\">frozen</a> at the point of the yield. When the generator is called (methods are discussed below) execution resumes and then freezes at the next yield.</p>\n<p><code>yield</code> provides an\neasy way of <a href=\"https://docs.python.org/2/library/stdtypes.html#generator-types\" rel=\"noreferrer\">implementing the iterator protocol</a>, defined by the following two methods:\n<code>__iter__</code> and <code>next</code> (Python 2) or <code>__next__</code> (Python 3).  Both of those methods\nmake an object an iterator that you could type-check with the <code>Iterator</code> Abstract Base\nClass from the <code>collections</code> module.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def func():\n...     yield 'I am'\n...     yield 'a generator!'\n... \n&gt;&gt;&gt; type(func)                 # A function with yield is still a function\n&lt;type 'function'&gt;\n&gt;&gt;&gt; gen = func()\n&gt;&gt;&gt; type(gen)                  # but it returns a generator\n&lt;type 'generator'&gt;\n&gt;&gt;&gt; hasattr(gen, '__iter__')   # that's an iterable\nTrue\n&gt;&gt;&gt; hasattr(gen, 'next')       # and with .next (.__next__ in Python 3)\nTrue                           # implements the iterator protocol.\n</code></pre>\n<p>The generator type is a sub-type of iterator:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import collections, types\n&gt;&gt;&gt; issubclass(types.GeneratorType, collections.Iterator)\nTrue\n</code></pre>\n<p>And if necessary, we can type-check like this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; isinstance(gen, types.GeneratorType)\nTrue\n&gt;&gt;&gt; isinstance(gen, collections.Iterator)\nTrue\n</code></pre>\n<p>A feature of an <code>Iterator</code> <a href=\"https://docs.python.org/2/glossary.html#term-iterator\" rel=\"noreferrer\">is that once exhausted</a>, you can't reuse or reset it:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(gen)\n['I am', 'a generator!']\n&gt;&gt;&gt; list(gen)\n[]\n</code></pre>\n<p>You'll have to make another if you want to use its functionality again (see footnote 2):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(func())\n['I am', 'a generator!']\n</code></pre>\n<p>One can yield data programmatically, for example:</p>\n<pre><code class=\"python\">def func(an_iterable):\n    for item in an_iterable:\n        yield item\n</code></pre>\n<p>The above simple generator is also equivalent to the below - as of Python 3.3 (and not available in Python 2), you can use <a href=\"https://www.python.org/dev/peps/pep-0380/\" rel=\"noreferrer\"><code>yield from</code></a>:</p>\n<pre><code class=\"python\">def func(an_iterable):\n    yield from an_iterable\n</code></pre>\n<p>However, <code>yield from</code> also allows for delegation to subgenerators,\nwhich will be explained in the following section on cooperative delegation with sub-coroutines.</p>\n<h1>Coroutines:</h1>\n<p><code>yield</code> forms an expression that allows data to be sent into the generator (see footnote 3)</p>\n<p>Here is an example, take note of the <code>received</code> variable, which will point to the data that is sent to the generator:</p>\n<pre><code class=\"python\">def bank_account(deposited, interest_rate):\n    while True:\n        calculated_interest = interest_rate * deposited \n        received = yield calculated_interest\n        if received:\n            deposited += received\n\n\n&gt;&gt;&gt; my_account = bank_account(1000, .05)\n</code></pre>\n<p>First, we must queue up the generator with the builtin function, <a href=\"https://docs.python.org/2/library/functions.html#next\" rel=\"noreferrer\"><code>next</code></a>. It will\ncall the appropriate <code>next</code> or <code>__next__</code> method, depending on the version of\nPython you are using:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; first_year_interest = next(my_account)\n&gt;&gt;&gt; first_year_interest\n50.0\n</code></pre>\n<p>And now we can send data into the generator. (<a href=\"https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators\" rel=\"noreferrer\">Sending <code>None</code> is\nthe same as calling <code>next</code></a>.) :</p>\n<pre><code class=\"python\">&gt;&gt;&gt; next_year_interest = my_account.send(first_year_interest + 1000)\n&gt;&gt;&gt; next_year_interest\n102.5\n</code></pre>\n<h2>Cooperative Delegation to Sub-Coroutine with <code>yield from</code></h2>\n<p>Now, recall that <code>yield from</code> is available in Python 3. This allows us to delegate coroutines to a subcoroutine:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">\ndef money_manager(expected_rate):\n    # must receive deposited value from .send():\n    under_management = yield                   # yield None to start.\n    while True:\n        try:\n            additional_investment = yield expected_rate * under_management \n            if additional_investment:\n                under_management += additional_investment\n        except GeneratorExit:\n            '''TODO: write function to send unclaimed funds to state'''\n            raise\n        finally:\n            '''TODO: write function to mail tax info to client'''\n        \n\ndef investment_account(deposited, manager):\n    '''very simple model of an investment account that delegates to a manager'''\n    # must queue up manager:\n    next(manager)      # &lt;- same as manager.send(None)\n    # This is where we send the initial deposit to the manager:\n    manager.send(deposited)\n    try:\n        yield from manager\n    except GeneratorExit:\n        return manager.close()  # delegate?\n</code></pre>\n<p>And now we can delegate functionality to a sub-generator and it can be used\nby a generator just as above:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">my_manager = money_manager(.06)\nmy_account = investment_account(1000, my_manager)\nfirst_year_return = next(my_account) # -&gt; 60.0\n</code></pre>\n<p>Now simulate adding another 1,000 to the account plus the return on the account (60.0):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">next_year_return = my_account.send(first_year_return + 1000)\nnext_year_return # 123.6\n</code></pre>\n<p>You can read more about the precise semantics of <code>yield from</code> in <a href=\"https://www.python.org/dev/peps/pep-0380/#formal-semantics\" rel=\"noreferrer\">PEP 380.</a></p>\n<h2>Other Methods: close and throw</h2>\n<p>The <code>close</code> method raises <code>GeneratorExit</code> at the point the function\nexecution was frozen. This will also be called by <code>__del__</code> so you\ncan put any cleanup code where you handle the <code>GeneratorExit</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">my_account.close()\n</code></pre>\n<p>You can also throw an exception which can be handled in the generator\nor propagated back to the user:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import sys\ntry:\n    raise ValueError\nexcept:\n    my_manager.throw(*sys.exc_info())\n</code></pre>\n<p>Raises:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">Traceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 4, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 6, in money_manager\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nValueError\n</code></pre>\n<h1>Conclusion</h1>\n<p>I believe I have covered all aspects of the following question:</p>\n<blockquote>\n<p><strong>What does the <code>yield</code> keyword do in Python?</strong></p>\n</blockquote>\n<p>It turns out that <code>yield</code> does a lot. I'm sure I could add even more\nthorough examples to this. If you want more or have some constructive criticism, let me know by commenting\nbelow.</p>\n<hr/>\n<h1>Appendix:</h1>\n<h2>Critique of the Top/Accepted Answer**</h2>\n<ul>\n<li>It is confused on what makes an <strong>iterable</strong>, just using a list as an example. See my references above, but in summary: an iterable has an <code>__iter__</code> method returning an <strong>iterator</strong>. An <strong>iterator</strong> provides a <code>.next</code> (Python 2 or <code>.__next__</code> (Python 3) method, which is implicitly called by <code>for</code> loops until it raises <code>StopIteration</code>, and once it does, it will continue to do so.</li>\n<li>It then uses a generator expression to describe what a generator is. Since a generator is simply a convenient way to create an <strong>iterator</strong>, it only confuses the matter, and we still have not yet gotten to the <code>yield</code> part.</li>\n<li>In <strong>Controlling a generator exhaustion</strong> he calls the <code>.next</code> method, when instead he should use the builtin function, <code>next</code>. It would be an appropriate layer of indirection, because his code does not work in Python 3.</li>\n<li>Itertools? This was not relevant to what <code>yield</code> does at all.</li>\n<li>No discussion of the methods that <code>yield</code> provides along with the new functionality <code>yield from</code> in Python 3. <strong>The top/accepted answer is a very incomplete answer.</strong></li>\n</ul>\n<h2>Critique of answer suggesting <code>yield</code> in a generator expression or comprehension.</h2>\n<p>The grammar currently allows any expression in a list comprehension.</p>\n<pre><code class=\"python\">expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |\n                     ('=' (yield_expr|testlist_star_expr))*)\n...\nyield_expr: 'yield' [yield_arg]\nyield_arg: 'from' test | testlist\n</code></pre>\n<p>Since yield is an expression, it has been touted by some as interesting to use it in comprehensions or generator expression - in spite of citing no particularly good use-case.</p>\n<p>The CPython core developers are <a href=\"https://mail.python.org/pipermail/python-dev/2017-January/147301.html\" rel=\"noreferrer\">discussing deprecating its allowance</a>.\nHere's a relevant post from the mailing list:</p>\n<blockquote>\n<p>On 30 January 2017 at 19:05, Brett Cannon  wrote:</p>\n<blockquote>\n<p>On Sun, 29 Jan 2017 at 16:39 Craig Rodrigues  wrote:</p>\n<blockquote>\n<p>I'm OK with either approach.  Leaving things the way they are in Python 3\nis no good, IMHO.</p>\n</blockquote>\n<p>My vote is it be a SyntaxError since you're not getting what you expect from\nthe syntax.</p>\n</blockquote>\n<p>I'd agree that's a sensible place for us to end up, as any code\nrelying on the current behaviour is really too clever to be\nmaintainable.</p>\n<p>In terms of getting there, we'll likely want:</p>\n<ul>\n<li>SyntaxWarning or DeprecationWarning in 3.7</li>\n<li>Py3k warning in 2.7.x</li>\n<li>SyntaxError in 3.8</li>\n</ul>\n<p>Cheers, Nick.</p>\n<p>--  Nick Coghlan   |   ncoghlan at gmail.com   |   Brisbane, Australia</p>\n</blockquote>\n<p>Further, there is an <a href=\"http://bugs.python.org/issue10544\" rel=\"noreferrer\">outstanding issue (10544)</a> which seems to be pointing in the direction of this <em>never</em> being a good idea (PyPy, a Python implementation written in Python, is already raising syntax warnings.)</p>\n<p>Bottom line, until the developers of CPython tell us otherwise: <strong>Don't put <code>yield</code> in a generator expression or comprehension.</strong></p>\n<h2>The <code>return</code> statement in a generator</h2>\n<p>In <a href=\"https://docs.python.org/2/reference/simple_stmts.html#the-return-statement\" rel=\"noreferrer\">Python 2</a>:</p>\n<blockquote>\n<p>In a generator function, the <code>return</code> statement is not allowed to include an <code>expression_list</code>. In that context, a bare <code>return</code> indicates that the generator is done and will cause <code>StopIteration</code> to be raised.</p>\n</blockquote>\n<p>An <code>expression_list</code> is basically any number of expressions separated by commas - essentially, in Python 2, you can stop the generator with <code>return</code>, but you can't return a value.</p>\n<p>In <a href=\"https://docs.python.org/3/reference/simple_stmts.html#the-return-statement\" rel=\"noreferrer\">Python 3</a>:</p>\n<blockquote>\n<p>In a generator function, the <code>return</code> statement indicates that the generator is done and will cause <code>StopIteration</code> to be raised. The returned value (if any) is used as an argument to construct <code>StopIteration</code> and becomes the <code>StopIteration.value</code> attribute.</p>\n</blockquote>\n<h2>Footnotes</h2>\n<ol>\n<li><p><sub>The languages CLU, Sather, and Icon were referenced in the proposal\nto introduce the concept of generators to Python. The general idea is\nthat a function can maintain internal state and yield intermediate\ndata points on demand by the user. This promised to be <a href=\"https://www.python.org/dev/peps/pep-0255/\" rel=\"noreferrer\">superior in performance\nto other approaches, including Python threading</a>, which isn't even available on some systems.</sub></p>\n</li>\n<li><p><sub> This means, for example, that <code>range</code> objects aren't <code>Iterator</code>s, even though they are iterable, because they can be reused. Like lists, their <code>__iter__</code> methods return iterator objects.</sub></p>\n</li>\n<li><sub>\n</sub></li>\n</ol>\n<p><code>yield</code> was originally introduced as a statement, meaning that it\ncould only appear at the beginning of a line in a code block.\nNow <code>yield</code> creates a yield expression.\n<a href=\"https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt\" rel=\"noreferrer\">https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt</a>\nThis change was <a href=\"https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators\" rel=\"noreferrer\">proposed</a> to allow a user to send data into the generator just as\none might receive it. To send data, one must be able to assign it to something, and\nfor that, a statement just won't work.</p>\n", "abstract": "What does the yield keyword do in Python? yield is only legal inside of a function definition, and the inclusion of yield in a function definition makes it return a generator. The idea for generators comes from other languages (see footnote 1) with varying implementations. In Python's Generators, the execution of the code is frozen at the point of the yield. When the generator is called (methods are discussed below) execution resumes and then freezes at the next yield. yield provides an\neasy way of implementing the iterator protocol, defined by the following two methods:\n__iter__ and next (Python 2) or __next__ (Python 3).  Both of those methods\nmake an object an iterator that you could type-check with the Iterator Abstract Base\nClass from the collections module. The generator type is a sub-type of iterator: And if necessary, we can type-check like this: A feature of an Iterator is that once exhausted, you can't reuse or reset it: You'll have to make another if you want to use its functionality again (see footnote 2): One can yield data programmatically, for example: The above simple generator is also equivalent to the below - as of Python 3.3 (and not available in Python 2), you can use yield from: However, yield from also allows for delegation to subgenerators,\nwhich will be explained in the following section on cooperative delegation with sub-coroutines. yield forms an expression that allows data to be sent into the generator (see footnote 3) Here is an example, take note of the received variable, which will point to the data that is sent to the generator: First, we must queue up the generator with the builtin function, next. It will\ncall the appropriate next or __next__ method, depending on the version of\nPython you are using: And now we can send data into the generator. (Sending None is\nthe same as calling next.) : Now, recall that yield from is available in Python 3. This allows us to delegate coroutines to a subcoroutine: And now we can delegate functionality to a sub-generator and it can be used\nby a generator just as above: Now simulate adding another 1,000 to the account plus the return on the account (60.0): You can read more about the precise semantics of yield from in PEP 380. The close method raises GeneratorExit at the point the function\nexecution was frozen. This will also be called by __del__ so you\ncan put any cleanup code where you handle the GeneratorExit: You can also throw an exception which can be handled in the generator\nor propagated back to the user: Raises: I believe I have covered all aspects of the following question: What does the yield keyword do in Python? It turns out that yield does a lot. I'm sure I could add even more\nthorough examples to this. If you want more or have some constructive criticism, let me know by commenting\nbelow. The grammar currently allows any expression in a list comprehension. Since yield is an expression, it has been touted by some as interesting to use it in comprehensions or generator expression - in spite of citing no particularly good use-case. The CPython core developers are discussing deprecating its allowance.\nHere's a relevant post from the mailing list: On 30 January 2017 at 19:05, Brett Cannon  wrote: On Sun, 29 Jan 2017 at 16:39 Craig Rodrigues  wrote: I'm OK with either approach.  Leaving things the way they are in Python 3\nis no good, IMHO. My vote is it be a SyntaxError since you're not getting what you expect from\nthe syntax. I'd agree that's a sensible place for us to end up, as any code\nrelying on the current behaviour is really too clever to be\nmaintainable. In terms of getting there, we'll likely want: Cheers, Nick. --  Nick Coghlan   |   ncoghlan at gmail.com   |   Brisbane, Australia Further, there is an outstanding issue (10544) which seems to be pointing in the direction of this never being a good idea (PyPy, a Python implementation written in Python, is already raising syntax warnings.) Bottom line, until the developers of CPython tell us otherwise: Don't put yield in a generator expression or comprehension. In Python 2: In a generator function, the return statement is not allowed to include an expression_list. In that context, a bare return indicates that the generator is done and will cause StopIteration to be raised. An expression_list is basically any number of expressions separated by commas - essentially, in Python 2, you can stop the generator with return, but you can't return a value. In Python 3: In a generator function, the return statement indicates that the generator is done and will cause StopIteration to be raised. The returned value (if any) is used as an argument to construct StopIteration and becomes the StopIteration.value attribute. The languages CLU, Sather, and Icon were referenced in the proposal\nto introduce the concept of generators to Python. The general idea is\nthat a function can maintain internal state and yield intermediate\ndata points on demand by the user. This promised to be superior in performance\nto other approaches, including Python threading, which isn't even available on some systems.  This means, for example, that range objects aren't Iterators, even though they are iterable, because they can be reused. Like lists, their __iter__ methods return iterator objects. yield was originally introduced as a statement, meaning that it\ncould only appear at the beginning of a line in a code block.\nNow yield creates a yield expression.\nhttps://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt\nThis change was proposed to allow a user to send data into the generator just as\none might receive it. To send data, one must be able to assign it to something, and\nfor that, a statement just won't work."}, {"id": 231778, "score": 428, "vote": 0, "content": "<p><code>yield</code> is just like <code>return</code> - it returns whatever you tell it to (as a generator). The difference is that the next time you call the generator, execution starts from the last call to the <code>yield</code> statement. Unlike return, <strong>the stack frame is not cleaned up when a yield occurs, however control is transferred back to the caller, so its state will resume the next time the function is called.</strong></p>\n<p>In the case of your code, the function <code>get_child_candidates</code> is acting like an iterator so that when you extend your list, it adds one element at a time to the new list.</p>\n<p><code>list.extend</code> calls an iterator until it's exhausted. In the case of the code sample you posted, it would be much clearer to just return a tuple and append that to the list.</p>\n", "abstract": "yield is just like return - it returns whatever you tell it to (as a generator). The difference is that the next time you call the generator, execution starts from the last call to the yield statement. Unlike return, the stack frame is not cleaned up when a yield occurs, however control is transferred back to the caller, so its state will resume the next time the function is called. In the case of your code, the function get_child_candidates is acting like an iterator so that when you extend your list, it adds one element at a time to the new list. list.extend calls an iterator until it's exhausted. In the case of the code sample you posted, it would be much clearer to just return a tuple and append that to the list."}, {"id": 232853, "score": 304, "vote": 0, "content": "<p>There's one extra thing to mention: a function that yields doesn't actually have to terminate. I've written code like this:</p>\n<pre><code class=\"python\">def fib():\n    last, cur = 0, 1\n    while True: \n        yield cur\n        last, cur = cur, last + cur\n</code></pre>\n<p>Then I can use it in other code like this:</p>\n<pre><code class=\"python\">for f in fib():\n    if some_condition: break\n    coolfuncs(f);\n</code></pre>\n<p>It really helps simplify some problems, and makes some things easier to work with. </p>\n", "abstract": "There's one extra thing to mention: a function that yields doesn't actually have to terminate. I've written code like this: Then I can use it in other code like this: It really helps simplify some problems, and makes some things easier to work with. "}, {"id": 14404292, "score": 295, "vote": 0, "content": "<p>For those who prefer a minimal working example, meditate on this interactive Python session:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def f():\n...   yield 1\n...   yield 2\n...   yield 3\n... \n&gt;&gt;&gt; g = f()\n&gt;&gt;&gt; for i in g:\n...   print(i)\n... \n1\n2\n3\n&gt;&gt;&gt; for i in g:\n...   print(i)\n... \n&gt;&gt;&gt; # Note that this time nothing was printed\n</code></pre>\n", "abstract": "For those who prefer a minimal working example, meditate on this interactive Python session:"}, {"id": 36220775, "score": 275, "vote": 0, "content": "<p><strong>TL;DR</strong></p>\n<h1>Instead of this:</h1>\n<pre><code class=\"python\">def square_list(n):\n    the_list = []                         # Replace\n    for x in range(n):\n        y = x * x\n        the_list.append(y)                # these\n    return the_list                       # lines\n</code></pre>\n<h1>do this:</h1>\n<pre><code class=\"python\">def square_yield(n):\n    for x in range(n):\n        y = x * x\n        yield y                           # with this one.\n</code></pre>\n<p>Whenever you find yourself building a list from scratch, <code>yield</code> each piece instead. </p>\n<p>This was my first \"aha\" moment with yield.</p>\n<hr/>\n<p><code>yield</code> is a <a href=\"https://en.wikipedia.org/wiki/Syntactic_sugar\" rel=\"noreferrer\">sugary</a> way to say </p>\n<blockquote>\n<p>build a series of stuff</p>\n</blockquote>\n<p>Same behavior:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; for square in square_list(4):\n...     print(square)\n...\n0\n1\n4\n9\n&gt;&gt;&gt; for square in square_yield(4):\n...     print(square)\n...\n0\n1\n4\n9\n</code></pre>\n<p>Different behavior:</p>\n<p>Yield is <strong>single-pass</strong>: you can only iterate through once. When a function has a yield in it we call it a <a href=\"https://stackoverflow.com/a/1756342/673991\">generator function</a>. And an <a href=\"https://stackoverflow.com/a/9884501/673991\">iterator</a> is what it returns. Those terms are revealing. We lose the convenience of a container, but gain the power of a series that's computed as needed, and arbitrarily long.</p>\n<p>Yield is <strong>lazy</strong>, it puts off computation. A function with a yield in it <em>doesn't actually execute at all when you call it.</em> It returns an <a href=\"https://docs.python.org/3/reference/expressions.html#yieldexpr\" rel=\"noreferrer\">iterator object</a> that remembers where it left off. Each time you call <code>next()</code> on the iterator (this happens in a for-loop) execution inches forward to the next yield. <code>return</code> raises StopIteration and ends the series (this is the natural end of a for-loop).</p>\n<p>Yield is <strong>versatile</strong>. Data doesn't have to be stored all together, it can be made available one at a time. It can be infinite.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def squares_all_of_them():\n...     x = 0\n...     while True:\n...         yield x * x\n...         x += 1\n...\n&gt;&gt;&gt; squares = squares_all_of_them()\n&gt;&gt;&gt; for _ in range(4):\n...     print(next(squares))\n...\n0\n1\n4\n9\n</code></pre>\n<hr/>\n<p>If you need <strong>multiple passes</strong> and the series isn't too long, just call <code>list()</code> on it:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(square_yield(4))\n[0, 1, 4, 9]\n</code></pre>\n<hr/>\n<p>Brilliant choice of the word <code>yield</code> because <a href=\"https://www.google.com/search?q=yield+meaning\" rel=\"noreferrer\">both meanings</a> apply:</p>\n<blockquote>\n<p><strong>yield</strong> \u2014 produce or provide (as in agriculture)</p>\n</blockquote>\n<p>...provide the next data in the series.</p>\n<blockquote>\n<p><strong>yield</strong> \u2014 give way or relinquish (as in political power)</p>\n</blockquote>\n<p>...relinquish CPU execution until the iterator advances.</p>\n", "abstract": "TL;DR Whenever you find yourself building a list from scratch, yield each piece instead.  This was my first \"aha\" moment with yield. yield is a sugary way to say  build a series of stuff Same behavior: Different behavior: Yield is single-pass: you can only iterate through once. When a function has a yield in it we call it a generator function. And an iterator is what it returns. Those terms are revealing. We lose the convenience of a container, but gain the power of a series that's computed as needed, and arbitrarily long. Yield is lazy, it puts off computation. A function with a yield in it doesn't actually execute at all when you call it. It returns an iterator object that remembers where it left off. Each time you call next() on the iterator (this happens in a for-loop) execution inches forward to the next yield. return raises StopIteration and ends the series (this is the natural end of a for-loop). Yield is versatile. Data doesn't have to be stored all together, it can be made available one at a time. It can be infinite. If you need multiple passes and the series isn't too long, just call list() on it: Brilliant choice of the word yield because both meanings apply: yield \u2014 produce or provide (as in agriculture) ...provide the next data in the series. yield \u2014 give way or relinquish (as in political power) ...relinquish CPU execution until the iterator advances."}, {"id": 14352675, "score": 236, "vote": 0, "content": "<p>Yield gives you a generator. </p>\n<pre><code class=\"python\">def get_odd_numbers(i):\n    return range(1, i, 2)\ndef yield_odd_numbers(i):\n    for x in range(1, i, 2):\n       yield x\nfoo = get_odd_numbers(10)\nbar = yield_odd_numbers(10)\nfoo\n[1, 3, 5, 7, 9]\nbar\n&lt;generator object yield_odd_numbers at 0x1029c6f50&gt;\nbar.next()\n1\nbar.next()\n3\nbar.next()\n5\n</code></pre>\n<p>As you can see, in the first case <code>foo</code> holds the entire list in memory at once. It's not a big deal for a list with 5 elements, but what if you want a list of 5 million? Not only is this a huge memory eater, it also costs a lot of time to build at the time that the function is called.</p>\n<p>In the second case, <code>bar</code> just gives you a generator. A generator is an iterable--which means you can use it in a <code>for</code> loop, etc, but each value can only be accessed once. All the values are also not stored in memory at the same time; the generator object \"remembers\" where it was in the looping the last time you called it--this way, if you're using an iterable to (say) count to 50 billion, you don't have to count to 50 billion all at once and store the 50 billion numbers to count through.</p>\n<p>Again, this is a pretty contrived example, you probably would use itertools if you really wanted to count to 50 billion. :)</p>\n<p>This is the most simple use case of generators. As you said, it can be used to write efficient permutations, using yield to push things up through the call stack instead of using some sort of stack variable. Generators can also be used for specialized tree traversal, and all manner of other things.</p>\n", "abstract": "Yield gives you a generator.  As you can see, in the first case foo holds the entire list in memory at once. It's not a big deal for a list with 5 elements, but what if you want a list of 5 million? Not only is this a huge memory eater, it also costs a lot of time to build at the time that the function is called. In the second case, bar just gives you a generator. A generator is an iterable--which means you can use it in a for loop, etc, but each value can only be accessed once. All the values are also not stored in memory at the same time; the generator object \"remembers\" where it was in the looping the last time you called it--this way, if you're using an iterable to (say) count to 50 billion, you don't have to count to 50 billion all at once and store the 50 billion numbers to count through. Again, this is a pretty contrived example, you probably would use itertools if you really wanted to count to 50 billion. :) This is the most simple use case of generators. As you said, it can be used to write efficient permutations, using yield to push things up through the call stack instead of using some sort of stack variable. Generators can also be used for specialized tree traversal, and all manner of other things."}, {"id": 231788, "score": 232, "vote": 0, "content": "<p>It's returning a generator. I'm not particularly familiar with Python, but I believe it's the same kind of thing as <a href=\"http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx\" rel=\"noreferrer\">C#'s iterator blocks</a> if you're familiar with those.</p>\n<p>The key idea is that the compiler/interpreter/whatever does some trickery so that as far as the caller is concerned, they can keep calling next() and it will keep returning values - <em>as if the generator method was paused</em>. Now obviously you can't really \"pause\" a method, so the compiler builds a state machine for you to remember where you currently are and what the local variables etc look like. This is much easier than writing an iterator yourself.</p>\n", "abstract": "It's returning a generator. I'm not particularly familiar with Python, but I believe it's the same kind of thing as C#'s iterator blocks if you're familiar with those. The key idea is that the compiler/interpreter/whatever does some trickery so that as far as the caller is concerned, they can keep calling next() and it will keep returning values - as if the generator method was paused. Now obviously you can't really \"pause\" a method, so the compiler builds a state machine for you to remember where you currently are and what the local variables etc look like. This is much easier than writing an iterator yourself."}, {"id": 15814755, "score": 207, "vote": 0, "content": "<p>There is one type of answer that I don't feel has been given yet, among the many great answers that describe how to use generators. Here is the programming language theory answer:</p>\n<p>The <code>yield</code> statement in Python returns a generator. A generator in Python is a function that returns <i>continuations</i> (and specifically a type of coroutine, but continuations represent the more general mechanism to understand what is going on).</p>\n<p>Continuations in programming languages theory are a much more fundamental kind of computation, but they are not often used, because they are extremely hard to reason about and also very difficult to implement. But the idea of what a continuation is, is straightforward: it is the state of a computation that has not yet finished. In this state, the current values of variables, the operations that have yet to be performed, and so on, are saved. Then at some point later in the program the continuation can be invoked, such that the program's variables are reset to that state and the operations that were saved are carried out.</p>\n<p>Continuations, in this more general form, can be implemented in two ways. In the <code>call/cc</code> way, the program's stack is literally saved and then when the continuation is invoked, the stack is restored.</p>\n<p>In continuation passing style (CPS), continuations are just normal functions (only in languages where functions are first class) which the programmer explicitly manages and passes around to subroutines. In this style, program state is represented by closures (and the variables that happen to be encoded in them) rather than variables that reside somewhere on the stack. Functions that manage control flow accept continuation as arguments (in some variations of CPS, functions may accept multiple continuations) and manipulate control flow by invoking them by simply calling them and returning afterwards. A very simple example of continuation passing style is as follows:</p>\n<pre><code class=\"python\">def save_file(filename):\n  def write_file_continuation():\n    write_stuff_to_file(filename)\n\n  check_if_file_exists_and_user_wants_to_overwrite(write_file_continuation)\n</code></pre>\n<p>In this (very simplistic) example, the programmer saves the operation of actually writing the file into a continuation (which can potentially be a very complex operation with many details to write out), and then passes that continuation (i.e, as a first-class closure) to another operator which does some more processing, and then calls it if necessary. (I use this design pattern a lot in actual GUI programming, either because it saves me lines of code or, more importantly, to manage control flow after GUI events trigger.)</p>\n<p>The rest of this post will, without loss of generality, conceptualize continuations as CPS, because it is a hell of a lot easier to understand and read.</p>\n<p><br/></p>\n<p>Now let's talk about generators in Python. Generators are a specific subtype of continuation. Whereas <strong>continuations are able in general to save the state of a <em>computation</em></strong> (i.e., the program's call stack), <strong>generators are only able to save the state of iteration over an <em>iterator</em></strong>. Although, this definition is slightly misleading for certain use cases of generators. For instance:</p>\n<pre><code class=\"python\">def f():\n  while True:\n    yield 4\n</code></pre>\n<p>This is clearly a reasonable iterable whose behavior is well defined -- each time the generator iterates over it, it returns 4 (and does so forever). But it isn't probably the prototypical type of iterable that comes to mind when thinking of iterators (i.e., <code>for x in collection: do_something(x)</code>). This example illustrates the power of generators: if anything is an iterator, a generator can save the state of its iteration.</p>\n<p>To reiterate: Continuations can save the state of a program's stack and generators can save the state of iteration. This means that continuations are more a lot powerful than generators, but also that generators are a lot, lot easier. They are easier for the language designer to implement, and they are easier for the programmer to use (if you have some time to burn, try to read and understand <a href=\"http://www.madore.org/~david/computers/callcc.html\" rel=\"noreferrer\">this page about continuations and call/cc</a>).</p>\n<p>But you could easily implement (and conceptualize) generators as a simple, specific case of continuation passing style:</p>\n<p>Whenever <code>yield</code> is called, it tells the function to return a continuation.  When the function is called again, it starts from wherever it left off. So, in pseudo-pseudocode (i.e., not pseudocode, but not code) the generator's <code>next</code> method is basically as follows:</p>\n<pre><code class=\"python\">class Generator():\n  def __init__(self,iterable,generatorfun):\n    self.next_continuation = lambda:generatorfun(iterable)\n\n  def next(self):\n    value, next_continuation = self.next_continuation()\n    self.next_continuation = next_continuation\n    return value\n</code></pre>\n<p>where the <code>yield</code> keyword is actually syntactic sugar for the real generator function, basically something like:</p>\n<pre><code class=\"python\">def generatorfun(iterable):\n  if len(iterable) == 0:\n    raise StopIteration\n  else:\n    return (iterable[0], lambda:generatorfun(iterable[1:]))\n</code></pre>\n<p>Remember that this is just pseudocode and the actual implementation of generators in Python is more complex. But as an exercise to understand what is going on, try to use continuation passing style to implement generator objects without use of the <code>yield</code> keyword.</p>\n", "abstract": "There is one type of answer that I don't feel has been given yet, among the many great answers that describe how to use generators. Here is the programming language theory answer: The yield statement in Python returns a generator. A generator in Python is a function that returns continuations (and specifically a type of coroutine, but continuations represent the more general mechanism to understand what is going on). Continuations in programming languages theory are a much more fundamental kind of computation, but they are not often used, because they are extremely hard to reason about and also very difficult to implement. But the idea of what a continuation is, is straightforward: it is the state of a computation that has not yet finished. In this state, the current values of variables, the operations that have yet to be performed, and so on, are saved. Then at some point later in the program the continuation can be invoked, such that the program's variables are reset to that state and the operations that were saved are carried out. Continuations, in this more general form, can be implemented in two ways. In the call/cc way, the program's stack is literally saved and then when the continuation is invoked, the stack is restored. In continuation passing style (CPS), continuations are just normal functions (only in languages where functions are first class) which the programmer explicitly manages and passes around to subroutines. In this style, program state is represented by closures (and the variables that happen to be encoded in them) rather than variables that reside somewhere on the stack. Functions that manage control flow accept continuation as arguments (in some variations of CPS, functions may accept multiple continuations) and manipulate control flow by invoking them by simply calling them and returning afterwards. A very simple example of continuation passing style is as follows: In this (very simplistic) example, the programmer saves the operation of actually writing the file into a continuation (which can potentially be a very complex operation with many details to write out), and then passes that continuation (i.e, as a first-class closure) to another operator which does some more processing, and then calls it if necessary. (I use this design pattern a lot in actual GUI programming, either because it saves me lines of code or, more importantly, to manage control flow after GUI events trigger.) The rest of this post will, without loss of generality, conceptualize continuations as CPS, because it is a hell of a lot easier to understand and read.  Now let's talk about generators in Python. Generators are a specific subtype of continuation. Whereas continuations are able in general to save the state of a computation (i.e., the program's call stack), generators are only able to save the state of iteration over an iterator. Although, this definition is slightly misleading for certain use cases of generators. For instance: This is clearly a reasonable iterable whose behavior is well defined -- each time the generator iterates over it, it returns 4 (and does so forever). But it isn't probably the prototypical type of iterable that comes to mind when thinking of iterators (i.e., for x in collection: do_something(x)). This example illustrates the power of generators: if anything is an iterator, a generator can save the state of its iteration. To reiterate: Continuations can save the state of a program's stack and generators can save the state of iteration. This means that continuations are more a lot powerful than generators, but also that generators are a lot, lot easier. They are easier for the language designer to implement, and they are easier for the programmer to use (if you have some time to burn, try to read and understand this page about continuations and call/cc). But you could easily implement (and conceptualize) generators as a simple, specific case of continuation passing style: Whenever yield is called, it tells the function to return a continuation.  When the function is called again, it starts from wherever it left off. So, in pseudo-pseudocode (i.e., not pseudocode, but not code) the generator's next method is basically as follows: where the yield keyword is actually syntactic sugar for the real generator function, basically something like: Remember that this is just pseudocode and the actual implementation of generators in Python is more complex. But as an exercise to understand what is going on, try to use continuation passing style to implement generator objects without use of the yield keyword."}, {"id": 232111, "score": 206, "vote": 0, "content": "<p>Here is an example in plain language. I will provide a correspondence between high-level human concepts to low-level Python concepts.</p>\n<p>I want to operate on a sequence of numbers, but I don't want to bother my self with the creation of that sequence, I want only to focus on the operation I want to do. So, I do the following:</p>\n<ul>\n<li>I call you and tell you that I want a sequence of numbers which are calculated in a specific way, and I let you know what the algorithm is. <br/>\n<b>This step corresponds to <code>def</code>ining the generator function, i.e. the function containing a <code>yield</code>.</b></li>\n<li>Sometime later, I tell you, \"OK, get ready to tell me the sequence of numbers\". <br/>\n<b>This step corresponds to calling the generator function which returns a generator object.</b> Note that you don't tell me any numbers yet; you just grab your paper and pencil.</li>\n<li>I ask you, \"tell me the next number\", and you tell me the first number; after that, you wait for me to ask you for the next number. It's your job to remember where you were, what numbers you have already said, and what is the next number. I don't care about the details. <br/>\n<b>This step corresponds to calling <code>next(generator)</code> on the generator object.</b><br/>\n(In Python 2, <code>.next</code> was a method of the generator object; in Python 3, it is named <code>.__next__</code>, but the proper way to call it is using the builtin <code>next()</code> function just like <code>len()</code> and <code>.__len__</code>)</li>\n<li>\u2026 repeat previous step, until\u2026</li>\n<li>eventually, you might come to an end. You don't tell me a number; you just shout, \"hold your horses! I'm done! No more numbers!\" <br/>\n<b>This step corresponds to the generator object ending its job, and raising a <code>StopIteration</code> exception.</b><br/>\nThe generator function does not need to raise the exception. It's raised automatically when the function ends or issues a <code>return</code>.</li>\n</ul>\n<p>This is what a generator does (a function that contains a <code>yield</code>); it starts executing on the first <code>next()</code>, pauses whenever it does a <code>yield</code>, and when asked for the <code>next()</code> value it continues from the point it was last. It fits perfectly by design with the iterator protocol of Python, which describes how to sequentially request values.</p>\n<p>The most famous user of the iterator protocol is the <code>for</code> command in Python. So, whenever you do a:</p>\n<pre><code class=\"python\">for item in sequence:\n</code></pre>\n<p>it doesn't matter if <code>sequence</code> is a list, a string, a dictionary or a generator <em>object</em> like described above; the result is the same: you read items off a sequence one by one.</p>\n<p>Note that <code>def</code>ining a function which contains a <code>yield</code> keyword is not the only way to create a generator; it's just the easiest way to create one.</p>\n<p>For more accurate information, read about <a href=\"http://docs.python.org/library/stdtypes.html#iterator-types\" rel=\"noreferrer\">iterator types</a>, the <a href=\"http://docs.python.org/reference/simple_stmts.html#yield\" rel=\"noreferrer\">yield statement</a> and <a href=\"http://docs.python.org/glossary.html#term-generator\" rel=\"noreferrer\">generators</a> in the Python documentation.</p>\n", "abstract": "Here is an example in plain language. I will provide a correspondence between high-level human concepts to low-level Python concepts. I want to operate on a sequence of numbers, but I don't want to bother my self with the creation of that sequence, I want only to focus on the operation I want to do. So, I do the following: This is what a generator does (a function that contains a yield); it starts executing on the first next(), pauses whenever it does a yield, and when asked for the next() value it continues from the point it was last. It fits perfectly by design with the iterator protocol of Python, which describes how to sequentially request values. The most famous user of the iterator protocol is the for command in Python. So, whenever you do a: it doesn't matter if sequence is a list, a string, a dictionary or a generator object like described above; the result is the same: you read items off a sequence one by one. Note that defining a function which contains a yield keyword is not the only way to create a generator; it's just the easiest way to create one. For more accurate information, read about iterator types, the yield statement and generators in the Python documentation."}, {"id": 21541902, "score": 162, "vote": 0, "content": "<p>While a lot of answers show why you'd use a <code>yield</code> to create a generator, there are more uses for <code>yield</code>.  It's quite easy to make a coroutine, which enables the passing of information between two blocks of code.  I won't repeat any of the fine examples that have already been given about using <code>yield</code> to create a generator.</p>\n<p>To help understand what a <code>yield</code> does in the following code, you can use your finger to trace the cycle through any code that has a <code>yield</code>.  Every time your finger hits the <code>yield</code>, you have to wait for a <code>next</code> or a <code>send</code> to be entered.  When a <code>next</code> is called, you trace through the code until you hit the <code>yield</code>\u2026 the code on the right of the <code>yield</code> is evaluated and returned to the caller\u2026 then you wait.  When <code>next</code> is called again, you perform another loop through the code.  However, you'll note that in a coroutine, <code>yield</code> can also be used with a <code>send</code>\u2026 which will send a value from the caller <em>into</em> the yielding function. If a <code>send</code> is given, then <code>yield</code> receives the value sent, and spits it out the left hand side\u2026 then the trace through the code progresses until you hit the <code>yield</code> again (returning the value at the end, as if <code>next</code> was called).</p>\n<p>For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def coroutine():\n...     i = -1\n...     while True:\n...         i += 1\n...         val = (yield i)\n...         print(\"Received %s\" % val)\n...\n&gt;&gt;&gt; sequence = coroutine()\n&gt;&gt;&gt; sequence.next()\n0\n&gt;&gt;&gt; sequence.next()\nReceived None\n1\n&gt;&gt;&gt; sequence.send('hello')\nReceived hello\n2\n&gt;&gt;&gt; sequence.close()\n</code></pre>\n", "abstract": "While a lot of answers show why you'd use a yield to create a generator, there are more uses for yield.  It's quite easy to make a coroutine, which enables the passing of information between two blocks of code.  I won't repeat any of the fine examples that have already been given about using yield to create a generator. To help understand what a yield does in the following code, you can use your finger to trace the cycle through any code that has a yield.  Every time your finger hits the yield, you have to wait for a next or a send to be entered.  When a next is called, you trace through the code until you hit the yield\u2026 the code on the right of the yield is evaluated and returned to the caller\u2026 then you wait.  When next is called again, you perform another loop through the code.  However, you'll note that in a coroutine, yield can also be used with a send\u2026 which will send a value from the caller into the yielding function. If a send is given, then yield receives the value sent, and spits it out the left hand side\u2026 then the trace through the code progresses until you hit the yield again (returning the value at the end, as if next was called). For example:"}, {"id": 24944096, "score": 158, "vote": 0, "content": "<p>There is another <code>yield</code> use and meaning (since Python 3.3):</p>\n<pre><code class=\"python\">yield from &lt;expr&gt;\n</code></pre>\n<p>From <em><a href=\"http://www.python.org/dev/peps/pep-0380/\" rel=\"noreferrer\">PEP 380 -- Syntax for Delegating to a Subgenerator</a></em>:</p>\n<blockquote>\n<p>A syntax is proposed for a generator to delegate part of its operations to another generator. This allows a section of code containing 'yield' to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator.</p>\n<p>The new syntax also opens up some opportunities for optimisation when one generator re-yields values produced by another.</p>\n</blockquote>\n<p>Moreover <a href=\"https://www.python.org/dev/peps/pep-0492/\" rel=\"noreferrer\">this</a> will introduce (since Python 3.5):</p>\n<pre><code class=\"python\">async def new_coroutine(data):\n   ...\n   await blocking_action()\n</code></pre>\n<p>to avoid coroutines being confused with a regular generator (today <code>yield</code> is used in both).</p>\n", "abstract": "There is another yield use and meaning (since Python 3.3): From PEP 380 -- Syntax for Delegating to a Subgenerator: A syntax is proposed for a generator to delegate part of its operations to another generator. This allows a section of code containing 'yield' to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator. The new syntax also opens up some opportunities for optimisation when one generator re-yields values produced by another. Moreover this will introduce (since Python 3.5): to avoid coroutines being confused with a regular generator (today yield is used in both)."}, {"id": 47285378, "score": 146, "vote": 0, "content": "<p>All great answers, however a bit difficult for newbies.</p>\n<p>I assume you have learned the <code>return</code> statement.</p>\n<p>As an analogy, <code>return</code> and <code>yield</code> are twins. <code>return</code> means 'return and stop' whereas 'yield` means 'return, but continue'</p>\n<blockquote>\n<ol>\n<li>Try to get a num_list with <code>return</code>.</li>\n</ol>\n</blockquote>\n<pre><code class=\"python\">def num_list(n):\n    for i in range(n):\n        return i\n</code></pre>\n<p>Run it:</p>\n<pre><code class=\"python\">In [5]: num_list(3)\nOut[5]: 0\n</code></pre>\n<p>See, you get only a single number rather than a list of them. <code>return</code> never allows you prevail happily, just implements once and quit.</p>\n<blockquote>\n<ol start=\"2\">\n<li>There comes <code>yield</code></li>\n</ol>\n</blockquote>\n<p>Replace <code>return</code> with <code>yield</code>:</p>\n<pre><code class=\"python\">In [10]: def num_list(n):\n    ...:     for i in range(n):\n    ...:         yield i\n    ...:\n\nIn [11]: num_list(3)\nOut[11]: &lt;generator object num_list at 0x10327c990&gt;\n\nIn [12]: list(num_list(3))\nOut[12]: [0, 1, 2]\n</code></pre>\n<p>Now, you win to get all the numbers.</p>\n<p>Comparing to <code>return</code> which runs once and stops, <code>yield</code> runs times you planed.\nYou can interpret <code>return</code> as <code>return one of them</code>, and <code>yield</code> as <code>return all of them</code>. This is called <code>iterable</code>.</p>\n<blockquote>\n<ol start=\"3\">\n<li>One more step we can rewrite <code>yield</code> statement with <code>return</code></li>\n</ol>\n</blockquote>\n<pre><code class=\"python\">In [15]: def num_list(n):\n    ...:     result = []\n    ...:     for i in range(n):\n    ...:         result.append(i)\n    ...:     return result\n\nIn [16]: num_list(3)\nOut[16]: [0, 1, 2]\n</code></pre>\n<p>It's the core about <code>yield</code>.</p>\n<p>The difference between a list <code>return</code> outputs and the object <code>yield</code> output is:</p>\n<p>You will always get [0, 1, 2] from a list object but only could retrieve them from 'the object <code>yield</code> output' once. So, it has a new name <code>generator</code> object as displayed in <code>Out[11]: &lt;generator object num_list at 0x10327c990&gt;</code>.</p>\n<p>In conclusion, as a metaphor to grok it:</p>\n<ul>\n<li><code>return</code> and <code>yield</code> are twins</li>\n<li><code>list</code> and <code>generator</code> are twins</li>\n</ul>\n", "abstract": "All great answers, however a bit difficult for newbies. I assume you have learned the return statement. As an analogy, return and yield are twins. return means 'return and stop' whereas 'yield` means 'return, but continue' Run it: See, you get only a single number rather than a list of them. return never allows you prevail happily, just implements once and quit. Replace return with yield: Now, you win to get all the numbers. Comparing to return which runs once and stops, yield runs times you planed.\nYou can interpret return as return one of them, and yield as return all of them. This is called iterable. It's the core about yield. The difference between a list return outputs and the object yield output is: You will always get [0, 1, 2] from a list object but only could retrieve them from 'the object yield output' once. So, it has a new name generator object as displayed in Out[11]: <generator object num_list at 0x10327c990>. In conclusion, as a metaphor to grok it:"}, {"id": 18365578, "score": 133, "vote": 0, "content": "<p>From a programming viewpoint, the iterators are implemented as <a href=\"http://en.wikipedia.org/wiki/Thunk_(functional_programming)\" rel=\"noreferrer\">thunks</a>.</p>\n<p>To implement iterators, generators, and thread pools for concurrent execution, etc. as thunks, one uses <a href=\"https://wiki.c2.com/?ClosuresAndObjectsAreEquivalent\" rel=\"noreferrer\">messages sent to a closure object</a>, which has a dispatcher, and the <a href=\"http://en.wikipedia.org/wiki/Message_passing\" rel=\"noreferrer\">dispatcher answers to \"messages\"</a>.</p>\n<p><a href=\"https://docs.python.org/3/library/functions.html#next\" rel=\"noreferrer\">\"<em>next</em>\"</a> is a message sent to a closure, created by the \"<em>iter</em>\" call.</p>\n<p>There are lots of ways to implement this computation. I used mutation, but it is possible to do this kind of computation without mutation, by returning the current value and the next yielder (making it <a href=\"https://en.wikipedia.org/wiki/Referential_transparency\" rel=\"noreferrer\">referential transparent</a>).  Racket uses a sequence of transformations of the initial program in some intermediary languages, one of such rewriting making the yield operator to be transformed in some language with simpler operators.</p>\n<p>Here is a demonstration of how yield could be rewritten, which uses the structure of R6RS, but the semantics is identical to Python's. It's the same model of computation, and only a change in syntax is required to rewrite it using yield of Python.</p>\n<blockquote>\n<pre><code class=\"python\">Welcome to Racket v6.5.0.3.\n\n-&gt; (define gen\n     (lambda (l)\n       (define yield\n         (lambda ()\n           (if (null? l)\n               'END\n               (let ((v (car l)))\n                 (set! l (cdr l))\n                 v))))\n       (lambda(m)\n         (case m\n           ('yield (yield))\n           ('init  (lambda (data)\n                     (set! l data)\n                     'OK))))))\n-&gt; (define stream (gen '(1 2 3)))\n-&gt; (stream 'yield)\n1\n-&gt; (stream 'yield)\n2\n-&gt; (stream 'yield)\n3\n-&gt; (stream 'yield)\n'END\n-&gt; ((stream 'init) '(a b))\n'OK\n-&gt; (stream 'yield)\n'a\n-&gt; (stream 'yield)\n'b\n-&gt; (stream 'yield)\n'END\n-&gt; (stream 'yield)\n'END\n-&gt;\n</code></pre>\n</blockquote>\n", "abstract": "From a programming viewpoint, the iterators are implemented as thunks. To implement iterators, generators, and thread pools for concurrent execution, etc. as thunks, one uses messages sent to a closure object, which has a dispatcher, and the dispatcher answers to \"messages\". \"next\" is a message sent to a closure, created by the \"iter\" call. There are lots of ways to implement this computation. I used mutation, but it is possible to do this kind of computation without mutation, by returning the current value and the next yielder (making it referential transparent).  Racket uses a sequence of transformations of the initial program in some intermediary languages, one of such rewriting making the yield operator to be transformed in some language with simpler operators. Here is a demonstration of how yield could be rewritten, which uses the structure of R6RS, but the semantics is identical to Python's. It's the same model of computation, and only a change in syntax is required to rewrite it using yield of Python."}, {"id": 12716515, "score": 127, "vote": 0, "content": "<p>Here are some Python examples of how to actually implement generators as if Python did not provide syntactic sugar for them:</p>\n<p><strong>As a Python generator:</strong></p>\n<pre><code class=\"python\">from itertools import islice\n\ndef fib_gen():\n    a, b = 1, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nassert [1, 1, 2, 3, 5] == list(islice(fib_gen(), 5))\n</code></pre>\n<p><strong>Using lexical closures instead of generators</strong></p>\n<pre><code class=\"python\">def ftake(fnext, last):\n    return [fnext() for _ in xrange(last)]\n\ndef fib_gen2():\n    #funky scope due to python2.x workaround\n    #for python 3.x use nonlocal\n    def _():\n        _.a, _.b = _.b, _.a + _.b\n        return _.a\n    _.a, _.b = 0, 1\n    return _\n\nassert [1,1,2,3,5] == ftake(fib_gen2(), 5)\n</code></pre>\n<p><strong>Using object closures instead of generators</strong> (because <a href=\"http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent\" rel=\"noreferrer\">ClosuresAndObjectsAreEquivalent</a>)</p>\n<pre><code class=\"python\">class fib_gen3:\n    def __init__(self):\n        self.a, self.b = 1, 1\n\n    def __call__(self):\n        r = self.a\n        self.a, self.b = self.b, self.a + self.b\n        return r\n\nassert [1,1,2,3,5] == ftake(fib_gen3(), 5)\n</code></pre>\n", "abstract": "Here are some Python examples of how to actually implement generators as if Python did not provide syntactic sugar for them: As a Python generator: Using lexical closures instead of generators Using object closures instead of generators (because ClosuresAndObjectsAreEquivalent)"}, {"id": 14554322, "score": 116, "vote": 0, "content": "<p>I was going to post \"read page 19 of Beazley's 'Python: Essential Reference' for a quick description of generators\", but so many others have posted good descriptions already.</p>\n<p>Also, note that <code>yield</code> can be used in coroutines as the dual of their use in generator functions.  Although it isn't the same use as your code snippet, <code>(yield)</code> can be used as an expression in a function.  When a caller sends a value to the method using the <code>send()</code> method, then the coroutine will execute until the next <code>(yield)</code> statement is encountered.</p>\n<p>Generators and coroutines are a cool way to set up data-flow type applications.  I thought it would be worthwhile knowing about the other use of the <code>yield</code> statement in functions.</p>\n", "abstract": "I was going to post \"read page 19 of Beazley's 'Python: Essential Reference' for a quick description of generators\", but so many others have posted good descriptions already. Also, note that yield can be used in coroutines as the dual of their use in generator functions.  Although it isn't the same use as your code snippet, (yield) can be used as an expression in a function.  When a caller sends a value to the method using the send() method, then the coroutine will execute until the next (yield) statement is encountered. Generators and coroutines are a cool way to set up data-flow type applications.  I thought it would be worthwhile knowing about the other use of the yield statement in functions."}, {"id": 20704301, "score": 100, "vote": 0, "content": "<p>Here is a simple example:</p>\n<pre><code class=\"python\">def isPrimeNumber(n):\n    print \"isPrimeNumber({}) call\".format(n)\n    if n==1:\n        return False\n    for x in range(2,n):\n        if n % x == 0:\n            return False\n    return True\n\ndef primes (n=1):\n    while(True):\n        print \"loop step ---------------- {}\".format(n)\n        if isPrimeNumber(n): yield n\n        n += 1\n\nfor n in primes():\n    if n&gt; 10:break\n    print \"wiriting result {}\".format(n)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">loop step ---------------- 1\nisPrimeNumber(1) call\nloop step ---------------- 2\nisPrimeNumber(2) call\nloop step ---------------- 3\nisPrimeNumber(3) call\nwiriting result 3\nloop step ---------------- 4\nisPrimeNumber(4) call\nloop step ---------------- 5\nisPrimeNumber(5) call\nwiriting result 5\nloop step ---------------- 6\nisPrimeNumber(6) call\nloop step ---------------- 7\nisPrimeNumber(7) call\nwiriting result 7\nloop step ---------------- 8\nisPrimeNumber(8) call\nloop step ---------------- 9\nisPrimeNumber(9) call\nloop step ---------------- 10\nisPrimeNumber(10) call\nloop step ---------------- 11\nisPrimeNumber(11) call\n</code></pre>\n<p>I am not a Python developer, but it looks to me <code>yield</code> holds the position of program flow and the next loop start from \"yield\" position. It seems like it is waiting at that position, and just before that, returning a value outside, and next time continues to work.</p>\n<p>It seems to be an interesting and nice ability :D</p>\n", "abstract": "Here is a simple example: Output: I am not a Python developer, but it looks to me yield holds the position of program flow and the next loop start from \"yield\" position. It seems like it is waiting at that position, and just before that, returning a value outside, and next time continues to work. It seems to be an interesting and nice ability :D"}, {"id": 17113322, "score": 86, "vote": 0, "content": "<p>Here is a mental image of what <code>yield</code> does.</p>\n<p>I like to think of a thread as having a stack (even when it's not implemented that way).</p>\n<p>When a normal function is called, it puts its local variables on the stack, does some computation, then clears the stack and returns. The values of its local variables are never seen again.</p>\n<p>With a <code>yield</code> function, when its code begins to run (i.e. after the function is called, returning a generator object, whose <code>next()</code> method is then invoked), it similarly puts its local variables onto the stack and computes for a while. But then, when it hits the <code>yield</code> statement, before clearing its part of the stack and returning, it takes a snapshot of its local variables and stores them in the generator object. It also writes down the place where it's currently up to in its code (i.e. the particular <code>yield</code> statement).</p>\n<p>So it's a kind of a frozen function that the generator is hanging onto.</p>\n<p>When <code>next()</code> is called subsequently, it retrieves the function's belongings onto the stack and re-animates it. The function continues to compute from where it left off, oblivious to the fact that it had just spent an eternity in cold storage.</p>\n<p>Compare the following examples:</p>\n<pre><code class=\"python\">def normalFunction():\n    return\n    if False:\n        pass\n\ndef yielderFunction():\n    return\n    if False:\n        yield 12\n</code></pre>\n<p>When we call the second function, it behaves very differently to the first. The <code>yield</code> statement might be unreachable, but if it's present anywhere, it changes the nature of what we're dealing with.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; yielderFunction()\n&lt;generator object yielderFunction at 0x07742D28&gt;\n</code></pre>\n<p>Calling <code>yielderFunction()</code> doesn't run its code, but makes a generator out of the code. (Maybe it's a good idea to name such things with the <code>yielder</code> prefix for readability.)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; gen = yielderFunction()\n&gt;&gt;&gt; dir(gen)\n['__class__',\n ...\n '__iter__',    #Returns gen itself, to make it work uniformly with containers\n ...            #when given to a for loop. (Containers return an iterator instead.)\n 'close',\n 'gi_code',\n 'gi_frame',\n 'gi_running',\n 'next',        #The method that runs the function's body.\n 'send',\n 'throw']\n</code></pre>\n<p>The <code>gi_code</code> and <code>gi_frame</code> fields are where the frozen state is stored. Exploring them with <code>dir(..)</code>, we can confirm that our mental model above is credible.</p>\n", "abstract": "Here is a mental image of what yield does. I like to think of a thread as having a stack (even when it's not implemented that way). When a normal function is called, it puts its local variables on the stack, does some computation, then clears the stack and returns. The values of its local variables are never seen again. With a yield function, when its code begins to run (i.e. after the function is called, returning a generator object, whose next() method is then invoked), it similarly puts its local variables onto the stack and computes for a while. But then, when it hits the yield statement, before clearing its part of the stack and returning, it takes a snapshot of its local variables and stores them in the generator object. It also writes down the place where it's currently up to in its code (i.e. the particular yield statement). So it's a kind of a frozen function that the generator is hanging onto. When next() is called subsequently, it retrieves the function's belongings onto the stack and re-animates it. The function continues to compute from where it left off, oblivious to the fact that it had just spent an eternity in cold storage. Compare the following examples: When we call the second function, it behaves very differently to the first. The yield statement might be unreachable, but if it's present anywhere, it changes the nature of what we're dealing with. Calling yielderFunction() doesn't run its code, but makes a generator out of the code. (Maybe it's a good idea to name such things with the yielder prefix for readability.) The gi_code and gi_frame fields are where the frozen state is stored. Exploring them with dir(..), we can confirm that our mental model above is credible."}, {"id": 55314423, "score": 81, "vote": 0, "content": "<img src=\"https://i.stack.imgur.com/AJZlN.png\" width=\"300\"/>\n<p>Imagine that you have created a remarkable machine that is capable of generating thousands and thousands of lightbulbs per day. The machine generates these lightbulbs in boxes with a unique serial number. You don't have enough space to store all of these lightbulbs at the same time, so you would like to adjust it to generate lightbulbs on-demand.</p>\n<p>Python generators don't differ much from this concept. Imagine that you have a function called <code>barcode_generator</code> that generates unique serial numbers for the boxes. Obviously, you can have a huge number of such barcodes returned by the function, subject to the hardware (RAM) limitations. A wiser, and space efficient, option is to generate those serial numbers on-demand.</p>\n<p>Machine's code:</p>\n<pre><code class=\"python\">def barcode_generator():\n    serial_number = 10000  # Initial barcode\n    while True:\n        yield serial_number\n        serial_number += 1\n\n\nbarcode = barcode_generator()\nwhile True:\n    number_of_lightbulbs_to_generate = int(input(\"How many lightbulbs to generate? \"))\n    barcodes = [next(barcode) for _ in range(number_of_lightbulbs_to_generate)]\n    print(barcodes)\n\n    # function_to_create_the_next_batch_of_lightbulbs(barcodes)\n\n    produce_more = input(\"Produce more? [Y/n]: \")\n    if produce_more == \"n\":\n        break\n</code></pre>\n<p>Note the <code>next(barcode)</code> bit.</p>\n<p>As you can see, we have a self-contained \u201cfunction\u201d to generate the next unique serial number each time. This function returns a <em>generator</em>! As you can see, we are not calling the function each time we need a new serial number, but instead we are using <code>next()</code> given the generator to obtain the next serial number.</p>\n<h1>Lazy Iterators</h1>\n<p>To be more precise, this generator is a <em>lazy iterator</em>! An iterator is an object that helps us traverse a sequence of objects. It's called <em>lazy</em> because it does not load all the items of the sequence in memory until they are needed. The use of <code>next</code> in the previous example is the <em>explicit</em> way to obtain the next item from the iterator. The <em>implicit</em> way is using for loops:</p>\n<pre><code class=\"python\">for barcode in barcode_generator():\n    print(barcode)\n</code></pre>\n<p>This will print barcodes infinitely, yet you will not run out of memory.</p>\n<p><strong>In other words, a generator <em>looks like</em> a function but <em>behaves like</em> an iterator.</strong></p>\n<h1>Real-world application?</h1>\n<p>Finally, real-world applications? They are usually useful when you work with big sequences. Imagine reading a <em>huge</em> file from disk with billions of records. Reading the entire file in memory, before you can work with its content, will probably be infeasible (i.e., you will run out of memory).</p>\n", "abstract": "Imagine that you have created a remarkable machine that is capable of generating thousands and thousands of lightbulbs per day. The machine generates these lightbulbs in boxes with a unique serial number. You don't have enough space to store all of these lightbulbs at the same time, so you would like to adjust it to generate lightbulbs on-demand. Python generators don't differ much from this concept. Imagine that you have a function called barcode_generator that generates unique serial numbers for the boxes. Obviously, you can have a huge number of such barcodes returned by the function, subject to the hardware (RAM) limitations. A wiser, and space efficient, option is to generate those serial numbers on-demand. Machine's code: Note the next(barcode) bit. As you can see, we have a self-contained \u201cfunction\u201d to generate the next unique serial number each time. This function returns a generator! As you can see, we are not calling the function each time we need a new serial number, but instead we are using next() given the generator to obtain the next serial number. To be more precise, this generator is a lazy iterator! An iterator is an object that helps us traverse a sequence of objects. It's called lazy because it does not load all the items of the sequence in memory until they are needed. The use of next in the previous example is the explicit way to obtain the next item from the iterator. The implicit way is using for loops: This will print barcodes infinitely, yet you will not run out of memory. In other words, a generator looks like a function but behaves like an iterator. Finally, real-world applications? They are usually useful when you work with big sequences. Imagine reading a huge file from disk with billions of records. Reading the entire file in memory, before you can work with its content, will probably be infeasible (i.e., you will run out of memory)."}, {"id": 41426583, "score": 78, "vote": 0, "content": "<p>An easy example to understand what it is: <code>yield</code></p>\n<pre><code class=\"python\">def f123():\n    for _ in range(4):\n        yield 1\n        yield 2\n\n\nfor i in f123():\n    print (i)\n</code></pre>\n<p>The output is: </p>\n<pre><code class=\"python\">1 2 1 2 1 2 1 2\n</code></pre>\n", "abstract": "An easy example to understand what it is: yield The output is: "}, {"id": 31692481, "score": 74, "vote": 0, "content": "<p>Like every answer suggests, <code>yield</code> is used for creating a sequence generator. It's used for generating some sequence dynamically. For example, while reading a file line by line on a network, you can use the <code>yield</code> function as follows:</p>\n<pre><code class=\"python\">def getNextLines():\n   while con.isOpen():\n       yield con.read()\n</code></pre>\n<p>You can use it in your code as follows:</p>\n<pre><code class=\"python\">for line in getNextLines():\n    doSomeThing(line)\n</code></pre>\n<p><strong><em>Execution Control Transfer gotcha</em></strong></p>\n<p>The execution control will be transferred from getNextLines() to the <code>for</code> loop when yield is executed. Thus, every time getNextLines() is invoked, execution begins from the point where it was paused last time.</p>\n<p>Thus in short, a function with the following code</p>\n<pre><code class=\"python\">def simpleYield():\n    yield \"first time\"\n    yield \"second time\"\n    yield \"third time\"\n    yield \"Now some useful value {}\".format(12)\n\nfor i in simpleYield():\n    print i\n</code></pre>\n<p>will print</p>\n<pre><code class=\"python\">\"first time\"\n\"second time\"\n\"third time\"\n\"Now some useful value 12\"\n</code></pre>\n", "abstract": "Like every answer suggests, yield is used for creating a sequence generator. It's used for generating some sequence dynamically. For example, while reading a file line by line on a network, you can use the yield function as follows: You can use it in your code as follows: Execution Control Transfer gotcha The execution control will be transferred from getNextLines() to the for loop when yield is executed. Thus, every time getNextLines() is invoked, execution begins from the point where it was paused last time. Thus in short, a function with the following code will print"}, {"id": 36214653, "score": 72, "vote": 0, "content": "<p>(My below answer only speaks from the perspective of using Python generator, not the <a href=\"https://stackoverflow.com/questions/8389812/how-are-generators-and-coroutines-implemented-in-cpython\">underlying implementation of generator mechanism</a>, which involves some tricks of stack and heap manipulation.)</p>\n<p>When <code>yield</code> is used instead of a <code>return</code> in a python function, that function is turned into something special called <code>generator function</code>. That function will return an object of <code>generator</code> type. <strong>The <code>yield</code> keyword is a flag to notify the python compiler to treat such function specially.</strong> Normal functions will terminate once some value is returned from it. But with the help of the compiler, the generator function <strong>can be thought of</strong> as resumable. That is, the execution context will be restored and the execution will continue from last run. Until you explicitly call return, which will raise a <code>StopIteration</code> exception (which is also part of the iterator protocol), or reach the end of the function. I found a lot of references about <code>generator</code> but this <a href=\"https://docs.python.org/dev/howto/functional.html#generators\" rel=\"noreferrer\">one</a> from the <code>functional programming perspective</code> is the most digestable.</p>\n<p>(Now I want to talk about the rationale behind <code>generator</code>, and the <code>iterator</code> based on my own understanding. I hope this can help you grasp the <strong><em>essential motivation</em></strong> of iterator and generator. Such concept shows up in other languages as well such as C#.)</p>\n<p>As I understand, when we want to process a bunch of data, we usually first store the data somewhere and then process it one by one. But this <em>naive</em> approach is problematic. If the data volume is huge, it's expensive to store them as a whole beforehand. <strong>So instead of storing the <code>data</code> itself directly, why not store some kind of <code>metadata</code> indirectly, i.e. <code>the logic how the data is computed</code></strong>. </p>\n<p>There are 2 approaches to wrap such metadata.</p>\n<ol>\n<li>The OO approach, we wrap the metadata <code>as a class</code>. This is the so-called <code>iterator</code> who implements the iterator protocol (i.e. the <code>__next__()</code>, and <code>__iter__()</code> methods). This is also the commonly seen <a href=\"https://en.wikipedia.org/wiki/Iterator_pattern#Python\" rel=\"noreferrer\">iterator design pattern</a>.</li>\n<li>The functional approach, we wrap the metadata <code>as a function</code>. This is\nthe so-called <code>generator function</code>. But under the hood, the returned <code>generator object</code> still <code>IS-A</code> iterator because it also implements the iterator protocol.</li>\n</ol>\n<p>Either way, an iterator is created, i.e. some object that can give you the data you want. The OO approach may be a bit complex. Anyway, which one to use is up to you.</p>\n", "abstract": "(My below answer only speaks from the perspective of using Python generator, not the underlying implementation of generator mechanism, which involves some tricks of stack and heap manipulation.) When yield is used instead of a return in a python function, that function is turned into something special called generator function. That function will return an object of generator type. The yield keyword is a flag to notify the python compiler to treat such function specially. Normal functions will terminate once some value is returned from it. But with the help of the compiler, the generator function can be thought of as resumable. That is, the execution context will be restored and the execution will continue from last run. Until you explicitly call return, which will raise a StopIteration exception (which is also part of the iterator protocol), or reach the end of the function. I found a lot of references about generator but this one from the functional programming perspective is the most digestable. (Now I want to talk about the rationale behind generator, and the iterator based on my own understanding. I hope this can help you grasp the essential motivation of iterator and generator. Such concept shows up in other languages as well such as C#.) As I understand, when we want to process a bunch of data, we usually first store the data somewhere and then process it one by one. But this naive approach is problematic. If the data volume is huge, it's expensive to store them as a whole beforehand. So instead of storing the data itself directly, why not store some kind of metadata indirectly, i.e. the logic how the data is computed.  There are 2 approaches to wrap such metadata. Either way, an iterator is created, i.e. some object that can give you the data you want. The OO approach may be a bit complex. Anyway, which one to use is up to you."}, {"id": 40022748, "score": 71, "vote": 0, "content": "<p>In summary, the <code>yield</code> statement transforms your function into a factory that produces a special object called a <code>generator</code> which wraps around the body of your original function. When the <code>generator</code> is iterated, it executes your function  until it reaches the next <code>yield</code> then suspends execution and evaluates to the value passed to <code>yield</code>. It repeats this process on each iteration until the path of execution exits the function. For instance,</p>\n<pre><code class=\"python\">def simple_generator():\n    yield 'one'\n    yield 'two'\n    yield 'three'\n\nfor i in simple_generator():\n    print i\n</code></pre>\n<p>simply outputs</p>\n<pre><code class=\"python\">one\ntwo\nthree\n</code></pre>\n<p>The power comes from using the generator with a loop that calculates a sequence, the generator executes the loop stopping each time to 'yield' the next result of the calculation, in this way it calculates a list on the fly, the benefit being the memory saved for especially large calculations</p>\n<p>Say you wanted to create a your own <code>range</code> function that produces an iterable range of numbers, you could do it like so,</p>\n<pre><code class=\"python\">def myRangeNaive(i):\n    n = 0\n    range = []\n    while n &lt; i:\n        range.append(n)\n        n = n + 1\n    return range\n</code></pre>\n<p>and use it like this;</p>\n<pre><code class=\"python\">for i in myRangeNaive(10):\n    print i\n</code></pre>\n<p>But this is inefficient because</p>\n<ul>\n<li>You create an array that you only use once (this wastes memory)</li>\n<li>This code actually loops over that array twice! :(</li>\n</ul>\n<p>Luckily Guido and his team were generous enough to develop generators so we could just do this;</p>\n<pre><code class=\"python\">def myRangeSmart(i):\n    n = 0\n    while n &lt; i:\n       yield n\n       n = n + 1\n    return\n\nfor i in myRangeSmart(10):\n    print i\n</code></pre>\n<p>Now upon each iteration a function on the generator called <code>next()</code> executes the function until it either reaches a 'yield' statement in which it stops and  'yields' the value or reaches the end of the function. In this case on the first call, <code>next()</code> executes up to the yield statement and yield 'n', on the next call it will execute the  increment statement, jump back to the 'while', evaluate it, and if true, it will stop and yield 'n' again, it will continue that way until the while condition returns false and the generator jumps to the end of the function.</p>\n", "abstract": "In summary, the yield statement transforms your function into a factory that produces a special object called a generator which wraps around the body of your original function. When the generator is iterated, it executes your function  until it reaches the next yield then suspends execution and evaluates to the value passed to yield. It repeats this process on each iteration until the path of execution exits the function. For instance, simply outputs The power comes from using the generator with a loop that calculates a sequence, the generator executes the loop stopping each time to 'yield' the next result of the calculation, in this way it calculates a list on the fly, the benefit being the memory saved for especially large calculations Say you wanted to create a your own range function that produces an iterable range of numbers, you could do it like so, and use it like this; But this is inefficient because Luckily Guido and his team were generous enough to develop generators so we could just do this; Now upon each iteration a function on the generator called next() executes the function until it either reaches a 'yield' statement in which it stops and  'yields' the value or reaches the end of the function. In this case on the first call, next() executes up to the yield statement and yield 'n', on the next call it will execute the  increment statement, jump back to the 'while', evaluate it, and if true, it will stop and yield 'n' again, it will continue that way until the while condition returns false and the generator jumps to the end of the function."}, {"id": 32331953, "score": 67, "vote": 0, "content": "<p><strong>Yield is an object</strong></p>\n<p>A <code>return</code> in a function will return a single value.</p>\n<p>If you want <strong>a function to return a huge set of values</strong>, use <code>yield</code>.</p>\n<p>More importantly, <code>yield</code> is a <strong>barrier</strong>.</p>\n<blockquote>\n<p>like barrier in the CUDA language, it will not transfer control until it gets\n  completed.</p>\n</blockquote>\n<p>That is, it will run the code in your function from the beginning until it hits <code>yield</code>. Then, it\u2019ll return the first value of the loop.</p>\n<p>Then, every other call will run the loop you have written in the function one more time, returning the next value until there isn't any value to return.</p>\n", "abstract": "Yield is an object A return in a function will return a single value. If you want a function to return a huge set of values, use yield. More importantly, yield is a barrier. like barrier in the CUDA language, it will not transfer control until it gets\n  completed. That is, it will run the code in your function from the beginning until it hits yield. Then, it\u2019ll return the first value of the loop. Then, every other call will run the loop you have written in the function one more time, returning the next value until there isn't any value to return."}, {"id": 39425637, "score": 65, "vote": 0, "content": "<p>Many people use <code>return</code> rather than <code>yield</code>, but in some cases <code>yield</code> can be more efficient and easier to work with.</p>\n<p>Here is an example which <code>yield</code> is definitely best for:</p>\n<blockquote>\n<p><strong>return</strong> (in function)</p>\n</blockquote>\n<pre><code class=\"python\">import random\n\ndef return_dates():\n    dates = [] # With 'return' you need to create a list then return it\n    for i in range(5):\n        date = random.choice([\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\", \"6th\", \"7th\", \"8th\", \"9th\", \"10th\"])\n        dates.append(date)\n    return dates\n</code></pre>\n<blockquote>\n<p><strong>yield</strong> (in function)</p>\n</blockquote>\n<pre><code class=\"python\">def yield_dates():\n    for i in range(5):\n        date = random.choice([\"1st\", \"2nd\", \"3rd\", \"4th\", \"5th\", \"6th\", \"7th\", \"8th\", \"9th\", \"10th\"])\n        yield date # 'yield' makes a generator automatically which works\n                   # in a similar way. This is much more efficient.\n</code></pre>\n<blockquote>\n<p><strong>Calling functions</strong></p>\n</blockquote>\n<pre><code class=\"python\">dates_list = return_dates()\nprint(dates_list)\nfor i in dates_list:\n    print(i)\n\ndates_generator = yield_dates()\nprint(dates_generator)\nfor i in dates_generator:\n    print(i)\n</code></pre>\n<p>Both functions do the same thing, but <code>yield</code> uses three lines instead of five and has one less variable to worry about.</p>\n<blockquote>\n<blockquote>\n<p><strong>This is the result from the code:</strong></p>\n</blockquote>\n</blockquote>\n<p><a href=\"https://i.stack.imgur.com/iUFNJ.png\" rel=\"noreferrer\"><img alt=\"Output\" src=\"https://i.stack.imgur.com/iUFNJ.png\"/></a></p>\n<p>As you can see both functions do the same thing. The only difference is <code>return_dates()</code> gives a list and <code>yield_dates()</code> gives a generator.</p>\n<p>A real life example would be something like reading a file line by line or if you just want to make a generator.</p>\n", "abstract": "Many people use return rather than yield, but in some cases yield can be more efficient and easier to work with. Here is an example which yield is definitely best for: return (in function) yield (in function) Calling functions Both functions do the same thing, but yield uses three lines instead of five and has one less variable to worry about. This is the result from the code:  As you can see both functions do the same thing. The only difference is return_dates() gives a list and yield_dates() gives a generator. A real life example would be something like reading a file line by line or if you just want to make a generator."}, {"id": 33788856, "score": 55, "vote": 0, "content": "<p>The <code>yield</code> keyword simply collects returning results. Think of <code>yield</code> like <code>return +=</code></p>\n", "abstract": "The yield keyword simply collects returning results. Think of yield like return +="}, {"id": 30341713, "score": 52, "vote": 0, "content": "<p><code>yield</code> is like a return element for a function. The difference is, that the <code>yield</code> element turns a function into a generator. A generator behaves just like a function until something is 'yielded'. The generator stops until it is next called, and continues from exactly the same point as it started. You can get a sequence of all the 'yielded' values in one, by calling <code>list(generator())</code>.</p>\n", "abstract": "yield is like a return element for a function. The difference is, that the yield element turns a function into a generator. A generator behaves just like a function until something is 'yielded'. The generator stops until it is next called, and continues from exactly the same point as it started. You can get a sequence of all the 'yielded' values in one, by calling list(generator())."}, {"id": 37964180, "score": 49, "vote": 0, "content": "<p>Yet another TL;DR</p>\n<p><strong>Iterator on list</strong>: <code>next()</code> returns the next element of the list</p>\n<p><strong>Iterator generator</strong>: <code>next()</code> will compute the next element on the fly (execute code)</p>\n<p>You can see the yield/generator as a way to manually run the <strong>control flow</strong> from outside (like continue loop one step), by calling <code>next</code>, however complex the flow.</p>\n<p><strong>Note</strong>: The generator is <strong>NOT</strong> a normal function. It remembers the previous state like local variables (stack). See other answers or articles for detailed explanation. The generator can only be <strong>iterated on once</strong>. You could do without <code>yield</code>, but it would not be as nice, so it can be considered 'very nice' language sugar.</p>\n", "abstract": "Yet another TL;DR Iterator on list: next() returns the next element of the list Iterator generator: next() will compute the next element on the fly (execute code) You can see the yield/generator as a way to manually run the control flow from outside (like continue loop one step), by calling next, however complex the flow. Note: The generator is NOT a normal function. It remembers the previous state like local variables (stack). See other answers or articles for detailed explanation. The generator can only be iterated on once. You could do without yield, but it would not be as nice, so it can be considered 'very nice' language sugar."}, {"id": 35526740, "score": 45, "vote": 0, "content": "<p>Here's a simple <code>yield</code> based approach, to compute the fibonacci series, explained:</p>\n<pre><code class=\"python\">def fib(limit=50):\n    a, b = 0, 1\n    for i in range(limit):\n       yield b\n       a, b = b, a+b\n</code></pre>\n<p>When you enter this into your REPL and then try and call it, you'll get a mystifying result:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; fib()\n&lt;generator object fib at 0x7fa38394e3b8&gt;\n</code></pre>\n<p>This is because the presence of <code>yield</code> signaled to Python that you want to create a <em>generator</em>, that is, an object that generates values on demand.</p>\n<p>So, how do you generate these values? This can either be done directly by using the built-in function <code>next</code>, or, indirectly by feeding it to a construct that consumes values. </p>\n<p>Using the built-in <code>next()</code> function, you directly invoke <code>.next</code>/<code>__next__</code>, forcing the generator to produce a value:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; g = fib()\n&gt;&gt;&gt; next(g)\n1\n&gt;&gt;&gt; next(g)\n1\n&gt;&gt;&gt; next(g)\n2\n&gt;&gt;&gt; next(g)\n3\n&gt;&gt;&gt; next(g)\n5\n</code></pre>\n<p>Indirectly, if you provide <code>fib</code> to a <code>for</code> loop, a <code>list</code> initializer, a <code>tuple</code> initializer, or anything else that expects an object that generates/produces values, you'll \"consume\" the generator until no more values can be produced by it (and it returns):</p>\n<pre><code class=\"python\">results = []\nfor i in fib(30):       # consumes fib\n    results.append(i) \n# can also be accomplished with\nresults = list(fib(30)) # consumes fib\n</code></pre>\n<p>Similarly, with a <code>tuple</code> initializer: </p>\n<pre><code class=\"python\">&gt;&gt;&gt; tuple(fib(5))       # consumes fib\n(1, 1, 2, 3, 5)\n</code></pre>\n<p>A generator differs from a function in the sense that it is lazy. It accomplishes this by maintaining it's local state and allowing you to resume whenever you need to. </p>\n<p>When you first invoke <code>fib</code> by calling it:</p>\n<pre><code class=\"python\">f = fib()\n</code></pre>\n<p>Python compiles the function, encounters the <code>yield</code> keyword and simply returns a generator object back at you. Not very helpful it seems. </p>\n<p>When you then request it generates the first value, directly or indirectly, it executes all statements that it finds, until it encounters a <code>yield</code>, it then yields back the value you supplied to <code>yield</code> and pauses. For an example that better demonstrates this, let's use some <code>print</code> calls (replace with <code>print \"text\"</code> if on Python 2):</p>\n<pre><code class=\"python\">def yielder(value):\n    \"\"\" This is an infinite generator. Only use next on it \"\"\" \n    while 1:\n        print(\"I'm going to generate the value for you\")\n        print(\"Then I'll pause for a while\")\n        yield value\n        print(\"Let's go through it again.\")\n</code></pre>\n<p>Now, enter in the REPL:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; gen = yielder(\"Hello, yield!\")\n</code></pre>\n<p>you have a generator object now waiting for a command for it to generate a value. Use <code>next</code> and see what get's printed:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; next(gen) # runs until it finds a yield\nI'm going to generate the value for you\nThen I'll pause for a while\n'Hello, yield!'\n</code></pre>\n<p>The unquoted results are what's printed. The quoted result is what is returned from <code>yield</code>. Call <code>next</code> again now:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; next(gen) # continues from yield and runs again\nLet's go through it again.\nI'm going to generate the value for you\nThen I'll pause for a while\n'Hello, yield!'\n</code></pre>\n<p>The generator remembers it was paused at <code>yield value</code> and resumes from there. The next message is printed and the search for the <code>yield</code> statement to pause at it performed again (due to the <code>while</code> loop).</p>\n", "abstract": "Here's a simple yield based approach, to compute the fibonacci series, explained: When you enter this into your REPL and then try and call it, you'll get a mystifying result: This is because the presence of yield signaled to Python that you want to create a generator, that is, an object that generates values on demand. So, how do you generate these values? This can either be done directly by using the built-in function next, or, indirectly by feeding it to a construct that consumes values.  Using the built-in next() function, you directly invoke .next/__next__, forcing the generator to produce a value: Indirectly, if you provide fib to a for loop, a list initializer, a tuple initializer, or anything else that expects an object that generates/produces values, you'll \"consume\" the generator until no more values can be produced by it (and it returns): Similarly, with a tuple initializer:  A generator differs from a function in the sense that it is lazy. It accomplishes this by maintaining it's local state and allowing you to resume whenever you need to.  When you first invoke fib by calling it: Python compiles the function, encounters the yield keyword and simply returns a generator object back at you. Not very helpful it seems.  When you then request it generates the first value, directly or indirectly, it executes all statements that it finds, until it encounters a yield, it then yields back the value you supplied to yield and pauses. For an example that better demonstrates this, let's use some print calls (replace with print \"text\" if on Python 2): Now, enter in the REPL: you have a generator object now waiting for a command for it to generate a value. Use next and see what get's printed: The unquoted results are what's printed. The quoted result is what is returned from yield. Call next again now: The generator remembers it was paused at yield value and resumes from there. The next message is printed and the search for the yield statement to pause at it performed again (due to the while loop)."}, {"id": 43698502, "score": 40, "vote": 0, "content": "<p><strong>yield</strong> is similar to return. The difference is: </p>\n<p><strong>yield</strong> makes a function iterable (in the following example <code>primes(n = 1)</code> function becomes iterable).<br/>\nWhat it essentially means is the next time the function is called, it will continue from where it left (which is after the line of <code>yield expression</code>).</p>\n<pre><code class=\"python\">def isprime(n):\n    if n == 1:\n        return False\n    for x in range(2, n):\n        if n % x == 0:\n            return False\n    else:\n        return True\n\ndef primes(n = 1):\n   while(True):\n       if isprime(n): yield n\n       n += 1 \n\nfor n in primes():\n    if n &gt; 100: break\n    print(n)\n</code></pre>\n<p>In the above example if <code>isprime(n)</code> is true it will return the prime number. In the next iteration it will continue from the next line </p>\n<pre><code class=\"python\">n += 1  \n</code></pre>\n", "abstract": "yield is similar to return. The difference is:  yield makes a function iterable (in the following example primes(n = 1) function becomes iterable).\nWhat it essentially means is the next time the function is called, it will continue from where it left (which is after the line of yield expression). In the above example if isprime(n) is true it will return the prime number. In the next iteration it will continue from the next line "}, {"id": 52244968, "score": 31, "vote": 0, "content": "<p>In Python <code>generators</code> (a special type of <code>iterators</code>) are used to generate series of values and <code>yield</code> keyword is just like the <code>return</code> keyword of generator functions. </p>\n<p><strong>The other fascinating thing <code>yield</code> keyword  does is saving the <code>state</code> of a generator function</strong>. </p>\n<p>So, we can set a <code>number</code> to a different value each time the <code>generator</code> yields. </p>\n<p>Here's an instance:</p>\n<pre><code class=\"python\">def getPrimes(number):\n    while True:\n        if isPrime(number):\n            number = yield number     # a miracle occurs here\n        number += 1\n\ndef printSuccessivePrimes(iterations, base=10):\n    primeGenerator = getPrimes(base)\n    primeGenerator.send(None)\n    for power in range(iterations):\n        print(primeGenerator.send(base ** power))\n</code></pre>\n", "abstract": "In Python generators (a special type of iterators) are used to generate series of values and yield keyword is just like the return keyword of generator functions.  The other fascinating thing yield keyword  does is saving the state of a generator function.  So, we can set a number to a different value each time the generator yields.  Here's an instance:"}, {"id": 54826880, "score": 30, "vote": 0, "content": "<p><code>yield</code> yields something. It's like somebody asks you to make 5 cupcakes. If you are done with at least one cupcake, you can give it to them to eat while you make other cakes.</p>\n<pre><code class=\"python\">In [4]: def make_cake(numbers):\n   ...:     for i in range(numbers):\n   ...:         yield 'Cake {}'.format(i)\n   ...:\n\nIn [5]: factory = make_cake(5)\n</code></pre>\n<p>Here <code>factory</code> is called a generator, which makes you cakes. If you call <code>make_function</code>, you get a generator instead of running that function. It is because when <code>yield</code> keyword is present in a function, it becomes a generator.</p>\n<pre><code class=\"python\">In [7]: next(factory)\nOut[7]: 'Cake 0'\n\nIn [8]: next(factory)\nOut[8]: 'Cake 1'\n\nIn [9]: next(factory)\nOut[9]: 'Cake 2'\n\nIn [10]: next(factory)\nOut[10]: 'Cake 3'\n\nIn [11]: next(factory)\nOut[11]: 'Cake 4'\n</code></pre>\n<p>They consumed all the cakes, but they ask for one again.</p>\n<pre><code class=\"python\">In [12]: next(factory)\n---------------------------------------------------------------------------\nStopIteration                             Traceback (most recent call last)\n&lt;ipython-input-12-0f5c45da9774&gt; in &lt;module&gt;\n----&gt; 1 next(factory)\n\nStopIteration:\n</code></pre>\n<p>and they are being told to stop asking more. So once you consumed a generator you are done with it. You need to call <code>make_cake</code> again if you want more cakes. It is like placing another order for cupcakes.</p>\n<pre><code class=\"python\">In [13]: factory = make_cake(3)\n\nIn [14]: for cake in factory:\n    ...:     print(cake)\n    ...:\nCake 0\nCake 1\nCake 2\n</code></pre>\n<p>You can also use for loop with a generator like the one above.</p>\n<p>One more example: Lets say you want a random password whenever you ask for it.</p>\n<pre><code class=\"python\">In [22]: import random\n\nIn [23]: import string\n\nIn [24]: def random_password_generator():\n    ...:     while True:\n    ...:         yield ''.join([random.choice(string.ascii_letters) for _ in range(8)])\n    ...:\n\nIn [25]: rpg = random_password_generator()\n\nIn [26]: for i in range(3):\n    ...:     print(next(rpg))\n    ...:\nFXpUBhhH\nDdUDHoHn\ndvtebEqG\n\nIn [27]: next(rpg)\nOut[27]: 'mJbYRMNo'\n</code></pre>\n<p>Here <code>rpg</code> is a generator, which can generate an infinite number of random passwords. So we can also say that generators are useful when we don't know the length of the sequence, unlike list which has a finite number of elements.</p>\n", "abstract": "yield yields something. It's like somebody asks you to make 5 cupcakes. If you are done with at least one cupcake, you can give it to them to eat while you make other cakes. Here factory is called a generator, which makes you cakes. If you call make_function, you get a generator instead of running that function. It is because when yield keyword is present in a function, it becomes a generator. They consumed all the cakes, but they ask for one again. and they are being told to stop asking more. So once you consumed a generator you are done with it. You need to call make_cake again if you want more cakes. It is like placing another order for cupcakes. You can also use for loop with a generator like the one above. One more example: Lets say you want a random password whenever you ask for it. Here rpg is a generator, which can generate an infinite number of random passwords. So we can also say that generators are useful when we don't know the length of the sequence, unlike list which has a finite number of elements."}, {"id": 46543549, "score": 22, "vote": 0, "content": "<p>All of the answers here are great; but only one of them (the most voted one) relates to <strong>how your code works</strong>. Others are relating to <em>generators</em> in general, and how they work.</p>\n<p>So I won't repeat what generators are or what yields do; I think these are covered by great existing answers. However, after spending few hours trying to understand a similar code to yours, I'll break it down how it works.</p>\n<p>Your code traverse a binary tree structure. Let's take this tree for example:</p>\n<pre><code class=\"python\">    5\n   / \\\n  3   6\n / \\   \\\n1   4   8\n</code></pre>\n<p>And another simpler implementation of a binary-search tree traversal:</p>\n<pre><code class=\"python\">class Node(object):\n..\ndef __iter__(self):\n    if self.has_left_child():\n        for child in self.left:\n            yield child\n\n    yield self.val\n\n    if self.has_right_child():\n        for child in self.right:\n            yield child\n</code></pre>\n<p>The execution code is on the <code>Tree</code> object, which implements <code>__iter__</code> as this:</p>\n<pre><code class=\"python\">def __iter__(self):\n\n    class EmptyIter():\n        def next(self):\n            raise StopIteration\n\n    if self.root:\n        return self.root.__iter__()\n    return EmptyIter()\n</code></pre>\n<p>The <code>while candidates</code> statement can be replaced with <code>for element in tree</code>; Python translate this to</p>\n<pre><code class=\"python\">it = iter(TreeObj)  # returns iter(self.root) which calls self.root.__iter__()\nfor element in it: \n    .. process element .. \n</code></pre>\n<p>Because <code>Node.__iter__</code> function is a generator, the code <strong>inside it</strong> is executed per iteration. So the execution would look like this:</p>\n<ol>\n<li>root element is first; check if it has left childs and <code>for</code> iterate them (let's call it it1 because its the first iterator object)</li>\n<li>it has a child so the <code>for</code> is executed. The <code>for child in self.left</code> creates a <strong>new iterator</strong> from <code>self.left</code>, which is a Node object itself (it2)</li>\n<li>Same logic as 2, and a new <code>iterator</code> is created (it3)</li>\n<li>Now we reached the left end of the tree. <code>it3</code> has no left childs so it continues and <code>yield self.value</code></li>\n<li>On the next call to <code>next(it3)</code> it raises <code>StopIteration</code> and exists since it has no right childs (it reaches to the end of the function without yield anything)</li>\n<li><code>it1</code> and <code>it2</code> are still active - they are not exhausted and calling <code>next(it2)</code> would yield values, not raise <code>StopIteration</code></li>\n<li>Now we are back to <code>it2</code> context, and call <code>next(it2)</code> which continues where it stopped: right after the <code>yield child</code> statement. Since it has no more left childs it continues and yields it's <code>self.val</code>.</li>\n</ol>\n<p>The catch here is that every iteration <strong>creates sub-iterators</strong> to traverse the tree, and holds the state of the current iterator. Once it reaches the end it traverse back the stack, and values are returned in the correct order (smallest yields value first).</p>\n<p>Your code example did something similar in a different technique: it populated a <strong>one-element list</strong> for every child, then on the next iteration it pops it and run the function code on the current object (hence the <code>self</code>).</p>\n<p>I hope this contributed a little to this legendary topic. I spent several good hours drawing this process to understand it.</p>\n", "abstract": "All of the answers here are great; but only one of them (the most voted one) relates to how your code works. Others are relating to generators in general, and how they work. So I won't repeat what generators are or what yields do; I think these are covered by great existing answers. However, after spending few hours trying to understand a similar code to yours, I'll break it down how it works. Your code traverse a binary tree structure. Let's take this tree for example: And another simpler implementation of a binary-search tree traversal: The execution code is on the Tree object, which implements __iter__ as this: The while candidates statement can be replaced with for element in tree; Python translate this to Because Node.__iter__ function is a generator, the code inside it is executed per iteration. So the execution would look like this: The catch here is that every iteration creates sub-iterators to traverse the tree, and holds the state of the current iterator. Once it reaches the end it traverse back the stack, and values are returned in the correct order (smallest yields value first). Your code example did something similar in a different technique: it populated a one-element list for every child, then on the next iteration it pops it and run the function code on the current object (hence the self). I hope this contributed a little to this legendary topic. I spent several good hours drawing this process to understand it."}, {"id": 70521893, "score": 17, "vote": 0, "content": "<p>The <code>yield</code> keyword in Python used to exit from the code without disturbing the state of local variables and when again the function is called the execution starts from the last point where we left the code.</p>\n<p>The below example demonstrates the working of <code>yield</code>:</p>\n<pre><code class=\"python\">def counter():\n    x=2\n    while x &lt; 5:\n        yield x\n        x += 1\n        \nprint(\"Initial value of x: \", counter()) \n\nfor y in counter():\n    print(y)\n</code></pre>\n<p>The above code generates the Below output:</p>\n<pre><code class=\"python\">Initial value of x:  &lt;generator object counter at 0x7f0263020ac0&gt;\n2\n3\n4\n</code></pre>\n", "abstract": "The yield keyword in Python used to exit from the code without disturbing the state of local variables and when again the function is called the execution starts from the last point where we left the code. The below example demonstrates the working of yield: The above code generates the Below output:"}, {"id": 63533381, "score": 16, "vote": 0, "content": "<h2>Can also send data back to the generator!</h2>\n<p>Indeed, as many answers here explain, using <code>yield</code> creates a <code>generator</code>.</p>\n<p>You can use the <code>yield</code> keyword to <strong>send data back to a \"live\" generator</strong>.</p>\n<h3>Example:</h3>\n<p>Let's say we have a method which translates from english to some other language. And in the beginning of it, it does something which is heavy and should be done once. We want this method run forever (don't really know why.. :)), and receive words words to be translated.</p>\n<pre><code class=\"python\">def translator():\n    # load all the words in English language and the translation to 'other lang'\n    my_words_dict = {'hello': 'hello in other language', 'dog': 'dog in other language'}\n\n    while True:\n        word = (yield)\n        yield my_words_dict.get(word, 'Unknown word...')\n</code></pre>\n<p>Running:</p>\n<pre><code class=\"python\">my_words_translator = translator()\n\nnext(my_words_translator)\nprint(my_words_translator.send('dog'))\n\nnext(my_words_translator)\nprint(my_words_translator.send('cat'))\n</code></pre>\n<p>will print:</p>\n<pre><code class=\"python\">dog in other language\nUnknown word...\n</code></pre>\n<h3>To summarise:</h3>\n<p>use <code>send</code> method inside a generator to send data back to the generator. To allow that, a <code>(yield)</code> is used.</p>\n", "abstract": "Indeed, as many answers here explain, using yield creates a generator. You can use the yield keyword to send data back to a \"live\" generator. Let's say we have a method which translates from english to some other language. And in the beginning of it, it does something which is heavy and should be done once. We want this method run forever (don't really know why.. :)), and receive words words to be translated. Running: will print: use send method inside a generator to send data back to the generator. To allow that, a (yield) is used."}, {"id": 59785342, "score": 12, "vote": 0, "content": "<p>yield in python is in a way similar to the return statement, except for some differences. If multiple values have to be returned from a function, return statement will return all the values as a list and it has to be stored in the memory in the caller block. But what if we don't want to use extra memory? Instead, we want to get the value from the function when we need it. This is where yield comes in. Consider the following function :-</p>\n<pre><code class=\"python\">def fun():\n   yield 1\n   yield 2\n   yield 3\n</code></pre>\n<p>And the caller is :-</p>\n<pre><code class=\"python\">def caller():\n   print ('First value printing')\n   print (fun())\n   print ('Second value printing')\n   print (fun())\n   print ('Third value printing')\n   print (fun())\n</code></pre>\n<p>The above code segment (caller function) when called, outputs :-</p>\n<pre><code class=\"python\">First value printing\n1\nSecond value printing\n2\nThird value printing\n3\n</code></pre>\n<p>As can be seen from above, yield returns a value to its caller, but when the function is called again, it doesn't start from the first statement, but from the statement right after the yield. In the above example, \"First value printing\" was printed and the function was called. 1 was returned and printed. Then \"Second value printing\" was printed and again fun() was called. Instead of printing 1 (the first statement), it returned 2, i.e., the statement just after yield 1. The same process is repeated further.</p>\n", "abstract": "yield in python is in a way similar to the return statement, except for some differences. If multiple values have to be returned from a function, return statement will return all the values as a list and it has to be stored in the memory in the caller block. But what if we don't want to use extra memory? Instead, we want to get the value from the function when we need it. This is where yield comes in. Consider the following function :- And the caller is :- The above code segment (caller function) when called, outputs :- As can be seen from above, yield returns a value to its caller, but when the function is called again, it doesn't start from the first statement, but from the statement right after the yield. In the above example, \"First value printing\" was printed and the function was called. 1 was returned and printed. Then \"Second value printing\" was printed and again fun() was called. Instead of printing 1 (the first statement), it returned 2, i.e., the statement just after yield 1. The same process is repeated further."}, {"id": 69427199, "score": 8, "vote": 0, "content": "<h1>Simple answer</h1>\n<p>When function contains at least one <code>yield</code> statement, the function automaticly becomes generator function. When you call generator function, python executes code in the generator function until <code>yield</code> statement occur. <code>yield</code> statement freezes the function with all its internal states. When you call generator function again, python continues execution of code in the generator function from frozen position, until <code>yield</code> statement occur again and again. The generator function executes code until generator function runs out without <code>yield</code> statement.</p>\n<h1>Benchmark</h1>\n<p>Create a list and return it:</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">def my_range(n):\n    my_list = []\n    i = 0\n    while i &lt; n:\n        my_list.append(i)\n        i += 1\n    return my_list\n\n@profile\ndef function():\n    my_sum = 0\n    my_values = my_range(1000000)\n    for my_value in my_values:\n        my_sum += my_value\n\nfunction()\n</code></pre>\n<p>Results with:</p>\n<pre><code class=\"python\">Total time: 1.07901 s\nTimer unit: 1e-06 s\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n     9                                           @profile\n    10                                           def function():\n    11         1          1.1      1.1      0.0      my_sum = 0\n    12         1     494875.0 494875.0     45.9      my_values = my_range(1000000)\n    13   1000001     262842.1      0.3     24.4      for my_value in my_values:\n    14   1000000     321289.8      0.3     29.8          my_sum += my_value\n\n\n\nLine #    Mem usage    Increment  Occurences   Line Contents\n============================================================\n     9   40.168 MiB   40.168 MiB           1   @profile\n    10                                         def function():\n    11   40.168 MiB    0.000 MiB           1       my_sum = 0\n    12   78.914 MiB   38.746 MiB           1       my_values = my_range(1000000)\n    13   78.941 MiB    0.012 MiB     1000001       for my_value in my_values:\n    14   78.941 MiB    0.016 MiB     1000000           my_sum += my_value\n</code></pre>\n<p>Generate values on the fly:</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">def my_range(n):\n    i = 0\n    while i &lt; n:\n        yield i\n        i += 1\n\n@profile\ndef function():\n    my_sum = 0\n    \n    for my_value in my_range(1000000):\n        my_sum += my_value\n\nfunction()\n</code></pre>\n<p>Results with:</p>\n<pre><code class=\"python\">Total time: 1.24841 s\nTimer unit: 1e-06 s\n\nLine #      Hits         Time  Per Hit   % Time  Line Contents\n==============================================================\n     7                                           @profile\n     8                                           def function():\n     9         1          1.1      1.1      0.0      my_sum = 0\n    10\n    11   1000001     895617.3      0.9     71.7      for my_value in my_range(1000000):\n    12   1000000     352793.7      0.4     28.3          my_sum += my_value\n\n\n\nLine #    Mem usage    Increment  Occurences   Line Contents\n============================================================\n     7   40.168 MiB   40.168 MiB           1   @profile\n     8                                         def function():\n     9   40.168 MiB    0.000 MiB           1       my_sum = 0\n    10\n    11   40.203 MiB    0.016 MiB     1000001       for my_value in my_range(1000000):\n    12   40.203 MiB    0.020 MiB     1000000           my_sum += my_value\n</code></pre>\n<h1>Summary</h1>\n<p>The generator function needs a little more time to execute, than function which returns a list but it use much less memory.</p>\n", "abstract": "When function contains at least one yield statement, the function automaticly becomes generator function. When you call generator function, python executes code in the generator function until yield statement occur. yield statement freezes the function with all its internal states. When you call generator function again, python continues execution of code in the generator function from frozen position, until yield statement occur again and again. The generator function executes code until generator function runs out without yield statement. Create a list and return it: Results with: Generate values on the fly: Results with: The generator function needs a little more time to execute, than function which returns a list but it use much less memory."}, {"id": 69893671, "score": 8, "vote": 0, "content": "<p>A simple use case:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def foo():\n    yield 100\n    yield 20\n    yield 3\n\n    \n&gt;&gt;&gt; for i in foo(): print(i)\n\n100\n20\n3\n&gt;&gt;&gt; \n</code></pre>\n<p>How it works: when called, the function returns an object immediately. The object can be passed to the next() function. Whenever the next() function is called, your function runs up until the next yield and provides the return value for the next() function.</p>\n<p>Under the hood, the for loop recognizes that the object is a generator object and uses next() to get the next value.</p>\n<p>In some languages like ES6 and higher, it's implemented a little differently so next is a member function of the generator object, and you could pass values from the caller every time it gets the next value. So if result is the generator then you could do something like y = result.next(555), and the program yielding values could say something like z = yield 999. The value of y would be 999 that next gets from the yield, and the value of z would be 555 that yield gets from the next. Python get and send methods have a similar effect.</p>\n", "abstract": "A simple use case: How it works: when called, the function returns an object immediately. The object can be passed to the next() function. Whenever the next() function is called, your function runs up until the next yield and provides the return value for the next() function. Under the hood, the for loop recognizes that the object is a generator object and uses next() to get the next value. In some languages like ES6 and higher, it's implemented a little differently so next is a member function of the generator object, and you could pass values from the caller every time it gets the next value. So if result is the generator then you could do something like y = result.next(555), and the program yielding values could say something like z = yield 999. The value of y would be 999 that next gets from the yield, and the value of z would be 555 that yield gets from the next. Python get and send methods have a similar effect."}, {"id": 67976136, "score": 5, "vote": 0, "content": "<p>Usually, it's used to create an iterator out of function.\nThink 'yield' as an append() to your function and your function as an array.\nAnd if certain criteria meet, you can add that value in your function to make it an iterator.</p>\n<pre><code class=\"python\">arr=[]\nif 2&gt;0:\n   arr.append(2)\n\ndef func():\n   if 2&gt;0:\n      yield 2\n</code></pre>\n<p>the output will be the same for both.</p>\n<p>The main advantage of using yield is to creating iterators.\nIterators don\u2019t compute the value of each item when instantiated. They only compute it when you ask for it. This is known as lazy evaluation.</p>\n", "abstract": "Usually, it's used to create an iterator out of function.\nThink 'yield' as an append() to your function and your function as an array.\nAnd if certain criteria meet, you can add that value in your function to make it an iterator. the output will be the same for both. The main advantage of using yield is to creating iterators.\nIterators don\u2019t compute the value of each item when instantiated. They only compute it when you ask for it. This is known as lazy evaluation."}, {"id": 70233705, "score": 4, "vote": 0, "content": "<p>Generators allow to get individual processed items immediately (without the need to wait for the whole collection to be processed). This is illustrated in the example below.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import time\n\ndef get_gen():\n    for i in range(10):\n        yield i\n        time.sleep(1)\n\ndef get_list():\n    ret = []\n    for i in range(10):\n        ret.append(i)\n        time.sleep(1)\n    return ret\n\n\nstart_time = time.time()\nprint('get_gen iteration (individual results come immediately)')\nfor i in get_gen():\n    print(f'result arrived after: {time.time() - start_time:.0f} seconds')\nprint()\n\nstart_time = time.time()\nprint('get_list iteration (results come all at once)') \nfor i in get_list():\n    print(f'result arrived after: {time.time() - start_time:.0f} seconds')\n\n</code></pre>\n<pre><code class=\"python\">get_gen iteration (individual results come immediately)\nresult arrived after: 0 seconds\nresult arrived after: 1 seconds\nresult arrived after: 2 seconds\nresult arrived after: 3 seconds\nresult arrived after: 4 seconds\nresult arrived after: 5 seconds\nresult arrived after: 6 seconds\nresult arrived after: 7 seconds\nresult arrived after: 8 seconds\nresult arrived after: 9 seconds\n\nget_list iteration (results come all at once)\nresult arrived after: 10 seconds\nresult arrived after: 10 seconds\nresult arrived after: 10 seconds\nresult arrived after: 10 seconds\nresult arrived after: 10 seconds\nresult arrived after: 10 seconds\nresult arrived after: 10 seconds\nresult arrived after: 10 seconds\nresult arrived after: 10 seconds\nresult arrived after: 10 seconds\n</code></pre>\n", "abstract": "Generators allow to get individual processed items immediately (without the need to wait for the whole collection to be processed). This is illustrated in the example below."}, {"id": 70617027, "score": 4, "vote": 0, "content": "<p>The <code>yield</code> keyword is used in enumeration/iteration where the function is expected to return more then one output. I want to quote this very simple <strong>example A</strong>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># example A\ndef getNumber():\n    for r in range(1,10):\n        return r\n</code></pre>\n<p>The above function will return only <strong>1</strong> even when it's called multiple times. Now if we replace <code>return</code> with <code>yield</code> as in <strong>example B</strong>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># example B\ndef getNumber():\n    for r in range(1,10):\n        yield r\n</code></pre>\n<p>It will return <strong>1</strong> when first called <strong>2</strong> when called again then <strong>3</strong>,<strong>4</strong> and it goes to increment till 10.</p>\n<p>Although the <strong>example B</strong> is conceptually true but to call it in <strong>python 3</strong> we have to do the following:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">\ng = getNumber() #instance\nprint(next(g)) #will print 1\nprint(next(g)) #will print 2\nprint(next(g)) #will print 3\n\n# so to assign it to a variables\nv = getNumber()\nv1 = next(v) #v1 will have 1\nv2 = next(v) #v2 will have 2\nv3 = next(v) #v3 will have 3\n</code></pre>\n", "abstract": "The yield keyword is used in enumeration/iteration where the function is expected to return more then one output. I want to quote this very simple example A: The above function will return only 1 even when it's called multiple times. Now if we replace return with yield as in example B: It will return 1 when first called 2 when called again then 3,4 and it goes to increment till 10. Although the example B is conceptually true but to call it in python 3 we have to do the following:"}, {"id": 67970221, "score": 3, "vote": 0, "content": "<p>Function - returns.</p>\n<p>Generator - yields (contains one or more yields and zero or more returns).</p>\n<pre><code class=\"python\">names = ['Sam', 'Sarah', 'Thomas', 'James']\n\n\n# Using function\ndef greet(name) :\n    return f'Hi, my name is {name}.'\n    \nfor each_name in names:\n    print(greet(each_name))\n\n# Output:   \n&gt;&gt;&gt;Hi, my name is Sam.\n&gt;&gt;&gt;Hi, my name is Sarah.\n&gt;&gt;&gt;Hi, my name is Thomas.\n&gt;&gt;&gt;Hi, my name is James.\n\n\n# using generator\ndef greetings(names) :\n    for each_name in names:\n        yield f'Hi, my name is {each_name}.'\n \nfor greet_name in greetings(names):\n    print (greet_name)\n\n# Output:    \n&gt;&gt;&gt;Hi, my name is Sam.\n&gt;&gt;&gt;Hi, my name is Sarah.\n&gt;&gt;&gt;Hi, my name is Thomas.\n&gt;&gt;&gt;Hi, my name is James.\n</code></pre>\n<p>A generator looks like a function but behaves like an iterator.</p>\n<p>A generator continues execution from where it is lefoff (or yielded). When resumed, the function continues the execution immediately after the last yield run. This allows its code to produce a series of values over time rather them computing them all at once and sending them back like a list.</p>\n<pre><code class=\"python\">def function():\n    yield 1 # return this first\n    yield 2 # start continue from here (yield don't execute above code once executed)\n    yield 3 # give this at last (yield don't execute above code once executed)\n\nfor processed_data in function(): \n    print(processed_data)\n    \n#Output:\n\n&gt;&gt;&gt;1\n&gt;&gt;&gt;2\n&gt;&gt;&gt;3\n</code></pre>\n<p>Note:\nYield should not be in the try ... finally construct.</p>\n", "abstract": "Function - returns. Generator - yields (contains one or more yields and zero or more returns). A generator looks like a function but behaves like an iterator. A generator continues execution from where it is lefoff (or yielded). When resumed, the function continues the execution immediately after the last yield run. This allows its code to produce a series of values over time rather them computing them all at once and sending them back like a list. Note:\nYield should not be in the try ... finally construct."}, {"id": 72334132, "score": 3, "vote": 0, "content": "<h2>Key points</h2>\n<ul>\n<li><p>The <a href=\"https://docs.python.org/3/reference/grammar.html\" rel=\"nofollow noreferrer\">grammar for Python</a> uses the presence of the <code>yield</code> keyword to make a function that returns a <a href=\"https://docs.python.org/3/glossary.html#term-generator\" rel=\"nofollow noreferrer\">generator</a>.</p>\n</li>\n<li><p>A generator is a kind of <a href=\"https://docs.python.org/3/glossary.html#term-iterator\" rel=\"nofollow noreferrer\">iterator</a>, which is that main way that  looping occurs in Python.</p>\n</li>\n<li><p>A generator is essentially a resumable function.  Unlike <code>return</code> that returns a value and ends a function, the <code>yield</code> keyword returns a value and suspends a function.</p>\n</li>\n<li><p>When <code>next(g)</code> is called on a generator, the function resumes execution where it left off.</p>\n</li>\n<li><p>Only when the function encounters an explicit or implied <code>return</code> does it actually end.</p>\n</li>\n</ul>\n<h2>Technique for writing and understanding generators</h2>\n<p>An easy way to understand and think about generators is to write a regular function with <code>print()</code> instead of <code>yield</code>:</p>\n<pre><code class=\"python\">def f(n):\n    for x in range(n):\n        print(x)\n        print(x * 10)\n</code></pre>\n<p>Watch what it outputs:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; f(3)\n0\n0\n1\n10\n2\n2\n</code></pre>\n<p>When that function is understood, substitute the <code>yield</code> for <code>print</code> to get a generator that produces the same values:</p>\n<pre><code class=\"python\">def f(n):\n    for x in range(n):\n        yield x\n        yield x * 10\n</code></pre>\n<p>Which gives:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(f(3))\n[0, 0, 1, 10, 2, 20]\n</code></pre>\n<h2>Iterator protocol</h2>\n<p>The answer to \"what yield does\" can be short and simple, but it is part of a larger world, the so-called \"iterator protocol\".</p>\n<p>On the sender side of iterator protocol, there are two relevant kinds of objects. The <em>iterables</em> are things you can loop over.  And the <em>iterators</em> are objects that track the loop state.</p>\n<p>On the consumer side of the iterator protocol, we call <a href=\"https://docs.python.org/3/library/functions.html#iter\" rel=\"nofollow noreferrer\">iter()</a> on the iterable object to get a iterator.  Then we call <a href=\"https://docs.python.org/3/library/functions.html#next\" rel=\"nofollow noreferrer\">next()</a> on the iterator to retrieve values from the iterator.  When there is  no more data, a <a href=\"https://docs.python.org/3/library/exceptions.html#StopIteration\" rel=\"nofollow noreferrer\">StopIteration</a> exception is raised:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; s = [10, 20, 30]    # The list is the \"iterable\"\n&gt;&gt;&gt; it = iter(s)        # This is the \"iterator\"\n&gt;&gt;&gt; next(it)            # Gets values out of an iterator\n10\n&gt;&gt;&gt; next(it)\n20\n&gt;&gt;&gt; next(it)\n30\n&gt;&gt;&gt; next(it)\nTraceback (most recent call last):\n ...\nStopIteration\n</code></pre>\n<p>To make this all easier for us, for-loops call iter and next on our behalf:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; for x in s:\n...     print(x)\n...   \n10\n20\n30\n</code></pre>\n<p>A person could write a book about all this, but these are the key points.  When I teach Python courses, I've found that this is a minimal sufficient explanation to build understand and start using it right away.  In particular, the trick of writing a function with <code>print</code>, testing it, and then converting to <code>yield</code> seems to work well with all levels of Python programmers.</p>\n", "abstract": "The grammar for Python uses the presence of the yield keyword to make a function that returns a generator. A generator is a kind of iterator, which is that main way that  looping occurs in Python. A generator is essentially a resumable function.  Unlike return that returns a value and ends a function, the yield keyword returns a value and suspends a function. When next(g) is called on a generator, the function resumes execution where it left off. Only when the function encounters an explicit or implied return does it actually end. An easy way to understand and think about generators is to write a regular function with print() instead of yield: Watch what it outputs: When that function is understood, substitute the yield for print to get a generator that produces the same values: Which gives: The answer to \"what yield does\" can be short and simple, but it is part of a larger world, the so-called \"iterator protocol\". On the sender side of iterator protocol, there are two relevant kinds of objects. The iterables are things you can loop over.  And the iterators are objects that track the loop state. On the consumer side of the iterator protocol, we call iter() on the iterable object to get a iterator.  Then we call next() on the iterator to retrieve values from the iterator.  When there is  no more data, a StopIteration exception is raised: To make this all easier for us, for-loops call iter and next on our behalf: A person could write a book about all this, but these are the key points.  When I teach Python courses, I've found that this is a minimal sufficient explanation to build understand and start using it right away.  In particular, the trick of writing a function with print, testing it, and then converting to yield seems to work well with all levels of Python programmers."}, {"id": 70516941, "score": 2, "vote": 0, "content": "<p>To understand its yield function, one must understand what a generator is. Moreover, before understanding generators, you must understand <em>iterables</em>.\nIterable: iterable\nTo create a list, you naturally need to be able to read each element one by one. The process of reading its items one by one is called iteration:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; mylist = [1, 2, 3]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n1\n2\n3 \n</code></pre>\n<p>mylist is an iterable. When you use list comprehensions, you create a list and therefore iterable\uff1a</p>\n<pre><code class=\"python\">&gt;&gt;&gt; mylist = [x*x for x in range(3)]\n&gt;&gt;&gt; for i in mylist:\n...    print(i)\n0\n1\n4 \n</code></pre>\n<p>All data structures that can be used for... in... are iterable; lists, strings, files...</p>\n<p>These iterable methods are convenient because you can read them at will, but you store all the values \u200b\u200bin memory, which is not always desirable when you have many values.\nGenerator: generator\nA generator is also a kind of iterator, a special kind of iteration, which can only be iterated once. The generator does not store all values \u200b\u200bin memory, but generates values \u200b\u200bon the fly:</p>\n<p>generator: generator, generator, generator generates electricity but does not store energy;)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; mygenerator = (x*x for x in range(3))\n&gt;&gt;&gt; for i in mygenerator:\n...    print(i)\n0\n1\n4 \n</code></pre>\n<p>As long as () is used instead of [], the list comprehension becomes the generator comprehension. However, since the generator can only be used once, you cannot execute for i in mygenerator a second time: the generator calculates 0, then discards it, then calculates 1, and the last time it calculates 4. The typical black blind man breaks corn.</p>\n<p>The yield keyword is used in the same way as return, except that the function will return the generator.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def createGenerator():\n...    mylist = range(3)\n...    for i in mylist:\n...        yield i*i\n...\n&gt;&gt;&gt; mygenerator = createGenerator() \n&gt;&gt;&gt; print(mygenerator) \n&lt;generator object createGenerator at 0xb7555c34&gt;\n&gt;&gt;&gt; for i in mygenerator:\n...     print(i)\n0\n1\n4 \n</code></pre>\n<p>This example itself is useless, but when you need a function to return a large number of values \u200b\u200band only need to read it once, using yield becomes convenient.</p>\n<p>To master the yield, one need to be clear is that when a function is called, the code written in the function body will not run. The function only returns the generator object. Beginners are likely to be confused about this.</p>\n<p>Second, understand that the code will continue from where it left off every time for uses the generator.</p>\n<p>The most difficult part now is:</p>\n<p>The first time for calls the generator object created from your function, it will run the code in the function from the beginning until it hits yield, and then it will return the first value of the loop. Then, each subsequent call will run the next iteration of the loop you wrote in the function and return the next value. This will continue until the generator is considered empty, which yields when there is no hit while the function is running. That may be because the loop has ended, or because you are no longer satisfied with \"if/else\".</p>\n<p>Personal understanding I hope to help you!</p>\n", "abstract": "To understand its yield function, one must understand what a generator is. Moreover, before understanding generators, you must understand iterables.\nIterable: iterable\nTo create a list, you naturally need to be able to read each element one by one. The process of reading its items one by one is called iteration: mylist is an iterable. When you use list comprehensions, you create a list and therefore iterable\uff1a All data structures that can be used for... in... are iterable; lists, strings, files... These iterable methods are convenient because you can read them at will, but you store all the values \u200b\u200bin memory, which is not always desirable when you have many values.\nGenerator: generator\nA generator is also a kind of iterator, a special kind of iteration, which can only be iterated once. The generator does not store all values \u200b\u200bin memory, but generates values \u200b\u200bon the fly: generator: generator, generator, generator generates electricity but does not store energy;) As long as () is used instead of [], the list comprehension becomes the generator comprehension. However, since the generator can only be used once, you cannot execute for i in mygenerator a second time: the generator calculates 0, then discards it, then calculates 1, and the last time it calculates 4. The typical black blind man breaks corn. The yield keyword is used in the same way as return, except that the function will return the generator. This example itself is useless, but when you need a function to return a large number of values \u200b\u200band only need to read it once, using yield becomes convenient. To master the yield, one need to be clear is that when a function is called, the code written in the function body will not run. The function only returns the generator object. Beginners are likely to be confused about this. Second, understand that the code will continue from where it left off every time for uses the generator. The most difficult part now is: The first time for calls the generator object created from your function, it will run the code in the function from the beginning until it hits yield, and then it will return the first value of the loop. Then, each subsequent call will run the next iteration of the loop you wrote in the function and return the next value. This will continue until the generator is considered empty, which yields when there is no hit while the function is running. That may be because the loop has ended, or because you are no longer satisfied with \"if/else\". Personal understanding I hope to help you!"}, {"id": 73457837, "score": 1, "vote": 0, "content": "<p><code>yield</code> is used to create a <code>generator</code>. Think of generator as an iterator whihc gives you value on each iteration. When you use yield in the loop you get a generator object which you could use to get items from the loop in an iterative manner</p>\n", "abstract": "yield is used to create a generator. Think of generator as an iterator whihc gives you value on each iteration. When you use yield in the loop you get a generator object which you could use to get items from the loop in an iterative manner"}, {"id": 73924762, "score": 0, "vote": 0, "content": "<p><strong>What Is Yield In Python?</strong></p>\n<p>The Yield keyword in Python is similar to a return statement used for returning values or objects in Python. However, there is a slight difference. The yield statement returns a generator object to the one who calls the function which contains yield, instead of simply returning a value.</p>\n<p>Inside a program, when you call a function that has a yield statement, as soon as a yield is encountered, the execution of the function stops and returns an object of the generator to the function caller. In simpler words, the yield keyword will convert an expression that is specified along with it to a generator object and return it to the caller. Hence, if you want to get the values stored inside the generator object, you need to iterate over it.</p>\n<p>It will not destroy the local variables\u2019 states. Whenever a function is called, the execution will start from the last yield expression. Please note that a function that contains a yield keyword is known as a generator function.</p>\n<p>When you use a function with a return value, every time you call the function, it starts with a new set of variables. In contrast, if you use a generator function instead of a normal function, the execution will start right from where it left last.</p>\n<p>If you want to return multiple values from a function, you can use generator functions with yield keywords. The yield expressions return multiple values. They return one value, then wait, save the local state, and resume again.</p>\n<p>Source: <a href=\"https://www.simplilearn.com/tutorials/python-tutorial/yield-in-python\" rel=\"nofollow noreferrer\">https://www.simplilearn.com/tutorials/python-tutorial/yield-in-python</a></p>\n", "abstract": "What Is Yield In Python? The Yield keyword in Python is similar to a return statement used for returning values or objects in Python. However, there is a slight difference. The yield statement returns a generator object to the one who calls the function which contains yield, instead of simply returning a value. Inside a program, when you call a function that has a yield statement, as soon as a yield is encountered, the execution of the function stops and returns an object of the generator to the function caller. In simpler words, the yield keyword will convert an expression that is specified along with it to a generator object and return it to the caller. Hence, if you want to get the values stored inside the generator object, you need to iterate over it. It will not destroy the local variables\u2019 states. Whenever a function is called, the execution will start from the last yield expression. Please note that a function that contains a yield keyword is known as a generator function. When you use a function with a return value, every time you call the function, it starts with a new set of variables. In contrast, if you use a generator function instead of a normal function, the execution will start right from where it left last. If you want to return multiple values from a function, you can use generator functions with yield keywords. The yield expressions return multiple values. They return one value, then wait, save the local state, and resume again. Source: https://www.simplilearn.com/tutorials/python-tutorial/yield-in-python"}]}, {"link": "https://stackoverflow.com/questions/419163/what-does-if-name-main-do", "question": {"id": "419163", "title": "What does if __name__ == &quot;__main__&quot;: do?", "content": "<p>What does this do, and why should one include the <code>if</code> statement?</p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n    print(\"Hello, World!\")\n</code></pre>\n<hr/>\n<p><sub>If you are trying to close a question where someone should be using this idiom and isn't, consider closing as a duplicate of <a href=\"https://stackoverflow.com/questions/6523791\">Why is Python running my module when I import it, and how do I stop it?</a> instead. For questions where someone simply hasn't called any functions, or incorrectly expects a function named <code>main</code> to be used as an entry point automatically, use <a href=\"https://stackoverflow.com/questions/17257631\">Why doesn't the main() function run when I start a Python script? Where does the script start running?</a>.</sub></p>\n", "abstract": "What does this do, and why should one include the if statement? If you are trying to close a question where someone should be using this idiom and isn't, consider closing as a duplicate of Why is Python running my module when I import it, and how do I stop it? instead. For questions where someone simply hasn't called any functions, or incorrectly expects a function named main to be used as an entry point automatically, use Why doesn't the main() function run when I start a Python script? Where does the script start running?."}, "answers": [{"id": 419185, "score": 8438, "vote": 0, "content": "<h1>Short Answer</h1>\n<p>It's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script:</p>\n<ul>\n<li><p>If you import the guardless script in another script (e.g. <code>import my_script_without_a_name_eq_main_guard</code>), then the latter script will trigger the former to run <em>at import time</em> and <em>using the second script's command line arguments</em>. This is almost always a mistake.</p>\n</li>\n<li><p>If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.</p>\n</li>\n</ul>\n<h1>Long Answer</h1>\n<p>To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.</p>\n<p>Whenever the Python interpreter reads a source file, it does two things:</p>\n<ul>\n<li><p>it sets a few special variables like <code>__name__</code>, and then</p>\n</li>\n<li><p>it executes all of the code found in the file.</p>\n</li>\n</ul>\n<p>Let's see how this works and how it relates to your question about the <code>__name__</code> checks we always see in Python scripts.</p>\n<h2>Code Sample</h2>\n<p>Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called <code>foo.py</code>.</p>\n<pre><code class=\"python\"># Suppose this is foo.py.\n\nprint(\"before import\")\nimport math\n\nprint(\"before function_a\")\ndef function_a():\n    print(\"Function A\")\n\nprint(\"before function_b\")\ndef function_b():\n    print(\"Function B {}\".format(math.sqrt(100)))\n\nprint(\"before __name__ guard\")\nif __name__ == '__main__':\n    function_a()\n    function_b()\nprint(\"after __name__ guard\")\n</code></pre>\n<h2>Special Variables</h2>\n<p>When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the <code>__name__</code> variable.</p>\n<p><strong>When Your Module Is the Main Program</strong></p>\n<p>If you are running your module (the source file) as the main program, e.g.</p>\n<pre><code class=\"python\">python foo.py\n</code></pre>\n<p>the interpreter will assign the hard-coded string <code>\"__main__\"</code> to the <code>__name__</code> variable, i.e.</p>\n<pre><code class=\"python\"># It's as if the interpreter inserts this at the top\n# of your module when run as the main program.\n__name__ = \"__main__\" \n</code></pre>\n<p><strong>When Your Module Is Imported By Another</strong></p>\n<p>On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:</p>\n<pre><code class=\"python\"># Suppose this is in some other main program.\nimport foo\n</code></pre>\n<p>The interpreter will search for your <code>foo.py</code> file (along with searching for a few other variants), and prior to executing that module, it will assign the name <code>\"foo\"</code> from the import statement to the <code>__name__</code> variable, i.e.</p>\n<pre><code class=\"python\"># It's as if the interpreter inserts this at the top\n# of your module when it's imported from another module.\n__name__ = \"foo\"\n</code></pre>\n<h2>Executing the Module's Code</h2>\n<p>After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.</p>\n<p><strong>Always</strong></p>\n<ol>\n<li><p>It prints the string <code>\"before import\"</code> (without quotes).</p>\n</li>\n<li><p>It loads the <code>math</code> module and assigns it to a variable called <code>math</code>. This is equivalent to replacing <code>import math</code> with the following (note that <code>__import__</code> is a low-level function in Python that takes a string and triggers the actual import):</p>\n</li>\n</ol>\n<pre><code class=\"python\"># Find and load a module given its string name, \"math\",\n# then assign it to a local variable called math.\nmath = __import__(\"math\")\n</code></pre>\n<ol start=\"3\">\n<li><p>It prints the string <code>\"before function_a\"</code>.</p>\n</li>\n<li><p>It executes the <code>def</code> block, creating a function object, then assigning that function object to a variable called <code>function_a</code>.</p>\n</li>\n<li><p>It prints the string <code>\"before function_b\"</code>.</p>\n</li>\n<li><p>It executes the second <code>def</code> block, creating another function object, then assigning it to a variable called <code>function_b</code>.</p>\n</li>\n<li><p>It prints the string <code>\"before __name__ guard\"</code>.</p>\n</li>\n</ol>\n<p><strong>Only When Your Module Is the Main Program</strong></p>\n<ol start=\"8\">\n<li>If your module is the main program, then it will see that <code>__name__</code> was indeed set to <code>\"__main__\"</code> and it calls the two functions, printing the strings <code>\"Function A\"</code> and <code>\"Function B 10.0\"</code>.</li>\n</ol>\n<p><strong>Only When Your Module Is Imported by Another</strong></p>\n<ol start=\"8\">\n<li>(<strong>instead</strong>) If your module is not the main program but was imported by another one, then <code>__name__</code> will be <code>\"foo\"</code>, not <code>\"__main__\"</code>, and it'll skip the body of the <code>if</code> statement.</li>\n</ol>\n<p><strong>Always</strong></p>\n<ol start=\"9\">\n<li>It will print the string <code>\"after __name__ guard\"</code> in both situations.</li>\n</ol>\n<p><em><strong>Summary</strong></em></p>\n<p>In summary, here's what'd be printed in the two cases:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\"># What gets printed if foo is the main program\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nFunction A\nFunction B 10.0\nafter __name__ guard\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\"># What gets printed if foo is imported as a regular module\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nafter __name__ guard\n</code></pre>\n<h2>Why Does It Work This Way?</h2>\n<p>You might naturally wonder why anybody would want this.  Well, sometimes you want to write a <code>.py</code> file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:</p>\n<ul>\n<li><p>Your module is a library, but you want to have a script mode where it runs some unit tests or a demo.</p>\n</li>\n<li><p>Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing <code>.py</code> files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.</p>\n</li>\n<li><p>Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.</p>\n</li>\n</ul>\n<p>Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. \"Running\" the script is a side effect of importing the script's module.</p>\n<h2>Food for Thought</h2>\n<ul>\n<li><p>Question: Can I have multiple <code>__name__</code> checking blocks?  Answer: it's strange to do so, but the language won't stop you.</p>\n</li>\n<li><p>Suppose the following is in <code>foo2.py</code>.  What happens if you say <code>python foo2.py</code> on the command-line? Why?</p>\n</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># Suppose this is foo2.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(\"a1\")\n    from foo2 import function_b\n    print(\"a2\")\n    function_b()\n    print(\"a3\")\n\ndef function_b():\n    print(\"b\")\n\nprint(\"t1\")\nif __name__ == \"__main__\":\n    print(\"m1\")\n    function_a()\n    print(\"m2\")\nprint(\"t2\")\n      \n</code></pre>\n<ul>\n<li>Now, figure out what will happen if you remove the <code>__name__</code> check in <code>foo3.py</code>:</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># Suppose this is foo3.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(\"a1\")\n    from foo3 import function_b\n    print(\"a2\")\n    function_b()\n    print(\"a3\")\n\ndef function_b():\n    print(\"b\")\n\nprint(\"t1\")\nprint(\"m1\")\nfunction_a()\nprint(\"m2\")\nprint(\"t2\")\n</code></pre>\n<ul>\n<li>What will this do when used as a script?  When imported as a module?</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># Suppose this is in foo4.py\n__name__ = \"__main__\"\n\ndef bar():\n    print(\"bar\")\n    \nprint(\"before __name__ guard\")\nif __name__ == \"__main__\":\n    bar()\nprint(\"after __name__ guard\")\n</code></pre>\n", "abstract": "It's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script: If you import the guardless script in another script (e.g. import my_script_without_a_name_eq_main_guard), then the latter script will trigger the former to run at import time and using the second script's command line arguments. This is almost always a mistake. If you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet. To better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism. Whenever the Python interpreter reads a source file, it does two things: it sets a few special variables like __name__, and then it executes all of the code found in the file. Let's see how this works and how it relates to your question about the __name__ checks we always see in Python scripts. Let's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called foo.py. When the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the __name__ variable. When Your Module Is the Main Program If you are running your module (the source file) as the main program, e.g. the interpreter will assign the hard-coded string \"__main__\" to the __name__ variable, i.e. When Your Module Is Imported By Another On the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports: The interpreter will search for your foo.py file (along with searching for a few other variants), and prior to executing that module, it will assign the name \"foo\" from the import statement to the __name__ variable, i.e. After the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation. Always It prints the string \"before import\" (without quotes). It loads the math module and assigns it to a variable called math. This is equivalent to replacing import math with the following (note that __import__ is a low-level function in Python that takes a string and triggers the actual import): It prints the string \"before function_a\". It executes the def block, creating a function object, then assigning that function object to a variable called function_a. It prints the string \"before function_b\". It executes the second def block, creating another function object, then assigning it to a variable called function_b. It prints the string \"before __name__ guard\". Only When Your Module Is the Main Program Only When Your Module Is Imported by Another Always Summary In summary, here's what'd be printed in the two cases: You might naturally wonder why anybody would want this.  Well, sometimes you want to write a .py file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples: Your module is a library, but you want to have a script mode where it runs some unit tests or a demo. Your module is only used as a main program, but it has some unit tests, and the testing framework works by importing .py files like your script and running special test functions. You don't want it to try running the script just because it's importing the module. Your module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users. Beyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. \"Running\" the script is a side effect of importing the script's module. Question: Can I have multiple __name__ checking blocks?  Answer: it's strange to do so, but the language won't stop you. Suppose the following is in foo2.py.  What happens if you say python foo2.py on the command-line? Why?"}, {"id": 419189, "score": 2110, "vote": 0, "content": "<p>When your script is run by passing it as a command to the Python interpreter,</p>\n<pre><code class=\"python\">python myscript.py\n</code></pre>\n<p>all of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there's no <code>main()</code> function that gets run automatically - the <code>main()</code> function is implicitly all the code at the top level.</p>\n<p>In this case, the top-level code is an <code>if</code> block.  <code>__name__</code> is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in <code>myscript.py</code> above), then <code>__name__</code> instead is set to the string <code>\"__main__\"</code>.  Thus, you can test whether your script is being run directly or being imported by something else by testing</p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n    ...\n</code></pre>\n<p>If your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the <code>if</code> clause above won't get run as the condition is not met. As a basic example, consider the following two scripts:</p>\n<pre><code class=\"python\"># file one.py\ndef func():\n    print(\"func() in one.py\")\n\nprint(\"top-level in one.py\")\n\nif __name__ == \"__main__\":\n    print(\"one.py is being run directly\")\nelse:\n    print(\"one.py is being imported into another module\")\n</code></pre>\n<pre><code class=\"python\"># file two.py\nimport one\n\nprint(\"top-level in two.py\")\none.func()\n\nif __name__ == \"__main__\":\n    print(\"two.py is being run directly\")\nelse:\n    print(\"two.py is being imported into another module\")\n</code></pre>\n<p>Now, if you invoke the interpreter as</p>\n<pre><code class=\"python\">python one.py\n</code></pre>\n<p>The output will be</p>\n<pre><code class=\"python\">top-level in one.py\none.py is being run directly\n</code></pre>\n<p>If you run <code>two.py</code> instead:</p>\n<pre><code class=\"python\">python two.py\n</code></pre>\n<p>You get</p>\n<pre><code class=\"python\">top-level in one.py\none.py is being imported into another module\ntop-level in two.py\nfunc() in one.py\ntwo.py is being run directly\n</code></pre>\n<p>Thus, when module <code>one</code> gets loaded, its <code>__name__</code> equals <code>\"one\"</code> instead of <code>\"__main__\"</code>.</p>\n", "abstract": "When your script is run by passing it as a command to the Python interpreter, all of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there's no main() function that gets run automatically - the main() function is implicitly all the code at the top level. In this case, the top-level code is an if block.  __name__ is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in myscript.py above), then __name__ instead is set to the string \"__main__\".  Thus, you can test whether your script is being run directly or being imported by something else by testing If your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the if clause above won't get run as the condition is not met. As a basic example, consider the following two scripts: Now, if you invoke the interpreter as The output will be If you run two.py instead: You get Thus, when module one gets loaded, its __name__ equals \"one\" instead of \"__main__\"."}, {"id": 419986, "score": 845, "vote": 0, "content": "<p>Create the following two files:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># a.py\n\nimport b\n</code></pre>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># b.py\n\nprint(\"__name__ equals \" + __name__)\n\nif __name__ == '__main__':\n    print(\"if-statement was executed\")\n</code></pre>\n<p>Now run each file individually.</p>\n<hr/>\n<p><strong>Running <code>python a.py</code>:</strong></p>\n<pre><code class=\"python\">$ python a.py\n__name__ equals b\n</code></pre>\n<p>When <code>a.py</code> is executed, it imports the module <code>b</code>. This causes all the code inside <code>b</code> to run. Python sets <code>globals()['__name__']</code> in the <code>b</code> module to the module's name, <code>b</code>.</p>\n<br/>\n<p><strong>Running <code>python b.py</code>:</strong></p>\n<pre><code class=\"python\">$ python b.py\n__name__ equals __main__\nif-statement was executed\n</code></pre>\n<p>When only the file <code>b.py</code> is executed, Python sets <code>globals()['__name__']</code> in this file to <code>\"__main__\"</code>. Therefore, the <code>if</code> statement evaluates to <code>True</code> this time.</p>\n", "abstract": "Create the following two files: Now run each file individually. Running python a.py: When a.py is executed, it imports the module b. This causes all the code inside b to run. Python sets globals()['__name__'] in the b module to the module's name, b. Running python b.py: When only the file b.py is executed, Python sets globals()['__name__'] in this file to \"__main__\". Therefore, the if statement evaluates to True this time."}, {"id": 20158605, "score": 592, "vote": 0, "content": "<blockquote>\n<h2>What does the <code>if __name__ == \"__main__\":</code> do?</h2>\n</blockquote>\n<p>To outline the basics:</p>\n<ul>\n<li><p>The global variable, <code>__name__</code>, in the module that is the entry point to your program, is <code>'__main__'</code>. Otherwise, it's the name you import the module by.</p></li>\n<li><p>So, code under the <code>if</code> block will only run if the module is the entry point to your program.</p></li>\n<li><p>It allows the code in the module to be importable by other modules, without executing the code block beneath on import.</p></li>\n</ul>\n<hr/>\n<p>Why do we need this?</p>\n<h2>Developing and Testing Your Code</h2>\n<p>Say you're writing a Python script designed to be used as a module:</p>\n<pre><code class=\"python\">def do_important():\n    \"\"\"This function does something very important\"\"\"\n</code></pre>\n<p>You <em>could</em> test the module by adding this call of the function to the bottom:</p>\n<pre><code class=\"python\">do_important()\n</code></pre>\n<p>and running it (on a command prompt) with something like:</p>\n<pre><code class=\"python\">~$ python important.py\n</code></pre>\n<h2>The Problem</h2>\n<p>However, if you want to import the module to another script:</p>\n<pre><code class=\"python\">import important\n</code></pre>\n<p>On import, the <code>do_important</code> function would be called, so you'd probably comment out your function call, <code>do_important()</code>, at the bottom. </p>\n<pre><code class=\"python\"># do_important() # I must remember to uncomment to execute this!\n</code></pre>\n<p>And then you'll have to remember whether or not you've commented out your test function call. And this extra complexity would mean you're likely to forget, making your development process more troublesome.</p>\n<h2>A Better Way</h2>\n<p>The <code>__name__</code> variable points to the namespace wherever the Python interpreter happens to be at the moment. </p>\n<p>Inside an imported module, it's the name of that module. </p>\n<p>But inside the primary module (or an interactive Python session, i.e. the interpreter's Read, Eval, Print Loop, or REPL) you are running everything from its <code>\"__main__\"</code>.</p>\n<p>So if you check before executing:</p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n    do_important()\n</code></pre>\n<p>With the above, your code will only execute when you're running it as the primary module (or intentionally call it from another script). </p>\n<h2>An Even Better Way</h2>\n<p>There's a Pythonic way to improve on this, though. </p>\n<p>What if we want to run this business process from outside the module?</p>\n<p>If we put the code we want to exercise as we develop and test in a function like this and then do our check for <code>'__main__'</code> immediately after:</p>\n<pre><code class=\"python\">def main():\n    \"\"\"business logic for when running this module as the primary one!\"\"\"\n    setup()\n    foo = do_important()\n    bar = do_even_more_important(foo)\n    for baz in bar:\n        do_super_important(baz)\n    teardown()\n\n# Here's our payoff idiom!\nif __name__ == '__main__':\n    main()\n</code></pre>\n<p>We now have a final function for the end of our module that will run if we run the module as the primary module. </p>\n<p>It will allow the module and its functions and classes to be imported into other scripts without running the <code>main</code> function, and will also allow the module (and its functions and classes) to be called when running from a different <code>'__main__'</code> module, i.e.</p>\n<pre><code class=\"python\">import important\nimportant.main()\n</code></pre>\n<p><a href=\"https://docs.python.org/2/library/__main__.html\" rel=\"noreferrer\">This idiom can also be found in the Python documentation in an explanation of the <code>__main__</code> module.</a> That text states:</p>\n<blockquote>\n<p>This module represents the (otherwise anonymous) scope in which the\n  interpreter\u2019s main program executes \u2014 commands read either from\n  standard input, from a script file, or from an interactive prompt. It\n  is this environment in which the idiomatic \u201cconditional script\u201d stanza\n  causes a script to run:</p>\n<pre><code class=\"python\">if __name__ == '__main__':\n    main()\n</code></pre>\n</blockquote>\n", "abstract": "To outline the basics: The global variable, __name__, in the module that is the entry point to your program, is '__main__'. Otherwise, it's the name you import the module by. So, code under the if block will only run if the module is the entry point to your program. It allows the code in the module to be importable by other modules, without executing the code block beneath on import. Why do we need this? Say you're writing a Python script designed to be used as a module: You could test the module by adding this call of the function to the bottom: and running it (on a command prompt) with something like: However, if you want to import the module to another script: On import, the do_important function would be called, so you'd probably comment out your function call, do_important(), at the bottom.  And then you'll have to remember whether or not you've commented out your test function call. And this extra complexity would mean you're likely to forget, making your development process more troublesome. The __name__ variable points to the namespace wherever the Python interpreter happens to be at the moment.  Inside an imported module, it's the name of that module.  But inside the primary module (or an interactive Python session, i.e. the interpreter's Read, Eval, Print Loop, or REPL) you are running everything from its \"__main__\". So if you check before executing: With the above, your code will only execute when you're running it as the primary module (or intentionally call it from another script).  There's a Pythonic way to improve on this, though.  What if we want to run this business process from outside the module? If we put the code we want to exercise as we develop and test in a function like this and then do our check for '__main__' immediately after: We now have a final function for the end of our module that will run if we run the module as the primary module.  It will allow the module and its functions and classes to be imported into other scripts without running the main function, and will also allow the module (and its functions and classes) to be called when running from a different '__main__' module, i.e. This idiom can also be found in the Python documentation in an explanation of the __main__ module. That text states: This module represents the (otherwise anonymous) scope in which the\n  interpreter\u2019s main program executes \u2014 commands read either from\n  standard input, from a script file, or from an interactive prompt. It\n  is this environment in which the idiomatic \u201cconditional script\u201d stanza\n  causes a script to run:"}, {"id": 419174, "score": 167, "vote": 0, "content": "<p><code>if __name__ == \"__main__\"</code> is the part that runs when the script is run from (say) the command line using a command like <code>python myscript.py</code>.</p>\n", "abstract": "if __name__ == \"__main__\" is the part that runs when the script is run from (say) the command line using a command like python myscript.py."}, {"id": 26369628, "score": 107, "vote": 0, "content": "<blockquote>\n<h2>What does <code>if __name__ == \"__main__\":</code> do?</h2>\n</blockquote>\n<p><code>__name__</code> is a global variable (in Python, global actually means on the <a href=\"https://docs.python.org/tutorial/modules.html#modules\" rel=\"noreferrer\">module level</a>) that exists in all namespaces. It is typically the module's name (as a <code>str</code> type).</p>\n<p>As the only special case, however, in whatever Python process you run, as in mycode.py:</p>\n<pre><code class=\"python\">python mycode.py\n</code></pre>\n<p>the otherwise anonymous global namespace is assigned the value of <code>'__main__'</code> to its <code>__name__</code>.</p>\n<p>Thus, including <a href=\"https://docs.python.org/library/__main__.html\" rel=\"noreferrer\">the final lines</a></p>\n<pre><code class=\"python\">if __name__ == '__main__':\n    main()\n</code></pre>\n<ul>\n<li>at the end of your mycode.py script,</li>\n<li>when it is the primary, entry-point module that is run by a Python process,</li>\n</ul>\n<p>will cause your script's uniquely defined <code>main</code> function to run.</p>\n<p>Another benefit of using this construct: you can also import your code as a module in another script and then run the main function if and when your program decides:</p>\n<pre><code class=\"python\">import mycode\n# ... any amount of other code\nmycode.main()\n</code></pre>\n", "abstract": "__name__ is a global variable (in Python, global actually means on the module level) that exists in all namespaces. It is typically the module's name (as a str type). As the only special case, however, in whatever Python process you run, as in mycode.py: the otherwise anonymous global namespace is assigned the value of '__main__' to its __name__. Thus, including the final lines will cause your script's uniquely defined main function to run. Another benefit of using this construct: you can also import your code as a module in another script and then run the main function if and when your program decides:"}, {"id": 39761460, "score": 92, "vote": 0, "content": "<p>There are lots of different takes here on the mechanics of the code in question, the \"How\", but for me none of it made sense until I understood the \"Why\". This should be especially helpful for new programmers.</p>\n<p>Take file \"ab.py\":</p>\n<pre><code class=\"python\">def a():\n    print('A function in ab file');\na()\n</code></pre>\n<p>And a second file \"xy.py\":</p>\n<pre><code class=\"python\">import ab\ndef main():\n    print('main function: this is where the action is')\ndef x():\n    print ('peripheral task: might be useful in other projects')\nx()\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<blockquote>\n<p>What is this code actually doing?</p>\n</blockquote>\n<p>When you execute <code>xy.py</code>, you <code>import ab</code>. The import statement runs the module immediately on import, so <code>ab</code>'s operations get executed before the remainder of <code>xy</code>'s. Once finished with <code>ab</code>, it continues with <code>xy</code>.</p>\n<p>The interpreter keeps track of which scripts are running with <code>__name__</code>. When you run a script - no matter what you've named it - the interpreter calls it <code>\"__main__\"</code>, making it the master or 'home' script that gets returned to after running an external script.</p>\n<p>Any other script that's called from this <code>\"__main__\"</code> script is assigned its filename as its <code>__name__</code> (e.g., <code>__name__ == \"ab.py\"</code>). Hence, the line <code>if __name__ == \"__main__\":</code> is the interpreter's test to determine if it's interpreting/parsing the 'home' script that was initially executed, or if it's temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it's executed directly vs. called externally.</p>\n<p>Let's step through the above code to understand what's happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or <code>def</code> - blocks don't do anything by themselves until they're called. What the interpreter might say if mumbled to itself:</p>\n<ul>\n<li>Open xy.py as the 'home' file; call it <code>\"__main__\"</code> in the <code>__name__</code> variable.</li>\n<li>Import and open file with the <code>__name__ == \"ab.py\"</code>.</li>\n<li>Oh, a function. I'll remember that.</li>\n<li>Ok, function <code>a()</code>; I just learned that. Printing '<em>A function in ab file</em>'.</li>\n<li>End of file; back to <code>\"__main__\"</code>!</li>\n<li>Oh, a function. I'll remember that.</li>\n<li>Another one.</li>\n<li>Function <code>x()</code>; ok, printing '<em>peripheral task: might be useful in other projects</em>'.</li>\n<li>What's this? An <code>if</code> statement. Well, the condition has been met (the variable <code>__name__</code> has been set to <code>\"__main__\"</code>), so I'll enter the <code>main()</code> function and print '<em>main function: this is where the action is</em>'.</li>\n</ul>\n<p>The bottom two lines mean: \"If this is the <code>\"__main__\"</code> or 'home' script, execute the function called <code>main()</code>\". That's why you'll see a <code>def main():</code> block up top, which contains the main flow of the script's functionality.</p>\n<blockquote>\n<p>Why implement this?</p>\n</blockquote>\n<p>Remember what I said earlier about import statements? When you import a module it doesn't just 'recognize' it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the <code>main()</code> function effectively quarantines it, putting it in isolation so that it won't immediately run when imported by another script.</p>\n<p>Again, there will be exceptions, but common practice is that <code>main()</code> doesn't usually get called externally. So you may be wondering one more thing: if we're not calling <code>main()</code>, why are we calling the script at all? It's because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They're then later called somewhere else in the body of the script. Which brings me to this:</p>\n<blockquote>\n<p>But the code works without it</p>\n</blockquote>\n<p>Yes, that's right. These separate functions <strong>can</strong> be called from an in-line script that's not contained inside a <code>main()</code> function. If you're accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you'll try to figure it out again if you ever need that operation again ... well, you're not used to this kind of internal structure to your code, because it's more complicated to build and it's not as intuitive to read.</p>\n<p>But that's a script that probably can't have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you're trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.</p>\n<p>In splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, \"example.py\" might import \"xy.py\" and call <code>x()</code>, making use of the 'x' function from \"xy.py\". (Maybe it's capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)</p>\n<p>(As an aside, <a href=\"https://stackoverflow.com/questions/23000075/purpose-of-if-name-main\">this question</a> contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it's been marked as a duplicate of <a href=\"https://stackoverflow.com/questions/419163/what-does-if-name-main-do\">this one</a>, which I think is a mistake.)</p>\n", "abstract": "There are lots of different takes here on the mechanics of the code in question, the \"How\", but for me none of it made sense until I understood the \"Why\". This should be especially helpful for new programmers. Take file \"ab.py\": And a second file \"xy.py\": What is this code actually doing? When you execute xy.py, you import ab. The import statement runs the module immediately on import, so ab's operations get executed before the remainder of xy's. Once finished with ab, it continues with xy. The interpreter keeps track of which scripts are running with __name__. When you run a script - no matter what you've named it - the interpreter calls it \"__main__\", making it the master or 'home' script that gets returned to after running an external script. Any other script that's called from this \"__main__\" script is assigned its filename as its __name__ (e.g., __name__ == \"ab.py\"). Hence, the line if __name__ == \"__main__\": is the interpreter's test to determine if it's interpreting/parsing the 'home' script that was initially executed, or if it's temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it's executed directly vs. called externally. Let's step through the above code to understand what's happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or def - blocks don't do anything by themselves until they're called. What the interpreter might say if mumbled to itself: The bottom two lines mean: \"If this is the \"__main__\" or 'home' script, execute the function called main()\". That's why you'll see a def main(): block up top, which contains the main flow of the script's functionality. Why implement this? Remember what I said earlier about import statements? When you import a module it doesn't just 'recognize' it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the main() function effectively quarantines it, putting it in isolation so that it won't immediately run when imported by another script. Again, there will be exceptions, but common practice is that main() doesn't usually get called externally. So you may be wondering one more thing: if we're not calling main(), why are we calling the script at all? It's because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They're then later called somewhere else in the body of the script. Which brings me to this: But the code works without it Yes, that's right. These separate functions can be called from an in-line script that's not contained inside a main() function. If you're accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you'll try to figure it out again if you ever need that operation again ... well, you're not used to this kind of internal structure to your code, because it's more complicated to build and it's not as intuitive to read. But that's a script that probably can't have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you're trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables. In splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, \"example.py\" might import \"xy.py\" and call x(), making use of the 'x' function from \"xy.py\". (Maybe it's capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.) (As an aside, this question contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it's been marked as a duplicate of this one, which I think is a mistake.)"}, {"id": 60017299, "score": 75, "vote": 0, "content": "<p>The code under <code>if __name__ == '__main__':</code> will <em>only</em> be executed if the module is invoked as a script.</p>\n<p>As an example, consider the following module <code>my_test_module.py</code>:</p>\n<pre><code class=\"python\"># my_test_module.py\n\nprint('This is going to be printed out, no matter what')\n\nif __name__ == '__main__':\n    print('This is going to be printed out, only if user invokes the module as a script')\n</code></pre>\n<hr/>\n<p><strong>First possibility: Import <code>my_test_module.py</code> in another module</strong></p>\n<pre><code class=\"python\"># main.py\n\nimport my_test_module\n\nif __name__ == '__main__':\n    print('Hello from main.py')\n</code></pre>\n<p>Now if you invoke <code>main.py</code>:</p>\n<pre><code class=\"python\">python main.py\n\n&gt;&gt; 'This is going to be printed out, no matter what'\n&gt;&gt; 'Hello from main.py'\n</code></pre>\n<p>Note that only the top-level <code>print()</code> statement in <code>my_test_module</code> is executed.</p>\n<hr/>\n<p><strong>Second possibility: Invoke <code>my_test_module.py</code> as a script</strong></p>\n<p>Now if you run <code>my_test_module.py</code> as a Python script, both <code>print()</code> statements will be executed:</p>\n<pre><code class=\"python\">python my_test_module.py\n\n&gt;&gt;&gt; 'This is going to be printed out, no matter what'\n&gt;&gt;&gt; 'This is going to be printed out, only if user invokes the module as a script'\n</code></pre>\n<hr/>\n<p>For a more comprehensive explanation, you can read <em><a href=\"https://towardsdatascience.com/what-does-if-name-main-do-e357dd61be1a\" rel=\"noreferrer\">What does <code>if __name__ == '__main__'</code> do in Python</a></em>.</p>\n", "abstract": "The code under if __name__ == '__main__': will only be executed if the module is invoked as a script. As an example, consider the following module my_test_module.py: First possibility: Import my_test_module.py in another module Now if you invoke main.py: Note that only the top-level print() statement in my_test_module is executed. Second possibility: Invoke my_test_module.py as a script Now if you run my_test_module.py as a Python script, both print() statements will be executed: For a more comprehensive explanation, you can read What does if __name__ == '__main__' do in Python."}, {"id": 15789709, "score": 68, "vote": 0, "content": "<p>When there are certain statements in our module (<code>M.py</code>) we want to be executed when it'll be running as main (not imported), we can place those statements (test-cases, print statements) under this <code>if</code> block.</p>\n<p>As by default (when module running as main, not imported) the <code>__name__</code> variable is set to <code>\"__main__\"</code>, and when it'll be imported the <code>__name__</code> variable will get a different value, most probably the name of the module (<code>'M'</code>).\nThis is helpful in running different variants of a modules together, and separating their specific input &amp; output statements and also if there are any test-cases.</p>\n<p><strong>In short</strong>, use this '<code>if __name__ == \"main\"</code> ' block to prevent (certain) code from being run when the module is imported.</p>\n", "abstract": "When there are certain statements in our module (M.py) we want to be executed when it'll be running as main (not imported), we can place those statements (test-cases, print statements) under this if block. As by default (when module running as main, not imported) the __name__ variable is set to \"__main__\", and when it'll be imported the __name__ variable will get a different value, most probably the name of the module ('M').\nThis is helpful in running different variants of a modules together, and separating their specific input & output statements and also if there are any test-cases. In short, use this 'if __name__ == \"main\" ' block to prevent (certain) code from being run when the module is imported."}, {"id": 40057173, "score": 63, "vote": 0, "content": "<p>Put simply, <code>__name__</code> is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module.</p>\n<p>So if we have two scripts;</p>\n<pre><code class=\"python\">#script1.py\nprint \"Script 1's name: {}\".format(__name__)\n</code></pre>\n<p>and</p>\n<pre><code class=\"python\">#script2.py\nimport script1\nprint \"Script 2's name: {}\".format(__name__)\n</code></pre>\n<p>The output from executing script1 is</p>\n<pre><code class=\"python\">Script 1's name: __main__\n</code></pre>\n<p>And the output from executing script2 is:</p>\n<pre><code class=\"python\">Script1's name is script1\nScript 2's name: __main__\n</code></pre>\n<p>As you can see, <code>__name__</code> tells us which code is the 'main' module.\nThis is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a 'main' function then it cannot be compiled as an executable and if it does, it cannot then be used as a library.</p>\n<p>Say you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the  <code>if __name__ == \"__main__\":</code> context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;</p>\n<p><a href=\"https://i.stack.imgur.com/hWLqr.png\" rel=\"noreferrer\"><img alt=\"Complicated importing in C\" src=\"https://i.stack.imgur.com/hWLqr.png\"/></a></p>\n<p>The arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:</p>\n<p><a href=\"https://i.stack.imgur.com/Eql0u.png\" rel=\"noreferrer\"><img alt=\"Elegant importing in Python\" src=\"https://i.stack.imgur.com/Eql0u.png\"/></a></p>\n<p>You write a module, and if someone wants to use your code they just import it and the <code>__name__</code> variable can help to separate the executable portion of the program from the library part.</p>\n", "abstract": "Put simply, __name__ is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module. So if we have two scripts; and The output from executing script1 is And the output from executing script2 is: As you can see, __name__ tells us which code is the 'main' module.\nThis is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a 'main' function then it cannot be compiled as an executable and if it does, it cannot then be used as a library. Say you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the  if __name__ == \"__main__\": context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;  The arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:  You write a module, and if someone wants to use your code they just import it and the __name__ variable can help to separate the executable portion of the program from the library part."}, {"id": 28051929, "score": 55, "vote": 0, "content": "<p>Let's look at the answer in a more abstract way:</p>\n<p>Suppose we have this code in <code>x.py</code>:</p>\n<pre><code class=\"python\">...\n&lt;Block A&gt;\nif __name__ == '__main__':\n    &lt;Block B&gt;\n...\n</code></pre>\n<p>Blocks A and B are run when we are running <code>x.py</code>.</p>\n<p>But just block A (and not B) is run when we are running another module, <code>y.py</code> for example, in which <code>x.py</code> is imported and the code is run from there (like when a function in <code>x.py</code> is called from <code>y.py</code>).</p>\n", "abstract": "Let's look at the answer in a more abstract way: Suppose we have this code in x.py: Blocks A and B are run when we are running x.py. But just block A (and not B) is run when we are running another module, y.py for example, in which x.py is imported and the code is run from there (like when a function in x.py is called from y.py)."}, {"id": 51011507, "score": 55, "vote": 0, "content": "<p>To be short, you need to know several points:</p>\n<ol>\n<li><p><code>import a</code> action actually runs all that can be run in <code>a.py</code>, meaning each line in <code>a.py</code></p>\n</li>\n<li><p>Because of point 1, you may not want everything to be run in <code>a.py</code> when importing it</p>\n</li>\n<li><p>To solve the problem in point 2, Python allows you to use a condition check</p>\n</li>\n<li><p><code>__name__</code> is an implicit variable in all <code>.py</code> modules:</p>\n</li>\n</ol>\n<ul>\n<li>when <code>a.py</code> is <code>import</code>ed, the value of <code>__name__</code> of <code>a.py</code> module is set to its file name \"<code>a</code>\"</li>\n<li>when <code>a.py</code> is run directly using \"<code>python a.py</code>\", the value of <code>__name__</code> is set to a string <code>__main__</code></li>\n</ul>\n<ol start=\"5\">\n<li>Based on the mechanism how Python sets the variable <code>__name__</code> for each module, do you know how to achieve point 3? The answer is fairly easy, right? Use an <em>if</em> condition: <code>if __name__ == \"__main__\": // do A</code></li>\n</ol>\n<ul>\n<li>then <code>python a.py</code> will run the part <code>// do A</code></li>\n<li>and <code>import a</code> will skip the part <code>// do A</code></li>\n</ul>\n<ol start=\"6\">\n<li>You can even put if <code>__name__ == \"a\"</code> depending on your functional need, but rarely do</li>\n</ol>\n<p>The important thing that Python is special at is point 4! The rest is just basic logic.</p>\n<p><sub>I've been reading so much throughout the answers on this page. I would say, if you know the thing, for sure you will understand those answers, otherwise, you are still confused.</sub></p>\n", "abstract": "To be short, you need to know several points: import a action actually runs all that can be run in a.py, meaning each line in a.py Because of point 1, you may not want everything to be run in a.py when importing it To solve the problem in point 2, Python allows you to use a condition check __name__ is an implicit variable in all .py modules: The important thing that Python is special at is point 4! The rest is just basic logic. I've been reading so much throughout the answers on this page. I would say, if you know the thing, for sure you will understand those answers, otherwise, you are still confused."}, {"id": 20517795, "score": 44, "vote": 0, "content": "<p>When you run Python interactively the local <code>__name__</code> variable is assigned a value of <code>__main__</code>. Likewise, when you execute a Python module from the command line, rather than importing it into another module, its <code>__name__</code> attribute is assigned a value of <code>__main__</code>, rather than the actual name of the module. In this way, modules can look at their own <code>__name__</code> value to determine for themselves how they are being used, whether as support for another program or as the main application executed from the command line. Thus, the following idiom is quite common in Python modules:</p>\n<pre><code class=\"python\">if __name__ == '__main__':\n    # Do something appropriate here, like calling a\n    # main() function defined elsewhere in this module.\n    main()\nelse:\n    # Do nothing. This module has been imported by another\n    # module that wants to make use of the functions,\n    # classes and other useful bits it has defined.\n</code></pre>\n", "abstract": "When you run Python interactively the local __name__ variable is assigned a value of __main__. Likewise, when you execute a Python module from the command line, rather than importing it into another module, its __name__ attribute is assigned a value of __main__, rather than the actual name of the module. In this way, modules can look at their own __name__ value to determine for themselves how they are being used, whether as support for another program or as the main application executed from the command line. Thus, the following idiom is quite common in Python modules:"}, {"id": 45824951, "score": 42, "vote": 0, "content": "<p>Consider:</p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n    main()\n</code></pre>\n<p>It checks if the <code>__name__</code> attribute of the Python script is <code>\"__main__\"</code>. In other words, if the program itself is executed, the attribute will be <code>__main__</code>, so the program will be executed (in this case the <code>main()</code> function).</p>\n<p>However, if your Python script is used by a module, any code outside of the <code>if</code> statement will be executed, so <code>if __name__ == \"__main__\"</code> is used just to check if the program is used as a module or not, and therefore decides whether to run the code.</p>\n", "abstract": "Consider: It checks if the __name__ attribute of the Python script is \"__main__\". In other words, if the program itself is executed, the attribute will be __main__, so the program will be executed (in this case the main() function). However, if your Python script is used by a module, any code outside of the if statement will be executed, so if __name__ == \"__main__\" is used just to check if the program is used as a module or not, and therefore decides whether to run the code."}, {"id": 49637838, "score": 40, "vote": 0, "content": "<p><em>Before explaining anything about <code>if __name__ == '__main__'</code> it is important to understand what <code>__name__</code> is and what it does.</em></p>\n<h2>What is <code>__name__</code>?</h2>\n<p><code>__name__</code> is a <a href=\"https://wiki.python.org/moin/DunderAlias\" rel=\"nofollow noreferrer\">DunderAlias</a> - can be thought of as a global variable (accessible from modules) and works in a similar way to <a href=\"https://stackoverflow.com/questions/13881395/in-python-what-is-a-global-statement\"><code>global</code></a>.</p>\n<p>It is a string (global as mentioned above) as indicated by <code>type(__name__)</code> (yielding <code>&lt;class 'str'&gt;</code>), and is an inbuilt standard for both <a href=\"https://docs.python.org/3/library/__main__.html\" rel=\"nofollow noreferrer\">Python 3</a> and <a href=\"https://docs.python.org/2/library/__main__.html\" rel=\"nofollow noreferrer\">Python 2</a> versions.</p>\n<h2>Where</h2>\n<p>It can not only be used in scripts but can also be found in both the interpreter and modules/packages.</p>\n<h3>Interpreter:</h3>\n<pre><code class=\"python\">&gt;&gt;&gt; print(__name__)\n__main__\n&gt;&gt;&gt;\n</code></pre>\n<h3>Script:</h3>\n<p><em>test_file.py</em>:</p>\n<pre><code class=\"python\">print(__name__)\n</code></pre>\n<p>Resulting in <code>__main__</code></p>\n<h3>Module or package:</h3>\n<p><em>somefile.py:</em></p>\n<pre><code class=\"python\">def somefunction():\n    print(__name__)\n</code></pre>\n<p><em>test_file.py:</em></p>\n<pre><code class=\"python\">import somefile\nsomefile.somefunction()\n</code></pre>\n<p>Resulting in <code>somefile</code></p>\n<p>Notice that when used in a package or module, <code>__name__</code> takes the name of the file.  The path of the actual module or package path is not given, but has its own DunderAlias <code>__file__</code>, that allows for this.</p>\n<p>You should see that, where <code>__name__</code>, where it is the main file (or program) will <em>always</em> return <code>__main__</code>, and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from.</p>\n<h2>Practice</h2>\n<p>Being a variable means that it's value <em>can</em> be overwritten (\"can\" does not mean \"should\"), overwriting the value of <code>__name__</code> will result in a lack of readability.  So do not do it, for any reason.  If you need a variable define a new variable.</p>\n<p>It is always assumed that the value of <code>__name__</code> to be <code>__main__</code> or the name of the file.  Once again changing this default value will cause more confusion that it will do good, causing problems further down the line.</p>\n<h3>Example:</h3>\n<pre><code class=\"python\">&gt;&gt;&gt; __name__ = 'Horrify' # Change default from __main__\n&gt;&gt;&gt; if __name__ == 'Horrify': print(__name__)\n...\n&gt;&gt;&gt; else: print('Not Horrify')\n...\nHorrify\n&gt;&gt;&gt;\n</code></pre>\n<p>It is considered good practice in general to include the <code>if __name__ == '__main__'</code> in scripts.</p>\n<h2>Now to answer <code>if __name__ == '__main__'</code>:</h2>\n<p><em>Now we know the behaviour of <code>__name__</code> things become clearer:</em></p>\n<p>An <a href=\"https://docs.python.org/3/tutorial/controlflow.html#if-statements\" rel=\"nofollow noreferrer\"><code>if</code></a> is a flow control statement that contains the block of code will execute if the value given is true. We have seen that <code>__name__</code> can take either\n<code>__main__</code> or the file name it has been imported from.</p>\n<p>This means that if <code>__name__</code> is equal to <code>__main__</code> then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script.</p>\n<p>If indeed <code>__name__</code> does take the value of <code>__main__</code> then whatever is in that block of code will execute.</p>\n<p>This tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute.  If it is a package then it should not, and the value will not be <code>__main__</code>.</p>\n<h3>Modules</h3>\n<p><code>__name__</code> can also be used in modules to define the name of a module</p>\n<h3>Variants</h3>\n<p>It is also possible to do other, less common but useful things with <code>__name__</code>, some I will show here:</p>\n<h3>Executing only if the file is a module or package</h3>\n<pre><code class=\"python\">if __name__ != '__main__':\n    # Do some useful things \n</code></pre>\n<h3>Running one condition if the file is the main one and another if it is not</h3>\n<pre><code class=\"python\">if __name__ == '__main__':\n    # Execute something\nelse:\n    # Do some useful things\n</code></pre>\n<p>You can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries.</p>\n<p>It also allows modules to be run from the command line as main scripts, which can be also very useful.</p>\n", "abstract": "Before explaining anything about if __name__ == '__main__' it is important to understand what __name__ is and what it does. __name__ is a DunderAlias - can be thought of as a global variable (accessible from modules) and works in a similar way to global. It is a string (global as mentioned above) as indicated by type(__name__) (yielding <class 'str'>), and is an inbuilt standard for both Python 3 and Python 2 versions. It can not only be used in scripts but can also be found in both the interpreter and modules/packages. test_file.py: Resulting in __main__ somefile.py: test_file.py: Resulting in somefile Notice that when used in a package or module, __name__ takes the name of the file.  The path of the actual module or package path is not given, but has its own DunderAlias __file__, that allows for this. You should see that, where __name__, where it is the main file (or program) will always return __main__, and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from. Being a variable means that it's value can be overwritten (\"can\" does not mean \"should\"), overwriting the value of __name__ will result in a lack of readability.  So do not do it, for any reason.  If you need a variable define a new variable. It is always assumed that the value of __name__ to be __main__ or the name of the file.  Once again changing this default value will cause more confusion that it will do good, causing problems further down the line. It is considered good practice in general to include the if __name__ == '__main__' in scripts. Now we know the behaviour of __name__ things become clearer: An if is a flow control statement that contains the block of code will execute if the value given is true. We have seen that __name__ can take either\n__main__ or the file name it has been imported from. This means that if __name__ is equal to __main__ then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script. If indeed __name__ does take the value of __main__ then whatever is in that block of code will execute. This tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute.  If it is a package then it should not, and the value will not be __main__. __name__ can also be used in modules to define the name of a module It is also possible to do other, less common but useful things with __name__, some I will show here: You can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries. It also allows modules to be run from the command line as main scripts, which can be also very useful."}, {"id": 14502904, "score": 35, "vote": 0, "content": "<p>It is a special for when a Python file is called from the command line. This is typically used to call a \"main()\" function or execute other appropriate startup code, like commandline arguments handling for instance.</p>\n<p>It could be written in several ways. Another is:</p>\n<pre><code class=\"python\">def some_function_for_instance_main():\n    dosomething()\n\n\n__name__ == '__main__' and some_function_for_instance_main()\n</code></pre>\n<p>I am not saying you should use this in production code, but it serves to illustrate that there is nothing \"magical\" about <code>if __name__ == '__main__'</code>.</p>\n<p>It just a convention for invoking a main function in Python files.</p>\n", "abstract": "It is a special for when a Python file is called from the command line. This is typically used to call a \"main()\" function or execute other appropriate startup code, like commandline arguments handling for instance. It could be written in several ways. Another is: I am not saying you should use this in production code, but it serves to illustrate that there is nothing \"magical\" about if __name__ == '__main__'. It just a convention for invoking a main function in Python files."}, {"id": 40881975, "score": 35, "vote": 0, "content": "<p>I think it's best to break the answer in depth and in simple words:</p>\n<p><code>__name__</code>: Every module in Python has a special attribute called <code>__name__</code>.\nIt is a built-in variable that returns the name of the module.</p>\n<p><code>__main__</code>: Like other programming languages, Python too has an execution entry point, i.e., main. <code>'__main__'</code> <em>is the name of the scope in which top-level code executes</em>. Basically you have two ways of using a Python module: Run it directly as a script, or import it. When a module is run as a script, its <code>__name__</code> is set to <code>__main__</code>.</p>\n<p>Thus, the value of the <code>__name__</code> attribute is set to <code>__main__</code> when the module is run as the main program. Otherwise the value of <code>__name__</code>  is set to contain the name of the module.</p>\n", "abstract": "I think it's best to break the answer in depth and in simple words: __name__: Every module in Python has a special attribute called __name__.\nIt is a built-in variable that returns the name of the module. __main__: Like other programming languages, Python too has an execution entry point, i.e., main. '__main__' is the name of the scope in which top-level code executes. Basically you have two ways of using a Python module: Run it directly as a script, or import it. When a module is run as a script, its __name__ is set to __main__. Thus, the value of the __name__ attribute is set to __main__ when the module is run as the main program. Otherwise the value of __name__  is set to contain the name of the module."}, {"id": 33916552, "score": 28, "vote": 0, "content": "<p>There are a number of variables that the system (Python interpreter) provides for source files (modules).  You can get their values anytime you want, so, let us focus on the <strong>__name__</strong> variable/attribute:</p>\n<p>When Python loads a source code file, it executes all of the code found in it. (Note that it doesn't call all of the methods and functions defined in the file, but it does define them.)</p>\n<p>Before the interpreter executes the source code file though, it defines a few special variables for that file; <strong>__name__</strong> is one of those special variables that Python automatically defines for each source code file.</p>\n<p>If Python is loading this source code file as the main program (i.e. the file you run), then it sets the special <strong>__name__</strong> variable for this file to have a value <strong>\"__main__\"</strong>.</p>\n<p>If this is being imported from another module, <strong>__name__</strong> will be set to that module's name.</p>\n<p>So, in your example in part:</p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n   lock = thread.allocate_lock()\n   thread.start_new_thread(myfunction, (\"Thread #: 1\", 2, lock))\n   thread.start_new_thread(myfunction, (\"Thread #: 2\", 2, lock))\n</code></pre>\n<p>means that the code block:</p>\n<pre><code class=\"python\">lock = thread.allocate_lock()\nthread.start_new_thread(myfunction, (\"Thread #: 1\", 2, lock))\nthread.start_new_thread(myfunction, (\"Thread #: 2\", 2, lock))\n</code></pre>\n<p>will be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of <strong>__name__</strong> will not equal to \"<strong>main</strong>\" in that particular instance.</p>\n<p>Hope this helps out.</p>\n", "abstract": "There are a number of variables that the system (Python interpreter) provides for source files (modules).  You can get their values anytime you want, so, let us focus on the __name__ variable/attribute: When Python loads a source code file, it executes all of the code found in it. (Note that it doesn't call all of the methods and functions defined in the file, but it does define them.) Before the interpreter executes the source code file though, it defines a few special variables for that file; __name__ is one of those special variables that Python automatically defines for each source code file. If Python is loading this source code file as the main program (i.e. the file you run), then it sets the special __name__ variable for this file to have a value \"__main__\". If this is being imported from another module, __name__ will be set to that module's name. So, in your example in part: means that the code block: will be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of __name__ will not equal to \"main\" in that particular instance. Hope this helps out."}, {"id": 36820845, "score": 26, "vote": 0, "content": "<p><code>if __name__ == \"__main__\":</code> is basically the top-level script environment, and it specifies the interpreter that ('I have the highest priority to be executed first').</p>\n<p><code>'__main__'</code> is the name of the scope in which top-level code executes. A module\u2019s <code>__name__</code> is set equal to <code>'__main__'</code> when read from standard input, a script, or from an interactive prompt.</p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n    # Execute only if run as a script\n    main()\n</code></pre>\n", "abstract": "if __name__ == \"__main__\": is basically the top-level script environment, and it specifies the interpreter that ('I have the highest priority to be executed first'). '__main__' is the name of the scope in which top-level code executes. A module\u2019s __name__ is set equal to '__main__' when read from standard input, a script, or from an interactive prompt."}, {"id": 37965772, "score": 25, "vote": 0, "content": "<p>Consider:</p>\n<pre><code class=\"python\">print __name__\n</code></pre>\n<p>The output for the above is <code>__main__</code>.</p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n  print \"direct method\"\n</code></pre>\n<p>The above statement is true and prints <em>\"direct method\"</em>. Suppose if they imported this class in another class it doesn't print <em>\"direct method\"</em> because, while importing, it will set <code>__name__ equal to \"first model name\"</code>.</p>\n", "abstract": "Consider: The output for the above is __main__. The above statement is true and prints \"direct method\". Suppose if they imported this class in another class it doesn't print \"direct method\" because, while importing, it will set __name__ equal to \"first model name\"."}, {"id": 42773985, "score": 20, "vote": 0, "content": "<blockquote>\n<p>You can make the file usable as a <strong>script</strong> as well as an <strong>importable module</strong>.</p>\n</blockquote>\n<p><strong>fibo.py (a module named <code>fibo</code>)</strong></p>\n<pre><code class=\"python\"># Other modules can IMPORT this MODULE to use the function fib\ndef fib(n):    # write Fibonacci series up to n\n    a, b = 0, 1\n    while b &lt; n:\n        print(b, end=' ')\n        a, b = b, a+b\n    print()\n\n# This allows the file to be used as a SCRIPT\nif __name__ == \"__main__\":\n    import sys\n    fib(int(sys.argv[1]))\n</code></pre>\n<p>Reference: <a href=\"https://docs.python.org/3.5/tutorial/modules.html\" rel=\"noreferrer\">https://docs.python.org/3.5/tutorial/modules.html</a></p>\n", "abstract": "You can make the file usable as a script as well as an importable module. fibo.py (a module named fibo) Reference: https://docs.python.org/3.5/tutorial/modules.html"}, {"id": 46371154, "score": 20, "vote": 0, "content": "<p>The reason for</p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n    main()\n</code></pre>\n<p>is primarily to avoid the <a href=\"https://docs.python.org/2/library/threading.html#importing-in-threaded-code\" rel=\"noreferrer\">import lock</a> problems that would arise from <a href=\"https://stackoverflow.com/questions/46326059/\">having code directly imported</a>. You want <code>main()</code> to run if your file was directly invoked (that's the <code>__name__ == \"__main__\"</code> case), but if your code was imported then the importer has to enter your code from the true main module to avoid import lock problems.</p>\n<p>A side-effect is that you automatically sign on to a methodology that supports multiple entry points. You can run your program using <code>main()</code> as the entry point, <em>but you don't have to</em>. While <code>setup.py</code> expects <code>main()</code>, other tools use alternate entry points. For example, to run your file as a <code>gunicorn</code> process, you define an <code>app()</code> function instead of a <code>main()</code>. Just as with <code>setup.py</code>, <code>gunicorn</code> imports your code so you don't want it do do anything while it's being imported (because of the import lock issue).</p>\n", "abstract": "The reason for is primarily to avoid the import lock problems that would arise from having code directly imported. You want main() to run if your file was directly invoked (that's the __name__ == \"__main__\" case), but if your code was imported then the importer has to enter your code from the true main module to avoid import lock problems. A side-effect is that you automatically sign on to a methodology that supports multiple entry points. You can run your program using main() as the entry point, but you don't have to. While setup.py expects main(), other tools use alternate entry points. For example, to run your file as a gunicorn process, you define an app() function instead of a main(). Just as with setup.py, gunicorn imports your code so you don't want it do do anything while it's being imported (because of the import lock issue)."}, {"id": 64488013, "score": 20, "vote": 0, "content": "<p>In simple words:</p>\n<p>The code you see under <code>if __name__ == \"__main__\":</code> will only get called upon when your Python file is executed as <code>python example1.py</code></p>\n<p>However, if you wish to import your Python file <code>example1.py</code> as a module to work with another Python file, say <code>example2.py</code>, the code under <code>if __name__ == \"__main__\":</code> will not run or take any effect.</p>\n", "abstract": "In simple words: The code you see under if __name__ == \"__main__\": will only get called upon when your Python file is executed as python example1.py However, if you wish to import your Python file example1.py as a module to work with another Python file, say example2.py, the code under if __name__ == \"__main__\": will not run or take any effect."}, {"id": 69778466, "score": 19, "vote": 0, "content": "<p>If you are a beginner, probably the only answer you need right now is that <em>this code is unnecessary</em> for a simple script. It is only useful if you want to be able to <code>import</code> your script (or <code>unpickle</code> etc; see the other answers here for some other non-beginner scenarios).</p>\n<p>In slightly different words, the <code>if __name__</code> guard is a mechanism for hiding code from other code. If you don't have a specific reason to hide something, don't: If you don't need to hide some code from <code>import</code>, don't put it behind this guard, and if you do, hide as little as possible.</p>\n<p>In slightly more detail, let's say you have a simple script <code>fib.py</code> (adapted from <a href=\"https://stackoverflow.com/a/42773985/874188\">this answer</a>):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># XXX FIXME: useless (see below)\nif __name__ == \"__main__\":\n    n = int(input('Write a number: '))\n    a, b = 0, 1\n    while b &lt; n:\n        a, b = b, a+b\n    print('Fibonacci number %i: %i' % (n, b))\n</code></pre>\n<p>Now, if you simply run <code>python fib.py</code> it works fine. But <code>__name__</code> will always be <code>\"__main__\"</code> in this scenario, so the condition is actually unnecessary. The script could be simplified to just</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">n = int(input('Write a number: '))\na, b = 0, 1\nwhile b &lt; n:\n    a, b = b, a+b\nprint('Fibonacci number %i: %i' % (n, b))\n</code></pre>\n<p>Now, you can't <code>import fib</code> with the new version, but if you didn't plan to do that in the first place, this version is actually better, because it's simpler and clearer.</p>\n<p>If you <em>do</em> want to be able to <code>import fib</code>, the first version is useless, too, because the useful code is in a section which will not run when you <code>import</code> this file (in which case <code>__name__</code> will not be <code>\"__main__\"</code>). The proper design in that case would be to refactor the code so that the useful parts are in a function you can run when you want to after you have <code>import</code>ed it.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def main():\n    n = int(input('Write a number: '))\n    a, b = 0, 1\n    while b &lt; n:\n        a, b = b, a+b\n    print('Fibonacci number %i: %i' % (n, b))\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p>Now, if you <code>import fib</code>, the call to <code>main()</code> will not be executed; but when you run <code>python fib.py</code>, it will.</p>\n<p>Actually, a better design still would be to isolate the reusable part (the actual calculation) from the user-visible input/output:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def fibn(n: int) -&gt; int:\n    a, b = 0, 1\n    while b &lt; n:\n        a, b = b, a+b\n    return b\n\ndef main() -&gt; None:\n    n = int(input('Write a number: '))\n    print('Fibonacci number %i: %i' % (n, fibn(n)))\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p>Now, you can <code>from fib import fibn</code> and call the <code>fibn()</code> function from the code which performs this <code>import</code>.</p>\n<p>(I called the function <code>fibn()</code> just to make it clearer what is what in this example. In real life, you might call it <code>fib()</code> and do <code>from fib import fib</code>.)</p>\n<p>Similarly, you could <code>import</code> and call the <code>main</code> function if you wanted to reuse it.</p>\n<p>Returning to the code in the question, I would similarly move the code from the <code>if</code> into a function as well, so that callers can invoke that function if they want to.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def main():\n    lock = thread.allocate_lock()\n    thread.start_new_thread(myfunction, (\"Thread #: 1\", 2, lock))\n    thread.start_new_thread(myfunction, (\"Thread #: 2\", 2, lock))\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p>This changes the scope of the <code>lock</code> variable; if the surrounding code needs access to it, you will need to make it <code>global</code> (or, perhaps, better, refactor <code>main</code> to <code>return lock</code>, and have the caller capture the value in a local variable of its own).</p>\n<p>(Unlike in languages like C, the name <code>main</code> has no specific meaning to Python; but it's a common convention to use it as the name of the thing which will be run. You still have to actually explicitly call it, like <code>main()</code>, unlike in C.)</p>\n", "abstract": "If you are a beginner, probably the only answer you need right now is that this code is unnecessary for a simple script. It is only useful if you want to be able to import your script (or unpickle etc; see the other answers here for some other non-beginner scenarios). In slightly different words, the if __name__ guard is a mechanism for hiding code from other code. If you don't have a specific reason to hide something, don't: If you don't need to hide some code from import, don't put it behind this guard, and if you do, hide as little as possible. In slightly more detail, let's say you have a simple script fib.py (adapted from this answer): Now, if you simply run python fib.py it works fine. But __name__ will always be \"__main__\" in this scenario, so the condition is actually unnecessary. The script could be simplified to just Now, you can't import fib with the new version, but if you didn't plan to do that in the first place, this version is actually better, because it's simpler and clearer. If you do want to be able to import fib, the first version is useless, too, because the useful code is in a section which will not run when you import this file (in which case __name__ will not be \"__main__\"). The proper design in that case would be to refactor the code so that the useful parts are in a function you can run when you want to after you have imported it. Now, if you import fib, the call to main() will not be executed; but when you run python fib.py, it will. Actually, a better design still would be to isolate the reusable part (the actual calculation) from the user-visible input/output: Now, you can from fib import fibn and call the fibn() function from the code which performs this import. (I called the function fibn() just to make it clearer what is what in this example. In real life, you might call it fib() and do from fib import fib.) Similarly, you could import and call the main function if you wanted to reuse it. Returning to the code in the question, I would similarly move the code from the if into a function as well, so that callers can invoke that function if they want to. This changes the scope of the lock variable; if the surrounding code needs access to it, you will need to make it global (or, perhaps, better, refactor main to return lock, and have the caller capture the value in a local variable of its own). (Unlike in languages like C, the name main has no specific meaning to Python; but it's a common convention to use it as the name of the thing which will be run. You still have to actually explicitly call it, like main(), unlike in C.)"}, {"id": 56558865, "score": 18, "vote": 0, "content": "<p>Every module in Python has an attribute called <code>__name__</code>. The value of <code>__name__</code>  attribute is  <code>__main__</code> when the module is run directly, like <code>python my_module.py</code>. Otherwise (like when you say <code>import my_module</code>) the value of <code>__name__</code>  is the name of the module.</p>\n<p>Small example to explain in short.</p>\n<h3>Script <em>test.py</em></h3>\n<pre><code class=\"python\">apple = 42\n\ndef hello_world():\n    print(\"I am inside hello_world\")\n\nif __name__ == \"__main__\":\n    print(\"Value of __name__ is: \", __name__)\n    print(\"Going to call hello_world\")\n    hello_world()\n</code></pre>\n<p>We can execute this directly as</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">python test.py\n</code></pre>\n<p>Output</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">Value of __name__ is: __main__\nGoing to call hello_world\nI am inside hello_world\n</code></pre>\n<p>Now suppose we call the above script from another script:</p>\n<h3>Script <em>external_calling.py</em></h3>\n<pre><code class=\"python\">import test\n\nprint(test.apple)\ntest.hello_world()\n\nprint(test.__name__)\n</code></pre>\n<p>When you execute this,</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">python external_calling.py\n</code></pre>\n<p>Output</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">42\nI am inside hello_world\ntest\n</code></pre>\n<p>So, the above is self-explanatory that when you call <em>test</em> from another script, if loop <code>__name__</code> in <code>test.py</code> will not execute.</p>\n", "abstract": "Every module in Python has an attribute called __name__. The value of __name__  attribute is  __main__ when the module is run directly, like python my_module.py. Otherwise (like when you say import my_module) the value of __name__  is the name of the module. Small example to explain in short. We can execute this directly as Output Now suppose we call the above script from another script: When you execute this, Output So, the above is self-explanatory that when you call test from another script, if loop __name__ in test.py will not execute."}, {"id": 52685565, "score": 15, "vote": 0, "content": "<p>This answer is for Java programmers learning Python.\nEvery Java file typically contains one public class. You can use that class in two ways: </p>\n<ol>\n<li><p>Call the class from other files. You just have to import it in the calling program.</p></li>\n<li><p>Run the class stand alone, for testing purposes. </p></li>\n</ol>\n<p>For the latter case, the class should contain a public static void main() method. In Python this purpose is served by the globally defined label <code>'__main__'</code>.</p>\n", "abstract": "This answer is for Java programmers learning Python.\nEvery Java file typically contains one public class. You can use that class in two ways:  Call the class from other files. You just have to import it in the calling program. Run the class stand alone, for testing purposes.  For the latter case, the class should contain a public static void main() method. In Python this purpose is served by the globally defined label '__main__'."}, {"id": 50927616, "score": 12, "vote": 0, "content": "<p>If this .py file are imported by other .py files, the code under the <code>if</code> statement will not be executed.</p>\n<p>If this .py are run by <code>python this_py.py</code> under shell, or double clicked in Windows. the code under the <code>if</code> statement will be executed.</p>\n<p>It is usually written for testing.</p>\n", "abstract": "If this .py file are imported by other .py files, the code under the if statement will not be executed. If this .py are run by python this_py.py under shell, or double clicked in Windows. the code under the if statement will be executed. It is usually written for testing."}, {"id": 49653760, "score": 11, "vote": 0, "content": "<p>We see if <code>__name__ == '__main__':</code> quite often.</p>\n<p>It checks if a module is being imported or not.</p>\n<p>In other words, the code within the <code>if</code> block will be executed only when the code runs directly. Here <code>directly</code> means <code>not imported</code>.</p>\n<p>Let's see what it does using a simple code that prints the name of the module:</p>\n<pre><code class=\"python\"># test.py\ndef test():\n   print('test module name=%s' %(__name__))\n\nif __name__ == '__main__':\n   print('call test()')\n   test()\n</code></pre>\n<p>If we run the code directly via <code>python test.py</code>, the module name is <code>__main__</code>:</p>\n<pre><code class=\"python\">call test()\ntest module name=__main__\n</code></pre>\n", "abstract": "We see if __name__ == '__main__': quite often. It checks if a module is being imported or not. In other words, the code within the if block will be executed only when the code runs directly. Here directly means not imported. Let's see what it does using a simple code that prints the name of the module: If we run the code directly via python test.py, the module name is __main__:"}, {"id": 57276038, "score": 11, "vote": 0, "content": "<p>If the Python interpreter is running a particular module then the <code>__name__</code> global variable will have the value <code>\"__main__\"</code>:</p>\n<pre><code class=\"python\">  def a():\n      print(\"a\")\n\n  def b():\n      print(\"b\")\n\n  if __name__ == \"__main__\":\n\n          print (\"you can see me\")\n          a()\n  else:\n\n          print (\"You can't see me\")\n          b()\n</code></pre>\n<p>When you run this script, it prints <strong>you can see me</strong>.</p>\n<p><strong>a</strong></p>\n<p>If you import this file, say A to file B, and execute the file B then <code>if __name__ == \"__main__\"</code> in file A becomes false, so it prints  <strong>You can't see me</strong>.</p>\n<p><strong>b</strong></p>\n", "abstract": "If the Python interpreter is running a particular module then the __name__ global variable will have the value \"__main__\": When you run this script, it prints you can see me. a If you import this file, say A to file B, and execute the file B then if __name__ == \"__main__\" in file A becomes false, so it prints  You can't see me. b"}, {"id": 50170459, "score": 8, "vote": 0, "content": "<p>All the answers have pretty much explained the functionality. But I will provide one example of its usage which might help clearing out the concept further.</p>\n<p>Assume that you have two Python files, a.py and b.py. Now, a.py imports b.py. We run the a.py file, where the \"import b.py\" code is executed first. Before the rest of the a.py code runs, the code in the file b.py must run completely.</p>\n<p>In the b.py code there is some code that is exclusive to that file b.py and we don't want any other file (other than b.py file), that has imported the b.py file, to run it.</p>\n<p>So that is what this line of code checks. If it is the main file (i.e., b.py) running the code, which in this case it is not (a.py is the main file running), then only the code gets executed.</p>\n", "abstract": "All the answers have pretty much explained the functionality. But I will provide one example of its usage which might help clearing out the concept further. Assume that you have two Python files, a.py and b.py. Now, a.py imports b.py. We run the a.py file, where the \"import b.py\" code is executed first. Before the rest of the a.py code runs, the code in the file b.py must run completely. In the b.py code there is some code that is exclusive to that file b.py and we don't want any other file (other than b.py file), that has imported the b.py file, to run it. So that is what this line of code checks. If it is the main file (i.e., b.py) running the code, which in this case it is not (a.py is the main file running), then only the code gets executed."}, {"id": 61458664, "score": 8, "vote": 0, "content": "<p>Every module in Python has a special attribute called <code>__name__</code>. The value of the <code>__name__</code>  attribute is set to <code>'__main__'</code> when the module is executed as the main program (e.g., running <code>python foo.py</code>).</p>\n<p>Otherwise, the value of <code>__name__</code> is set to the name of the module that it was called from.</p>\n", "abstract": "Every module in Python has a special attribute called __name__. The value of the __name__  attribute is set to '__main__' when the module is executed as the main program (e.g., running python foo.py). Otherwise, the value of __name__ is set to the name of the module that it was called from."}, {"id": 48153234, "score": 7, "vote": 0, "content": "<p>Create a file, <strong>a.py</strong>:</p>\n<pre><code class=\"python\">print(__name__) # It will print out __main__\n</code></pre>\n<p><code>__name__</code> is always equal to <code>__main__</code> whenever that file is <strong>run directly</strong> showing that this is the main file.</p>\n<p>Create another file, <strong>b.py</strong>, in the same directory:</p>\n<pre><code class=\"python\">import a  # Prints a\n</code></pre>\n<p>Run it. It will print <strong>a</strong>, i.e., the name of the file which <strong>is imported</strong>.</p>\n<p>So, to show <strong>two different behavior of the same file</strong>, this is a commonly used trick:</p>\n<pre><code class=\"python\"># Code to be run when imported into another python file\n\nif __name__ == '__main__':\n    # Code to be run only when run directly\n</code></pre>\n", "abstract": "Create a file, a.py: __name__ is always equal to __main__ whenever that file is run directly showing that this is the main file. Create another file, b.py, in the same directory: Run it. It will print a, i.e., the name of the file which is imported. So, to show two different behavior of the same file, this is a commonly used trick:"}, {"id": 67015395, "score": 5, "vote": 0, "content": "<p>When a Python file is executed it creates many special variables such as <code>__name__</code>. The variable <code>__name__</code> holds the name of the file. And the answer to your question is that</p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n       # Do something\n</code></pre>\n<p>This means that if the name of the file being executed is running as the source file and <strong>not a module</strong> then it will run the code inside it. This can be proved with a simple example. Create two Python files, <code>foo.py</code> and <code>second.py</code>. Then in the <code>foo.py</code>, type this:</p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n       print(\"file is not imported\")\nelse:\n       print(\"file is imported\")\n</code></pre>\n<p>And in the <code>second.py</code>, type this:</p>\n<pre><code class=\"python\">import foo\n\nif foo.__name__ == \"__main__\":\n       print(\"file is not imported\")\nelse:\n       print(\"file is imported\")\n</code></pre>\n<p>In addition to this, if you will do this <code>print(__name__)</code> then it will print <code>__main__</code>. Why?</p>\n<p>Because the file is running as the <strong>main</strong> source and if you'll do <code>print(foo.__name__)</code> it will print <em>foo</em> because the default value of the <code>__name__</code> variable is the name of the file and by default I mean you can change it too. To do this, just go to the <code>foo.py</code> file and do this: <code>__name__ = \"name\"</code>. Then when you'll run the file, for example,</p>\n<pre><code class=\"python\">__name__ = \"Hello, World!\"\nprint(__name__)\n</code></pre>\n<p>then the output will be:</p>\n<pre><code class=\"python\">Hello, World!\n</code></pre>\n", "abstract": "When a Python file is executed it creates many special variables such as __name__. The variable __name__ holds the name of the file. And the answer to your question is that This means that if the name of the file being executed is running as the source file and not a module then it will run the code inside it. This can be proved with a simple example. Create two Python files, foo.py and second.py. Then in the foo.py, type this: And in the second.py, type this: In addition to this, if you will do this print(__name__) then it will print __main__. Why? Because the file is running as the main source and if you'll do print(foo.__name__) it will print foo because the default value of the __name__ variable is the name of the file and by default I mean you can change it too. To do this, just go to the foo.py file and do this: __name__ = \"name\". Then when you'll run the file, for example, then the output will be:"}, {"id": 72334200, "score": 5, "vote": 0, "content": "<h2>Only facts you need to know</h2>\n<p>The other answers to this question are way too long.  The actual mechanics are quite simple and there are only two essential facts:</p>\n<ol>\n<li><p>Pure Python modules are always created with the variable <code>__name__</code> set to the string <code>\"__main__\"</code>.</p>\n</li>\n<li><p>Importing a module has the side-effect of changing the <code>__name__</code> variable to the base filename without the <code>.py</code> extension.</p>\n</li>\n</ol>\n<h2>How this information is used</h2>\n<p>People write <code>__name__ == '__main__'</code> to test whether a module has been imported.</p>\n<p>It is common to have some code that shouldn't run when an import occurs: Test code, one-time use code, a command-line front-end, or a web server front-end.</p>\n<p>The idea is that person running a module directly wants these actions to happen, but a person importing the module just wants direct access to the functions, classes, and variables.</p>\n<p>As you can see from the other answers, people seem to be able to talk endlessly about this topic, but it really is a simple thing and is easily mastered.  The Python tutorial <a href=\"https://docs.python.org/3/tutorial/modules.html#executing-modules-as-scripts\" rel=\"noreferrer\">covers this</a> in about two minutes worth of reading.  Don't let the other answers drown you with overexplaining :-)</p>\n", "abstract": "The other answers to this question are way too long.  The actual mechanics are quite simple and there are only two essential facts: Pure Python modules are always created with the variable __name__ set to the string \"__main__\". Importing a module has the side-effect of changing the __name__ variable to the base filename without the .py extension. People write __name__ == '__main__' to test whether a module has been imported. It is common to have some code that shouldn't run when an import occurs: Test code, one-time use code, a command-line front-end, or a web server front-end. The idea is that person running a module directly wants these actions to happen, but a person importing the module just wants direct access to the functions, classes, and variables. As you can see from the other answers, people seem to be able to talk endlessly about this topic, but it really is a simple thing and is easily mastered.  The Python tutorial covers this in about two minutes worth of reading.  Don't let the other answers drown you with overexplaining :-)"}, {"id": 60008967, "score": 4, "vote": 0, "content": "<p>You can check up on the special variable <code>__name__</code> with this simple example:</p>\n<p>Create <em>file1.py</em></p>\n<pre><code class=\"python\">if __name__ == \"__main__\":\n    print(\"file1 is being run directly\")\nelse:\n    print(\"file1 is being imported\")\n</code></pre>\n<p>Create *file2.<em>py</em></p>\n<pre><code class=\"python\">import file1 as f1\n\nprint(\"__name__ from file1: {}\".format(f1.__name__))\nprint(\"__name__ from file2: {}\".format(__name__))\n\nif __name__ == \"__main__\":\n    print(\"file2 is being run directly\")\nelse:\n    print(\"file2 is being imported\")\n</code></pre>\n<p>Execute file2.py</p>\n<p><em>Output</em>:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">file1 is being imported\n__name__ from file1: file1\n__name__ from file2: __main__\nfile2 is being run directly\n</code></pre>\n", "abstract": "You can check up on the special variable __name__ with this simple example: Create file1.py Create *file2.py Execute file2.py Output:"}, {"id": 61342829, "score": 3, "vote": 0, "content": "<p>The <strong>Python main function</strong> is the starting point of any program. When the program is run, the Python interpreter runs the code sequentially. The main function is executed only when it is run as a Python program...</p>\n<pre><code class=\"python\">def main():\n    print(\"I am in the function\")\n\nprint(\"I am out of the function\")\n</code></pre>\n<p>when you run the script shows:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">I am out of the function\n</code></pre>\n<p>And not the code \"I am in the function\".</p>\n<p>It is because we did not declare the call function \"if__name__== \"<strong>main</strong>\".</p>\n<p>If you use from it:</p>\n<pre><code class=\"python\">def main():\n    print(\"I am in the function\")\n\nif __name__ == \"__main__\":\n    main()\n\nprint(\"I am out of the function\")\n</code></pre>\n<p>The output is equal to</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">I am in the function\nI am out of the function\n</code></pre>\n<p>In Python, <code>if__name__== \"__main__\"</code> allows you to run the Python files either as reusable modules or stand-alone programs.</p>\n<p>When Python interpreter reads a source file, it will execute all the code found in it.\nWhen Python runs the \"source file\" as the main program, it sets the special variable <code>__name__</code> to have a value <code>\"__main__\"</code>.</p>\n<p>When you execute the main function, it will then read the <code>if</code> statement which checks whether <code>__name__</code> is equal to <code>__main__</code>.</p>\n", "abstract": "The Python main function is the starting point of any program. When the program is run, the Python interpreter runs the code sequentially. The main function is executed only when it is run as a Python program... when you run the script shows: And not the code \"I am in the function\". It is because we did not declare the call function \"if__name__== \"main\". If you use from it: The output is equal to In Python, if__name__== \"__main__\" allows you to run the Python files either as reusable modules or stand-alone programs. When Python interpreter reads a source file, it will execute all the code found in it.\nWhen Python runs the \"source file\" as the main program, it sets the special variable __name__ to have a value \"__main__\". When you execute the main function, it will then read the if statement which checks whether __name__ is equal to __main__."}, {"id": 68244934, "score": 2, "vote": 0, "content": "<p>Suppose I wrote functions and classes for web scraping on Wikipedia. Of course, this may not be a good example.</p>\n<p>I want to use those functions in another program without rewriting it.</p>\n<p>Well, I import them, but at the end of that file\nI put <code>__name__ == '__main__'</code></p>\n<p>When we <code>import</code> a module, all the code inside it is executed from start to end. But when it reaches the condition, it does not run <em>func</em>, <em>func2</em>, etc., which is the Wikipedia <code>__scrape__</code>.</p>\n<p>Well, in the global scope a Python <code>__name__</code> is defined to <code>'__main__'</code> for the current program.</p>\n<p>When we <code>import</code> a module, it is defined as a variable in the name space of our current program\nand current program <code>__name__</code> is <code>'__main__'</code>:</p>\n<h3>File <em>test.py</em></h3>\n<pre><code class=\"python\">def func():\n    # Do something\n    pass\n\ndef func2():\n    # Do something\n    pass\n\nprint('The program name is set to ', globals()['__name__'])\n\nif __name__=='__main__':\n    # In the current program, __name__ is equal to '__main__'\n    func('https://www.wikipedia.org')\n    func2('https://www.wikipedia.org')\n    # Or do more jobs\n\n</code></pre>\n<pre><code class=\"python\">import test1\nprint('inside of current program')\nprint('name is current program', __name__)\nprint(globals()['test1'])\ntest1.func('another site')\ntest1.func2('another site')\n</code></pre>\n<h3>Output</h3>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">inside of test 1\nname of program is set to test1\nend of module\ninside of current\n__main__\n&lt;module 'test1' from 'C:\\\\users\\\\ir\\\\appdata\\\\local\\\\programs\\\\python\\\\python38\\\\lib\\\\test1.py'&gt;\n</code></pre>\n", "abstract": "Suppose I wrote functions and classes for web scraping on Wikipedia. Of course, this may not be a good example. I want to use those functions in another program without rewriting it. Well, I import them, but at the end of that file\nI put __name__ == '__main__' When we import a module, all the code inside it is executed from start to end. But when it reaches the condition, it does not run func, func2, etc., which is the Wikipedia __scrape__. Well, in the global scope a Python __name__ is defined to '__main__' for the current program. When we import a module, it is defined as a variable in the name space of our current program\nand current program __name__ is '__main__':"}, {"id": 66116665, "score": 1, "vote": 0, "content": "<p><code>if __name__ == \"__main__\"</code> means that if you are running the Python file normally like <code>python foo.py</code>, it will assign the special variable <code>__name__</code> to <code>\"__main__\"</code>.</p>\n<p>But if you are importing the file like \"import foo\", it will assign <code>__name__</code> to <code>\"foo\"</code> and will not run the function.</p>\n", "abstract": "if __name__ == \"__main__\" means that if you are running the Python file normally like python foo.py, it will assign the special variable __name__ to \"__main__\". But if you are importing the file like \"import foo\", it will assign __name__ to \"foo\" and will not run the function."}, {"id": 54506767, "score": 0, "vote": 0, "content": "<p>Simply, it is the entry point to run the file, like the <code>main</code> function in the <em>C</em> programming language.</p>\n", "abstract": "Simply, it is the entry point to run the file, like the main function in the C programming language."}, {"id": 67406389, "score": 0, "vote": 0, "content": "<p>When you execute the module (the source file), the <em>if</em> condition checks whether the module is called directly or it is called from another source file. Here directly means not imported.</p>\n<p>If it is directly called to execute, the module name is set to \"main\" and then the code within the <em>if</em> block will be executed.</p>\n", "abstract": "When you execute the module (the source file), the if condition checks whether the module is called directly or it is called from another source file. Here directly means not imported. If it is directly called to execute, the module name is set to \"main\" and then the code within the if block will be executed."}, {"id": 73622411, "score": 0, "vote": 0, "content": "<p>When you <code>import</code> some code that has this condition, it will return <code>False</code> (inside the imported code), but will return <code>True</code> for the code that will be run.</p>\n", "abstract": "When you import some code that has this condition, it will return False (inside the imported code), but will return True for the code that will be run."}, {"id": 71678221, "score": -1, "vote": 0, "content": "<p>The simple answer is the code that is written under <em>if <strong>name</strong> == \"<strong>main</strong>\":</em> will not execute if you import it in another file.</p>\n", "abstract": "The simple answer is the code that is written under if name == \"main\": will not execute if you import it in another file."}]}, {"link": "https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator", "question": {"id": "394809", "title": "Does Python have a ternary conditional operator?", "content": "<p>Is there a <a href=\"https://en.wikipedia.org/wiki/%3F:#Python\" rel=\"noreferrer\">ternary conditional operator</a> in Python?</p>\n", "abstract": "Is there a ternary conditional operator in Python?"}, "answers": [{"id": 394814, "score": 8640, "vote": 0, "content": "<p>Yes, it was <a href=\"https://mail.python.org/pipermail/python-dev/2005-September/056846.html\" rel=\"noreferrer\" title=\"[Python-Dev] Conditional Expression Resolution\">added</a> in version 2.5. The expression syntax is:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">a if condition else b\n</code></pre>\n<p>First <code>condition</code> is evaluated, then exactly one of either <code>a</code> or <code>b</code> is evaluated and returned based on the <a href=\"https://en.wikipedia.org/wiki/Boolean_data_type\" rel=\"noreferrer\" title=\"Boolean data type\">Boolean</a> value of <code>condition</code>. If <code>condition</code> evaluates to <code>True</code>, then <code>a</code> is evaluated and returned but <code>b</code> is ignored, or else when <code>b</code> is evaluated and returned but <code>a</code> is ignored.</p>\n<p>This allows short-circuiting because when <code>condition</code> is true only <code>a</code> is evaluated and <code>b</code> is not evaluated at all, but when <code>condition</code> is false only <code>b</code> is evaluated and <code>a</code> is not evaluated at all.</p>\n<p>For example:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; 'true' if True else 'false'\n'true'\n&gt;&gt;&gt; 'true' if False else 'false'\n'false'\n</code></pre>\n<p>Note that conditionals are an <em>expression</em>, not a <em>statement</em>. This means you can't use <strong>statements</strong> such as <code>pass</code>, or assignments with <code>=</code> (or \"augmented\" assignments like <code>+=</code>), within a conditional <strong>expression</strong>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; pass if False else pass\n  File \"&lt;stdin&gt;\", line 1\n    pass if False else pass\n         ^\nSyntaxError: invalid syntax\n\n&gt;&gt;&gt; # Python parses this as `x = (1 if False else y) = 2`\n&gt;&gt;&gt; # The `(1 if False else x)` part is actually valid, but\n&gt;&gt;&gt; # it can't be on the left-hand side of `=`.\n&gt;&gt;&gt; x = 1 if False else y = 2\n  File \"&lt;stdin&gt;\", line 1\nSyntaxError: cannot assign to conditional expression\n\n&gt;&gt;&gt; # If we parenthesize it instead...\n&gt;&gt;&gt; (x = 1) if False else (y = 2)\n  File \"&lt;stdin&gt;\", line 1\n    (x = 1) if False else (y = 2)\n       ^\nSyntaxError: invalid syntax\n</code></pre>\n<p>(In 3.8 and above, the <code>:=</code> \"walrus\" operator allows simple assignment of values <em>as an expression</em>, which is then compatible with this syntax. But please don't write code like that; it will quickly become very difficult to understand.)</p>\n<p>Similarly, because it is an expression, the <code>else</code> part is <em>mandatory</em>:</p>\n<pre><code class=\"python\"># Invalid syntax: we didn't specify what the value should be if the \n# condition isn't met. It doesn't matter if we can verify that\n# ahead of time.\na if True\n</code></pre>\n<p>You can, however, use conditional expressions to assign a variable like so:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">x = a if True else b\n</code></pre>\n<p>Or for example to return a value:</p>\n<pre><code class=\"python\"># Of course we should just use the standard library `max`;\n# this is just for demonstration purposes.\ndef my_max(a, b):\n    return a if a &gt; b else b\n</code></pre>\n<p>Think of the conditional expression as switching between two values. We can use it when we are in a 'one value or another' situation, where we will <em>do the same thing</em> with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to <em>do something different</em> depending on the condition, then use a normal <code>if</code> <strong>statement</strong> instead.</p>\n<hr/>\n<p>Keep in mind that it's frowned upon by some Pythonistas for several reasons:</p>\n<ul>\n<li>The order of the arguments is different from those of the classic <code>condition ? a : b</code> ternary operator from many other languages (such as <a href=\"https://en.wikipedia.org/wiki/C_%28programming_language%29\" rel=\"noreferrer\">C</a>, <a href=\"https://en.wikipedia.org/wiki/C%2B%2B\" rel=\"noreferrer\">C++</a>, <a href=\"https://en.wikipedia.org/wiki/Go_%28programming_language%29\" rel=\"noreferrer\">Go</a>, <a href=\"https://en.wikipedia.org/wiki/Perl\" rel=\"noreferrer\">Perl</a>, <a href=\"https://en.wikipedia.org/wiki/Ruby_%28programming_language%29\" rel=\"noreferrer\">Ruby</a>, <a href=\"https://en.wikipedia.org/wiki/Java_%28programming_language%29\" rel=\"noreferrer\">Java</a>, <a href=\"https://en.wikipedia.org/wiki/JavaScript\" rel=\"noreferrer\">JavaScript</a>, etc.), which may lead to bugs when people unfamiliar with Python's \"surprising\" behaviour use it (they may reverse the argument order).</li>\n<li>Some find it \"unwieldy\", since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).</li>\n<li>Stylistic reasons. (Although the 'inline <code>if</code>' can be <em>really</em> useful, and make your script more concise, it really does complicate your code)</li>\n</ul>\n<p>If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, <code>x = 4 if b &gt; 8 else 9</code> is read aloud as <code>x will be 4 if b is greater than 8 otherwise 9</code>.</p>\n<p>Official documentation:</p>\n<ul>\n<li><a href=\"https://docs.python.org/3/reference/expressions.html#conditional-expressions\" rel=\"noreferrer\" title=\"Conditional expressions\">Conditional expressions</a></li>\n<li><a href=\"https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator\" rel=\"noreferrer\" title=\"Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?\">Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?</a></li>\n</ul>\n", "abstract": "Yes, it was added in version 2.5. The expression syntax is: First condition is evaluated, then exactly one of either a or b is evaluated and returned based on the Boolean value of condition. If condition evaluates to True, then a is evaluated and returned but b is ignored, or else when b is evaluated and returned but a is ignored. This allows short-circuiting because when condition is true only a is evaluated and b is not evaluated at all, but when condition is false only b is evaluated and a is not evaluated at all. For example: Note that conditionals are an expression, not a statement. This means you can't use statements such as pass, or assignments with = (or \"augmented\" assignments like +=), within a conditional expression: (In 3.8 and above, the := \"walrus\" operator allows simple assignment of values as an expression, which is then compatible with this syntax. But please don't write code like that; it will quickly become very difficult to understand.) Similarly, because it is an expression, the else part is mandatory: You can, however, use conditional expressions to assign a variable like so: Or for example to return a value: Think of the conditional expression as switching between two values. We can use it when we are in a 'one value or another' situation, where we will do the same thing with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to do something different depending on the condition, then use a normal if statement instead. Keep in mind that it's frowned upon by some Pythonistas for several reasons: If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, x = 4 if b > 8 else 9 is read aloud as x will be 4 if b is greater than 8 otherwise 9. Official documentation:"}, {"id": 470376, "score": 959, "vote": 0, "content": "<p>You can index into a tuple:</p>\n<pre><code class=\"python\">(falseValue, trueValue)[test]\n</code></pre>\n<p><code>test</code> needs to return <em>True</em> or <em>False</em>.<br/>\nIt might be safer to always implement it as:</p>\n<pre><code class=\"python\">(falseValue, trueValue)[test == True]\n</code></pre>\n<p>or you can use the built-in <a href=\"https://docs.python.org/3.3/library/functions.html#bool\" rel=\"noreferrer\" title=\"bool\"><code>bool()</code></a> to assure a <a href=\"https://en.wikipedia.org/wiki/Boolean_data_type\" rel=\"noreferrer\" title=\"Boolean data type\">Boolean</a> value:</p>\n<pre><code class=\"python\">(falseValue, trueValue)[bool(&lt;expression&gt;)]\n</code></pre>\n", "abstract": "You can index into a tuple: test needs to return True or False.\nIt might be safer to always implement it as: or you can use the built-in bool() to assure a Boolean value:"}, {"id": 394887, "score": 422, "vote": 0, "content": "<p>For versions prior to 2.5, there's the trick:</p>\n<pre><code class=\"python\">[expression] and [on_true] or [on_false]\n</code></pre>\n<p>It can give wrong results when <code>on_true</code> has a false Boolean value.<sup>1</sup></p>\n<p>Although it does have the benefit of evaluating expressions left to right, which is clearer in my opinion.</p>\n<p><sub>1. <a href=\"http://docs.python.org/3.3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator\" rel=\"noreferrer\">Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?</a></sub></p>\n", "abstract": "For versions prior to 2.5, there's the trick: It can give wrong results when on_true has a false Boolean value.1 Although it does have the benefit of evaluating expressions left to right, which is clearer in my opinion. 1. Is there an equivalent of C\u2019s \u201d?:\u201d ternary operator?"}, {"id": 2919360, "score": 337, "vote": 0, "content": "<p><code> <i>&lt;expression 1&gt;</i> <b>if</b> <i>&lt;condition&gt;</i> <b>else</b> <i>&lt;expression 2&gt;</i> </code></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">a = 1\nb = 2\n\n1 if a &gt; b else -1 \n# Output is -1\n\n1 if a &gt; b else -1 if a &lt; b else 0\n# Output is -1\n</code></pre>\n", "abstract": " <expression 1> if <condition> else <expression 2> "}, {"id": 394815, "score": 197, "vote": 0, "content": "<p>From <a href=\"https://docs.python.org/3/reference/expressions.html#conditional-expressions\" rel=\"noreferrer\" title=\"Conditional expressions\">the documentation</a>:</p>\n<blockquote>\n<p>Conditional expressions (sometimes called a \u201cternary operator\u201d) have the lowest priority of all Python operations.</p>\n<p>The expression <code>x if C else y</code> first evaluates the condition, <em>C</em> (<em>not x</em>); if <em>C</em> is true, <em>x</em> is evaluated and its value is returned; otherwise, <em>y</em> is evaluated and its value is returned.</p>\n<p>See <a href=\"https://www.python.org/dev/peps/pep-0308/\" rel=\"noreferrer\" title=\"PEP 308 -- Conditional Expressions\">PEP 308</a> for more details about conditional expressions.</p>\n</blockquote>\n<p>New since version 2.5.</p>\n", "abstract": "From the documentation: Conditional expressions (sometimes called a \u201cternary operator\u201d) have the lowest priority of all Python operations. The expression x if C else y first evaluates the condition, C (not x); if C is true, x is evaluated and its value is returned; otherwise, y is evaluated and its value is returned. See PEP 308 for more details about conditional expressions. New since version 2.5."}, {"id": 30052371, "score": 163, "vote": 0, "content": "<p>An operator for a conditional expression in Python was added in 2006 as part of <a href=\"https://www.python.org/dev/peps/pep-0308/\" rel=\"noreferrer\">Python Enhancement Proposal 308</a>. Its form differ from common <code>?:</code> operator and it's:</p>\n<pre><code class=\"python\">&lt;expression1&gt; if &lt;condition&gt; else &lt;expression2&gt;\n</code></pre>\n<p>which is equivalent to:</p>\n<pre><code class=\"python\">if &lt;condition&gt;: &lt;expression1&gt; else: &lt;expression2&gt;\n</code></pre>\n<p>Here is an example:</p>\n<pre><code class=\"python\">result = x if a &gt; b else y\n</code></pre>\n<p>Another syntax which can be used (compatible with versions before 2.5):</p>\n<pre><code class=\"python\">result = (lambda:y, lambda:x)[a &gt; b]()\n</code></pre>\n<p>where operands are <a href=\"https://en.wikipedia.org/wiki/Lazy_evaluation\" rel=\"noreferrer\">lazily evaluated</a>.</p>\n<p>Another way is by indexing a tuple (which isn't consistent with the conditional operator of most other languages):</p>\n<pre><code class=\"python\">result = (y, x)[a &gt; b]\n</code></pre>\n<p>or explicitly constructed dictionary:</p>\n<pre><code class=\"python\">result = {True: x, False: y}[a &gt; b]\n</code></pre>\n<p>Another (less reliable), but simpler method is to use <code>and</code> and <code>or</code> operators:</p>\n<pre><code class=\"python\">result = (a &gt; b) and x or y\n</code></pre>\n<p>however this won't work if <code>x</code> would be <code>False</code>.</p>\n<p>A possible workaround is to make <code>x</code> and <code>y</code> lists or tuples as in the following:</p>\n<pre><code class=\"python\">result = ((a &gt; b) and [x] or [y])[0]\n</code></pre>\n<p>or:</p>\n<pre><code class=\"python\">result = ((a &gt; b) and (x,) or (y,))[0]\n</code></pre>\n<p>If you're working with dictionaries, instead of using a ternary conditional, you can take advantage of <a href=\"https://docs.python.org/3/library/stdtypes.html#dict.get\" rel=\"noreferrer\"><code>get(key, default)</code></a>, for example:</p>\n<pre><code class=\"python\">shell = os.environ.get('SHELL', \"/bin/sh\")\n</code></pre>\n<p><sup>Source: <a href=\"https://en.wikipedia.org/wiki/%3F:#Python\" rel=\"noreferrer\">?: in Python at Wikipedia</a></sup></p>\n", "abstract": "An operator for a conditional expression in Python was added in 2006 as part of Python Enhancement Proposal 308. Its form differ from common ?: operator and it's: which is equivalent to: Here is an example: Another syntax which can be used (compatible with versions before 2.5): where operands are lazily evaluated. Another way is by indexing a tuple (which isn't consistent with the conditional operator of most other languages): or explicitly constructed dictionary: Another (less reliable), but simpler method is to use and and or operators: however this won't work if x would be False. A possible workaround is to make x and y lists or tuples as in the following: or: If you're working with dictionaries, instead of using a ternary conditional, you can take advantage of get(key, default), for example: Source: ?: in Python at Wikipedia"}, {"id": 1855173, "score": 118, "vote": 0, "content": "<p>Unfortunately, the</p>\n<pre><code class=\"python\">(falseValue, trueValue)[test]\n</code></pre>\n<p>solution doesn't have short-circuit behaviour; thus both <code>falseValue</code> and <code>trueValue</code> are evaluated regardless of the condition. This could be suboptimal or even buggy (i.e. both <code>trueValue</code> and <code>falseValue</code> could be methods and have side effects).</p>\n<p>One solution to this would be</p>\n<pre><code class=\"python\">(lambda: falseValue, lambda: trueValue)[test]()\n</code></pre>\n<p>(execution delayed until the winner is known ;)), but it introduces inconsistency between callable and non-callable objects. In addition, it doesn't solve the case when using properties.</p>\n<p>And so the story goes - choosing between three mentioned solutions is a trade-off between having the short-circuit feature, using at least Python 2.5 (IMHO, not a problem anymore) and not being prone to \"<code>trueValue</code>-evaluates-to-false\" errors.</p>\n", "abstract": "Unfortunately, the solution doesn't have short-circuit behaviour; thus both falseValue and trueValue are evaluated regardless of the condition. This could be suboptimal or even buggy (i.e. both trueValue and falseValue could be methods and have side effects). One solution to this would be (execution delayed until the winner is known ;)), but it introduces inconsistency between callable and non-callable objects. In addition, it doesn't solve the case when using properties. And so the story goes - choosing between three mentioned solutions is a trade-off between having the short-circuit feature, using at least Python 2.5 (IMHO, not a problem anymore) and not being prone to \"trueValue-evaluates-to-false\" errors."}, {"id": 39067220, "score": 95, "vote": 0, "content": "<h2><strong>Ternary operator in different programming languages</strong></h2>\n<p>Here I just try to show some important differences in the <a href=\"https://en.wikipedia.org/wiki/%3F:\" rel=\"noreferrer\">ternary operator</a> between a couple of programming languages.</p>\n<h3><em>Ternary operator in <a href=\"https://en.wikipedia.org/wiki/JavaScript\" rel=\"noreferrer\">JavaScript</a></em></h3>\n<pre><code class=\"python\">var a = true ? 1 : 0;\n# 1\nvar b = false ? 1 : 0;\n# 0\n</code></pre>\n<h3><em>Ternary operator in <a href=\"https://en.wikipedia.org/wiki/Ruby_%28programming_language%29\" rel=\"noreferrer\">Ruby</a></em></h3>\n<pre><code class=\"python\">a = true ? 1 : 0\n# 1\nb = false ? 1 : 0\n# 0\n</code></pre>\n<h3><em>Ternary operator in <a href=\"https://en.wikipedia.org/wiki/Scala_%28programming_language%29\" rel=\"noreferrer\">Scala</a></em></h3>\n<pre><code class=\"python\">val a = true ? 1 | 0\n# 1\nval b = false ? 1 | 0\n# 0\n</code></pre>\n<h3><em>Ternary operator in <a href=\"https://en.wikipedia.org/wiki/R_%28programming_language%29\" rel=\"noreferrer\">R</a> programming</em></h3>\n<pre><code class=\"python\">a &lt;- if (TRUE) 1 else 0\n# 1\nb &lt;- if (FALSE) 1 else 0\n# 0\n</code></pre>\n<h3><em>Ternary operator in Python</em></h3>\n<pre><code class=\"python\">a = 1 if True else 0\n# 1\nb = 1 if False else 0\n# 0\n</code></pre>\n", "abstract": "Here I just try to show some important differences in the ternary operator between a couple of programming languages."}, {"id": 10314837, "score": 79, "vote": 0, "content": "<p>For Python 2.5 and newer there is a specific syntax:</p>\n<pre><code class=\"python\">[on_true] if [cond] else [on_false]\n</code></pre>\n<p>In older Pythons a ternary operator is not implemented but it's possible to simulate it.</p>\n<pre><code class=\"python\">cond and on_true or on_false\n</code></pre>\n<p>Though, there is a potential problem, which if <code>cond</code> evaluates to <code>True</code> and <code>on_true</code> evaluates to <code>False</code> then <code>on_false</code> is returned instead of <code>on_true</code>. If you want this behavior the method is OK, otherwise use this:</p>\n<pre><code class=\"python\">{True: on_true, False: on_false}[cond is True] # is True, not == True\n</code></pre>\n<p>which can be wrapped by:</p>\n<pre><code class=\"python\">def q(cond, on_true, on_false)\n    return {True: on_true, False: on_false}[cond is True]\n</code></pre>\n<p>and used this way:</p>\n<pre><code class=\"python\">q(cond, on_true, on_false)\n</code></pre>\n<p>It is compatible with all Python versions.</p>\n", "abstract": "For Python 2.5 and newer there is a specific syntax: In older Pythons a ternary operator is not implemented but it's possible to simulate it. Though, there is a potential problem, which if cond evaluates to True and on_true evaluates to False then on_false is returned instead of on_true. If you want this behavior the method is OK, otherwise use this: which can be wrapped by: and used this way: It is compatible with all Python versions."}, {"id": 14321907, "score": 57, "vote": 0, "content": "<p>You might often find</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">cond and on_true or on_false\n</code></pre>\n<p>but this leads to a problem when on_true == 0</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; x = 0\n&gt;&gt;&gt; print x == 0 and 0 or 1\n1\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; print x == 0 and 0 or 1\n1\n</code></pre>\n<p>Where you would expect this result for a normal ternary operator:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; x = 0\n&gt;&gt;&gt; print 0 if x == 0 else 1\n0\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; print 0 if x == 0 else 1\n1\n</code></pre>\n", "abstract": "You might often find but this leads to a problem when on_true == 0 Where you would expect this result for a normal ternary operator:"}, {"id": 33765206, "score": 51, "vote": 0, "content": "<blockquote>\n<h1>Does Python have a ternary conditional operator?</h1>\n</blockquote>\n<p>Yes. From the <a href=\"https://docs.python.org/reference/grammar.html\" rel=\"nofollow noreferrer\">grammar file</a>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">test: or_test ['if' or_test 'else' test] | lambdef\n</code></pre>\n<p>The part of interest is:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">or_test ['if' or_test 'else' test]\n</code></pre>\n<p>So, a ternary conditional operation is of the form:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">expression1 if expression2 else expression3\n</code></pre>\n<p><code>expression3</code> will be lazily evaluated (that is, evaluated only if <code>expression2</code> is false in a boolean context). And because of the recursive definition, you can chain them indefinitely (though it may considered bad style.)</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">expression1 if expression2 else expression3 if expression4 else expression5 # and so on\n</code></pre>\n<h3>A note on usage:</h3>\n<p>Note that every <code>if</code> must be followed with an <code>else</code>. People learning list comprehensions and generator expressions may find this to be a difficult lesson to learn - the following will not work, as Python expects a third expression for an else:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">[expression1 if expression2 for element in iterable]\n#                          ^-- need an else here\n</code></pre>\n<p>which raises a <code>SyntaxError: invalid syntax</code>.\nSo the above is either an incomplete piece of logic (perhaps the user expects a no-op in the false condition) or what may be intended is to use <code>expression2</code> as a filter - notes that the following is legal Python:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">[expression1 for element in iterable if expression2]\n</code></pre>\n<p><code>expression2</code> works as a filter for the list comprehension, and is <em>not</em> a ternary conditional operator.</p>\n<h3>Alternative syntax for a more narrow case:</h3>\n<p>You may find it somewhat painful to write the following:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">expression1 if expression1 else expression2\n</code></pre>\n<p><code>expression1</code> will have to be evaluated twice with the above usage. It can limit redundancy if it is simply a local variable. However, a common and performant Pythonic idiom for this use-case is to use <code>or</code>'s shortcutting behavior:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">expression1 or expression2\n</code></pre>\n<p>which is equivalent in semantics. Note that some style-guides may limit this usage on the grounds of clarity - it does pack a lot of meaning into very little syntax.</p>\n", "abstract": "Yes. From the grammar file: The part of interest is: So, a ternary conditional operation is of the form: expression3 will be lazily evaluated (that is, evaluated only if expression2 is false in a boolean context). And because of the recursive definition, you can chain them indefinitely (though it may considered bad style.) Note that every if must be followed with an else. People learning list comprehensions and generator expressions may find this to be a difficult lesson to learn - the following will not work, as Python expects a third expression for an else: which raises a SyntaxError: invalid syntax.\nSo the above is either an incomplete piece of logic (perhaps the user expects a no-op in the false condition) or what may be intended is to use expression2 as a filter - notes that the following is legal Python: expression2 works as a filter for the list comprehension, and is not a ternary conditional operator. You may find it somewhat painful to write the following: expression1 will have to be evaluated twice with the above usage. It can limit redundancy if it is simply a local variable. However, a common and performant Pythonic idiom for this use-case is to use or's shortcutting behavior: which is equivalent in semantics. Note that some style-guides may limit this usage on the grounds of clarity - it does pack a lot of meaning into very little syntax."}, {"id": 54609267, "score": 35, "vote": 0, "content": "<p>One of the alternatives to Python's <a href=\"https://mail.python.org/pipermail/python-dev/2005-September/056846.html\" rel=\"nofollow noreferrer\">conditional expression</a></p>\n<pre><code class=\"python\">\"yes\" if boolean else \"no\"\n</code></pre>\n<p>is the following:</p>\n<pre><code class=\"python\">{True: \"yes\", False: \"no\"}[boolean]\n</code></pre>\n<p>which has the following nice extension:</p>\n<pre><code class=\"python\">{True: \"yes\", False: \"no\", None: \"maybe\"}[boolean_or_none]\n</code></pre>\n<p>The shortest alternative remains</p>\n<pre><code class=\"python\">(\"no\", \"yes\")[boolean]\n</code></pre>\n<p>which works because <code>issubclass(bool, int)</code>.</p>\n<p>Careful, though: the alternative to</p>\n<pre><code class=\"python\">yes() if boolean else no()\n</code></pre>\n<p>is <em>not</em></p>\n<pre><code class=\"python\">(no(), yes())[boolean]  # bad: BOTH no() and yes() are called\n</code></pre>\n<p>but</p>\n<pre><code class=\"python\">(no, yes)[boolean]()\n</code></pre>\n<p>This works fine as long as <code>no</code> and <code>yes</code> are to be called with exactly the same parameters. If they are not, like in</p>\n<pre><code class=\"python\">yes(\"ok\") if boolean else no()  # (1)\n</code></pre>\n<p>or in</p>\n<pre><code class=\"python\">yes(\"ok\") if boolean else no(\"sorry\")  # (2)\n</code></pre>\n<p>then a similar alternative either does not exist (1) or is hardly viable (2). (In rare cases, depending on the context, something like</p>\n<pre><code class=\"python\">msg = (\"sorry\", \"ok\")[boolean]\n(no, yes)[boolean](msg)\n</code></pre>\n<p>could make sense.)</p>\n<p><sub>Thanks to Radek Roj\u00edk for his comment</sub></p>\n", "abstract": "One of the alternatives to Python's conditional expression is the following: which has the following nice extension: The shortest alternative remains which works because issubclass(bool, int). Careful, though: the alternative to is not but This works fine as long as no and yes are to be called with exactly the same parameters. If they are not, like in or in then a similar alternative either does not exist (1) or is hardly viable (2). (In rare cases, depending on the context, something like could make sense.) Thanks to Radek Roj\u00edk for his comment"}, {"id": 58409100, "score": 33, "vote": 0, "content": "<p>As already answered, yes, there is a ternary operator in Python:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&lt;expression 1&gt; if &lt;condition&gt; else &lt;expression 2&gt;\n</code></pre>\n<p>In many cases <code>&lt;expression 1&gt;</code> is also used as Boolean evaluated <code>&lt;condition&gt;</code>. Then you can use <a href=\"https://en.wikipedia.org/wiki/Short-circuit_evaluation\" rel=\"nofollow noreferrer\">short-circuit evaluation</a>.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">a = 0\nb = 1\n\n# Instead of this:\nx = a if a else b\n# Evaluates as 'a if bool(a) else b'\n\n# You could use short-circuit evaluation:\nx = a or b\n</code></pre>\n<p>One big pro of short-circuit evaluation is the possibility of chaining more than two expressions:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">x = a or b or c or d or e\n</code></pre>\n<p>When working with functions it is more different in detail:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># Evaluating functions:\ndef foo(x):\n    print('foo executed')\n    return x\n\n\ndef bar(y):\n    print('bar executed')\n    return y\n\n\ndef blubb(z):\n    print('blubb executed')\n    return z\n\n\n# Ternary Operator expression 1 equals to False\nprint(foo(0) if foo(0) else bar(1))\n''' foo and bar are executed once\nfoo executed\nbar executed\n1\n'''\n\n# Ternary Operator expression 1 equals to True\nprint(foo(2) if foo(2) else bar(3))\n''' foo is executed twice!\nfoo executed\nfoo executed\n2\n'''\n\n# Short-circuit evaluation second equals to True\nprint(foo(0) or bar(1) or blubb(2))\n''' blubb is not executed\nfoo executed\nbar executed\n1\n'''\n\n# Short-circuit evaluation third equals to True\nprint(foo(0) or bar(0) or blubb(2))\n'''\nfoo executed\nbar executed\nblubb executed\n2\n'''\n\n# Short-circuit evaluation all equal to False\nprint(foo(0) or bar(0) or blubb(0))\n''' Result is 0 (from blubb(0)) because no value equals to True\nfoo executed\nbar executed\nblubb executed\n0\n'''\n</code></pre>\n<p>PS: Of course, a short-circuit evaluation is not a ternary operator, but often the ternary is used in cases where the short circuit would be enough. It has a better readability and can be chained.</p>\n", "abstract": "As already answered, yes, there is a ternary operator in Python: In many cases <expression 1> is also used as Boolean evaluated <condition>. Then you can use short-circuit evaluation. One big pro of short-circuit evaluation is the possibility of chaining more than two expressions: When working with functions it is more different in detail: PS: Of course, a short-circuit evaluation is not a ternary operator, but often the ternary is used in cases where the short circuit would be enough. It has a better readability and can be chained."}, {"id": 20093702, "score": 32, "vote": 0, "content": "<p>Simulating the Python ternary operator.</p>\n<p>For example</p>\n<pre><code class=\"python\">a, b, x, y = 1, 2, 'a greather than b', 'b greater than a'\nresult = (lambda:y, lambda:x)[a &gt; b]()\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">'b greater than a'\n</code></pre>\n", "abstract": "Simulating the Python ternary operator. For example Output:"}, {"id": 53653902, "score": 29, "vote": 0, "content": "<pre><code class=\"python\">a if condition else b\n</code></pre>\n<p>Just memorize this pyramid if you have trouble remembering:</p>\n<pre><code class=\"python\">     condition\n  if           else\na                   b \n</code></pre>\n", "abstract": "Just memorize this pyramid if you have trouble remembering:"}, {"id": 49653070, "score": 28, "vote": 0, "content": "<p>The ternary conditional operator simply allows testing a condition in a single line replacing the multiline if-else making the code compact.</p>\n<h3>Syntax:</h3>\n<blockquote>\n<p>[on_true] if [expression] else [on_false]</p>\n</blockquote>\n<h3>1- Simple Method to use ternary operator:</h3>\n<pre><code class=\"python\"># Program to demonstrate conditional operator\na, b = 10, 20\n# Copy value of a in min if a &lt; b else copy b\nmin = a if a &lt; b else b\nprint(min)  # Output: 10\n</code></pre>\n<h3>2- Direct Method of using tuples, Dictionary, and lambda:</h3>\n<pre><code class=\"python\"># Python program to demonstrate ternary operator\na, b = 10, 20\n# Use tuple for selecting an item\nprint( (b, a) [a &lt; b] )\n# Use Dictionary for selecting an item\nprint({True: a, False: b} [a &lt; b])\n# lambda is more efficient than above two methods\n# because in lambda  we are assure that\n# only one expression will be evaluated unlike in\n# tuple and Dictionary\nprint((lambda: b, lambda: a)[a &lt; b]()) # in output you should see three 10\n</code></pre>\n<h3>3- Ternary operator can be written as nested if-else:</h3>\n<pre><code class=\"python\"># Python program to demonstrate nested ternary operator\na, b = 10, 20\nprint (\"Both a and b are equal\" if a == b else \"a is greater than b\"\n        if a &gt; b else \"b is greater than a\")\n</code></pre>\n<p>Above approach can be written as:</p>\n<pre><code class=\"python\"># Python program to demonstrate nested ternary operator\na, b = 10, 20\nif a != b:\n    if a &gt; b:\n        print(\"a is greater than b\")\n    else:\n        print(\"b is greater than a\")\nelse:\n    print(\"Both a and b are equal\")\n# Output: b is greater than a\n</code></pre>\n", "abstract": "The ternary conditional operator simply allows testing a condition in a single line replacing the multiline if-else making the code compact. [on_true] if [expression] else [on_false] Above approach can be written as:"}, {"id": 37155553, "score": 27, "vote": 0, "content": "<p>More a tip than an answer (I don't need to repeat the obvious for the hundredth time), but I sometimes use it as a one-liner shortcut in such constructs:</p>\n<pre><code class=\"python\">if conditionX:\n    print('yes')\nelse:\n    print('nah')\n</code></pre>\n<p>, becomes:</p>\n<pre><code class=\"python\">print('yes') if conditionX else print('nah')\n</code></pre>\n<p>Some (many :) may frown upon it as unpythonic (even, Ruby-ish :), but I personally find it more natural - i.e., how you'd express it normally, plus a bit more visually appealing in large blocks of code.</p>\n", "abstract": "More a tip than an answer (I don't need to repeat the obvious for the hundredth time), but I sometimes use it as a one-liner shortcut in such constructs: , becomes: Some (many :) may frown upon it as unpythonic (even, Ruby-ish :), but I personally find it more natural - i.e., how you'd express it normally, plus a bit more visually appealing in large blocks of code."}, {"id": 45779600, "score": 27, "vote": 0, "content": "<p>You can do this:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">[condition] and [expression_1] or [expression_2];\n</code></pre>\n<p>Example:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">print(number%2 and \"odd\" or \"even\")\n</code></pre>\n<p>This would print \"odd\" if the number is odd or \"even\" if the number is even.</p>\n<hr/>\n<p><strong>The result:</strong> If condition is true, exp_1 is executed, else exp_2 is executed.</p>\n<p><strong>Note:</strong> 0, None, False, emptylist, and emptyString evaluates as False.</p>\n<p>And any data other than 0 evaluates to True.</p>\n<h2>Here's how it works:</h2>\n<p>If the condition [condition] becomes \"True\", then expression_1 will be evaluated, but not expression_2.</p>\n<p>If we \"and\" something with 0 (zero), the result will always to be false. So in the below statement,</p>\n<pre><code class=\"python\">0 and exp\n</code></pre>\n<p>The expression <em>exp</em> won't be evaluated at all since \"and\" with 0 will always evaluate to zero and there is no need to evaluate the expression. This is how the compiler itself works, in all languages.</p>\n<p>In</p>\n<pre><code class=\"python\">1 or exp\n</code></pre>\n<p>the expression <em>exp</em> won't be evaluated at all since \"or\" with 1 will always be 1. So it won't bother to evaluate the expression exp since the result will be 1 anyway (compiler optimization methods).</p>\n<p>But in case of</p>\n<pre><code class=\"python\">True and exp1 or exp2\n</code></pre>\n<p>The second expression exp2 won't be evaluated since <code>True and exp1</code> would be True when exp1 isn't false.</p>\n<p>Similarly in</p>\n<pre><code class=\"python\">False and exp1 or exp2\n</code></pre>\n<p>The expression <em>exp1</em> won't be evaluated since False is equivalent to writing 0 and doing \"and\" with 0 would be 0 itself, but after exp1 since \"or\" is used, it will evaluate the expression exp2 after \"or\".</p>\n<hr/>\n<p><strong>Note:-</strong> This kind of branching using \"or\" and \"and\" can only be used when the expression_1 doesn't have a Truth value of False (or 0 or None or emptylist [ ] or emptystring ' '.) since if expression_1 becomes False, then the expression_2 will be evaluated because of the presence \"or\" between exp_1 and exp_2.</p>\n<p><strong>In case you still want to make it work for all the cases regardless of what exp_1 and exp_2 truth values are, do this:</strong></p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">[condition] and ([expression_1] or 1) or [expression_2];\n</code></pre>\n", "abstract": "You can do this: Example: This would print \"odd\" if the number is odd or \"even\" if the number is even. The result: If condition is true, exp_1 is executed, else exp_2 is executed. Note: 0, None, False, emptylist, and emptyString evaluates as False. And any data other than 0 evaluates to True. If the condition [condition] becomes \"True\", then expression_1 will be evaluated, but not expression_2. If we \"and\" something with 0 (zero), the result will always to be false. So in the below statement, The expression exp won't be evaluated at all since \"and\" with 0 will always evaluate to zero and there is no need to evaluate the expression. This is how the compiler itself works, in all languages. In the expression exp won't be evaluated at all since \"or\" with 1 will always be 1. So it won't bother to evaluate the expression exp since the result will be 1 anyway (compiler optimization methods). But in case of The second expression exp2 won't be evaluated since True and exp1 would be True when exp1 isn't false. Similarly in The expression exp1 won't be evaluated since False is equivalent to writing 0 and doing \"and\" with 0 would be 0 itself, but after exp1 since \"or\" is used, it will evaluate the expression exp2 after \"or\". Note:- This kind of branching using \"or\" and \"and\" can only be used when the expression_1 doesn't have a Truth value of False (or 0 or None or emptylist [ ] or emptystring ' '.) since if expression_1 becomes False, then the expression_2 will be evaluated because of the presence \"or\" between exp_1 and exp_2. In case you still want to make it work for all the cases regardless of what exp_1 and exp_2 truth values are, do this:"}, {"id": 65422380, "score": 27, "vote": 0, "content": "<p><a href=\"https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator/394814#394814\">Vinko Vrsalovic's answer</a> is good enough. There is only one more thing:</p>\n<blockquote>\n<p>Note that conditionals are an <em>expression</em>, not a <em>statement</em>. This means you can't use assignment statements or <code>pass</code> or other <strong>statements</strong> within a conditional <strong>expression</strong></p>\n</blockquote>\n<h3>Walrus operator in Python 3.8</h3>\n<p>After the <a href=\"https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions\" rel=\"nofollow noreferrer\">walrus operator</a> was introduced in Python 3.8, something changed.</p>\n<pre><code class=\"python\">(a := 3) if True else (b := 5)\n</code></pre>\n<p>gives <code>a = 3</code> and <code>b is not defined</code>,</p>\n<pre><code class=\"python\">(a := 3) if False else (b := 5)\n</code></pre>\n<p>gives <code>a is not defined</code> and <code>b = 5</code>, and</p>\n<pre><code class=\"python\">c = (a := 3) if False else (b := 5)\n</code></pre>\n<p>gives <code>c = 5</code>, <code>a is not defined</code> and <code>b = 5</code>.</p>\n<p>Even if this may be ugly, <strong>assignments</strong> can be done <strong>inside</strong> conditional expressions after Python 3.8. Anyway, it is still better to use normal <code>if</code> <strong>statement</strong> instead in this case.</p>\n", "abstract": "Vinko Vrsalovic's answer is good enough. There is only one more thing: Note that conditionals are an expression, not a statement. This means you can't use assignment statements or pass or other statements within a conditional expression After the walrus operator was introduced in Python 3.8, something changed. gives a = 3 and b is not defined, gives a is not defined and b = 5, and gives c = 5, a is not defined and b = 5. Even if this may be ugly, assignments can be done inside conditional expressions after Python 3.8. Anyway, it is still better to use normal if statement instead in this case."}, {"id": 53922638, "score": 16, "vote": 0, "content": "<p>Many programming languages derived from <a href=\"https://en.wikipedia.org/wiki/C_%28programming_language%29\" rel=\"nofollow noreferrer\">C</a> usually have the following syntax of the ternary conditional operator:</p>\n<pre><code class=\"python\">&lt;condition&gt; ? &lt;expression1&gt; : &lt;expression2&gt;\n</code></pre>\n<p>At first, the Python's <a href=\"https://en.wikipedia.org/wiki/Benevolent_dictator_for_life\" rel=\"nofollow noreferrer\">benevolent dictator for life</a> (I mean <a href=\"https://en.wikipedia.org/wiki/Guido_van_Rossum\" rel=\"nofollow noreferrer\">Guido van Rossum</a>, of course) rejected it (as non-Pythonic style), since it's quite hard to understand for people not used to C language. Also, the colon sign <strong><code>:</code></strong> already has many uses in Python. After <strong>PEP 308</strong> was approved, Python finally received its own shortcut conditional expression (what we use now):</p>\n<pre><code class=\"python\">&lt;expression1&gt; if &lt;condition&gt; else &lt;expression2&gt;\n</code></pre>\n<p>So, firstly it evaluates the condition. If it returns <code>True</code>, <strong>expression1</strong> will be evaluated to give the result, otherwise <strong>expression2</strong> will be evaluated. Due to <a href=\"https://en.wikipedia.org/wiki/Lazy_evaluation\" rel=\"nofollow noreferrer\">lazy evaluation</a> mechanics \u2013 only one expression will be executed.</p>\n<p>Here are some examples (conditions will be evaluated from left to right):</p>\n<pre><code class=\"python\">pressure = 10\nprint('High' if pressure &lt; 20 else 'Critical')\n\n# Result is 'High'\n</code></pre>\n<p>Ternary operators can be chained in series:</p>\n<pre><code class=\"python\">pressure = 5\nprint('Normal' if pressure &lt; 10 else 'High' if pressure &lt; 20 else 'Critical')\n\n# Result is 'Normal'\n</code></pre>\n<p>The following one is the same as previous one:</p>\n<pre><code class=\"python\">pressure = 5\n\nif pressure &lt; 20:\n    if pressure &lt; 10:\n        print('Normal')\n    else:\n        print('High')\nelse:\n    print('Critical')\n\n# Result is 'Normal'\n</code></pre>\n", "abstract": "Many programming languages derived from C usually have the following syntax of the ternary conditional operator: At first, the Python's benevolent dictator for life (I mean Guido van Rossum, of course) rejected it (as non-Pythonic style), since it's quite hard to understand for people not used to C language. Also, the colon sign : already has many uses in Python. After PEP 308 was approved, Python finally received its own shortcut conditional expression (what we use now): So, firstly it evaluates the condition. If it returns True, expression1 will be evaluated to give the result, otherwise expression2 will be evaluated. Due to lazy evaluation mechanics \u2013 only one expression will be executed. Here are some examples (conditions will be evaluated from left to right): Ternary operators can be chained in series: The following one is the same as previous one:"}, {"id": 52919467, "score": 15, "vote": 0, "content": "<p><em>Yes</em>, Python have a ternary operator, here is the syntax and an example code to demonstrate the same :)</p>\n<pre><code class=\"python\">#[On true] if [expression] else[On false]\n# if the expression evaluates to true then it will pass On true otherwise On false\n\na = input(\"Enter the First Number \")\nb = input(\"Enter the Second Number \")\n\nprint(\"A is Bigger\") if a&gt;b else print(\"B is Bigger\")\n</code></pre>\n", "abstract": "Yes, Python have a ternary operator, here is the syntax and an example code to demonstrate the same :)"}, {"id": 61896436, "score": 12, "vote": 0, "content": "<p>Other answers correctly talk about the Python ternary operator. I would like to complement by mentioning a scenario for which the ternary operator is often used, but for which there is a better idiom. This is the scenario of using a default value.</p>\n<p>Suppose we want to use <code>option_value</code> with a default value if it is not set:</p>\n<pre><code class=\"python\">run_algorithm(option_value if option_value is not None else 10)\n</code></pre>\n<p>or, if <code>option_value</code> is never set to a falsy value (<code>0</code>, <code>\"\"</code>, etc.), simply</p>\n<pre><code class=\"python\">run_algorithm(option_value if option_value else 10)\n</code></pre>\n<p>However, in this case an ever better solution is simply to write</p>\n<pre><code class=\"python\">run_algorithm(option_value or 10)\n</code></pre>\n", "abstract": "Other answers correctly talk about the Python ternary operator. I would like to complement by mentioning a scenario for which the ternary operator is often used, but for which there is a better idiom. This is the scenario of using a default value. Suppose we want to use option_value with a default value if it is not set: or, if option_value is never set to a falsy value (0, \"\", etc.), simply However, in this case an ever better solution is simply to write"}, {"id": 71819081, "score": 12, "vote": 0, "content": "<p>The syntax for the ternary operator in Python is:</p>\n<p><code>[on_true] if [expression] else [on_false]</code></p>\n<p>Using that syntax, here is how we would rewrite the code above using Python\u2019s ternary operator:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">game_type = 'home'\nshirt = 'white' if game_type == 'home' else 'green'\n\n</code></pre>\n<p>It's still pretty clear, but much shorter. Note that the expression could be any type of expression, including a function call, that returns a value that evaluates to True or False.</p>\n", "abstract": "The syntax for the ternary operator in Python is: [on_true] if [expression] else [on_false] Using that syntax, here is how we would rewrite the code above using Python\u2019s ternary operator: It's still pretty clear, but much shorter. Note that the expression could be any type of expression, including a function call, that returns a value that evaluates to True or False."}, {"id": 60630600, "score": 9, "vote": 0, "content": "<p>Python has a ternary form for assignments; however there may be even a shorter form that people should be aware of.</p>\n<p>It's very common to need to assign to a variable one value or another depending on a condition.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; li1 = None\n&gt;&gt;&gt; li2 = [1, 2, 3]\n&gt;&gt;&gt;\n&gt;&gt;&gt; if li1:\n...     a = li1\n... else:\n...     a = li2\n...\n&gt;&gt;&gt; a\n[1, 2, 3]\n</code></pre>\n<p>^ This is the long form for doing such assignments.</p>\n<p>Below is the ternary form. But this isn't the most succinct way - see the last example.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = li1 if li1 else li2\n&gt;&gt;&gt;\n&gt;&gt;&gt; a\n[1, 2, 3]\n&gt;&gt;&gt;\n</code></pre>\n<p>With Python, you can simply use <code>or</code> for alternative assignments.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = li1 or li2\n&gt;&gt;&gt;\n&gt;&gt;&gt; a\n[1, 2, 3]\n&gt;&gt;&gt;\n</code></pre>\n<p>The above works since <code>li1</code> is <code>None</code> and the interpreter treats that as False in logic expressions. The interpreter then moves on and evaluates the second expression, which is not <code>None</code> and it's not an empty list - so it gets assigned to <em>a</em>.</p>\n<p>This also works with empty lists. For instance, if you want to assign <code>a</code> whichever list has items.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; li1 = []\n&gt;&gt;&gt; li2 = [1, 2, 3]\n&gt;&gt;&gt;\n&gt;&gt;&gt; a = li1 or li2\n&gt;&gt;&gt;\n&gt;&gt;&gt; a\n[1, 2, 3]\n&gt;&gt;&gt;\n</code></pre>\n<p>Knowing this, you can simply such assignments whenever you encounter them. This also works with strings and other iterables. You could assign <code>a</code> whichever string isn't empty.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; s1 = ''\n&gt;&gt;&gt; s2 = 'hello world'\n&gt;&gt;&gt;\n&gt;&gt;&gt; a = s1 or s2\n&gt;&gt;&gt;\n&gt;&gt;&gt; a\n'hello world'\n&gt;&gt;&gt;\n</code></pre>\n<p>I always liked the C ternary syntax, but Python takes it a step further!</p>\n<p>I understand that some may say this isn't a good stylistic choice, because it relies on mechanics that aren't immediately apparent to all developers. I personally disagree with that viewpoint. Python is a syntax-rich language with lots of idiomatic tricks that aren't immediately apparent to the dabbler. But the more you learn and understand the mechanics of the underlying system, the more you appreciate it.</p>\n", "abstract": "Python has a ternary form for assignments; however there may be even a shorter form that people should be aware of. It's very common to need to assign to a variable one value or another depending on a condition. ^ This is the long form for doing such assignments. Below is the ternary form. But this isn't the most succinct way - see the last example. With Python, you can simply use or for alternative assignments. The above works since li1 is None and the interpreter treats that as False in logic expressions. The interpreter then moves on and evaluates the second expression, which is not None and it's not an empty list - so it gets assigned to a. This also works with empty lists. For instance, if you want to assign a whichever list has items. Knowing this, you can simply such assignments whenever you encounter them. This also works with strings and other iterables. You could assign a whichever string isn't empty. I always liked the C ternary syntax, but Python takes it a step further! I understand that some may say this isn't a good stylistic choice, because it relies on mechanics that aren't immediately apparent to all developers. I personally disagree with that viewpoint. Python is a syntax-rich language with lots of idiomatic tricks that aren't immediately apparent to the dabbler. But the more you learn and understand the mechanics of the underlying system, the more you appreciate it."}, {"id": 70523744, "score": 7, "vote": 0, "content": "<p>Pythonic way of doing the things:</p>\n<pre><code class=\"python\">\"true\" if var else \"false\"\n</code></pre>\n<p>But there always exists a different way of doing a ternary condition too:</p>\n<pre><code class=\"python\">\"true\" and var or \"false\"\n</code></pre>\n", "abstract": "Pythonic way of doing the things: But there always exists a different way of doing a ternary condition too:"}, {"id": 70941294, "score": 3, "vote": 0, "content": "<p>The <strong>if else-if</strong> version can be written as:</p>\n<pre><code class=\"python\">sample_set=\"train\" if \"Train\" in full_path else (\"test\" if \"Test\" in full_path else \"validation\")\n</code></pre>\n", "abstract": "The if else-if version can be written as:"}, {"id": 71007804, "score": 3, "vote": 0, "content": "<p>There are multiple ways. The simplest one is to use the condition inside the \"print\" method.</p>\n<p>You can use</p>\n<pre><code class=\"python\">print(\"Twenty\" if number == 20 else \"Not twenty\")\n</code></pre>\n<p>Which is equivalent to:</p>\n<pre><code class=\"python\">if number == 20:\n    print(\"Twenty\")\nelse:\n    print(\"Not twenty\")\n</code></pre>\n<p>In this way, more than two statements are also possible to print. For example:</p>\n<pre><code class=\"python\">if number == 20:\n    print(\"Twenty\")\nelif number &lt; 20:\n    print(\"Lesser\")\nelif 30 &gt; number &gt; 20:\n    print(\"Between\")\nelse:\n    print(\"Greater\")\n</code></pre>\n<p>can be written as:</p>\n<pre><code class=\"python\">print(\"Twenty\" if number == 20 else \"Lesser\" if number &lt; 20 else \"Between\" if 30 &gt; number &gt; 20 else \"Greater\")\n</code></pre>\n", "abstract": "There are multiple ways. The simplest one is to use the condition inside the \"print\" method. You can use Which is equivalent to: In this way, more than two statements are also possible to print. For example: can be written as:"}, {"id": 71150434, "score": 3, "vote": 0, "content": "<p>Yes, it has, but it's different from C-syntax-like programming languages (which is <code>condition ? value_if_true : value_if_false</code></p>\n<p>In Python, it goes like this: <code>value_if_true if condition else value_if_false</code></p>\n<p>Example: <code>even_or_odd = \"even\" if x % 2 == 0 else \"odd\"</code></p>\n", "abstract": "Yes, it has, but it's different from C-syntax-like programming languages (which is condition ? value_if_true : value_if_false In Python, it goes like this: value_if_true if condition else value_if_false Example: even_or_odd = \"even\" if x % 2 == 0 else \"odd\""}, {"id": 56099511, "score": 1, "vote": 0, "content": "<p><em>A neat way to chain multiple operators:</em></p>\n<pre><code class=\"python\">f = lambda x,y: 'greater' if x &gt; y else 'less' if y &gt; x else 'equal'\n\narray = [(0,0),(0,1),(1,0),(1,1)]\n\nfor a in array:\n  x, y = a[0], a[1]\n  print(f(x,y))\n\n# Output is:\n#   equal,\n#   less,\n#   greater,\n#   equal\n\n</code></pre>\n", "abstract": "A neat way to chain multiple operators:"}, {"id": 60876846, "score": 0, "vote": 0, "content": "<p>I find the default Python syntax <code>val = a if cond else b</code> cumbersome, so sometimes I do this:</p>\n<pre><code class=\"python\">iif = lambda (cond, a, b): a if cond else b\n# So I can then use it like:\nval = iif(cond, a, b)\n</code></pre>\n<p>Of course, it has the downside of always evaluating both sides (<em>a</em> and <em>b</em>), but the syntax is way clearer to me.</p>\n", "abstract": "I find the default Python syntax val = a if cond else b cumbersome, so sometimes I do this: Of course, it has the downside of always evaluating both sides (a and b), but the syntax is way clearer to me."}]}, {"link": "https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python", "question": {"id": "100003", "title": "What are metaclasses in Python?", "content": "<p>What are metaclasses? What are they used for?</p>\n", "abstract": "What are metaclasses? What are they used for?"}, "answers": [{"id": 6581949, "score": 8395, "vote": 0, "content": "<h1>Classes as objects</h1>\n<p>Before understanding metaclasses, you need to master classes in Python. And Python has a very peculiar idea of what classes are, borrowed from the Smalltalk language.</p>\n<p>In most languages, classes are just pieces of code that describe how to produce an object. That's kinda true in Python too:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class ObjectCreator(object):\n...       pass\n...\n\n&gt;&gt;&gt; my_object = ObjectCreator()\n&gt;&gt;&gt; print(my_object)\n&lt;__main__.ObjectCreator object at 0x8974f2c&gt;\n</code></pre>\n<p>But classes are more than that in Python. Classes are objects too.</p>\n<p>Yes, objects.</p>\n<p>As soon as you use the keyword <code>class</code>, Python executes it and creates\nan <strong>object</strong>. The instruction</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class ObjectCreator(object):\n...       pass\n...\n</code></pre>\n<p>creates in memory an object with the name <code>ObjectCreator</code>.</p>\n<p><strong>This object (the class) is itself capable of creating objects (the instances),\nand this is why it's a class</strong>.</p>\n<p>But still, it's an object, and therefore:</p>\n<ul>\n<li>you can assign it to a variable</li>\n<li>you can copy it</li>\n<li>you can add attributes to it</li>\n<li>you can pass it as a function parameter</li>\n</ul>\n<p>e.g.:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print(ObjectCreator) # you can print a class because it's an object\n&lt;class '__main__.ObjectCreator'&gt;\n&gt;&gt;&gt; def echo(o):\n...       print(o)\n...\n&gt;&gt;&gt; echo(ObjectCreator) # you can pass a class as a parameter\n&lt;class '__main__.ObjectCreator'&gt;\n&gt;&gt;&gt; print(hasattr(ObjectCreator, 'new_attribute'))\nFalse\n&gt;&gt;&gt; ObjectCreator.new_attribute = 'foo' # you can add attributes to a class\n&gt;&gt;&gt; print(hasattr(ObjectCreator, 'new_attribute'))\nTrue\n&gt;&gt;&gt; print(ObjectCreator.new_attribute)\nfoo\n&gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # you can assign a class to a variable\n&gt;&gt;&gt; print(ObjectCreatorMirror.new_attribute)\nfoo\n&gt;&gt;&gt; print(ObjectCreatorMirror())\n&lt;__main__.ObjectCreator object at 0x8997b4c&gt;\n</code></pre>\n<h1>Creating classes dynamically</h1>\n<p>Since classes are objects, you can create them on the fly, like any object.</p>\n<p>First, you can create a class in a function using <code>class</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def choose_class(name):\n...     if name == 'foo':\n...         class Foo(object):\n...             pass\n...         return Foo # return the class, not an instance\n...     else:\n...         class Bar(object):\n...             pass\n...         return Bar\n...\n&gt;&gt;&gt; MyClass = choose_class('foo')\n&gt;&gt;&gt; print(MyClass) # the function returns a class, not an instance\n&lt;class '__main__.Foo'&gt;\n&gt;&gt;&gt; print(MyClass()) # you can create an object from this class\n&lt;__main__.Foo object at 0x89c6d4c&gt;\n</code></pre>\n<p>But it's not so dynamic, since you still have to write the whole class yourself.</p>\n<p>Since classes are objects, they must be generated by something.</p>\n<p>When you use the <code>class</code> keyword, Python creates this object automatically. But as\nwith most things in Python, it gives you a way to do it manually.</p>\n<p>Remember the function <code>type</code>? The good old function that lets you know what\ntype an object is:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print(type(1))\n&lt;type 'int'&gt;\n&gt;&gt;&gt; print(type(\"1\"))\n&lt;type 'str'&gt;\n&gt;&gt;&gt; print(type(ObjectCreator))\n&lt;type 'type'&gt;\n&gt;&gt;&gt; print(type(ObjectCreator()))\n&lt;class '__main__.ObjectCreator'&gt;\n</code></pre>\n<p>Well, <a href=\"http://docs.python.org/2/library/functions.html#type\" rel=\"noreferrer\"><code>type</code></a> has a completely different ability, it can also create classes on the fly. <code>type</code> can take the description of a class as parameters,\nand return a class.</p>\n<p>(I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backward\ncompatibility in Python)</p>\n<p><code>type</code> works this way:</p>\n<pre><code class=\"python\">type(name, bases, attrs)\n</code></pre>\n<p>Where:</p>\n<ul>\n<li><strong><code>name</code></strong>: name of the class</li>\n<li><strong><code>bases</code></strong>: tuple of the parent class (for inheritance, can be empty)</li>\n<li><strong><code>attrs</code></strong>: dictionary containing attributes names and values</li>\n</ul>\n<p>e.g.:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class MyShinyClass(object):\n...       pass\n</code></pre>\n<p>can be created manually this way:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; MyShinyClass = type('MyShinyClass', (), {}) # returns a class object\n&gt;&gt;&gt; print(MyShinyClass)\n&lt;class '__main__.MyShinyClass'&gt;\n&gt;&gt;&gt; print(MyShinyClass()) # create an instance with the class\n&lt;__main__.MyShinyClass object at 0x8997cec&gt;\n</code></pre>\n<p>You'll notice that we use <code>MyShinyClass</code> as the name of the class\nand as the variable to hold the class reference. They can be different,\nbut there is no reason to complicate things.</p>\n<p><code>type</code> accepts a dictionary to define the attributes of the class. So:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class Foo(object):\n...       bar = True\n</code></pre>\n<p>Can be translated to:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; Foo = type('Foo', (), {'bar':True})\n</code></pre>\n<p>And used as a normal class:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print(Foo)\n&lt;class '__main__.Foo'&gt;\n&gt;&gt;&gt; print(Foo.bar)\nTrue\n&gt;&gt;&gt; f = Foo()\n&gt;&gt;&gt; print(f)\n&lt;__main__.Foo object at 0x8a9b84c&gt;\n&gt;&gt;&gt; print(f.bar)\nTrue\n</code></pre>\n<p>And of course, you can inherit from it, so:</p>\n<pre><code class=\"python\">&gt;&gt;&gt;   class FooChild(Foo):\n...         pass\n</code></pre>\n<p>would be:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {})\n&gt;&gt;&gt; print(FooChild)\n&lt;class '__main__.FooChild'&gt;\n&gt;&gt;&gt; print(FooChild.bar) # bar is inherited from Foo\nTrue\n</code></pre>\n<p>Eventually, you'll want to add methods to your class. Just define a function\nwith the proper signature and assign it as an attribute.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def echo_bar(self):\n...       print(self.bar)\n...\n&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n&gt;&gt;&gt; hasattr(Foo, 'echo_bar')\nFalse\n&gt;&gt;&gt; hasattr(FooChild, 'echo_bar')\nTrue\n&gt;&gt;&gt; my_foo = FooChild()\n&gt;&gt;&gt; my_foo.echo_bar()\nTrue\n</code></pre>\n<p>And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def echo_bar_more(self):\n...       print('yet another method')\n...\n&gt;&gt;&gt; FooChild.echo_bar_more = echo_bar_more\n&gt;&gt;&gt; hasattr(FooChild, 'echo_bar_more')\nTrue\n</code></pre>\n<p>You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.</p>\n<p>This is what Python does when you use the keyword <code>class</code>, and it does so by using a metaclass.</p>\n<h1>What are metaclasses (finally)</h1>\n<p>Metaclasses are the 'stuff' that creates classes.</p>\n<p>You define classes in order to create objects, right?</p>\n<p>But we learned that Python classes are objects.</p>\n<p>Well, metaclasses are what create these objects. They are the classes' classes,\nyou can picture them this way:</p>\n<pre><code class=\"python\">MyClass = MetaClass()\nmy_object = MyClass()\n</code></pre>\n<p>You've seen that <code>type</code> lets you do something like this:</p>\n<pre><code class=\"python\">MyClass = type('MyClass', (), {})\n</code></pre>\n<p>It's because the function <code>type</code> is in fact a metaclass. <code>type</code> is the\nmetaclass Python uses to create all classes behind the scenes.</p>\n<p>Now you wonder \"why the heck is it written in lowercase, and not <code>Type</code>?\"</p>\n<p>Well, I guess it's a matter of consistency with <code>str</code>, the class that creates\nstrings objects, and <code>int</code> the class that creates integer objects. <code>type</code> is\njust the class that creates class objects.</p>\n<p>You see that by checking the <code>__class__</code> attribute.</p>\n<p>Everything, and I mean everything, is an object in Python. That includes integers,\nstrings, functions and classes. All of them are objects. And all of them have\nbeen created from a class:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; age = 35\n&gt;&gt;&gt; age.__class__\n&lt;type 'int'&gt;\n&gt;&gt;&gt; name = 'bob'\n&gt;&gt;&gt; name.__class__\n&lt;type 'str'&gt;\n&gt;&gt;&gt; def foo(): pass\n&gt;&gt;&gt; foo.__class__\n&lt;type 'function'&gt;\n&gt;&gt;&gt; class Bar(object): pass\n&gt;&gt;&gt; b = Bar()\n&gt;&gt;&gt; b.__class__\n&lt;class '__main__.Bar'&gt;\n</code></pre>\n<p>Now, what is the <code>__class__</code> of any <code>__class__</code> ?</p>\n<pre><code class=\"python\">&gt;&gt;&gt; age.__class__.__class__\n&lt;type 'type'&gt;\n&gt;&gt;&gt; name.__class__.__class__\n&lt;type 'type'&gt;\n&gt;&gt;&gt; foo.__class__.__class__\n&lt;type 'type'&gt;\n&gt;&gt;&gt; b.__class__.__class__\n&lt;type 'type'&gt;\n</code></pre>\n<p>So, a metaclass is just the stuff that creates class objects.</p>\n<p>You can call it a 'class factory' if you wish.</p>\n<p><code>type</code> is the built-in metaclass Python uses, but of course, you can create your\nown metaclass.</p>\n<h1>The <a href=\"http://docs.python.org/2/reference/datamodel.html?highlight=__metaclass__#__metaclass__\" rel=\"noreferrer\"><code>__metaclass__</code></a> attribute</h1>\n<p>In Python 2, you can add a <code>__metaclass__</code> attribute when you write a class (see next section for the Python 3 syntax):</p>\n<pre><code class=\"python\">class Foo(object):\n    __metaclass__ = something...\n    [...]\n</code></pre>\n<p>If you do so, Python will use the metaclass to create the class <code>Foo</code>.</p>\n<p>Careful, it's tricky.</p>\n<p>You write <code>class Foo(object)</code> first, but the class object <code>Foo</code> is not created\nin memory yet.</p>\n<p>Python will look for <code>__metaclass__</code> in the class definition. If it finds it,\nit will use it to create the object class <code>Foo</code>. If it doesn't, it will use\n<code>type</code> to create the class.</p>\n<p>Read that several times.</p>\n<p>When you do:</p>\n<pre><code class=\"python\">class Foo(Bar):\n    pass\n</code></pre>\n<p>Python does the following:</p>\n<p>Is there a <code>__metaclass__</code> attribute in <code>Foo</code>?</p>\n<p>If yes, create in-memory a class object (I said a class object, stay with me here), with the name <code>Foo</code> by using what is in <code>__metaclass__</code>.</p>\n<p>If Python can't find <code>__metaclass__</code>, it will look for a <code>__metaclass__</code> at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes).</p>\n<p>Then if it can't find any <code>__metaclass__</code> at all, it will use the <code>Bar</code>'s (the first parent) own metaclass (which might be the default <code>type</code>) to create the class object.</p>\n<p>Be careful here that the <code>__metaclass__</code> attribute will not be inherited, the metaclass of the parent (<code>Bar.__class__</code>) will be. If <code>Bar</code> used a <code>__metaclass__</code> attribute that created <code>Bar</code> with <code>type()</code> (and not <code>type.__new__()</code>), the subclasses will not inherit that behavior.</p>\n<p>Now the big question is, what can you put in <code>__metaclass__</code>?</p>\n<p>The answer is something that can create a class.</p>\n<p>And what can create a class? <code>type</code>, or anything that subclasses or uses it.</p>\n<h1>Metaclasses in Python 3</h1>\n<p>The syntax to set the metaclass has been changed in Python 3:</p>\n<pre><code class=\"python\">class Foo(object, metaclass=something):\n    ...\n</code></pre>\n<p>i.e. the <code>__metaclass__</code> attribute is no longer used, in favor of a keyword argument in the list of base classes.</p>\n<p>The behavior of metaclasses however stays <a href=\"https://www.python.org/dev/peps/pep-3115/\" rel=\"noreferrer\">largely the same</a>.</p>\n<p>One thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:</p>\n<pre><code class=\"python\">class Foo(object, metaclass=something, kwarg1=value1, kwarg2=value2):\n    ...\n</code></pre>\n<p>Read the section below for how Python handles this.</p>\n<h1>Custom metaclasses</h1>\n<p>The main purpose of a metaclass is to change the class automatically,\nwhen it's created.</p>\n<p>You usually do this for APIs, where you want to create classes matching the\ncurrent context.</p>\n<p>Imagine a stupid example, where you decide that all classes in your module\nshould have their attributes written in uppercase. There are several ways to\ndo this, but one way is to set <code>__metaclass__</code> at the module level.</p>\n<p>This way, all classes of this module will be created using this metaclass,\nand we just have to tell the metaclass to turn all attributes to uppercase.</p>\n<p>Luckily, <code>__metaclass__</code> can actually be any callable, it doesn't need to be a\nformal class (I know, something with 'class' in its name doesn't need to be\na class, go figure... but it's helpful).</p>\n<p>So we will start with a simple example, by using a function.</p>\n<pre><code class=\"python\"># the metaclass will automatically get passed the same argument\n# that you usually pass to `type`\ndef upper_attr(future_class_name, future_class_parents, future_class_attrs):\n    \"\"\"\n      Return a class object, with the list of its attribute turned\n      into uppercase.\n    \"\"\"\n    # pick up any attribute that doesn't start with '__' and uppercase it\n    uppercase_attrs = {\n        attr if attr.startswith(\"__\") else attr.upper(): v\n        for attr, v in future_class_attrs.items()\n    }\n\n    # let `type` do the class creation\n    return type(future_class_name, future_class_parents, uppercase_attrs)\n\n__metaclass__ = upper_attr # this will affect all classes in the module\n\nclass Foo(): # global __metaclass__ won't work with \"object\" though\n    # but we can define __metaclass__ here instead to affect only this class\n    # and this will work with \"object\" children\n    bar = 'bip'\n</code></pre>\n<p>Let's check:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; hasattr(Foo, 'bar')\nFalse\n&gt;&gt;&gt; hasattr(Foo, 'BAR')\nTrue\n&gt;&gt;&gt; Foo.BAR\n'bip'\n</code></pre>\n<p>Now, let's do exactly the same, but using a real class for a metaclass:</p>\n<pre><code class=\"python\"># remember that `type` is actually a class like `str` and `int`\n# so you can inherit from it\nclass UpperAttrMetaclass(type):\n    # __new__ is the method called before __init__\n    # it's the method that creates the object and returns it\n    # while __init__ just initializes the object passed as parameter\n    # you rarely use __new__, except when you want to control how the object\n    # is created.\n    # here the created object is the class, and we want to customize it\n    # so we override __new__\n    # you can do some stuff in __init__ too if you wish\n    # some advanced use involves overriding __call__ as well, but we won't\n    # see this\n    def __new__(upperattr_metaclass, future_class_name,\n                future_class_parents, future_class_attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(\"__\") else attr.upper(): v\n            for attr, v in future_class_attrs.items()\n        }\n        return type(future_class_name, future_class_parents, uppercase_attrs)\n</code></pre>\n<p>Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean:</p>\n<pre><code class=\"python\">class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(\"__\") else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n        return type(clsname, bases, uppercase_attrs)\n</code></pre>\n<p>You may have noticed the extra argument <code>cls</code>. There is\nnothing special about it: <code>__new__</code> always receives the class it's defined in, as the first parameter. Just like you have <code>self</code> for ordinary methods which receive the instance as the first parameter, or the defining class for class methods.</p>\n<p>But this is not proper OOP. We are calling <code>type</code> directly and we aren't overriding or calling the parent's <code>__new__</code>. Let's do that instead:</p>\n<pre><code class=\"python\">class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(\"__\") else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n        return type.__new__(cls, clsname, bases, uppercase_attrs)\n</code></pre>\n<p>We can make it even cleaner by using <code>super</code>, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):</p>\n<pre><code class=\"python\">class UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(\"__\") else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n\n        # Python 2 requires passing arguments to super:\n        return super(UpperAttrMetaclass, cls).__new__(\n            cls, clsname, bases, uppercase_attrs)\n\n        # Python 3 can use no-arg super() which infers them:\n        return super().__new__(cls, clsname, bases, uppercase_attrs)\n</code></pre>\n<p>Oh, and in Python 3 if you do this call with keyword arguments, like this:</p>\n<pre><code class=\"python\">class Foo(object, metaclass=MyMetaclass, kwarg1=value1):\n    ...\n</code></pre>\n<p>It translates to this in the metaclass to use it:</p>\n<pre><code class=\"python\">class MyMetaclass(type):\n    def __new__(cls, clsname, bases, dct, kwargs1=default):\n        ...\n</code></pre>\n<p>That's it. There is really nothing more about metaclasses.</p>\n<p>The reason behind the complexity of the code using metaclasses is not because\nof metaclasses, it's because you usually use metaclasses to do twisted stuff\nrelying on introspection, manipulating inheritance, vars such as <code>__dict__</code>, etc.</p>\n<p>Indeed, metaclasses are especially useful to do black magic, and therefore\ncomplicated stuff. But by themselves, they are simple:</p>\n<ul>\n<li>intercept a class creation</li>\n<li>modify the class</li>\n<li>return the modified class</li>\n</ul>\n<h1>Why would you use metaclasses classes instead of functions?</h1>\n<p>Since <code>__metaclass__</code> can accept any callable, why would you use a class\nsince it's obviously more complicated?</p>\n<p>There are several reasons to do so:</p>\n<ul>\n<li>The intention is clear. When you read <code>UpperAttrMetaclass(type)</code>, you know\nwhat's going to follow</li>\n<li>You can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.</li>\n<li>Subclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.</li>\n<li>You can structure your code better. You never use metaclasses for something as trivial as the above example. It's usually for something complicated. Having the ability to make several methods and group them in one class is very useful to make the code easier to read.</li>\n<li>You can hook on <code>__new__</code>, <code>__init__</code> and <code>__call__</code>. Which will allow you to do different stuff, Even if usually you can do it all in <code>__new__</code>,\nsome people are just more comfortable using <code>__init__</code>.</li>\n<li>These are called metaclasses, damn it! It must mean something!</li>\n</ul>\n<h1>Why would you use metaclasses?</h1>\n<p>Now the big question. Why would you use some obscure error-prone feature?</p>\n<p>Well, usually you don't:</p>\n<blockquote>\n<p>Metaclasses are deeper magic that\n99% of users should never worry about it.\nIf you wonder whether you need them,\nyou don't (the people who actually\nneed them know with certainty that\nthey need them, and don't need an\nexplanation about why).</p>\n</blockquote>\n<p><em>Python Guru Tim Peters</em></p>\n<p>The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:</p>\n<pre><code class=\"python\">class Person(models.Model):\n    name = models.CharField(max_length=30)\n    age = models.IntegerField()\n</code></pre>\n<p>But if you do this:</p>\n<pre><code class=\"python\">person = Person(name='bob', age='35')\nprint(person.age)\n</code></pre>\n<p>It won't return an <code>IntegerField</code> object. It will return an <code>int</code>, and can even take it directly from the database.</p>\n<p>This is possible because <code>models.Model</code> defines <code>__metaclass__</code> and\nit uses some magic that will turn the <code>Person</code> you just defined with simple statements\ninto a complex hook to a database field.</p>\n<p>Django makes something complex look simple by exposing a simple API\nand using metaclasses, recreating code from this API to do the real job\nbehind the scenes.</p>\n<h1>The last word</h1>\n<p>First, you know that classes are objects that can create instances.</p>\n<p>Well, in fact, classes are themselves instances. Of metaclasses.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class Foo(object): pass\n&gt;&gt;&gt; id(Foo)\n142630324\n</code></pre>\n<p>Everything is an object in Python, and they are all either instance of classes\nor instances of metaclasses.</p>\n<p>Except for <code>type</code>.</p>\n<p><code>type</code> is actually its own metaclass. This is not something you could\nreproduce in pure Python, and is done by cheating a little bit at the implementation\nlevel.</p>\n<p>Secondly, metaclasses are complicated. You may not want to use them for\nvery simple class alterations. You can change classes by using two different techniques:</p>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Monkey_patch\" rel=\"noreferrer\">monkey patching</a></li>\n<li>class decorators</li>\n</ul>\n<p>99% of the time you need class alteration, you are better off using these.</p>\n<p>But 98% of the time, you don't need class alteration at all.</p>\n", "abstract": "Before understanding metaclasses, you need to master classes in Python. And Python has a very peculiar idea of what classes are, borrowed from the Smalltalk language. In most languages, classes are just pieces of code that describe how to produce an object. That's kinda true in Python too: But classes are more than that in Python. Classes are objects too. Yes, objects. As soon as you use the keyword class, Python executes it and creates\nan object. The instruction creates in memory an object with the name ObjectCreator. This object (the class) is itself capable of creating objects (the instances),\nand this is why it's a class. But still, it's an object, and therefore: e.g.: Since classes are objects, you can create them on the fly, like any object. First, you can create a class in a function using class: But it's not so dynamic, since you still have to write the whole class yourself. Since classes are objects, they must be generated by something. When you use the class keyword, Python creates this object automatically. But as\nwith most things in Python, it gives you a way to do it manually. Remember the function type? The good old function that lets you know what\ntype an object is: Well, type has a completely different ability, it can also create classes on the fly. type can take the description of a class as parameters,\nand return a class. (I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backward\ncompatibility in Python) type works this way: Where: e.g.: can be created manually this way: You'll notice that we use MyShinyClass as the name of the class\nand as the variable to hold the class reference. They can be different,\nbut there is no reason to complicate things. type accepts a dictionary to define the attributes of the class. So: Can be translated to: And used as a normal class: And of course, you can inherit from it, so: would be: Eventually, you'll want to add methods to your class. Just define a function\nwith the proper signature and assign it as an attribute. And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object. You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically. This is what Python does when you use the keyword class, and it does so by using a metaclass. Metaclasses are the 'stuff' that creates classes. You define classes in order to create objects, right? But we learned that Python classes are objects. Well, metaclasses are what create these objects. They are the classes' classes,\nyou can picture them this way: You've seen that type lets you do something like this: It's because the function type is in fact a metaclass. type is the\nmetaclass Python uses to create all classes behind the scenes. Now you wonder \"why the heck is it written in lowercase, and not Type?\" Well, I guess it's a matter of consistency with str, the class that creates\nstrings objects, and int the class that creates integer objects. type is\njust the class that creates class objects. You see that by checking the __class__ attribute. Everything, and I mean everything, is an object in Python. That includes integers,\nstrings, functions and classes. All of them are objects. And all of them have\nbeen created from a class: Now, what is the __class__ of any __class__ ? So, a metaclass is just the stuff that creates class objects. You can call it a 'class factory' if you wish. type is the built-in metaclass Python uses, but of course, you can create your\nown metaclass. In Python 2, you can add a __metaclass__ attribute when you write a class (see next section for the Python 3 syntax): If you do so, Python will use the metaclass to create the class Foo. Careful, it's tricky. You write class Foo(object) first, but the class object Foo is not created\nin memory yet. Python will look for __metaclass__ in the class definition. If it finds it,\nit will use it to create the object class Foo. If it doesn't, it will use\ntype to create the class. Read that several times. When you do: Python does the following: Is there a __metaclass__ attribute in Foo? If yes, create in-memory a class object (I said a class object, stay with me here), with the name Foo by using what is in __metaclass__. If Python can't find __metaclass__, it will look for a __metaclass__ at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes). Then if it can't find any __metaclass__ at all, it will use the Bar's (the first parent) own metaclass (which might be the default type) to create the class object. Be careful here that the __metaclass__ attribute will not be inherited, the metaclass of the parent (Bar.__class__) will be. If Bar used a __metaclass__ attribute that created Bar with type() (and not type.__new__()), the subclasses will not inherit that behavior. Now the big question is, what can you put in __metaclass__? The answer is something that can create a class. And what can create a class? type, or anything that subclasses or uses it. The syntax to set the metaclass has been changed in Python 3: i.e. the __metaclass__ attribute is no longer used, in favor of a keyword argument in the list of base classes. The behavior of metaclasses however stays largely the same. One thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so: Read the section below for how Python handles this. The main purpose of a metaclass is to change the class automatically,\nwhen it's created. You usually do this for APIs, where you want to create classes matching the\ncurrent context. Imagine a stupid example, where you decide that all classes in your module\nshould have their attributes written in uppercase. There are several ways to\ndo this, but one way is to set __metaclass__ at the module level. This way, all classes of this module will be created using this metaclass,\nand we just have to tell the metaclass to turn all attributes to uppercase. Luckily, __metaclass__ can actually be any callable, it doesn't need to be a\nformal class (I know, something with 'class' in its name doesn't need to be\na class, go figure... but it's helpful). So we will start with a simple example, by using a function. Let's check: Now, let's do exactly the same, but using a real class for a metaclass: Let's rewrite the above, but with shorter and more realistic variable names now that we know what they mean: You may have noticed the extra argument cls. There is\nnothing special about it: __new__ always receives the class it's defined in, as the first parameter. Just like you have self for ordinary methods which receive the instance as the first parameter, or the defining class for class methods. But this is not proper OOP. We are calling type directly and we aren't overriding or calling the parent's __new__. Let's do that instead: We can make it even cleaner by using super, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type): Oh, and in Python 3 if you do this call with keyword arguments, like this: It translates to this in the metaclass to use it: That's it. There is really nothing more about metaclasses. The reason behind the complexity of the code using metaclasses is not because\nof metaclasses, it's because you usually use metaclasses to do twisted stuff\nrelying on introspection, manipulating inheritance, vars such as __dict__, etc. Indeed, metaclasses are especially useful to do black magic, and therefore\ncomplicated stuff. But by themselves, they are simple: Since __metaclass__ can accept any callable, why would you use a class\nsince it's obviously more complicated? There are several reasons to do so: Now the big question. Why would you use some obscure error-prone feature? Well, usually you don't: Metaclasses are deeper magic that\n99% of users should never worry about it.\nIf you wonder whether you need them,\nyou don't (the people who actually\nneed them know with certainty that\nthey need them, and don't need an\nexplanation about why). Python Guru Tim Peters The main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this: But if you do this: It won't return an IntegerField object. It will return an int, and can even take it directly from the database. This is possible because models.Model defines __metaclass__ and\nit uses some magic that will turn the Person you just defined with simple statements\ninto a complex hook to a database field. Django makes something complex look simple by exposing a simple API\nand using metaclasses, recreating code from this API to do the real job\nbehind the scenes. First, you know that classes are objects that can create instances. Well, in fact, classes are themselves instances. Of metaclasses. Everything is an object in Python, and they are all either instance of classes\nor instances of metaclasses. Except for type. type is actually its own metaclass. This is not something you could\nreproduce in pure Python, and is done by cheating a little bit at the implementation\nlevel. Secondly, metaclasses are complicated. You may not want to use them for\nvery simple class alterations. You can change classes by using two different techniques: 99% of the time you need class alteration, you are better off using these. But 98% of the time, you don't need class alteration at all."}, {"id": 100146, "score": 3386, "vote": 0, "content": "<p>A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.</p>\n<p>While in Python you can use arbitrary callables for metaclasses (like <a href=\"https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037\">Jerub</a> shows), the better approach is to make it an actual class itself. <code>type</code> is the usual metaclass in Python. <code>type</code> is itself a class, and it is its own type. You won't be able to recreate something like <code>type</code> purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass <code>type</code>.</p>\n<p>A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal <code>__init__</code> and <code>__new__</code> methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.</p>\n<p>When the <code>class</code> statement is executed, Python first executes the body of the <code>class</code> statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the <code>__metaclass__</code> attribute of the class-to-be (if any) or the <code>__metaclass__</code> global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.</p>\n<p>However, metaclasses actually define the <em>type</em> of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. <code>type.__subclasses__()</code> is an example of a method on the <code>type</code> metaclass. You can also define the normal 'magic' methods, like <code>__add__</code>, <code>__iter__</code> and <code>__getattr__</code>, to implement or change how the class behaves.</p>\n<p>Here's an aggregated example of the bits and pieces:</p>\n<pre><code class=\"python\">def make_hook(f):\n    \"\"\"Decorator to turn 'foo' method into '__foo__'\"\"\"\n    f.is_hook = 1\n    return f\n\nclass MyType(type):\n    def __new__(mcls, name, bases, attrs):\n\n        if name.startswith('None'):\n            return None\n\n        # Go over attributes and see if they should be renamed.\n        newattrs = {}\n        for attrname, attrvalue in attrs.iteritems():\n            if getattr(attrvalue, 'is_hook', 0):\n                newattrs['__%s__' % attrname] = attrvalue\n            else:\n                newattrs[attrname] = attrvalue\n\n        return super(MyType, mcls).__new__(mcls, name, bases, newattrs)\n\n    def __init__(self, name, bases, attrs):\n        super(MyType, self).__init__(name, bases, attrs)\n\n        # classregistry.register(self, self.interfaces)\n        print \"Would register class %s now.\" % self\n\n    def __add__(self, other):\n        class AutoClass(self, other):\n            pass\n        return AutoClass\n        # Alternatively, to autogenerate the classname as well as the class:\n        # return type(self.__name__ + other.__name__, (self, other), {})\n\n    def unregister(self):\n        # classregistry.unregister(self)\n        print \"Would unregister class %s now.\" % self\n\nclass MyObject:\n    __metaclass__ = MyType\n\n\nclass NoneSample(MyObject):\n    pass\n\n# Will print \"NoneType None\"\nprint type(NoneSample), repr(NoneSample)\n\nclass Example(MyObject):\n    def __init__(self, value):\n        self.value = value\n    @make_hook\n    def add(self, other):\n        return self.__class__(self.value + other.value)\n\n# Will unregister the class\nExample.unregister()\n\ninst = Example(10)\n# Will fail with an AttributeError\n#inst.unregister()\n\nprint inst + inst\nclass Sibling(MyObject):\n    pass\n\nExampleSibling = Example + Sibling\n# ExampleSibling is now a subclass of both Example and Sibling (with no\n# content of its own) although it will believe it's called 'AutoClass'\nprint ExampleSibling\nprint ExampleSibling.__mro__\n</code></pre>\n", "abstract": "A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass. While in Python you can use arbitrary callables for metaclasses (like Jerub shows), the better approach is to make it an actual class itself. type is the usual metaclass in Python. type is itself a class, and it is its own type. You won't be able to recreate something like type purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass type. A metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal __init__ and __new__ methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely. When the class statement is executed, Python first executes the body of the class statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the __metaclass__ attribute of the class-to-be (if any) or the __metaclass__ global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it. However, metaclasses actually define the type of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. type.__subclasses__() is an example of a method on the type metaclass. You can also define the normal 'magic' methods, like __add__, __iter__ and __getattr__, to implement or change how the class behaves. Here's an aggregated example of the bits and pieces:"}, {"id": 100037, "score": 477, "vote": 0, "content": "<p><em>Note, this answer is for Python 2.x as it was written in 2008, metaclasses are slightly different in 3.x.</em></p>\n<p>Metaclasses are the secret sauce that make 'class' work. The default metaclass for a new style object is called 'type'.</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">class type(object)\n  |  type(object) -&gt; the object's type\n  |  type(name, bases, dict) -&gt; a new type\n</code></pre>\n<p>Metaclasses take 3 args. '<strong>name</strong>', '<strong>bases</strong>' and '<strong>dict</strong>'</p>\n<p>Here is where the secret starts. Look for where name, bases and the dict come from in this example class definition.</p>\n<pre><code class=\"python\">class ThisIsTheName(Bases, Are, Here):\n    All_the_code_here\n    def doesIs(create, a):\n        dict\n</code></pre>\n<p>Lets define a metaclass that will demonstrate how '<strong>class:</strong>' calls it.</p>\n<pre><code class=\"python\">def test_metaclass(name, bases, dict):\n    print 'The Class Name is', name\n    print 'The Class Bases are', bases\n    print 'The dict has', len(dict), 'elems, the keys are', dict.keys()\n\n    return \"yellow\"\n\nclass TestName(object, None, int, 1):\n    __metaclass__ = test_metaclass\n    foo = 1\n    def baz(self, arr):\n        pass\n\nprint 'TestName = ', repr(TestName)\n\n# output =&gt; \nThe Class Name is TestName\nThe Class Bases are (&lt;type 'object'&gt;, None, &lt;type 'int'&gt;, 1)\nThe dict has 4 elems, the keys are ['baz', '__module__', 'foo', '__metaclass__']\nTestName =  'yellow'\n</code></pre>\n<p>And now, an example that actually means something, this will automatically make the variables in the list \"attributes\" set on the class, and set to None.</p>\n<pre><code class=\"python\">def init_attributes(name, bases, dict):\n    if 'attributes' in dict:\n        for attr in dict['attributes']:\n            dict[attr] = None\n\n    return type(name, bases, dict)\n\nclass Initialised(object):\n    __metaclass__ = init_attributes\n    attributes = ['foo', 'bar', 'baz']\n\nprint 'foo =&gt;', Initialised.foo\n# output=&gt;\nfoo =&gt; None\n</code></pre>\n<p><strong>Note that the magic behaviour that <code>Initialised</code> gains by having the metaclass <code>init_attributes</code> is not passed onto a subclass of <code>Initialised</code>.</strong></p>\n<p>Here is an even more concrete example, showing how you can subclass 'type' to make a metaclass that performs an action when the class is created. This is quite tricky:</p>\n<pre><code class=\"python\">class MetaSingleton(type):\n    instance = None\n    def __call__(cls, *args, **kw):\n        if cls.instance is None:\n            cls.instance = super(MetaSingleton, cls).__call__(*args, **kw)\n        return cls.instance\n\nclass Foo(object):\n    __metaclass__ = MetaSingleton\n\na = Foo()\nb = Foo()\nassert a is b\n</code></pre>\n", "abstract": "Note, this answer is for Python 2.x as it was written in 2008, metaclasses are slightly different in 3.x. Metaclasses are the secret sauce that make 'class' work. The default metaclass for a new style object is called 'type'. Metaclasses take 3 args. 'name', 'bases' and 'dict' Here is where the secret starts. Look for where name, bases and the dict come from in this example class definition. Lets define a metaclass that will demonstrate how 'class:' calls it. And now, an example that actually means something, this will automatically make the variables in the list \"attributes\" set on the class, and set to None. Note that the magic behaviour that Initialised gains by having the metaclass init_attributes is not passed onto a subclass of Initialised. Here is an even more concrete example, showing how you can subclass 'type' to make a metaclass that performs an action when the class is created. This is quite tricky:"}, {"id": 6428779, "score": 219, "vote": 0, "content": "<p>Others have explained how metaclasses work and how they fit into the Python type system. Here's an example of what they can be used for. In a testing framework I wrote, I wanted to keep track of the order in which classes were defined, so that I could later instantiate them in this order. I found it easiest to do this using a metaclass.</p>\n<pre><code class=\"python\">class MyMeta(type):\n\n    counter = 0\n\n    def __init__(cls, name, bases, dic):\n        type.__init__(cls, name, bases, dic)\n        cls._order = MyMeta.counter\n        MyMeta.counter += 1\n\nclass MyType(object):              # Python 2\n    __metaclass__ = MyMeta\n\nclass MyType(metaclass=MyMeta):    # Python 3\n    pass\n</code></pre>\n<p>Anything that's a subclass of <code>MyType</code> then gets a class attribute <code>_order</code> that records the order in which the classes were defined.</p>\n", "abstract": "Others have explained how metaclasses work and how they fit into the Python type system. Here's an example of what they can be used for. In a testing framework I wrote, I wanted to keep track of the order in which classes were defined, so that I could later instantiate them in this order. I found it easiest to do this using a metaclass. Anything that's a subclass of MyType then gets a class attribute _order that records the order in which the classes were defined."}, {"id": 100091, "score": 195, "vote": 0, "content": "<p>One use for metaclasses is adding new properties and methods to an instance automatically.</p>\n<p>For example, if you look at <a href=\"http://docs.djangoproject.com/en/dev/topics/db/models/\" rel=\"noreferrer\">Django models</a>, their definition looks a bit confusing. It looks as if you are only defining class properties:</p>\n<pre><code class=\"python\">class Person(models.Model):\n    first_name = models.CharField(max_length=30)\n    last_name = models.CharField(max_length=30)\n</code></pre>\n<p>However, at runtime the Person objects are filled with all sorts of useful methods. See the <a href=\"http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py\" rel=\"noreferrer\">source</a> for some amazing metaclassery.</p>\n", "abstract": "One use for metaclasses is adding new properties and methods to an instance automatically. For example, if you look at Django models, their definition looks a bit confusing. It looks as if you are only defining class properties: However, at runtime the Person objects are filled with all sorts of useful methods. See the source for some amazing metaclassery."}, {"id": 100059, "score": 159, "vote": 0, "content": "<p>I think the ONLamp introduction to metaclass programming is well written and gives a really good introduction to the topic despite being several years old already.</p>\n<p><a href=\"http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html\" rel=\"noreferrer\">http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html</a> (archived at <a href=\"https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html\" rel=\"noreferrer\">https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html</a>)</p>\n<p>In short: A class is a blueprint for the creation of an instance, a metaclass is a blueprint for the creation of a class. It can be easily seen that in Python classes need to be first-class objects too to enable this behavior.</p>\n<p>I've never written one myself, but I think one of the nicest uses of metaclasses can be seen in the <a href=\"http://www.djangoproject.com/\" rel=\"noreferrer\">Django framework</a>. The model classes use a metaclass approach to enable a declarative style of writing new models or form classes. While the metaclass is creating the class, all members get the possibility to customize the class itself.</p>\n<ul>\n<li><a href=\"http://docs.djangoproject.com/en/dev/intro/tutorial01/#id3\" rel=\"noreferrer\">Creating a new model</a></li>\n<li><a href=\"http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py#L25\" rel=\"noreferrer\">The metaclass enabling this</a></li>\n</ul>\n<p>The thing that's left to say is: If you don't know what metaclasses are, the probability that you <strong>will not need them</strong> is 99%.</p>\n", "abstract": "I think the ONLamp introduction to metaclass programming is well written and gives a really good introduction to the topic despite being several years old already. http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html (archived at https://web.archive.org/web/20080206005253/http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html) In short: A class is a blueprint for the creation of an instance, a metaclass is a blueprint for the creation of a class. It can be easily seen that in Python classes need to be first-class objects too to enable this behavior. I've never written one myself, but I think one of the nicest uses of metaclasses can be seen in the Django framework. The model classes use a metaclass approach to enable a declarative style of writing new models or form classes. While the metaclass is creating the class, all members get the possibility to customize the class itself. The thing that's left to say is: If you don't know what metaclasses are, the probability that you will not need them is 99%."}, {"id": 31930795, "score": 147, "vote": 0, "content": "<blockquote>\n<h2>What are metaclasses? What do you use them for?</h2>\n</blockquote>\n<p>TLDR: A metaclass instantiates and defines behavior for a class just like a class instantiates and defines behavior for an instance. </p>\n<p>Pseudocode:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; Class(...)\ninstance\n</code></pre>\n<p>The above should look familiar. Well, where does <code>Class</code> come from? It's an instance of a metaclass (also pseudocode):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; Metaclass(...)\nClass\n</code></pre>\n<p>In real code, we can pass the default metaclass, <code>type</code>, everything we need to instantiate a class and we get a class:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; type('Foo', (object,), {}) # requires a name, bases, and a namespace\n&lt;class '__main__.Foo'&gt;\n</code></pre>\n<h2>Putting it differently</h2>\n<ul>\n<li><p>A class is to an instance as a metaclass is to a class. </p>\n<p>When we instantiate an object, we get an instance:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; object()                          # instantiation of class\n&lt;object object at 0x7f9069b4e0b0&gt;     # instance\n</code></pre>\n<p>Likewise, when we define a class explicitly with the default metaclass, <code>type</code>, we instantiate it:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; type('Object', (object,), {})     # instantiation of metaclass\n&lt;class '__main__.Object'&gt;             # instance\n</code></pre></li>\n<li><p>Put another way, a class is an instance of a metaclass:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; isinstance(object, type)\nTrue\n</code></pre></li>\n<li><p>Put a third way, a metaclass is a class's class.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; type(object) == type\nTrue\n&gt;&gt;&gt; object.__class__\n&lt;class 'type'&gt;\n</code></pre></li>\n</ul>\n<p>When you write a class definition and Python executes it, it uses a metaclass to instantiate the class object (which will, in turn, be used to instantiate instances of that class).</p>\n<p>Just as we can use class definitions to change how custom object instances behave, we can use a metaclass class definition to change the way a class object behaves.</p>\n<p>What can they be used for? From the <a href=\"https://docs.python.org/3/reference/datamodel.html#metaclass-example\" rel=\"noreferrer\">docs</a>:</p>\n<blockquote>\n<p>The potential uses for metaclasses are boundless. Some ideas that have been explored include logging, interface checking, automatic delegation, automatic property creation, proxies, frameworks, and automatic resource locking/synchronization.</p>\n</blockquote>\n<p>Nevertheless, it is usually encouraged for users to avoid using metaclasses unless absolutely necessary.</p>\n<h1>You use a metaclass every time you create a class:</h1>\n<p>When you write a class definition, for example, like this,</p>\n<pre><code class=\"python\">class Foo(object): \n    'demo'\n</code></pre>\n<p>You instantiate a class object.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; Foo\n&lt;class '__main__.Foo'&gt;\n&gt;&gt;&gt; isinstance(Foo, type), isinstance(Foo, object)\n(True, True)\n</code></pre>\n<p>It is the same as functionally calling <code>type</code> with the appropriate arguments and assigning the result to a variable of that name:</p>\n<pre><code class=\"python\">name = 'Foo'\nbases = (object,)\nnamespace = {'__doc__': 'demo'}\nFoo = type(name, bases, namespace)\n</code></pre>\n<p>Note, some things automatically get added to the <code>__dict__</code>, i.e., the namespace:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; Foo.__dict__\ndict_proxy({'__dict__': &lt;attribute '__dict__' of 'Foo' objects&gt;, \n'__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' \nof 'Foo' objects&gt;, '__doc__': 'demo'})\n</code></pre>\n<p>The <em>metaclass</em> of the object we created, in both cases, is <code>type</code>. </p>\n<p>(A side-note on the contents of the class <code>__dict__</code>: <code>__module__</code> is there because classes must know where they are defined, and  <code>__dict__</code> and <code>__weakref__</code> are there because we don't define <code>__slots__</code> - if we <a href=\"https://stackoverflow.com/q/472000/541136\">define <code>__slots__</code></a> we'll save a bit of space in the instances, as we can disallow <code>__dict__</code> and <code>__weakref__</code> by excluding them. For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; Baz = type('Bar', (object,), {'__doc__': 'demo', '__slots__': ()})\n&gt;&gt;&gt; Baz.__dict__\nmappingproxy({'__doc__': 'demo', '__slots__': (), '__module__': '__main__'})\n</code></pre>\n<p>... but I digress.)</p>\n<h1>We can extend <code>type</code> just like any other class definition:</h1>\n<p>Here's the default <code>__repr__</code> of classes:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; Foo\n&lt;class '__main__.Foo'&gt;\n</code></pre>\n<p>One of the most valuable things we can do by default in writing a Python object is to provide it with a good <code>__repr__</code>. When we call <code>help(repr)</code> we learn that there's a good test for a <code>__repr__</code> that also requires a test for equality - <code>obj == eval(repr(obj))</code>. The following simple implementation of <code>__repr__</code> and <code>__eq__</code> for class instances of our type class provides us with a demonstration that may improve on the default <code>__repr__</code> of classes:</p>\n<pre><code class=\"python\">class Type(type):\n    def __repr__(cls):\n        \"\"\"\n        &gt;&gt;&gt; Baz\n        Type('Baz', (Foo, Bar,), {'__module__': '__main__', '__doc__': None})\n        &gt;&gt;&gt; eval(repr(Baz))\n        Type('Baz', (Foo, Bar,), {'__module__': '__main__', '__doc__': None})\n        \"\"\"\n        metaname = type(cls).__name__\n        name = cls.__name__\n        parents = ', '.join(b.__name__ for b in cls.__bases__)\n        if parents:\n            parents += ','\n        namespace = ', '.join(': '.join(\n          (repr(k), repr(v) if not isinstance(v, type) else v.__name__))\n               for k, v in cls.__dict__.items())\n        return '{0}(\\'{1}\\', ({2}), {{{3}}})'.format(metaname, name, parents, namespace)\n    def __eq__(cls, other):\n        \"\"\"\n        &gt;&gt;&gt; Baz == eval(repr(Baz))\n        True            \n        \"\"\"\n        return (cls.__name__, cls.__bases__, cls.__dict__) == (\n                other.__name__, other.__bases__, other.__dict__)\n</code></pre>\n<p>So now when we create an object with this metaclass, the <code>__repr__</code> echoed on the command line provides a much less ugly sight than the default:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class Bar(object): pass\n&gt;&gt;&gt; Baz = Type('Baz', (Foo, Bar,), {'__module__': '__main__', '__doc__': None})\n&gt;&gt;&gt; Baz\nType('Baz', (Foo, Bar,), {'__module__': '__main__', '__doc__': None})\n</code></pre>\n<p>With a nice <code>__repr__</code> defined for the class instance, we have a stronger ability to debug our code. However, much further checking with <code>eval(repr(Class))</code> is unlikely (as functions would be rather impossible to eval from their default <code>__repr__</code>'s).</p>\n<h1>An expected usage: <code>__prepare__</code> a namespace</h1>\n<p>If, for example, we want to know in what order a class's methods are created in, we could provide an ordered dict as the namespace of the class. We would do this with <code>__prepare__</code> which <a href=\"https://docs.python.org/3/reference/datamodel.html#preparing-the-class-namespace\" rel=\"noreferrer\">returns the namespace dict for the class if it is implemented in Python 3</a>: </p>\n<pre><code class=\"python\">from collections import OrderedDict\n\nclass OrderedType(Type):\n    @classmethod\n    def __prepare__(metacls, name, bases, **kwargs):\n        return OrderedDict()\n    def __new__(cls, name, bases, namespace, **kwargs):\n        result = Type.__new__(cls, name, bases, dict(namespace))\n        result.members = tuple(namespace)\n        return result\n</code></pre>\n<p>And usage:</p>\n<pre><code class=\"python\">class OrderedMethodsObject(object, metaclass=OrderedType):\n    def method1(self): pass\n    def method2(self): pass\n    def method3(self): pass\n    def method4(self): pass\n</code></pre>\n<p>And now we have a record of the order in which these methods (and other class attributes) were created:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; OrderedMethodsObject.members\n('__module__', '__qualname__', 'method1', 'method2', 'method3', 'method4')\n</code></pre>\n<p>Note, this example was adapted from the <a href=\"https://docs.python.org/3/reference/datamodel.html#metaclass-example\" rel=\"noreferrer\">documentation</a> - the new <a href=\"https://github.com/python/cpython/blob/master/Lib/enum.py\" rel=\"noreferrer\">enum in the standard library</a> does this.</p>\n<p>So what we did was instantiate a metaclass by creating a class. We can also treat the metaclass as we would any other class. It has a method resolution order:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; inspect.getmro(OrderedType)\n(&lt;class '__main__.OrderedType'&gt;, &lt;class '__main__.Type'&gt;, &lt;class 'type'&gt;, &lt;class 'object'&gt;)\n</code></pre>\n<p>And it has approximately the correct <code>repr</code> (which we can no longer eval unless we can find a way to represent our functions.):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; OrderedMethodsObject\nOrderedType('OrderedMethodsObject', (object,), {'method1': &lt;function OrderedMethodsObject.method1 at 0x0000000002DB01E0&gt;, 'members': ('__module__', '__qualname__', 'method1', 'method2', 'method3', 'method4'), 'method3': &lt;function OrderedMet\nhodsObject.method3 at 0x0000000002DB02F0&gt;, 'method2': &lt;function OrderedMethodsObject.method2 at 0x0000000002DB0268&gt;, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'OrderedMethodsObject' objects&gt;, '__doc__': None, '__d\nict__': &lt;attribute '__dict__' of 'OrderedMethodsObject' objects&gt;, 'method4': &lt;function OrderedMethodsObject.method4 at 0x0000000002DB0378&gt;})\n</code></pre>\n", "abstract": "TLDR: A metaclass instantiates and defines behavior for a class just like a class instantiates and defines behavior for an instance.  Pseudocode: The above should look familiar. Well, where does Class come from? It's an instance of a metaclass (also pseudocode): In real code, we can pass the default metaclass, type, everything we need to instantiate a class and we get a class: A class is to an instance as a metaclass is to a class.  When we instantiate an object, we get an instance: Likewise, when we define a class explicitly with the default metaclass, type, we instantiate it: Put another way, a class is an instance of a metaclass: Put a third way, a metaclass is a class's class. When you write a class definition and Python executes it, it uses a metaclass to instantiate the class object (which will, in turn, be used to instantiate instances of that class). Just as we can use class definitions to change how custom object instances behave, we can use a metaclass class definition to change the way a class object behaves. What can they be used for? From the docs: The potential uses for metaclasses are boundless. Some ideas that have been explored include logging, interface checking, automatic delegation, automatic property creation, proxies, frameworks, and automatic resource locking/synchronization. Nevertheless, it is usually encouraged for users to avoid using metaclasses unless absolutely necessary. When you write a class definition, for example, like this, You instantiate a class object. It is the same as functionally calling type with the appropriate arguments and assigning the result to a variable of that name: Note, some things automatically get added to the __dict__, i.e., the namespace: The metaclass of the object we created, in both cases, is type.  (A side-note on the contents of the class __dict__: __module__ is there because classes must know where they are defined, and  __dict__ and __weakref__ are there because we don't define __slots__ - if we define __slots__ we'll save a bit of space in the instances, as we can disallow __dict__ and __weakref__ by excluding them. For example: ... but I digress.) Here's the default __repr__ of classes: One of the most valuable things we can do by default in writing a Python object is to provide it with a good __repr__. When we call help(repr) we learn that there's a good test for a __repr__ that also requires a test for equality - obj == eval(repr(obj)). The following simple implementation of __repr__ and __eq__ for class instances of our type class provides us with a demonstration that may improve on the default __repr__ of classes: So now when we create an object with this metaclass, the __repr__ echoed on the command line provides a much less ugly sight than the default: With a nice __repr__ defined for the class instance, we have a stronger ability to debug our code. However, much further checking with eval(repr(Class)) is unlikely (as functions would be rather impossible to eval from their default __repr__'s). If, for example, we want to know in what order a class's methods are created in, we could provide an ordered dict as the namespace of the class. We would do this with __prepare__ which returns the namespace dict for the class if it is implemented in Python 3:  And usage: And now we have a record of the order in which these methods (and other class attributes) were created: Note, this example was adapted from the documentation - the new enum in the standard library does this. So what we did was instantiate a metaclass by creating a class. We can also treat the metaclass as we would any other class. It has a method resolution order: And it has approximately the correct repr (which we can no longer eval unless we can find a way to represent our functions.):"}, {"id": 35732111, "score": 110, "vote": 0, "content": "<p><strong>Python 3 update</strong></p>\n<p>There are (at this point) two key methods in a metaclass:</p>\n<ul>\n<li><code>__prepare__</code>, and</li>\n<li><code>__new__</code></li>\n</ul>\n<p><code>__prepare__</code> lets you supply a custom mapping (such as an <code>OrderedDict</code>) to be used as the namespace while the class is being created.  You must return an instance of whatever namespace you choose.  If you don't implement <code>__prepare__</code> a normal <code>dict</code> is used.</p>\n<p><code>__new__</code> is responsible for the actual creation/modification of the final class.</p>\n<p>A bare-bones, do-nothing-extra metaclass would like:</p>\n<pre><code class=\"python\">class Meta(type):\n\n    def __prepare__(metaclass, cls, bases):\n        return dict()\n\n    def __new__(metacls, cls, bases, clsdict):\n        return super().__new__(metacls, cls, bases, clsdict)\n</code></pre>\n<p>A simple example:</p>\n<p>Say you want some simple validation code to run on your attributes -- like it must always be an <code>int</code> or a <code>str</code>.  Without a metaclass, your class would look something like:</p>\n<pre><code class=\"python\">class Person:\n    weight = ValidateType('weight', int)\n    age = ValidateType('age', int)\n    name = ValidateType('name', str)\n</code></pre>\n<p>As you can see, you have to repeat the name of the attribute twice.  This makes typos possible along with irritating bugs.</p>\n<p>A simple metaclass can address that problem:</p>\n<pre><code class=\"python\">class Person(metaclass=Validator):\n    weight = ValidateType(int)\n    age = ValidateType(int)\n    name = ValidateType(str)\n</code></pre>\n<p>This is what the metaclass would look like (not using <code>__prepare__</code> since it is not needed):</p>\n<pre><code class=\"python\">class Validator(type):\n    def __new__(metacls, cls, bases, clsdict):\n        # search clsdict looking for ValidateType descriptors\n        for name, attr in clsdict.items():\n            if isinstance(attr, ValidateType):\n                attr.name = name\n                attr.attr = '_' + name\n        # create final class and return it\n        return super().__new__(metacls, cls, bases, clsdict)\n</code></pre>\n<p>A sample run of:</p>\n<pre><code class=\"python\">p = Person()\np.weight = 9\nprint(p.weight)\np.weight = '9'\n</code></pre>\n<p>produces:</p>\n<pre><code class=\"python\">9\nTraceback (most recent call last):\n  File \"simple_meta.py\", line 36, in &lt;module&gt;\n    p.weight = '9'\n  File \"simple_meta.py\", line 24, in __set__\n    (self.name, self.type, value))\nTypeError: weight must be of type(s) &lt;class 'int'&gt; (got '9')\n</code></pre>\n<hr/>\n<p><strong>Note</strong>:  This example is simple enough it could have also been accomplished with a class decorator, but presumably an actual metaclass would be doing much more.</p>\n<p>The 'ValidateType' class for reference:</p>\n<pre><code class=\"python\">class ValidateType:\n    def __init__(self, type):\n        self.name = None  # will be set by metaclass\n        self.attr = None  # will be set by metaclass\n        self.type = type\n    def __get__(self, inst, cls):\n        if inst is None:\n            return self\n        else:\n            return inst.__dict__[self.attr]\n    def __set__(self, inst, value):\n        if not isinstance(value, self.type):\n            raise TypeError('%s must be of type(s) %s (got %r)' %\n                    (self.name, self.type, value))\n        else:\n            inst.__dict__[self.attr] = value\n</code></pre>\n", "abstract": "Python 3 update There are (at this point) two key methods in a metaclass: __prepare__ lets you supply a custom mapping (such as an OrderedDict) to be used as the namespace while the class is being created.  You must return an instance of whatever namespace you choose.  If you don't implement __prepare__ a normal dict is used. __new__ is responsible for the actual creation/modification of the final class. A bare-bones, do-nothing-extra metaclass would like: A simple example: Say you want some simple validation code to run on your attributes -- like it must always be an int or a str.  Without a metaclass, your class would look something like: As you can see, you have to repeat the name of the attribute twice.  This makes typos possible along with irritating bugs. A simple metaclass can address that problem: This is what the metaclass would look like (not using __prepare__ since it is not needed): A sample run of: produces: Note:  This example is simple enough it could have also been accomplished with a class decorator, but presumably an actual metaclass would be doing much more. The 'ValidateType' class for reference:"}, {"id": 40017019, "score": 97, "vote": 0, "content": "<h1>Role of a metaclass' <code>__call__()</code> method when creating a class instance</h1>\n<p>If you've done Python programming for more than a few months you'll eventually stumble upon code that looks like this:</p>\n<pre><code class=\"python\"># define a class\nclass SomeClass(object):\n    # ...\n    # some definition here ...\n    # ...\n\n# create an instance of it\ninstance = SomeClass()\n\n# then call the object as if it's a function\nresult = instance('foo', 'bar')\n</code></pre>\n<p>The latter is possible when you implement the <code>__call__()</code> magic method on the class.</p>\n<pre><code class=\"python\">class SomeClass(object):\n    # ...\n    # some definition here ...\n    # ...\n\n    def __call__(self, foo, bar):\n        return bar + foo\n</code></pre>\n<p>The <code>__call__()</code> method is invoked when an instance of a class is used as a callable. But as we've seen from previous answers a class itself is an instance of a metaclass, so when we use the class as a callable (i.e. when we create an instance of it) we're actually calling its metaclass' <code>__call__()</code> method. At this point most Python programmers are a bit confused because they've been told that when creating an instance like this <code>instance = SomeClass()</code> you're calling its <code>__init__()</code> method. Some who've dug a bit deeper know that before <code>__init__()</code> there's <code>__new__()</code>. Well, today another layer of truth is being revealed, before <code>__new__()</code> there's the metaclass' <code>__call__()</code>.</p>\n<p>Let's study the method call chain from specifically the perspective of creating an instance of a class.</p>\n<p>This is a metaclass that logs exactly the moment before an instance is created and the moment it's about to return it.</p>\n<pre><code class=\"python\">class Meta_1(type):\n    def __call__(cls):\n        print \"Meta_1.__call__() before creating an instance of \", cls\n        instance = super(Meta_1, cls).__call__()\n        print \"Meta_1.__call__() about to return instance.\"\n        return instance\n</code></pre>\n<p>This is a class that uses that metaclass</p>\n<pre><code class=\"python\">class Class_1(object):\n\n    __metaclass__ = Meta_1\n\n    def __new__(cls):\n        print \"Class_1.__new__() before creating an instance.\"\n        instance = super(Class_1, cls).__new__(cls)\n        print \"Class_1.__new__() about to return instance.\"\n        return instance\n\n    def __init__(self):\n        print \"entering Class_1.__init__() for instance initialization.\"\n        super(Class_1,self).__init__()\n        print \"exiting Class_1.__init__().\"\n</code></pre>\n<p>And now let's create an instance of <code>Class_1</code></p>\n<pre><code class=\"python\">instance = Class_1()\n# Meta_1.__call__() before creating an instance of &lt;class '__main__.Class_1'&gt;.\n# Class_1.__new__() before creating an instance.\n# Class_1.__new__() about to return instance.\n# entering Class_1.__init__() for instance initialization.\n# exiting Class_1.__init__().\n# Meta_1.__call__() about to return instance.\n</code></pre>\n<p>Observe that the code above doesn't actually do anything more than logging the tasks. Each method delegates the actual work to its parent's implementation, thus keeping the default behavior. Since <code>type</code> is <code>Meta_1</code>'s parent class (<code>type</code> being the default parent metaclass) and considering the ordering sequence of the output above, we now have a clue as to what would be the pseudo implementation of <code>type.__call__()</code>:</p>\n<pre><code class=\"python\">class type:\n    def __call__(cls, *args, **kwarg):\n\n        # ... maybe a few things done to cls here\n\n        # then we call __new__() on the class to create an instance\n        instance = cls.__new__(cls, *args, **kwargs)\n\n        # ... maybe a few things done to the instance here\n\n        # then we initialize the instance with its __init__() method\n        instance.__init__(*args, **kwargs)\n\n        # ... maybe a few more things done to instance here\n\n        # then we return it\n        return instance\n</code></pre>\n<p>We can see that the metaclass' <code>__call__()</code> method is the one that's called first. It then delegates creation of the instance to the class's <code>__new__()</code> method and initialization to the instance's <code>__init__()</code>. It's also the one that ultimately returns the instance.</p>\n<p>From the above it stems that the metaclass' <code>__call__()</code> is also given the opportunity to decide whether or not a call to <code>Class_1.__new__()</code> or <code>Class_1.__init__()</code> will eventually be made. Over the course of its execution it could actually return an object that hasn't been touched by either of these methods. Take for example this approach to the singleton pattern:</p>\n<pre><code class=\"python\">class Meta_2(type):\n    singletons = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls in Meta_2.singletons:\n            # we return the only instance and skip a call to __new__()\n            # and __init__()\n            print (\"{} singleton returning from Meta_2.__call__(), \"\n                   \"skipping creation of new instance.\".format(cls))\n            return Meta_2.singletons[cls]\n\n        # else if the singleton isn't present we proceed as usual\n        print \"Meta_2.__call__() before creating an instance.\"\n        instance = super(Meta_2, cls).__call__(*args, **kwargs)\n        Meta_2.singletons[cls] = instance\n        print \"Meta_2.__call__() returning new instance.\"\n        return instance\n\nclass Class_2(object):\n\n    __metaclass__ = Meta_2\n\n    def __new__(cls, *args, **kwargs):\n        print \"Class_2.__new__() before creating instance.\"\n        instance = super(Class_2, cls).__new__(cls)\n        print \"Class_2.__new__() returning instance.\"\n        return instance\n\n    def __init__(self, *args, **kwargs):\n        print \"entering Class_2.__init__() for initialization.\"\n        super(Class_2, self).__init__()\n        print \"exiting Class_2.__init__().\"\n</code></pre>\n<p>Let's observe what happens when repeatedly trying to create an object of type <code>Class_2</code></p>\n<pre><code class=\"python\">a = Class_2()\n# Meta_2.__call__() before creating an instance.\n# Class_2.__new__() before creating instance.\n# Class_2.__new__() returning instance.\n# entering Class_2.__init__() for initialization.\n# exiting Class_2.__init__().\n# Meta_2.__call__() returning new instance.\n\nb = Class_2()\n# &lt;class '__main__.Class_2'&gt; singleton returning from Meta_2.__call__(), skipping creation of new instance.\n\nc = Class_2()\n# &lt;class '__main__.Class_2'&gt; singleton returning from Meta_2.__call__(), skipping creation of new instance.\n\na is b is c # True\n</code></pre>\n", "abstract": "If you've done Python programming for more than a few months you'll eventually stumble upon code that looks like this: The latter is possible when you implement the __call__() magic method on the class. The __call__() method is invoked when an instance of a class is used as a callable. But as we've seen from previous answers a class itself is an instance of a metaclass, so when we use the class as a callable (i.e. when we create an instance of it) we're actually calling its metaclass' __call__() method. At this point most Python programmers are a bit confused because they've been told that when creating an instance like this instance = SomeClass() you're calling its __init__() method. Some who've dug a bit deeper know that before __init__() there's __new__(). Well, today another layer of truth is being revealed, before __new__() there's the metaclass' __call__(). Let's study the method call chain from specifically the perspective of creating an instance of a class. This is a metaclass that logs exactly the moment before an instance is created and the moment it's about to return it. This is a class that uses that metaclass And now let's create an instance of Class_1 Observe that the code above doesn't actually do anything more than logging the tasks. Each method delegates the actual work to its parent's implementation, thus keeping the default behavior. Since type is Meta_1's parent class (type being the default parent metaclass) and considering the ordering sequence of the output above, we now have a clue as to what would be the pseudo implementation of type.__call__(): We can see that the metaclass' __call__() method is the one that's called first. It then delegates creation of the instance to the class's __new__() method and initialization to the instance's __init__(). It's also the one that ultimately returns the instance. From the above it stems that the metaclass' __call__() is also given the opportunity to decide whether or not a call to Class_1.__new__() or Class_1.__init__() will eventually be made. Over the course of its execution it could actually return an object that hasn't been touched by either of these methods. Take for example this approach to the singleton pattern: Let's observe what happens when repeatedly trying to create an object of type Class_2"}, {"id": 21999253, "score": 77, "vote": 0, "content": "<p>A <code>metaclass</code> is a class that tells how (some) other class should be created.</p>\n<p>This is a case where I saw <code>metaclass</code> as a solution to my problem:\nI had a really complicated problem, that probably could have been solved differently, but I chose to solve it using a <code>metaclass</code>.  Because of the complexity, it is one of the few modules I have written where the comments in the module surpass the amount of code that has been written.  Here it is...</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">#!/usr/bin/env python\n\n# Copyright (C) 2013-2014 Craig Phillips.  All rights reserved.\n\n# This requires some explaining.  The point of this metaclass excercise is to\n# create a static abstract class that is in one way or another, dormant until\n# queried.  I experimented with creating a singlton on import, but that did\n# not quite behave how I wanted it to.  See now here, we are creating a class\n# called GsyncOptions, that on import, will do nothing except state that its\n# class creator is GsyncOptionsType.  This means, docopt doesn't parse any\n# of the help document, nor does it start processing command line options.\n# So importing this module becomes really efficient.  The complicated bit\n# comes from requiring the GsyncOptions class to be static.  By that, I mean\n# any property on it, may or may not exist, since they are not statically\n# defined; so I can't simply just define the class with a whole bunch of\n# properties that are @property @staticmethods.\n#\n# So here's how it works:\n#\n# Executing 'from libgsync.options import GsyncOptions' does nothing more\n# than load up this module, define the Type and the Class and import them\n# into the callers namespace.  Simple.\n#\n# Invoking 'GsyncOptions.debug' for the first time, or any other property\n# causes the __metaclass__ __getattr__ method to be called, since the class\n# is not instantiated as a class instance yet.  The __getattr__ method on\n# the type then initialises the class (GsyncOptions) via the __initialiseClass\n# method.  This is the first and only time the class will actually have its\n# dictionary statically populated.  The docopt module is invoked to parse the\n# usage document and generate command line options from it.  These are then\n# paired with their defaults and what's in sys.argv.  After all that, we\n# setup some dynamic properties that could not be defined by their name in\n# the usage, before everything is then transplanted onto the actual class\n# object (or static class GsyncOptions).\n#\n# Another piece of magic, is to allow command line options to be set in\n# in their native form and be translated into argparse style properties.\n#\n# Finally, the GsyncListOptions class is actually where the options are\n# stored.  This only acts as a mechanism for storing options as lists, to\n# allow aggregation of duplicate options or options that can be specified\n# multiple times.  The __getattr__ call hides this by default, returning the\n# last item in a property's list.  However, if the entire list is required,\n# calling the 'list()' method on the GsyncOptions class, returns a reference\n# to the GsyncListOptions class, which contains all of the same properties\n# but as lists and without the duplication of having them as both lists and\n# static singlton values.\n#\n# So this actually means that GsyncOptions is actually a static proxy class...\n#\n# ...And all this is neatly hidden within a closure for safe keeping.\ndef GetGsyncOptionsType():\n    class GsyncListOptions(object):\n        __initialised = False\n\n    class GsyncOptionsType(type):\n        def __initialiseClass(cls):\n            if GsyncListOptions._GsyncListOptions__initialised: return\n\n            from docopt import docopt\n            from libgsync.options import doc\n            from libgsync import __version__\n\n            options = docopt(\n                doc.__doc__ % __version__,\n                version = __version__,\n                options_first = True\n            )\n\n            paths = options.pop('&lt;path&gt;', None)\n            setattr(cls, \"destination_path\", paths.pop() if paths else None)\n            setattr(cls, \"source_paths\", paths)\n            setattr(cls, \"options\", options)\n\n            for k, v in options.iteritems():\n                setattr(cls, k, v)\n\n            GsyncListOptions._GsyncListOptions__initialised = True\n\n        def list(cls):\n            return GsyncListOptions\n\n        def __getattr__(cls, name):\n            cls.__initialiseClass()\n            return getattr(GsyncListOptions, name)[-1]\n\n        def __setattr__(cls, name, value):\n            # Substitut option names: --an-option-name for an_option_name\n            import re\n            name = re.sub(r'^__', \"\", re.sub(r'-', \"_\", name))\n            listvalue = []\n\n            # Ensure value is converted to a list type for GsyncListOptions\n            if isinstance(value, list):\n                if value:\n                    listvalue = [] + value\n                else:\n                    listvalue = [ None ]\n            else:\n                listvalue = [ value ]\n\n            type.__setattr__(GsyncListOptions, name, listvalue)\n\n    # Cleanup this module to prevent tinkering.\n    import sys\n    module = sys.modules[__name__]\n    del module.__dict__['GetGsyncOptionsType']\n\n    return GsyncOptionsType\n\n# Our singlton abstract proxy class.\nclass GsyncOptions(object):\n    __metaclass__ = GetGsyncOptionsType()\n</code></pre>\n", "abstract": "A metaclass is a class that tells how (some) other class should be created. This is a case where I saw metaclass as a solution to my problem:\nI had a really complicated problem, that probably could have been solved differently, but I chose to solve it using a metaclass.  Because of the complexity, it is one of the few modules I have written where the comments in the module surpass the amount of code that has been written.  Here it is..."}, {"id": 41338238, "score": 64, "vote": 0, "content": "<h2>The tl;dr version</h2>\n<p>The <code>type(obj)</code> function gets you the type of an object. </p>\n<p><strong>The <code>type()</code> of a class is its <em>metaclass</em>.</strong></p>\n<p>To use a metaclass:</p>\n<pre><code class=\"python\">class Foo(object):\n    __metaclass__ = MyMetaClass\n</code></pre>\n<p><code>type</code> is its own metaclass. The class of a class is a metaclass-- the body of a class is the arguments passed to the metaclass that is used to construct the class.</p>\n<p><a href=\"https://docs.python.org/3/reference/datamodel.html#metaclasses\" rel=\"noreferrer\">Here</a> you can read about how to use metaclasses to customize class construction.</p>\n", "abstract": "The type(obj) function gets you the type of an object.  The type() of a class is its metaclass. To use a metaclass: type is its own metaclass. The class of a class is a metaclass-- the body of a class is the arguments passed to the metaclass that is used to construct the class. Here you can read about how to use metaclasses to customize class construction."}, {"id": 38858285, "score": 59, "vote": 0, "content": "<p><code>type</code> is actually a <code>metaclass</code> -- a class that creates another classes.\nMost <code>metaclass</code> are the subclasses of <code>type</code>. The <code>metaclass</code> receives the <code>new</code> class as its first argument and provide access to class object with details as mentioned below:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class MetaClass(type):\n...     def __init__(cls, name, bases, attrs):\n...         print ('class name: %s' %name )\n...         print ('Defining class %s' %cls)\n...         print('Bases %s: ' %bases)\n...         print('Attributes')\n...         for (name, value) in attrs.items():\n...             print ('%s :%r' %(name, value))\n... \n\n&gt;&gt;&gt; class NewClass(object, metaclass=MetaClass):\n...    get_choch='dairy'\n... \nclass name: NewClass\nBases &lt;class 'object'&gt;: \nDefining class &lt;class 'NewClass'&gt;\nget_choch :'dairy'\n__module__ :'builtins'\n__qualname__ :'NewClass'\n</code></pre>\n<p><code>Note:</code></p>\n<p>Notice that the class was not instantiated at any time; the simple act of creating the class triggered execution of the <code>metaclass</code>.</p>\n", "abstract": "type is actually a metaclass -- a class that creates another classes.\nMost metaclass are the subclasses of type. The metaclass receives the new class as its first argument and provide access to class object with details as mentioned below: Note: Notice that the class was not instantiated at any time; the simple act of creating the class triggered execution of the metaclass."}, {"id": 45074712, "score": 43, "vote": 0, "content": "<p>Python classes are themselves objects - as in instance - of their meta-class. </p>\n<p>The default metaclass, which is applied when when you determine classes as:</p>\n<pre><code class=\"python\">class foo:\n    ...\n</code></pre>\n<p>meta class are used to apply some rule to an entire set of classes. For example, suppose you're building an ORM to access a database, and you want records from each table to be of a class mapped to that table (based on fields, business rules, etc..,), a possible use of metaclass is for instance, connection pool logic, which is share by all classes of record from all tables. Another use is logic to to support foreign keys, which involves multiple classes of records. </p>\n<p>when you define metaclass, you subclass type, and can overrided the following magic methods to insert your logic. </p>\n<pre><code class=\"python\">class somemeta(type):\n    __new__(mcs, name, bases, clsdict):\n      \"\"\"\n  mcs: is the base metaclass, in this case type.\n  name: name of the new class, as provided by the user.\n  bases: tuple of base classes \n  clsdict: a dictionary containing all methods and attributes defined on class\n\n  you must return a class object by invoking the __new__ constructor on the base metaclass. \n ie: \n    return type.__call__(mcs, name, bases, clsdict).\n\n  in the following case:\n\n  class foo(baseclass):\n        __metaclass__ = somemeta\n\n  an_attr = 12\n\n  def bar(self):\n      ...\n\n  @classmethod\n  def foo(cls):\n      ...\n\n      arguments would be : ( somemeta, \"foo\", (baseclass, baseofbase,..., object), {\"an_attr\":12, \"bar\": &lt;function&gt;, \"foo\": &lt;bound class method&gt;}\n\n      you can modify any of these values before passing on to type\n      \"\"\"\n      return type.__call__(mcs, name, bases, clsdict)\n\n\n    def __init__(self, name, bases, clsdict):\n      \"\"\" \n      called after type has been created. unlike in standard classes, __init__ method cannot modify the instance (cls) - and should be used for class validaton.\n      \"\"\"\n      pass\n\n\n    def __prepare__():\n        \"\"\"\n        returns a dict or something that can be used as a namespace.\n        the type will then attach methods and attributes from class definition to it.\n\n        call order :\n\n        somemeta.__new__ -&gt;  type.__new__ -&gt; type.__init__ -&gt; somemeta.__init__ \n        \"\"\"\n        return dict()\n\n    def mymethod(cls):\n        \"\"\" works like a classmethod, but for class objects. Also, my method will not be visible to instances of cls.\n        \"\"\"\n        pass\n</code></pre>\n<p>anyhow, those two are the most commonly used hooks. metaclassing is powerful, and above is nowhere near and exhaustive list of uses for metaclassing. </p>\n", "abstract": "Python classes are themselves objects - as in instance - of their meta-class.  The default metaclass, which is applied when when you determine classes as: meta class are used to apply some rule to an entire set of classes. For example, suppose you're building an ORM to access a database, and you want records from each table to be of a class mapped to that table (based on fields, business rules, etc..,), a possible use of metaclass is for instance, connection pool logic, which is share by all classes of record from all tables. Another use is logic to to support foreign keys, which involves multiple classes of records.  when you define metaclass, you subclass type, and can overrided the following magic methods to insert your logic.  anyhow, those two are the most commonly used hooks. metaclassing is powerful, and above is nowhere near and exhaustive list of uses for metaclassing. "}, {"id": 48222963, "score": 42, "vote": 0, "content": "<p>The type() function can return the type of an object or create a new type, </p>\n<p>for example, we can create a Hi class with the type() function and do not  need to use this way with class Hi(object):</p>\n<pre><code class=\"python\">def func(self, name='mike'):\n    print('Hi, %s.' % name)\n\nHi = type('Hi', (object,), dict(hi=func))\nh = Hi()\nh.hi()\nHi, mike.\n\ntype(Hi)\ntype\n\ntype(h)\n__main__.Hi\n</code></pre>\n<p>In addition to using type() to create classes dynamically, you can control creation behavior of class and use metaclass.</p>\n<p>According to the Python object model, the class is the object, so the class must be an instance of another certain class.\nBy default, a Python class is instance of the type class. That is, type is metaclass of most of the built-in classes and metaclass of user-defined classes.</p>\n<pre><code class=\"python\">class ListMetaclass(type):\n    def __new__(cls, name, bases, attrs):\n        attrs['add'] = lambda self, value: self.append(value)\n        return type.__new__(cls, name, bases, attrs)\n\nclass CustomList(list, metaclass=ListMetaclass):\n    pass\n\nlst = CustomList()\nlst.add('custom_list_1')\nlst.add('custom_list_2')\n\nlst\n['custom_list_1', 'custom_list_2']\n</code></pre>\n<p>Magic will take effect when we passed keyword arguments in metaclass, it indicates the Python interpreter to create the CustomList through ListMetaclass. <strong>new</strong> (), at this point, we can modify the class definition, for example, and add a new method and then return the revised definition.</p>\n", "abstract": "The type() function can return the type of an object or create a new type,  for example, we can create a Hi class with the type() function and do not  need to use this way with class Hi(object): In addition to using type() to create classes dynamically, you can control creation behavior of class and use metaclass. According to the Python object model, the class is the object, so the class must be an instance of another certain class.\nBy default, a Python class is instance of the type class. That is, type is metaclass of most of the built-in classes and metaclass of user-defined classes. Magic will take effect when we passed keyword arguments in metaclass, it indicates the Python interpreter to create the CustomList through ListMetaclass. new (), at this point, we can modify the class definition, for example, and add a new method and then return the revised definition."}, {"id": 52344780, "score": 30, "vote": 0, "content": "<p>In addition to the published answers I can say that a <code>metaclass</code> defines the behaviour for a class. So, you can explicitly set your metaclass. Whenever Python gets a keyword <code>class</code> then it starts searching for the <code>metaclass</code>. If it's not found \u2013 the default metaclass type is used to create the class's object. Using the <code>__metaclass__</code> attribute, you can set <code>metaclass</code> of your class:</p>\n<pre><code class=\"python\">class MyClass:\n   __metaclass__ = type\n   # write here other method\n   # write here one more method\n\nprint(MyClass.__metaclass__)\n</code></pre>\n<p>It'll produce the output like this:</p>\n<pre><code class=\"python\">class 'type'\n</code></pre>\n<p>And, of course, you can create your own <code>metaclass</code> to define the behaviour of any class that are created using your class.</p>\n<p>For doing that, your default <code>metaclass</code> type class must be inherited as this is the main <code>metaclass</code>:</p>\n<pre><code class=\"python\">class MyMetaClass(type):\n   __metaclass__ = type\n   # you can write here any behaviour you want\n\nclass MyTestClass:\n   __metaclass__ = MyMetaClass\n\nObj = MyTestClass()\nprint(Obj.__metaclass__)\nprint(MyMetaClass.__metaclass__)\n</code></pre>\n<p>The output will be:</p>\n<pre><code class=\"python\">class '__main__.MyMetaClass'\nclass 'type'\n</code></pre>\n", "abstract": "In addition to the published answers I can say that a metaclass defines the behaviour for a class. So, you can explicitly set your metaclass. Whenever Python gets a keyword class then it starts searching for the metaclass. If it's not found \u2013 the default metaclass type is used to create the class's object. Using the __metaclass__ attribute, you can set metaclass of your class: It'll produce the output like this: And, of course, you can create your own metaclass to define the behaviour of any class that are created using your class. For doing that, your default metaclass type class must be inherited as this is the main metaclass: The output will be:"}, {"id": 60504738, "score": 22, "vote": 0, "content": "<p>Note that in python 3.6 a new dunder method <code>__init_subclass__(cls, **kwargs)</code> was introduced to replace a lot of common use cases for metaclasses. Is is called when a subclass of the defining class is created. See <a href=\"https://docs.python.org/3.6/reference/datamodel.html\" rel=\"noreferrer\">python docs</a>.</p>\n", "abstract": "Note that in python 3.6 a new dunder method __init_subclass__(cls, **kwargs) was introduced to replace a lot of common use cases for metaclasses. Is is called when a subclass of the defining class is created. See python docs."}, {"id": 59424178, "score": 20, "vote": 0, "content": "<p>Here's another example of what it can be used for:</p>\n<ul>\n<li>You can use the <code>metaclass</code> to change the function of its instance (the class).</li>\n</ul>\n<pre><code class=\"python\">class MetaMemberControl(type):\n    __slots__ = ()\n\n    @classmethod\n    def __prepare__(mcs, f_cls_name, f_cls_parents,  # f_cls means: future class\n                    meta_args=None, meta_options=None):  # meta_args and meta_options is not necessarily needed, just so you know.\n        f_cls_attr = dict()\n        if not \"do something or if you want to define your cool stuff of dict...\":\n            return dict(make_your_special_dict=None)\n        else:\n            return f_cls_attr\n\n    def __new__(mcs, f_cls_name, f_cls_parents, f_cls_attr,\n                meta_args=None, meta_options=None):\n\n        original_getattr = f_cls_attr.get('__getattribute__')\n        original_setattr = f_cls_attr.get('__setattr__')\n\n        def init_getattr(self, item):\n            if not item.startswith('_'):  # you can set break points at here\n                alias_name = '_' + item\n                if alias_name in f_cls_attr['__slots__']:\n                    item = alias_name\n            if original_getattr is not None:\n                return original_getattr(self, item)\n            else:\n                return super(eval(f_cls_name), self).__getattribute__(item)\n\n        def init_setattr(self, key, value):\n            if not key.startswith('_') and ('_' + key) in f_cls_attr['__slots__']:\n                raise AttributeError(f\"you can't modify private members:_{key}\")\n            if original_setattr is not None:\n                original_setattr(self, key, value)\n            else:\n                super(eval(f_cls_name), self).__setattr__(key, value)\n\n        f_cls_attr['__getattribute__'] = init_getattr\n        f_cls_attr['__setattr__'] = init_setattr\n\n        cls = super().__new__(mcs, f_cls_name, f_cls_parents, f_cls_attr)\n        return cls\n\n\nclass Human(metaclass=MetaMemberControl):\n    __slots__ = ('_age', '_name')\n\n    def __init__(self, name, age):\n        self._name = name\n        self._age = age\n\n    def __getattribute__(self, item):\n        \"\"\"\n        is just for IDE recognize.\n        \"\"\"\n        return super().__getattribute__(item)\n\n    \"\"\" with MetaMemberControl then you don't have to write as following\n    @property\n    def name(self):\n        return self._name\n\n    @property\n    def age(self):\n        return self._age\n    \"\"\"\n\n\ndef test_demo():\n    human = Human('Carson', 27)\n    # human.age = 18  # you can't modify private members:_age  &lt;-- this is defined by yourself.\n    # human.k = 18  # 'Human' object has no attribute 'k'  &lt;-- system error.\n    age1 = human._age  # It's OK, although the IDE will show some warnings. (Access to a protected member _age of a class)\n\n    age2 = human.age  # It's OK! see below:\n    \"\"\"\n    if you do not define `__getattribute__` at the class of Human,\n    the IDE will show you: Unresolved attribute reference 'age' for class 'Human'\n    but it's ok on running since the MetaMemberControl will help you.\n    \"\"\"\n\n\nif __name__ == '__main__':\n    test_demo()\n\n</code></pre>\n<p>The <code>metaclass</code> is powerful, there are many things (such as monkey magic) you can do with it, but be careful this may only be known to you.</p>\n", "abstract": "Here's another example of what it can be used for: The metaclass is powerful, there are many things (such as monkey magic) you can do with it, but be careful this may only be known to you."}, {"id": 56945952, "score": 19, "vote": 0, "content": "<p>In object-oriented programming, a metaclass is a class whose instances are classes. Just as an ordinary class defines the behavior of certain objects, a metaclass defines the behavior of certain class and their instances\nThe term metaclass simply means something used to create classes. In other words, it is the class of a class. The metaclass is used to create the class so like the object being an instance of a class, a class is an instance of a metaclass. In python classes are also considered objects.</p>\n", "abstract": "In object-oriented programming, a metaclass is a class whose instances are classes. Just as an ordinary class defines the behavior of certain objects, a metaclass defines the behavior of certain class and their instances\nThe term metaclass simply means something used to create classes. In other words, it is the class of a class. The metaclass is used to create the class so like the object being an instance of a class, a class is an instance of a metaclass. In python classes are also considered objects."}, {"id": 68417609, "score": 19, "vote": 0, "content": "<p><strong>The top answer is correct</strong>.</p>\n<p>But readers may be coming here searching answers about similarly named inner classes. They are present in popular libraries, such as <code>Django</code> and <code>WTForms</code>.</p>\n<p>As DavidW points out in the comments beneath this answer, <strong>these are <em>library-specific</em> features and are not to be confused with the advanced, unrelated <em>Python language</em> feature with a similar name</strong>.</p>\n<p>Rather, these are namespaces within classes' dicts. They are constructed using inner classes for sake of readability.</p>\n<p>In this example special field, <code>abstract</code> is visibly separate from fields of Author model.</p>\n<pre><code class=\"python\">from django.db import models\n\nclass Author(models.Model):\n    name = models.CharField(max_length=50)\n    email = models.EmailField()\n\n    class Meta:\n        abstract = True\n</code></pre>\n<p>Another example is from the documentation for <code>WTForms</code>:</p>\n<pre><code class=\"python\">from wtforms.form import Form\nfrom wtforms.csrf.session import SessionCSRF\nfrom wtforms.fields import StringField\n\nclass MyBaseForm(Form):\n    class Meta:\n        csrf = True\n        csrf_class = SessionCSRF\n\n    name = StringField(\"name\")\n</code></pre>\n<p>This syntax does not get special treatment in the python programming language. <code>Meta</code> is not a keyword here, and does not trigger metaclass behavior. Rather, third-party library code in packages like <code>Django</code> and <code>WTForms</code> reads this property in the constructors of certain classes, and elsewhere.</p>\n<p>The presence of these declarations modifies the behavior of the classes that have these declarations. For example, <code>WTForms</code> reads <code>self.Meta.csrf</code> to determine if the form needs a <code>csrf</code> field.</p>\n", "abstract": "The top answer is correct. But readers may be coming here searching answers about similarly named inner classes. They are present in popular libraries, such as Django and WTForms. As DavidW points out in the comments beneath this answer, these are library-specific features and are not to be confused with the advanced, unrelated Python language feature with a similar name. Rather, these are namespaces within classes' dicts. They are constructed using inner classes for sake of readability. In this example special field, abstract is visibly separate from fields of Author model. Another example is from the documentation for WTForms: This syntax does not get special treatment in the python programming language. Meta is not a keyword here, and does not trigger metaclass behavior. Rather, third-party library code in packages like Django and WTForms reads this property in the constructors of certain classes, and elsewhere. The presence of these declarations modifies the behavior of the classes that have these declarations. For example, WTForms reads self.Meta.csrf to determine if the form needs a csrf field."}, {"id": 59818321, "score": 18, "vote": 0, "content": "<p>A class, in Python, is an object, and just like any other object, it is an instance of \"something\". This \"something\" is what is termed as a Metaclass. This metaclass is a special type of class that creates other class's objects. Hence, metaclass is responsible for making new classes. This allows the programmer to customize the way classes are generated.</p>\n<p>To create a metaclass, overriding of <strong>new</strong>() and <strong>init</strong>() methods is usually done. <strong>new</strong>() can be overridden to change the way objects are created, while <strong>init</strong>() can be overridden to change the way of initializing the object. Metaclass can be created by a number of ways. One of the ways is to use type() function. type() function, when called with 3 parameters, creates a metaclass. The parameters are :-</p>\n<ol>\n<li>Class Name</li>\n<li>Tuple having base classes inherited by class</li>\n<li>A dictionary having all class methods and class variables</li>\n</ol>\n<p>Another way of creating a metaclass comprises of 'metaclass' keyword. Define the metaclass as a simple class. In the parameters of inherited class, pass metaclass=metaclass_name</p>\n<p>Metaclass can be specifically used in the following situations :-</p>\n<ol>\n<li>when a particular effect has to be applied to all the subclasses</li>\n<li>Automatic change of class (on creation) is required</li>\n<li>By API developers</li>\n</ol>\n", "abstract": "A class, in Python, is an object, and just like any other object, it is an instance of \"something\". This \"something\" is what is termed as a Metaclass. This metaclass is a special type of class that creates other class's objects. Hence, metaclass is responsible for making new classes. This allows the programmer to customize the way classes are generated. To create a metaclass, overriding of new() and init() methods is usually done. new() can be overridden to change the way objects are created, while init() can be overridden to change the way of initializing the object. Metaclass can be created by a number of ways. One of the ways is to use type() function. type() function, when called with 3 parameters, creates a metaclass. The parameters are :- Another way of creating a metaclass comprises of 'metaclass' keyword. Define the metaclass as a simple class. In the parameters of inherited class, pass metaclass=metaclass_name Metaclass can be specifically used in the following situations :-"}, {"id": 68354618, "score": 12, "vote": 0, "content": "<p>I saw an interesting use case for metaclasses in a package called <code>classutilities</code>. It checks if all class variables are in upper case format (it is convenient to have unified logic for configuration classes), and checks if there are no instance level methods in class.\nAnother interesting example for metaclases was deactivation of unittests based on complex conditions (checking values of multiple environmental variables).</p>\n", "abstract": "I saw an interesting use case for metaclasses in a package called classutilities. It checks if all class variables are in upper case format (it is convenient to have unified logic for configuration classes), and checks if there are no instance level methods in class.\nAnother interesting example for metaclases was deactivation of unittests based on complex conditions (checking values of multiple environmental variables)."}, {"id": 67201732, "score": 10, "vote": 0, "content": "<p>In Python, a metaclass is a subclass of a subclass that determines how a subclass behaves. A class is an instance of another metaclass. In Python, a class specifies how the class's instance will behave.</p>\n<p>Since metaclasses are in charge of class generation, you can\u00a0write your own custom metaclasses to change how classes are created by performing additional actions or injecting code. Custom metaclasses aren't always important, but they can be.</p>\n", "abstract": "In Python, a metaclass is a subclass of a subclass that determines how a subclass behaves. A class is an instance of another metaclass. In Python, a class specifies how the class's instance will behave. Since metaclasses are in charge of class generation, you can\u00a0write your own custom metaclasses to change how classes are created by performing additional actions or injecting code. Custom metaclasses aren't always important, but they can be."}, {"id": 69426577, "score": 3, "vote": 0, "content": "<p>look this:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">Python 3.10.0rc2 (tags/v3.10.0rc2:839d789, Sep  7 2021, 18:51:45) [MSC v.1929 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; class Object:\n...     pass\n... \n&gt;&gt;&gt; class Meta(type):\n...     test = 'Worked!!!'\n...     def __repr__(self):\n...             return 'This is \"Meta\" metaclass'\n... \n&gt;&gt;&gt; class ObjectWithMetaClass(metaclass=Meta):\n...     pass\n... \n&gt;&gt;&gt; Object or type(Object())\n&lt;class '__main__.Object'&gt;\n&gt;&gt;&gt; ObjectWithMetaClass or type(ObjectWithMetaClass())\nThis is \"Meta\" metaclass\n&gt;&gt;&gt; Object.test\nAttributeError: ...\n&gt;&gt;&gt; ObjectWithMetaClass.test\n'Worked!!!'\n&gt;&gt;&gt; type(Object)\n&lt;class 'type'&gt;\n&gt;&gt;&gt; type(ObjectWithMetaClass)\n&lt;class '__main__.Meta'&gt;\n&gt;&gt;&gt; type(type(ObjectWithMetaClass))\n&lt;class 'type'&gt;\n&gt;&gt;&gt; Object.__bases__\n(&lt;class 'object'&gt;,)\n&gt;&gt;&gt; ObjectWithMetaClass.__bases__\n(&lt;class 'object'&gt;,)\n&gt;&gt;&gt; type(ObjectWithMetaClass).__bases__\n(&lt;class 'type'&gt;,)\n&gt;&gt;&gt; Object.__mro__\n(&lt;class '__main__.Object'&gt;, &lt;class 'object'&gt;)\n&gt;&gt;&gt; ObjectWithMetaClass.__mro__\n(This is \"Meta\" metaclass, &lt;class 'object'&gt;)\n&gt;&gt;&gt; \n</code></pre>\n<p>In other words, when an object was not created (type of object), we looking MetaClass.</p>\n", "abstract": "look this: In other words, when an object was not created (type of object), we looking MetaClass."}, {"id": 73205479, "score": -2, "vote": 0, "content": "<p>Meta is a Greek word which means 'after' or 'beyond'.\nGenerally meta referring to self.\nMeta represents the additional information.\nMeta class is a helper class to explicitly tell about any additional information that has to be mentioned or any additional thing that has to be added about to the super or parent class.\nIn python, when you define a class, it automatically takes it as a type=metaclass and this class functionality (behavior-methods, properties-self information) is applicable to other child class when created.</p>\n<p>Here is a <a href=\"https://www.pythontutorial.net/python-oop/python-metaclass/\" rel=\"nofollow noreferrer\">detailed explanation</a> of what is a meta class and how it works, with coding examples.</p>\n", "abstract": "Meta is a Greek word which means 'after' or 'beyond'.\nGenerally meta referring to self.\nMeta represents the additional information.\nMeta class is a helper class to explicitly tell about any additional information that has to be mentioned or any additional thing that has to be added about to the super or parent class.\nIn python, when you define a class, it automatically takes it as a type=metaclass and this class functionality (behavior-methods, properties-self information) is applicable to other child class when created. Here is a detailed explanation of what is a meta class and how it works, with coding examples."}]}, {"link": "https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-without-exceptions", "question": {"id": "82831", "title": "How do I check whether a file exists without exceptions?", "content": "<p>How do I check whether a file exists or not, without using the <a href=\"https://docs.python.org/3.6/reference/compound_stmts.html#try\" rel=\"noreferrer\"><code>try</code></a> statement?</p>\n", "abstract": "How do I check whether a file exists or not, without using the try statement?"}, "answers": [{"id": 82852, "score": 6185, "vote": 0, "content": "<p>If the reason you're checking is so you can do something like <code>if file_exists: open_it()</code>, it's safer to use a <code>try</code> around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.</p>\n<p>If you're not planning to open the file immediately, you can use <a href=\"https://docs.python.org/library/os.path.html#os.path.isfile\" rel=\"noreferrer\"><code>os.path.isfile</code></a></p>\n<blockquote>\n<p>Return <code>True</code> if path is an existing regular file. This follows symbolic links, so both <a href=\"https://docs.python.org/library/os.path.html#os.path.islink\" rel=\"noreferrer\">islink()</a> and <a href=\"https://docs.python.org/library/os.path.html#os.path.isfile\" rel=\"noreferrer\">isfile()</a> can be true for the same path.</p>\n</blockquote>\n<pre><code class=\"python\">import os.path\nos.path.isfile(fname) \n</code></pre>\n<p>if you need to be sure it's a file.</p>\n<p>Starting with Python 3.4, the <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file\" rel=\"noreferrer\"><code>pathlib</code> module</a> offers an object-oriented approach (backported to <code>pathlib2</code> in Python 2.7):</p>\n<pre><code class=\"python\">from pathlib import Path\n\nmy_file = Path(\"/path/to/file\")\nif my_file.is_file():\n    # file exists\n</code></pre>\n<p>To check a directory, do:</p>\n<pre><code class=\"python\">if my_file.is_dir():\n    # directory exists\n</code></pre>\n<p>To check whether a <code>Path</code> object exists independently of whether is it a file or directory, use <code>exists()</code>:</p>\n<pre><code class=\"python\">if my_file.exists():\n    # path exists\n</code></pre>\n<p>You can also use <code>resolve(strict=True)</code> in a <code>try</code> block:</p>\n<pre><code class=\"python\">try:\n    my_abs_path = my_file.resolve(strict=True)\nexcept FileNotFoundError:\n    # doesn't exist\nelse:\n    # exists\n</code></pre>\n", "abstract": "If the reason you're checking is so you can do something like if file_exists: open_it(), it's safer to use a try around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it. If you're not planning to open the file immediately, you can use os.path.isfile Return True if path is an existing regular file. This follows symbolic links, so both islink() and isfile() can be true for the same path. if you need to be sure it's a file. Starting with Python 3.4, the pathlib module offers an object-oriented approach (backported to pathlib2 in Python 2.7): To check a directory, do: To check whether a Path object exists independently of whether is it a file or directory, use exists(): You can also use resolve(strict=True) in a try block:"}, {"id": 82846, "score": 2502, "vote": 0, "content": "<p>Use <a href=\"https://docs.python.org/3/library/os.path.html#os.path.exists\" rel=\"nofollow noreferrer\"><code>os.path.exists</code></a> to check both files and directories:</p>\n<pre><code class=\"python\">import os.path\nos.path.exists(file_path)\n</code></pre>\n<p>Use <a href=\"https://docs.python.org/3/library/os.path.html#os.path.isfile\" rel=\"nofollow noreferrer\"><code>os.path.isfile</code></a> to check only files (note: follows <a href=\"https://en.wikipedia.org/wiki/Symbolic_link\" rel=\"nofollow noreferrer\">symbolic links</a>):</p>\n<pre><code class=\"python\">os.path.isfile(file_path)\n</code></pre>\n", "abstract": "Use os.path.exists to check both files and directories: Use os.path.isfile to check only files (note: follows symbolic links):"}, {"id": 84173, "score": 1173, "vote": 0, "content": "<p>Unlike <a href=\"https://docs.python.org/library/os.path.html#os.path.isfile\" rel=\"nofollow noreferrer\"><code>isfile()</code></a>, <a href=\"https://docs.python.org/library/os.path.html#os.path.exists\" rel=\"nofollow noreferrer\"><code>exists()</code></a> will return <code>True</code> for directories. So depending on if you want only plain files or also directories, you'll use <code>isfile()</code> or <code>exists()</code>. Here is some simple <a href=\"https://en.wikipedia.org/wiki/Read-eval-print_loop\" rel=\"nofollow noreferrer\">REPL</a> output:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; os.path.isfile(\"/etc/password.txt\")\nTrue\n&gt;&gt;&gt; os.path.isfile(\"/etc\")\nFalse\n&gt;&gt;&gt; os.path.isfile(\"/does/not/exist\")\nFalse\n&gt;&gt;&gt; os.path.exists(\"/etc/password.txt\")\nTrue\n&gt;&gt;&gt; os.path.exists(\"/etc\")\nTrue\n&gt;&gt;&gt; os.path.exists(\"/does/not/exist\")\nFalse\n</code></pre>\n", "abstract": "Unlike isfile(), exists() will return True for directories. So depending on if you want only plain files or also directories, you'll use isfile() or exists(). Here is some simple REPL output:"}, {"id": 82836, "score": 857, "vote": 0, "content": "<pre><code class=\"python\">import os\n\nif os.path.isfile(filepath):\n   print(\"File exists\")\n</code></pre>\n", "abstract": ""}, {"id": 8876254, "score": 411, "vote": 0, "content": "<p>Use <a href=\"https://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.isfile\" rel=\"noreferrer\"><code>os.path.isfile()</code></a> with <a href=\"https://docs.python.org/3.3/library/os.html?highlight=os.access#os.access\" rel=\"noreferrer\"><code>os.access()</code></a>:</p>\n<pre><code class=\"python\">import os\n\nPATH = './file.txt'\nif os.path.isfile(PATH) and os.access(PATH, os.R_OK):\n    print(\"File exists and is readable\")\nelse:\n    print(\"Either the file is missing or not readable\")\n</code></pre>\n", "abstract": "Use os.path.isfile() with os.access():"}, {"id": 82841, "score": 347, "vote": 0, "content": "<pre><code class=\"python\">import os\nos.path.exists(path) # Returns whether the path (directory or file) exists or not\nos.path.isfile(path) # Returns whether the file exists or not\n</code></pre>\n", "abstract": ""}, {"id": 44661513, "score": 279, "vote": 0, "content": "<p>Although almost every possible way has been listed in (at least one of) the existing answers (e.g. <em>Python 3.4</em> specific stuff was added), I'll try to group everything together.</p>\n<p><strong>Note</strong>: every piece of <em>Python</em> standard library code that I'm going to post, belongs to version <strong>3.5.3</strong>.</p>\n<p><strong>Problem statement</strong>:</p>\n<ol>\n<li>Check file (<em>arguable</em>: also folder (\"special\" file) ?) existence</li>\n<li>Don't use <em><strong>try</strong></em> / <em><strong>except</strong></em> / <em><strong>else</strong></em> / <em><strong>finally</strong></em> blocks</li>\n</ol>\n<p><strong>Possible solutions</strong>:</p>\n<ol>\n<li><p><a href=\"https://docs.python.org/3/library/os.path.html#os.path.exists\" rel=\"nofollow noreferrer\">[Python 3]: os.path.<strong>exists</strong>(<em>path</em>)</a> (also check other function family members like <code>os.path.isfile</code>, <code>os.path.isdir</code>, <code>os.path.lexists</code> for slightly different behaviors)</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"> os.path.exists(path)\n</code></pre>\n<blockquote>\n<p>Return <code>True</code> if <em>path</em> refers to an existing path or an open file descriptor. Returns <code>False</code> for broken symbolic links. On some platforms, this function may return <code>False</code> if permission is not granted to execute <a href=\"https://docs.python.org/3/library/os.html#os.stat\" rel=\"nofollow noreferrer\">os.stat()</a> on the requested file, even if the <em>path</em> physically exists.</p>\n</blockquote>\n<p>All good, but if following the import tree:</p>\n<ul>\n<li><code>os.path</code> - <em>posixpath.py</em> (<em>ntpath.py</em>)\n<ul>\n<li><p><em>genericpath.py</em>, line <em>~#20+</em></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">  def exists(path):\n      \"\"\"Test whether a path exists.  Returns False for broken symbolic links\"\"\"\n      try:\n          st = os.stat(path)\n      except os.error:\n          return False\n      return True\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p>it's just a <em><strong>try</strong></em> / <em><strong>except</strong></em> block around <a href=\"https://docs.python.org/3/library/os.html#os.stat\" rel=\"nofollow noreferrer\">[Python 3]: os.<strong>stat</strong>(<em>path, *, dir_fd=None, follow_symlinks=True</em>)</a>. So, your code is <em><strong>try</strong></em> / <em><strong>except</strong></em> free, but lower in the framestack there's (at least) <strong>one</strong> such block. This also applies to other functions (<strong>including</strong> <code>os.path.isfile</code>).</p>\n<p>1.1. <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file\" rel=\"nofollow noreferrer\">[Python 3]: Path.<strong>is_file</strong>()</a></p>\n<ul>\n<li><p>It's a fancier (and more <a href=\"https://en.wiktionary.org/wiki/Pythonic#Adjective\" rel=\"nofollow noreferrer\">Pythonic</a>) way of handling paths, <strong>but</strong></p>\n</li>\n<li><p>Under the hood, it does <strong>exactly</strong> the same thing (<em>pathlib.py</em>, line <em>~#1330</em>):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">  def is_file(self):\n      \"\"\"\n      Whether this path is a regular file (also True for symlinks pointing\n      to regular files).\n      \"\"\"\n      try:\n          return S_ISREG(self.stat().st_mode)\n      except OSError as e:\n          if e.errno not in (ENOENT, ENOTDIR):\n              raise\n          # Path doesn't exist or is a broken symlink\n          # (see https://bitbucket.org/pitrou/pathlib/issue/12/)\n          return False\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://docs.python.org/3/reference/datamodel.html#context-managers\" rel=\"nofollow noreferrer\">[Python 3]: With Statement Context Managers</a>. Either:</p>\n<ul>\n<li><p>Create one:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">  class Swallow:  # Dummy example\n      swallowed_exceptions = (FileNotFoundError,)\n\n      def __enter__(self):\n          print(\"Entering...\")\n\n      def __exit__(self, exc_type, exc_value, exc_traceback):\n          print(\"Exiting:\", exc_type, exc_value, exc_traceback)\n          return exc_type in Swallow.swallowed_exceptions  # only swallow FileNotFoundError (not e.g. TypeError - if the user passes a wrong argument like None or float or ...)\n</code></pre>\n<ul>\n<li><p>And its usage - I'll replicate the <code>os.path.isfile</code> behavior (note that this is just for demonstrating purposes, do <strong>not</strong> attempt to write such code for <em>production</em>):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">  import os\n  import stat\n\n\n  def isfile_seaman(path):  # Dummy func\n      result = False\n      with Swallow():\n          result = stat.S_ISREG(os.stat(path).st_mode)\n      return result\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Use <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.suppress\" rel=\"nofollow noreferrer\">[Python 3]: contextlib.<strong>suppress</strong>(<em>*exceptions</em>)</a> - which was <strong>specifically</strong> designed for selectively suppressing exceptions</p>\n</li>\n</ul>\n<p><br/>But, they seem to be wrappers over <em><strong>try</strong></em> / <em><strong>except</strong></em> / <em><strong>else</strong></em> / <em><strong>finally</strong></em> blocks, as <a href=\"https://docs.python.org/3/reference/compound_stmts.html#with\" rel=\"nofollow noreferrer\">[Python 3]: The <em>with</em> statement</a> states:</p>\n<blockquote>\n<p>This allows common <a href=\"https://docs.python.org/3/reference/compound_stmts.html#try\" rel=\"nofollow noreferrer\">try</a>...<a href=\"https://docs.python.org/3/reference/compound_stmts.html#except\" rel=\"nofollow noreferrer\">except</a>...<a href=\"https://docs.python.org/3/reference/compound_stmts.html#finally\" rel=\"nofollow noreferrer\">finally</a> usage patterns to be encapsulated for convenient reuse.</p>\n</blockquote>\n</li>\n<li><p>Filesystem traversal functions (and search the results for matching item(s))</p>\n<ul>\n<li><p><a href=\"https://docs.python.org/3/library/os.html#os.listdir\" rel=\"nofollow noreferrer\">[Python 3]: os.<strong>listdir</strong>(<em>path='.'</em>)</a> (or <a href=\"https://docs.python.org/3/library/os.html#os.scandir\" rel=\"nofollow noreferrer\">[Python 3]: os.<strong>scandir</strong>(<em>path='.'</em>)</a> on <em>Python v<strong>3.5</strong></em>+, backport: <a href=\"https://pypi.org/project/scandir\" rel=\"nofollow noreferrer\">[PyPI]: scandir</a>)</p>\n<ul>\n<li><p>Under the hood, both use:</p>\n<ul>\n<li><em>Unix-like</em>: <a href=\"http://man7.org/linux/man-pages/man3/opendir.3.html\" rel=\"nofollow noreferrer\">[man7]: OPENDIR(3)</a> / <a href=\"http://man7.org/linux/man-pages/man3/readdir.3.html\" rel=\"nofollow noreferrer\">[man7]: READDIR(3)</a> / <a href=\"http://man7.org/linux/man-pages/man3/closedir.3.html\" rel=\"nofollow noreferrer\">[man7]: CLOSEDIR(3)</a></li>\n<li><em>Windows</em>: <a href=\"https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew\" rel=\"nofollow noreferrer\">[MS.Docs]: FindFirstFileW function</a> / <a href=\"https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew\" rel=\"nofollow noreferrer\">[MS.Docs]: FindNextFileW function</a> / <a href=\"https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose\" rel=\"nofollow noreferrer\">[MS.Docs]: FindClose function</a></li>\n</ul>\n<p>via <a href=\"https://github.com/python/cpython/blob/master/Modules/posixmodule.c\" rel=\"nofollow noreferrer\">[GitHub]: Python/CPython - (master) cpython/Modules/posixmodule.c</a></p>\n</li>\n</ul>\n<blockquote>\n<p>Using <a href=\"https://docs.python.org/3/library/os.html#os.scandir\" rel=\"nofollow noreferrer\">scandir()</a> instead of <a href=\"https://docs.python.org/3/library/os.html#os.listdir\" rel=\"nofollow noreferrer\">listdir()</a> can significantly increase the performance of code that also needs file type or file attribute information, because <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry\" rel=\"nofollow noreferrer\">os.DirEntry</a> objects expose this information if the operating system provides it when scanning a directory. All <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry\" rel=\"nofollow noreferrer\">os.DirEntry</a> methods may perform a system call, but <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry.is_dir\" rel=\"nofollow noreferrer\">is_dir()</a> and <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry.is_file\" rel=\"nofollow noreferrer\">is_file()</a> usually only require a system call for symbolic links; <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry.stat\" rel=\"nofollow noreferrer\">os.DirEntry.stat()</a> always requires a system call on Unix, but only requires one for symbolic links on Windows.</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/os.html#os.walk\" rel=\"nofollow noreferrer\">[Python 3]: os.<strong>walk</strong>(<em>top, topdown=True, onerror=None, followlinks=False</em>)</a></p>\n<ul>\n<li>It uses <code>os.listdir</code> (<code>os.scandir</code> when available)</li>\n</ul>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/glob.html#glob.iglob\" rel=\"nofollow noreferrer\">[Python 3]: glob.<strong>iglob</strong>(<em>pathname, *, recursive=False</em>)</a> (or its predecessor: <code>glob.glob</code>)</p>\n<ul>\n<li>Doesn't seem a traversing function <em>per se</em> (at least in some cases), but it still uses <code>os.listdir</code></li>\n</ul>\n</li>\n</ul>\n<p><br/>Since these iterate over folders, (in most of the cases) they are inefficient for our problem (there are exceptions, like non wildcarded <em>glob</em>bing - as @ShadowRanger pointed out), so I'm not going to insist on them. Not to mention that in some cases, filename processing might be required.</p>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/os.html#os.access\" rel=\"nofollow noreferrer\">[Python 3]: os.<strong>access</strong>(<em>path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True</em>)</a> whose behavior is close to <code>os.path.exists</code> (actually it's wider, mainly because of the 2<sup>nd</sup> argument)</p>\n<ul>\n<li><strong>user permissions</strong> might restrict the file \"visibility\" as the doc states:\n<blockquote>\n<p>...test if the invoking user has the specified access to <em>path</em>. <em>mode</em> should be <a href=\"https://docs.python.org/3/library/os.html#os.F_OK\" rel=\"nofollow noreferrer\">F_OK</a> to test the existence of path...</p>\n</blockquote>\n</li>\n</ul>\n<p><code>os.access(\"/tmp\", os.F_OK)</code></p>\n<p>Since I also work in <em>C</em>, I use this method as well because under the hood, it calls <strong>native <em>API</em>s</strong> (again, via <em>\"${PYTHON_SRC_DIR}/Modules/posixmodule.c\"</em>), but it also opens a gate for possible <strong>user errors</strong>, and it's not as Pythonic as other variants. So, as @AaronHall rightly pointed out, don't use it unless you know what you're doing:</p>\n<ul>\n<li><em>Unix-like</em>: <a href=\"http://man7.org/linux/man-pages/man2/access.2.html\" rel=\"nofollow noreferrer\">[man7]: ACCESS(2)</a> (!!! pay attention to the note about the <strong>security hole</strong> its usage might introduce !!!)</li>\n<li><em>Windows</em>: <a href=\"https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-getfileattributesw\" rel=\"nofollow noreferrer\">[MS.Docs]: GetFileAttributesW function</a></li>\n</ul>\n<p><strong>Note</strong>: calling native <em>API</em>s is also possible via <a href=\"https://docs.python.org/3/library/ctypes.html#module-ctypes\" rel=\"nofollow noreferrer\">[Python 3]: <em>ctypes</em> - A foreign function library for Python</a>, but in most cases it's more complicated.</p>\n<p>(<em><strong>Windows</strong></em>-specific): Since <em>vcruntime*</em> (<em>msvcr*</em>) <em>.dll</em> exports a <a href=\"https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=vs-2015\" rel=\"nofollow noreferrer\">[MS.Docs]: _access, _waccess</a> function family as well, here's an example:</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">Python 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32\n</code></pre>\n</blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"> Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n</code></pre>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import os, ctypes\n&gt;&gt;&gt; ctypes.CDLL(\"msvcrt\")._waccess(u\"C:\\\\Windows\\\\System32\\\\cmd.exe\", os.F_OK)\n</code></pre>\n</blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"> 0\n</code></pre>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; ctypes.CDLL(\"msvcrt\")._waccess(u\"C:\\\\Windows\\\\System32\\\\cmd.exe.notexist\", os.F_OK)\n</code></pre>\n</blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"> -1\n</code></pre>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li>Although it's not a good practice, I'm using <code>os.F_OK</code> in the call, but that's just for clarity (its value is <strong>0</strong>)</li>\n<li>I'm using <em>_waccess</em> so that the same code works on <em>Python3</em> and <em>Python2</em> (in spite of <em><a href=\"https://en.wikipedia.org/wiki/Unicode\" rel=\"nofollow noreferrer\">Unicode</a></em>-related differences between them)</li>\n<li>Although this targets a very specific area, <strong>it was not mentioned in any of the previous answers</strong></li>\n</ul>\n<p><br/>The <em>Linux</em> (<em>Ubuntu (<a href=\"https://en.wikipedia.org/wiki/Ubuntu_version_history#Ubuntu_16.04_LTS_.28Xenial_Xerus.29\" rel=\"nofollow noreferrer\">16</a> x64)</em>) counterpart as well:</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">Python 3.5.2 (default, Nov 17 2016, 17:05:23)\n</code></pre>\n</blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"> [GCC 5.4.0 20160609] on linux\n Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n</code></pre>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import os, ctypes\n&gt;&gt;&gt; ctypes.CDLL(\"/lib/x86_64-linux-gnu/libc.so.6\").access(b\"/tmp\", os.F_OK)\n</code></pre>\n</blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"> 0\n</code></pre>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; ctypes.CDLL(\"/lib/x86_64-linux-gnu/libc.so.6\").access(b\"/tmp.notexist\", os.F_OK)\n</code></pre>\n</blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"> -1\n</code></pre>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li><p>Instead hardcoding <em>libc</em>'s path (<em>\"/lib/x86_64-linux-gnu/libc.so.6\"</em>) which may (and most likely, will) vary across systems, <em>None</em> (or the empty string) can be passed to <em>CDLL</em> constructor (<strong><code>ctypes.CDLL(None).access(b\"/tmp\", os.F_OK)</code></strong>). According to <a href=\"http://man7.org/linux/man-pages/man3/dlopen.3.html\" rel=\"nofollow noreferrer\">[man7]: DLOPEN(3)</a>:</p>\n<blockquote>\n<p>If <em>filename</em> is NULL, then the returned handle is for the main\nprogram.  When given to <strong>dlsym</strong>(), this handle causes a search for a\nsymbol in the main program, followed by all shared objects loaded at\nprogram startup, and then all shared objects loaded by <strong>dlopen</strong>() with\nthe flag <strong>RTLD_GLOBAL</strong>.</p>\n</blockquote>\n</li>\n<li><p>Main (current) program (<em>python</em>) is linked against <em>libc</em>, so its symbols (including <em>access</em>) will be loaded</p>\n</li>\n<li><p>This has to be handled with care, since functions like <em>main</em>, <em>Py_Main</em> and (all the) others are available; calling them could have disastrous effects (on the current program)</p>\n</li>\n<li><p>This doesn't also apply to <em>Windows</em> (but that's not such a big deal, since <em>msvcrt.dll</em> is located in <em>\"%SystemRoot%\\System32\"</em> which is in <em>%PATH%</em> by default). I wanted to take things further and replicate this behavior on <em>Windows</em> (and submit a patch), but as it turns out, <a href=\"https://docs.microsoft.com/en-gb/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress\" rel=\"nofollow noreferrer\">[MS.Docs]: GetProcAddress function</a> only \"sees\" <strong>exported</strong> symbols, so unless someone declares the functions in the main executable as <code>__declspec(dllexport)</code> (why on Earth the <em>regular</em> person would do that?), the main program is loadable, but it is pretty much unusable</p>\n</li>\n</ul>\n</li>\n<li><p>Install some third-party module with filesystem capabilities</p>\n<p>Most likely, will rely on one of the ways above (maybe with slight customizations). <br/>One example would be (again, <em>Windows</em>-specific) <a href=\"https://github.com/mhammond/pywin32\" rel=\"nofollow noreferrer\">[GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions</a>, which is a <em>Python</em> wrapper over <em>WINAPI</em>s.</p>\n<p>But, since this is more like a workaround, I'm stopping here.</p>\n</li>\n<li><p>Another (lame) workaround (<em>gainarie</em>) is (as I like to call it,) the <em>system administrator</em> approach: use <em>Python</em> as a wrapper to execute shell commands</p>\n<ul>\n<li><p><em>Windows</em>:</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">(py35x64_test) e:\\Work\\Dev\\StackOverflow\\q000082831&gt;\"e:\\Work\\Dev\\VEnvs\\py35x64_test\\Scripts\\python.exe\" -c \"import os; print(os.system('dir /b \\\"C:\\\\Windows\\\\System32\\\\cmd.exe\\\" &gt; nul 2&gt;&amp;1'))\"\n</code></pre>\n</blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">  0\n</code></pre>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">(py35x64_test) e:\\Work\\Dev\\StackOverflow\\q000082831&gt;\"e:\\Work\\Dev\\VEnvs\\py35x64_test\\Scripts\\python.exe\" -c \"import os; print(os.system('dir /b \\\"C:\\\\Windows\\\\System32\\\\cmd.exe.notexist\\\" &gt; nul 2&gt;&amp;1'))\"\n</code></pre>\n</blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">  1\n</code></pre>\n</li>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Unix-like\" rel=\"nofollow noreferrer\">Unix-like</a> (<em>Linux</em> (<em>Ubuntu</em>)):</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">[cfati@cfati-ubtu16x64-0:~]&gt; python3 -c \"import os; print(os.system('ls \\\"/tmp\\\" &gt; /dev/null 2&gt;&amp;1'))\"\n</code></pre>\n</blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">  0\n  [cfati@cfati-ubtu16x64-0:~]&gt; python3 -c \"import os; print(os.system('ls \\\"/tmp.notexist\\\" &gt; /dev/null 2&gt;&amp;1'))\"\n  512\n</code></pre>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>Bottom line</strong>:</p>\n<ul>\n<li><strong>Do</strong> use <em><strong>try</strong></em> / <em><strong>except</strong></em> / <em><strong>else</strong></em> / <em><strong>finally</strong></em> blocks, because they can prevent you running into a series of nasty problems. A counterexample that I can think of, is performance: such blocks are costly, so try not to place them in code that it's supposed to run hundreds of thousands times per second (but since (in most cases) it involves disk access, it won't be the case).</li>\n</ul>\n", "abstract": "Although almost every possible way has been listed in (at least one of) the existing answers (e.g. Python 3.4 specific stuff was added), I'll try to group everything together. Note: every piece of Python standard library code that I'm going to post, belongs to version 3.5.3. Problem statement: Possible solutions: [Python 3]: os.path.exists(path) (also check other function family members like os.path.isfile, os.path.isdir, os.path.lexists for slightly different behaviors) Return True if path refers to an existing path or an open file descriptor. Returns False for broken symbolic links. On some platforms, this function may return False if permission is not granted to execute os.stat() on the requested file, even if the path physically exists. All good, but if following the import tree: genericpath.py, line ~#20+ it's just a try / except block around [Python 3]: os.stat(path, *, dir_fd=None, follow_symlinks=True). So, your code is try / except free, but lower in the framestack there's (at least) one such block. This also applies to other functions (including os.path.isfile). 1.1. [Python 3]: Path.is_file() It's a fancier (and more Pythonic) way of handling paths, but Under the hood, it does exactly the same thing (pathlib.py, line ~#1330): [Python 3]: With Statement Context Managers. Either: Create one: And its usage - I'll replicate the os.path.isfile behavior (note that this is just for demonstrating purposes, do not attempt to write such code for production): Use [Python 3]: contextlib.suppress(*exceptions) - which was specifically designed for selectively suppressing exceptions But, they seem to be wrappers over try / except / else / finally blocks, as [Python 3]: The with statement states: This allows common try...except...finally usage patterns to be encapsulated for convenient reuse. Filesystem traversal functions (and search the results for matching item(s)) [Python 3]: os.listdir(path='.') (or [Python 3]: os.scandir(path='.') on Python v3.5+, backport: [PyPI]: scandir) Under the hood, both use: via [GitHub]: Python/CPython - (master) cpython/Modules/posixmodule.c Using scandir() instead of listdir() can significantly increase the performance of code that also needs file type or file attribute information, because os.DirEntry objects expose this information if the operating system provides it when scanning a directory. All os.DirEntry methods may perform a system call, but is_dir() and is_file() usually only require a system call for symbolic links; os.DirEntry.stat() always requires a system call on Unix, but only requires one for symbolic links on Windows. [Python 3]: os.walk(top, topdown=True, onerror=None, followlinks=False) [Python 3]: glob.iglob(pathname, *, recursive=False) (or its predecessor: glob.glob) Since these iterate over folders, (in most of the cases) they are inefficient for our problem (there are exceptions, like non wildcarded globbing - as @ShadowRanger pointed out), so I'm not going to insist on them. Not to mention that in some cases, filename processing might be required. [Python 3]: os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True) whose behavior is close to os.path.exists (actually it's wider, mainly because of the 2nd argument) ...test if the invoking user has the specified access to path. mode should be F_OK to test the existence of path... os.access(\"/tmp\", os.F_OK) Since I also work in C, I use this method as well because under the hood, it calls native APIs (again, via \"${PYTHON_SRC_DIR}/Modules/posixmodule.c\"), but it also opens a gate for possible user errors, and it's not as Pythonic as other variants. So, as @AaronHall rightly pointed out, don't use it unless you know what you're doing: Note: calling native APIs is also possible via [Python 3]: ctypes - A foreign function library for Python, but in most cases it's more complicated. (Windows-specific): Since vcruntime* (msvcr*) .dll exports a [MS.Docs]: _access, _waccess function family as well, here's an example: Notes: The Linux (Ubuntu (16 x64)) counterpart as well: Notes: Instead hardcoding libc's path (\"/lib/x86_64-linux-gnu/libc.so.6\") which may (and most likely, will) vary across systems, None (or the empty string) can be passed to CDLL constructor (ctypes.CDLL(None).access(b\"/tmp\", os.F_OK)). According to [man7]: DLOPEN(3): If filename is NULL, then the returned handle is for the main\nprogram.  When given to dlsym(), this handle causes a search for a\nsymbol in the main program, followed by all shared objects loaded at\nprogram startup, and then all shared objects loaded by dlopen() with\nthe flag RTLD_GLOBAL. Main (current) program (python) is linked against libc, so its symbols (including access) will be loaded This has to be handled with care, since functions like main, Py_Main and (all the) others are available; calling them could have disastrous effects (on the current program) This doesn't also apply to Windows (but that's not such a big deal, since msvcrt.dll is located in \"%SystemRoot%\\System32\" which is in %PATH% by default). I wanted to take things further and replicate this behavior on Windows (and submit a patch), but as it turns out, [MS.Docs]: GetProcAddress function only \"sees\" exported symbols, so unless someone declares the functions in the main executable as __declspec(dllexport) (why on Earth the regular person would do that?), the main program is loadable, but it is pretty much unusable Install some third-party module with filesystem capabilities Most likely, will rely on one of the ways above (maybe with slight customizations). One example would be (again, Windows-specific) [GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions, which is a Python wrapper over WINAPIs. But, since this is more like a workaround, I'm stopping here. Another (lame) workaround (gainarie) is (as I like to call it,) the system administrator approach: use Python as a wrapper to execute shell commands Windows: Unix-like (Linux (Ubuntu)): Bottom line:"}, {"id": 21641213, "score": 214, "vote": 0, "content": "<p><strong>Python 3.4+</strong> has an object-oriented path module: <a href=\"https://docs.python.org/3/library/pathlib.html\" rel=\"noreferrer\"><strong>pathlib</strong></a>.  Using this new module, you can check whether a file exists like this:</p>\n<pre><code class=\"python\">import pathlib\np = pathlib.Path('path/to/file')\nif p.is_file():  # or p.is_dir() to see if it is a directory\n    # do stuff\n</code></pre>\n<p>You can (and usually should) still use a <code>try/except</code> block when opening files:</p>\n<pre><code class=\"python\">try:\n    with p.open() as f:\n        # do awesome stuff\nexcept OSError:\n    print('Well darn.')\n</code></pre>\n<p>The pathlib module has lots of cool stuff in it: convenient globbing, checking file's owner, easier path joining, etc.  It's worth checking out.  If you're on an older Python (version 2.6 or later), you can still install pathlib with pip:</p>\n<pre><code class=\"python\"># installs pathlib2 on older Python versions\n# the original third-party module, pathlib, is no longer maintained.\npip install pathlib2\n</code></pre>\n<p>Then import it as follows:</p>\n<pre><code class=\"python\"># Older Python versions\nimport pathlib2 as pathlib\n</code></pre>\n", "abstract": "Python 3.4+ has an object-oriented path module: pathlib.  Using this new module, you can check whether a file exists like this: You can (and usually should) still use a try/except block when opening files: The pathlib module has lots of cool stuff in it: convenient globbing, checking file's owner, easier path joining, etc.  It's worth checking out.  If you're on an older Python (version 2.6 or later), you can still install pathlib with pip: Then import it as follows:"}, {"id": 17344732, "score": 171, "vote": 0, "content": "<p>This is the simplest way to check if a file exists. Just <strong>because</strong> the file existed when you checked doesn't <strong>guarantee</strong> that it will be there when you need to open it.</p>\n<pre><code class=\"python\">import os\nfname = \"foo.txt\"\nif os.path.isfile(fname):\n    print(\"file does exist at this time\")\nelse:\n    print(\"no such file exists at this time\")\n</code></pre>\n", "abstract": "This is the simplest way to check if a file exists. Just because the file existed when you checked doesn't guarantee that it will be there when you need to open it."}, {"id": 31932925, "score": 138, "vote": 0, "content": "<blockquote>\n<h2>How do I check whether a file exists, using Python, without using a try statement?</h2>\n</blockquote>\n<p>Now available since Python 3.4, import and instantiate a <code>Path</code> object with the file name, and check the <code>is_file</code> method (note that this returns True for symlinks pointing to regular files as well):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; Path('/').is_file()\nFalse\n&gt;&gt;&gt; Path('/initrd.img').is_file()\nTrue\n&gt;&gt;&gt; Path('/doesnotexist').is_file()\nFalse\n</code></pre>\n<p>If you're on Python 2, you can backport the pathlib module from pypi, <a href=\"https://pypi.python.org/pypi/pathlib2/\" rel=\"noreferrer\"><code>pathlib2</code></a>, or otherwise check <code>isfile</code> from the <code>os.path</code> module:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.path.isfile('/')\nFalse\n&gt;&gt;&gt; os.path.isfile('/initrd.img')\nTrue\n&gt;&gt;&gt; os.path.isfile('/doesnotexist')\nFalse\n</code></pre>\n<p>Now the above is probably the best pragmatic direct answer here, but there's the possibility of a race condition (depending on what you're trying to accomplish), and the fact that the underlying implementation uses a <code>try</code>, but Python uses <code>try</code> everywhere in its implementation. </p>\n<p>Because Python uses <code>try</code> everywhere, there's really no reason to avoid an implementation that uses it.</p>\n<p>But the rest of this answer attempts to consider these caveats.</p>\n<h2>Longer, much more pedantic answer</h2>\n<p>Available since Python 3.4, use the new <code>Path</code> object in <code>pathlib</code>. Note that <code>.exists</code> is not quite right, because directories are not files (except in the unix sense that <em>everything</em> is a file).</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; root = Path('/')\n&gt;&gt;&gt; root.exists()\nTrue\n</code></pre>\n<p>So we need to use <code>is_file</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; root.is_file()\nFalse\n</code></pre>\n<p>Here's the help on <code>is_file</code>:</p>\n<pre><code class=\"python\">is_file(self)\n    Whether this path is a regular file (also True for symlinks pointing\n    to regular files).\n</code></pre>\n<p>So let's get a file that we know is a file:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; file = tempfile.NamedTemporaryFile()\n&gt;&gt;&gt; filepathobj = Path(file.name)\n&gt;&gt;&gt; filepathobj.is_file()\nTrue\n&gt;&gt;&gt; filepathobj.exists()\nTrue\n</code></pre>\n<p>By default, <code>NamedTemporaryFile</code> deletes the file when closed (and will automatically close when no more references exist to it).</p>\n<pre><code class=\"python\">&gt;&gt;&gt; del file\n&gt;&gt;&gt; filepathobj.exists()\nFalse\n&gt;&gt;&gt; filepathobj.is_file()\nFalse\n</code></pre>\n<p>If you dig into <a href=\"https://github.com/python/cpython/blob/master/Lib/pathlib.py#L1318\" rel=\"noreferrer\">the implementation</a>, though, you'll see that <code>is_file</code> uses <code>try</code>:</p>\n<pre><code class=\"python\">def is_file(self):\n    \"\"\"\n    Whether this path is a regular file (also True for symlinks pointing\n    to regular files).\n    \"\"\"\n    try:\n        return S_ISREG(self.stat().st_mode)\n    except OSError as e:\n        if e.errno not in (ENOENT, ENOTDIR):\n            raise\n        # Path doesn't exist or is a broken symlink\n        # (see https://bitbucket.org/pitrou/pathlib/issue/12/)\n        return False\n</code></pre>\n<h2>Race Conditions: Why we like try</h2>\n<p>We like <code>try</code> because it avoids race conditions. With <code>try</code>, you simply attempt to read your file, expecting it to be there, and if not, you catch the exception and perform whatever fallback behavior makes sense.</p>\n<p>If you want to check that a file exists before you attempt to read it, and you might be deleting it and then you might be using multiple threads or processes, or another program knows about that file and could delete it - you risk the chance of a <strong>race condition</strong> if you check it exists, because you are then <em>racing</em> to open it before its <em>condition</em> (its existence) changes. </p>\n<p>Race conditions are very hard to debug because there's a very small window in which they can cause your program to fail.</p>\n<p>But if this is your motivation, you <em>can</em> get the value of a <code>try</code> statement by using the <code>suppress</code> context manager.</p>\n<h2>Avoiding race conditions without a try statement: <code>suppress</code></h2>\n<p>Python 3.4 gives us the <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.suppress\" rel=\"noreferrer\"><code>suppress</code></a> context manager (previously the <a href=\"https://bugs.python.org/issue19266\" rel=\"noreferrer\"><code>ignore</code></a> context manager), which does semantically exactly the same thing in fewer lines, while also (at least superficially) meeting the original ask to avoid a <code>try</code> statement:</p>\n<pre><code class=\"python\">from contextlib import suppress\nfrom pathlib import Path\n</code></pre>\n<p>Usage:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; with suppress(OSError), Path('doesnotexist').open() as f:\n...     for line in f:\n...         print(line)\n... \n&gt;&gt;&gt;\n&gt;&gt;&gt; with suppress(OSError):\n...     Path('doesnotexist').unlink()\n... \n&gt;&gt;&gt; \n</code></pre>\n<p>For earlier Pythons, you could roll your own <code>suppress</code>, but without a <code>try</code> will be more verbose than with. I do believe <strong>this actually is the only answer that doesn't use <code>try</code> at any level in the Python</strong> that can be applied to prior to Python 3.4 because it uses a context manager instead:</p>\n<pre><code class=\"python\">class suppress(object):\n    def __init__(self, *exceptions):\n        self.exceptions = exceptions\n    def __enter__(self):\n        return self\n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_type is not None:\n            return issubclass(exc_type, self.exceptions)\n</code></pre>\n<p>Perhaps easier with a try:</p>\n<pre><code class=\"python\">from contextlib import contextmanager\n\n@contextmanager\ndef suppress(*exceptions):\n    try:\n        yield\n    except exceptions:\n        pass\n</code></pre>\n<h2>Other options that don't meet the ask for \"without try\":</h2>\n<p><strong>isfile</strong></p>\n<pre><code class=\"python\">import os\nos.path.isfile(path)\n</code></pre>\n<p>from the <a href=\"https://docs.python.org/library/os.path.html#os.path.isfile\" rel=\"noreferrer\">docs</a>:</p>\n<blockquote>\n<p><code>os.path.isfile(path)</code></p>\n<p>Return True if path is an existing regular file. This follows symbolic\n  links, so both <code>islink()</code> and <code>isfile()</code> can be true for the same path.</p>\n</blockquote>\n<p>But if you examine the <a href=\"https://hg.python.org/cpython/file/tip/Lib/genericpath.py#l25\" rel=\"noreferrer\">source</a> of this function, you'll see it actually does use a try statement:</p>\n<blockquote>\n<pre><code class=\"python\"># This follows symbolic links, so both islink() and isdir() can be true\n# for the same path on systems that support symlinks\ndef isfile(path):\n    \"\"\"Test whether a path is a regular file\"\"\"\n    try:\n        st = os.stat(path)\n    except os.error:\n        return False\n    return stat.S_ISREG(st.st_mode)\n</code></pre>\n</blockquote>\n<pre><code class=\"python\">&gt;&gt;&gt; OSError is os.error\nTrue\n</code></pre>\n<p>All it's doing is using the given path to see if it can get stats on it,  catching <code>OSError</code> and then checking if it's a file if it didn't raise the exception.</p>\n<p>If you intend to do something with the file, I would suggest directly attempting it with a try-except to avoid a race condition:</p>\n<pre><code class=\"python\">try:\n    with open(path) as f:\n        f.read()\nexcept OSError:\n    pass\n</code></pre>\n<p><strong>os.access</strong></p>\n<p>Available for Unix and Windows is <code>os.access</code>, but to use you must pass flags, and it does not differentiate between files and directories. This is more used to test if the real invoking user has access in an elevated privilege environment:</p>\n<pre><code class=\"python\">import os\nos.access(path, os.F_OK)\n</code></pre>\n<p>It also suffers from the same race condition problems as <code>isfile</code>. From the <a href=\"https://docs.python.org/2/library/os.html#os.access\" rel=\"noreferrer\">docs</a>:</p>\n<blockquote>\n<p>Note:\n  Using access() to check if a user is authorized to e.g. open a file\n  before actually doing so using open() creates a security hole, because\n  the user might exploit the short time interval between checking and\n  opening the file to manipulate it. It\u2019s preferable to use EAFP\n  techniques. For example:</p>\n<pre><code class=\"python\">if os.access(\"myfile\", os.R_OK):\n    with open(\"myfile\") as fp:\n        return fp.read()\nreturn \"some default data\"\n</code></pre>\n<p>is better written as:</p>\n<pre><code class=\"python\">try:\n    fp = open(\"myfile\")\nexcept IOError as e:\n    if e.errno == errno.EACCES:\n        return \"some default data\"\n    # Not a permission error.\n    raise\nelse:\n    with fp:\n        return fp.read()\n</code></pre>\n</blockquote>\n<p>Avoid using <code>os.access</code>. It is a low level function that has more opportunities for user error than the higher level objects and functions discussed above.</p>\n<h3>Criticism of another answer:</h3>\n<p>Another answer says this about <code>os.access</code>:</p>\n<blockquote>\n<p>Personally, I prefer this one because under the hood, it calls native APIs (via \"${PYTHON_SRC_DIR}/Modules/posixmodule.c\"), but it also opens a gate for possible user errors, and it's not as Pythonic as other variants:</p>\n</blockquote>\n<p>This answer says it prefers a non-Pythonic, error-prone method, with no justification. It seems to encourage users to use low-level APIs without understanding them. </p>\n<p>It also creates a context manager which, by unconditionally returning <code>True</code>, allows all Exceptions (including <code>KeyboardInterrupt</code> and <code>SystemExit</code>!) to pass silently, which is a good way to hide bugs.</p>\n<p>This seems to encourage users to adopt poor practices.</p>\n", "abstract": "Now available since Python 3.4, import and instantiate a Path object with the file name, and check the is_file method (note that this returns True for symlinks pointing to regular files as well): If you're on Python 2, you can backport the pathlib module from pypi, pathlib2, or otherwise check isfile from the os.path module: Now the above is probably the best pragmatic direct answer here, but there's the possibility of a race condition (depending on what you're trying to accomplish), and the fact that the underlying implementation uses a try, but Python uses try everywhere in its implementation.  Because Python uses try everywhere, there's really no reason to avoid an implementation that uses it. But the rest of this answer attempts to consider these caveats. Available since Python 3.4, use the new Path object in pathlib. Note that .exists is not quite right, because directories are not files (except in the unix sense that everything is a file). So we need to use is_file: Here's the help on is_file: So let's get a file that we know is a file: By default, NamedTemporaryFile deletes the file when closed (and will automatically close when no more references exist to it). If you dig into the implementation, though, you'll see that is_file uses try: We like try because it avoids race conditions. With try, you simply attempt to read your file, expecting it to be there, and if not, you catch the exception and perform whatever fallback behavior makes sense. If you want to check that a file exists before you attempt to read it, and you might be deleting it and then you might be using multiple threads or processes, or another program knows about that file and could delete it - you risk the chance of a race condition if you check it exists, because you are then racing to open it before its condition (its existence) changes.  Race conditions are very hard to debug because there's a very small window in which they can cause your program to fail. But if this is your motivation, you can get the value of a try statement by using the suppress context manager. Python 3.4 gives us the suppress context manager (previously the ignore context manager), which does semantically exactly the same thing in fewer lines, while also (at least superficially) meeting the original ask to avoid a try statement: Usage: For earlier Pythons, you could roll your own suppress, but without a try will be more verbose than with. I do believe this actually is the only answer that doesn't use try at any level in the Python that can be applied to prior to Python 3.4 because it uses a context manager instead: Perhaps easier with a try: isfile from the docs: os.path.isfile(path) Return True if path is an existing regular file. This follows symbolic\n  links, so both islink() and isfile() can be true for the same path. But if you examine the source of this function, you'll see it actually does use a try statement: All it's doing is using the given path to see if it can get stats on it,  catching OSError and then checking if it's a file if it didn't raise the exception. If you intend to do something with the file, I would suggest directly attempting it with a try-except to avoid a race condition: os.access Available for Unix and Windows is os.access, but to use you must pass flags, and it does not differentiate between files and directories. This is more used to test if the real invoking user has access in an elevated privilege environment: It also suffers from the same race condition problems as isfile. From the docs: Note:\n  Using access() to check if a user is authorized to e.g. open a file\n  before actually doing so using open() creates a security hole, because\n  the user might exploit the short time interval between checking and\n  opening the file to manipulate it. It\u2019s preferable to use EAFP\n  techniques. For example: is better written as: Avoid using os.access. It is a low level function that has more opportunities for user error than the higher level objects and functions discussed above. Another answer says this about os.access: Personally, I prefer this one because under the hood, it calls native APIs (via \"${PYTHON_SRC_DIR}/Modules/posixmodule.c\"), but it also opens a gate for possible user errors, and it's not as Pythonic as other variants: This answer says it prefers a non-Pythonic, error-prone method, with no justification. It seems to encourage users to use low-level APIs without understanding them.  It also creates a context manager which, by unconditionally returning True, allows all Exceptions (including KeyboardInterrupt and SystemExit!) to pass silently, which is a good way to hide bugs. This seems to encourage users to adopt poor practices."}, {"id": 1671095, "score": 137, "vote": 0, "content": "<p>Prefer the try statement. It's considered better style and avoids race conditions.</p>\n<p>Don't take my word for it. There's plenty of support for this theory. Here's a couple:</p>\n<ul>\n<li>Style: Section \"Handling unusual conditions\" of <a href=\"http://allendowney.com/sd/notes/notes11.txt\" rel=\"nofollow noreferrer\">these course notes for <em>Software Design</em></a> (2007)</li>\n<li><a href=\"https://developer.apple.com/library/mac/#documentation/security/conceptual/SecureCodingGuide/Articles/RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW8\" rel=\"nofollow noreferrer\">Avoiding Race Conditions</a></li>\n</ul>\n", "abstract": "Prefer the try statement. It's considered better style and avoids race conditions. Don't take my word for it. There's plenty of support for this theory. Here's a couple:"}, {"id": 30444116, "score": 98, "vote": 0, "content": "<p>Use:</p>\n<pre><code class=\"python\">import os\n#Your path here e.g. \"C:\\Program Files\\text.txt\"\n#For access purposes: \"C:\\\\Program Files\\\\text.txt\"\nif os.path.exists(\"C:\\...\"):\n    print \"File found!\"\nelse:\n    print \"File not found!\"\n</code></pre>\n<p>Importing <code>os</code> makes it easier to navigate and perform standard actions with your operating system.</p>\n<p>For reference, also see <em><a href=\"/q/82831\">How do I check whether a file exists without exceptions?</a></em>.</p>\n<p>If you need high-level operations, use <code>shutil</code>.</p>\n", "abstract": "Use: Importing os makes it easier to navigate and perform standard actions with your operating system. For reference, also see How do I check whether a file exists without exceptions?. If you need high-level operations, use shutil."}, {"id": 39932496, "score": 96, "vote": 0, "content": "<p>Testing for files and folders with <code>os.path.isfile()</code>, <code>os.path.isdir()</code> and <code>os.path.exists()</code></p>\n<p>Assuming that the \"path\" is a valid path, this table shows what is returned by each function for files and folders:</p>\n<p><a href=\"https://i.stack.imgur.com/tOs9p.png\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/tOs9p.png\"/></a></p>\n<p>You can also test if a file is a certain type of file using <code>os.path.splitext()</code> to get the extension (if you don't already know it)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import os\n&gt;&gt;&gt; path = \"path to a word document\"\n&gt;&gt;&gt; os.path.isfile(path)\nTrue\n&gt;&gt;&gt; os.path.splitext(path)[1] == \".docx\" # test if the extension is .docx\nTrue\n</code></pre>\n", "abstract": "Testing for files and folders with os.path.isfile(), os.path.isdir() and os.path.exists() Assuming that the \"path\" is a valid path, this table shows what is returned by each function for files and folders:  You can also test if a file is a certain type of file using os.path.splitext() to get the extension (if you don't already know it)"}, {"id": 65857751, "score": 88, "vote": 0, "content": "<p><strong>TL;DR</strong> <br/>\nThe answer is: use the <strong><code>pathlib</code></strong> module</p>\n<hr/>\n<p><strong>Pathlib</strong> is probably the most modern and convenient way for almost all of the file operations. For the existence of a <strong>file</strong> or a <strong>folder</strong> a single line of code is enough. If file is not exists, it will <em><strong>not</strong></em> throw any exception.</p>\n<pre><code class=\"python\">from pathlib import Path\n\nif Path(\"myfile.txt\").exists(): # works for both file and folders\n    # do your cool stuff...\n</code></pre>\n<p>The <code>pathlib</code> module was introduced in Python 3.4, so you need to have Python 3.4+. This library makes your life much easier while working with files and folders, and it is pretty to use. Here is more documentation about it: <em><a href=\"https://docs.python.org/3/library/pathlib.html\" rel=\"nofollow noreferrer\">pathlib \u2014 Object-oriented filesystem paths</a></em>.</p>\n<p>BTW, if you are going to reuse the path, then it is better to assign it to a variable.</p>\n<p>So it will become:</p>\n<pre><code class=\"python\">from pathlib import Path\n\np = Path(\"loc/of/myfile.txt\")\nif p.exists(): # works for both file and folders\n    # do stuffs...\n#reuse 'p' if needed.\n</code></pre>\n", "abstract": "TL;DR \nThe answer is: use the pathlib module Pathlib is probably the most modern and convenient way for almost all of the file operations. For the existence of a file or a folder a single line of code is enough. If file is not exists, it will not throw any exception. The pathlib module was introduced in Python 3.4, so you need to have Python 3.4+. This library makes your life much easier while working with files and folders, and it is pretty to use. Here is more documentation about it: pathlib \u2014 Object-oriented filesystem paths. BTW, if you are going to reuse the path, then it is better to assign it to a variable. So it will become:"}, {"id": 35602588, "score": 81, "vote": 0, "content": "<p>In 2016 the best way is still using <code>os.path.isfile</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; os.path.isfile('/path/to/some/file.txt')\n</code></pre>\n<p>Or in Python 3 you can use <code>pathlib</code>:</p>\n<pre><code class=\"python\">import pathlib\npath = pathlib.Path('/path/to/some/file.txt')\nif path.is_file():\n    ...\n</code></pre>\n", "abstract": "In 2016 the best way is still using os.path.isfile: Or in Python 3 you can use pathlib:"}, {"id": 18994918, "score": 74, "vote": 0, "content": "<p>It doesn't seem like there's a meaningful functional difference between try/except and <code>isfile()</code>, so you should use which one makes sense.</p>\n<p>If you want to read a file, if it exists, do</p>\n<pre><code class=\"python\">try:\n    f = open(filepath)\nexcept IOError:\n    print 'Oh dear.'\n</code></pre>\n<p>But if you just wanted to rename a file if it exists, and therefore don't need to open it, do</p>\n<pre><code class=\"python\">if os.path.isfile(filepath):\n    os.rename(filepath, filepath + '.old')\n</code></pre>\n<p>If you want to write to a file, if it doesn't exist, do</p>\n<pre><code class=\"python\"># Python 2\nif not os.path.isfile(filepath):\n    f = open(filepath, 'w')\n\n# Python 3: x opens for exclusive creation, failing if the file already exists\ntry:\n    f = open(filepath, 'wx')\nexcept IOError:\n    print 'file already exists'\n</code></pre>\n<p>If you need file locking, that's a different matter.</p>\n", "abstract": "It doesn't seem like there's a meaningful functional difference between try/except and isfile(), so you should use which one makes sense. If you want to read a file, if it exists, do But if you just wanted to rename a file if it exists, and therefore don't need to open it, do If you want to write to a file, if it doesn't exist, do If you need file locking, that's a different matter."}, {"id": 4799818, "score": 65, "vote": 0, "content": "<p>You could try this (safer):</p>\n<pre><code class=\"python\">try:\n    # http://effbot.org/zone/python-with-statement.htm\n    # 'with' is safer to open a file\n    with open('whatever.txt') as fh:\n        # Do something with 'fh'\nexcept IOError as e:\n    print(\"({})\".format(e))\n</code></pre>\n<p>The ouput would be:</p>\n<blockquote>\n<p>([Errno 2] No such file or directory:\n  'whatever.txt')</p>\n</blockquote>\n<p>Then, depending on the result, your program can just keep running from there or you can code to stop it if you want.</p>\n", "abstract": "You could try this (safer): The ouput would be: ([Errno 2] No such file or directory:\n  'whatever.txt') Then, depending on the result, your program can just keep running from there or you can code to stop it if you want."}, {"id": 47629576, "score": 56, "vote": 0, "content": "<p>Date: 2017-12-04</p>\n<p>Every possible solution has been listed in other answers.</p>\n<p>An intuitive and arguable way to check if a file exists is the following:</p>\n<pre><code class=\"python\">import os\n\nos.path.isfile('~/file.md')  # Returns True if exists, else False\n\n# Additionally, check a directory\nos.path.isdir('~/folder')  # Returns True if the folder exists, else False\n\n# Check either a directory or a file\nos.path.exists('~/file')\n</code></pre>\n<p>I made an exhaustive cheat sheet for your reference:</p>\n<pre><code class=\"python\"># os.path methods in exhaustive cheat sheet\n{'definition': ['dirname',\n               'basename',\n               'abspath',\n               'relpath',\n               'commonpath',\n               'normpath',\n               'realpath'],\n'operation': ['split', 'splitdrive', 'splitext',\n               'join', 'normcase'],\n'compare': ['samefile', 'sameopenfile', 'samestat'],\n'condition': ['isdir',\n              'isfile',\n              'exists',\n              'lexists'\n              'islink',\n              'isabs',\n              'ismount',],\n 'expand': ['expanduser',\n            'expandvars'],\n 'stat': ['getatime', 'getctime', 'getmtime',\n          'getsize']}\n</code></pre>\n", "abstract": "Date: 2017-12-04 Every possible solution has been listed in other answers. An intuitive and arguable way to check if a file exists is the following: I made an exhaustive cheat sheet for your reference:"}, {"id": 27661444, "score": 54, "vote": 0, "content": "<p>Although I always recommend using <code>try</code> and <code>except</code> statements, here are a few possibilities for you (my personal favourite is using <code>os.access</code>):</p>\n<ol>\n<li><p>Try opening the file:</p>\n<p>Opening the file will always verify the existence of the file. You can make a function just like so:</p>\n<pre><code class=\"python\">def File_Existence(filepath):\n    f = open(filepath)\n    return True\n</code></pre>\n<p>If it's False, it will stop execution with an unhanded IOError\nor OSError in later versions of Python. To catch the exception,\nyou have to use a try except clause. Of course, you can always\nuse a <code>try</code> except` statement like so (thanks to <a href=\"https://stackoverflow.com/users/3256073/hsandt\">hsandt</a>\nfor making me think):</p>\n<pre><code class=\"python\">def File_Existence(filepath):\n    try:\n        f = open(filepath)\n    except IOError, OSError: # Note OSError is for later versions of Python\n        return False\n\n    return True\n</code></pre></li>\n<li><p>Use <code>os.path.exists(path)</code>:</p>\n<p>This will check the existence of what you specify. However, it checks for files <em>and</em> directories so beware about how you use it.</p>\n<pre><code class=\"python\">import os.path\n&gt;&gt;&gt; os.path.exists(\"this/is/a/directory\")\nTrue\n&gt;&gt;&gt; os.path.exists(\"this/is/a/file.txt\")\nTrue\n&gt;&gt;&gt; os.path.exists(\"not/a/directory\")\nFalse\n</code></pre></li>\n<li><p>Use <code>os.access(path, mode)</code>:</p>\n<p>This will check whether you have access to the file. It will check for permissions. Based on the os.py documentation, typing in <code>os.F_OK</code>, it will check the existence of the path. However, using this will create a security hole, as someone can attack your file using the time between checking the permissions and opening the file. You should instead go directly to opening the file instead of checking its permissions. (<a href=\"https://docs.python.org/2/glossary.html#term-eafp\" rel=\"noreferrer\">EAFP</a> vs <a href=\"https://docs.python.org/2/glossary.html#term-lbyl\" rel=\"noreferrer\">LBYP</a>). If you're not going to open the file afterwards, and only checking its existence, then you can use this.</p>\n<p>Anyway, here:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.access(\"/is/a/file.txt\", os.F_OK)\nTrue\n</code></pre></li>\n</ol>\n<p>I should also mention that there are two ways that you will not be able to verify the existence of a file. Either the issue will be <code>permission denied</code> or <code>no such file or directory</code>. If you catch an <code>IOError</code>, set the <code>IOError as e</code> (like my first option), and then type in <code>print(e.args)</code> so that you can hopefully determine your issue. I hope it helps! :)</p>\n", "abstract": "Although I always recommend using try and except statements, here are a few possibilities for you (my personal favourite is using os.access): Try opening the file: Opening the file will always verify the existence of the file. You can make a function just like so: If it's False, it will stop execution with an unhanded IOError\nor OSError in later versions of Python. To catch the exception,\nyou have to use a try except clause. Of course, you can always\nuse a try except` statement like so (thanks to hsandt\nfor making me think): Use os.path.exists(path): This will check the existence of what you specify. However, it checks for files and directories so beware about how you use it. Use os.access(path, mode): This will check whether you have access to the file. It will check for permissions. Based on the os.py documentation, typing in os.F_OK, it will check the existence of the path. However, using this will create a security hole, as someone can attack your file using the time between checking the permissions and opening the file. You should instead go directly to opening the file instead of checking its permissions. (EAFP vs LBYP). If you're not going to open the file afterwards, and only checking its existence, then you can use this. Anyway, here: I should also mention that there are two ways that you will not be able to verify the existence of a file. Either the issue will be permission denied or no such file or directory. If you catch an IOError, set the IOError as e (like my first option), and then type in print(e.args) so that you can hopefully determine your issue. I hope it helps! :)"}, {"id": 26335110, "score": 42, "vote": 0, "content": "<p>If the file is for opening you could use one of the following techniques:</p>\n<pre><code class=\"python\">with open('somefile', 'xt') as f: # Using the x-flag, Python 3.3 and above\n    f.write('Hello\\n')\n\nif not os.path.exists('somefile'): \n    with open('somefile', 'wt') as f:\n        f.write(\"Hello\\n\")\nelse:\n    print('File already exists!')\n</code></pre>\n<hr/>\n<p>Note: This finds either a file <strong>or</strong> a directory with the given name.</p>\n", "abstract": "If the file is for opening you could use one of the following techniques: Note: This finds either a file or a directory with the given name."}, {"id": 83012, "score": 41, "vote": 0, "content": "<p>Additionally, <code>os.access()</code>:</p>\n<pre><code class=\"python\">if os.access(\"myfile\", os.R_OK):\n    with open(\"myfile\") as fp:\n        return fp.read()\n</code></pre>\n<p>Being <code>R_OK</code>, <code>W_OK</code>, and <code>X_OK</code> the flags to test for permissions (<a href=\"https://docs.python.org/3/library/os.html#os.access\" rel=\"noreferrer\">doc</a>).</p>\n", "abstract": "Additionally, os.access(): Being R_OK, W_OK, and X_OK the flags to test for permissions (doc)."}, {"id": 29909391, "score": 23, "vote": 0, "content": "<pre><code class=\"python\">if os.path.isfile(path_to_file):\n    try:\n        open(path_to_file)\n            pass\n    except IOError as e:\n        print \"Unable to open file\"\n</code></pre>\n<blockquote>\n<p>Raising exceptions is considered to be an acceptable, and Pythonic,\napproach for flow control in your program. Consider handling missing\nfiles with IOErrors. In this situation, an IOError exception will be\nraised if the file exists but the user does not have read permissions.</p>\n</blockquote>\n<p>Source: <em><a href=\"http://www.pfinn.net/python-check-if-file-exists.html\" rel=\"nofollow noreferrer\">Using Python: How To Check If A File Exists</a></em></p>\n", "abstract": "Raising exceptions is considered to be an acceptable, and Pythonic,\napproach for flow control in your program. Consider handling missing\nfiles with IOErrors. In this situation, an IOError exception will be\nraised if the file exists but the user does not have read permissions. Source: Using Python: How To Check If A File Exists"}, {"id": 45605450, "score": 22, "vote": 0, "content": "<p>If you imported NumPy already for other purposes then there is no need to import other libraries like <code>pathlib</code>, <code>os</code>, <code>paths</code>, etc.</p>\n<pre><code class=\"python\">import numpy as np\nnp.DataSource().exists(\"path/to/your/file\")\n</code></pre>\n<p>This will return true or false based on its existence.</p>\n", "abstract": "If you imported NumPy already for other purposes then there is no need to import other libraries like pathlib, os, paths, etc. This will return true or false based on its existence."}, {"id": 21688350, "score": 20, "vote": 0, "content": "<p>You can write Brian's suggestion without the <code>try:</code>.</p>\n<pre><code class=\"python\">from contextlib import suppress\n\nwith suppress(IOError), open('filename'):\n    process()\n</code></pre>\n<p><code>suppress</code> is part of Python 3.4. In older releases you can quickly write your own suppress:</p>\n<pre><code class=\"python\">from contextlib import contextmanager\n\n@contextmanager\ndef suppress(*exceptions):\n    try:\n        yield\n    except exceptions:\n        pass\n</code></pre>\n", "abstract": "You can write Brian's suggestion without the try:. suppress is part of Python 3.4. In older releases you can quickly write your own suppress:"}, {"id": 49092615, "score": 20, "vote": 0, "content": "<h2>Check file or directory exists</h2>\n<p>You can follow these three ways:</p>\n<h3>1. Using isfile()</h3>\n<p>Note 1: The <code>os.path.isfile</code> used only for files</p>\n<pre><code class=\"python\">import os.path\nos.path.isfile(filename) # True if file exists\nos.path.isfile(dirname) # False if directory exists\n</code></pre>\n<h3>2. Using <em>exists</em></h3>\n<p>Note 2: The <code>os.path.exists</code> is used for both files and directories</p>\n<pre><code class=\"python\">import os.path\nos.path.exists(filename) # True if file exists\nos.path.exists(dirname) # True if directory exists\n</code></pre>\n<h3>3. The <code>pathlib.Path</code> method (included in Python 3+, installable with pip for Python 2)</h3>\n<pre><code class=\"python\">from pathlib import Path\nPath(filename).exists()\n</code></pre>\n", "abstract": "You can follow these three ways: Note 1: The os.path.isfile used only for files Note 2: The os.path.exists is used for both files and directories"}, {"id": 37050053, "score": 18, "vote": 0, "content": "<p>I'm the author of a package that's been around for about 10 years, and it has a function that addresses this question directly. Basically, if you are on a non-Windows system, it uses <code>Popen</code> to access <code>find</code>.  However, if you are on Windows, it replicates <code>find</code> with an efficient filesystem walker.</p>\n<p>The code itself does not use a <code>try</code> block\u2026 except in determining the operating system and thus steering you to the \"Unix\"-style <code>find</code> or the hand-buillt <code>find</code>. Timing tests showed that the <code>try</code> was faster in determining the OS, so I did use one there (but nowhere else).</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import pox\n&gt;&gt;&gt; pox.find('*python*', type='file', root=pox.homedir(), recurse=False)\n['/Users/mmckerns/.python']\n</code></pre>\n<p>And the doc\u2026</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print pox.find.__doc__\nfind(patterns[,root,recurse,type]); Get path to a file or directory\n\n    patterns: name or partial name string of items to search for\n    root: path string of top-level directory to search\n    recurse: if True, recurse down from root directory\n    type: item filter; one of {None, file, dir, link, socket, block, char}\n    verbose: if True, be a little verbose about the search\n\n    On some OS, recursion can be specified by recursion depth (an integer).\n    patterns can be specified with basic pattern matching. Additionally,\n    multiple patterns can be specified by splitting patterns with a ';'\n    For example:\n        &gt;&gt;&gt; find('pox*', root='..')\n        ['/Users/foo/pox/pox', '/Users/foo/pox/scripts/pox_launcher.py']\n\n        &gt;&gt;&gt; find('*shutils*;*init*')\n        ['/Users/foo/pox/pox/shutils.py', '/Users/foo/pox/pox/__init__.py']\n\n&gt;&gt;&gt;\n</code></pre>\n<p>The implementation, if you care to look, is here:\n<a href=\"https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190\" rel=\"noreferrer\">https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190</a></p>\n", "abstract": "I'm the author of a package that's been around for about 10 years, and it has a function that addresses this question directly. Basically, if you are on a non-Windows system, it uses Popen to access find.  However, if you are on Windows, it replicates find with an efficient filesystem walker. The code itself does not use a try block\u2026 except in determining the operating system and thus steering you to the \"Unix\"-style find or the hand-buillt find. Timing tests showed that the try was faster in determining the OS, so I did use one there (but nowhere else). And the doc\u2026 The implementation, if you care to look, is here:\nhttps://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190"}, {"id": 38793323, "score": 18, "vote": 0, "content": "<p>Adding one more slight variation which isn't exactly reflected in the other answers.</p>\n<p>This will handle the case of the <code>file_path</code> being <code>None</code> or empty string.</p>\n<p></p>\n<pre><code class=\"python\">def file_exists(file_path):\n    if not file_path:\n        return False\n    elif not os.path.isfile(file_path):\n        return False\n    else:\n        return True\n</code></pre>\n<p>Adding a variant based on suggestion from Shahbaz\n</p>\n<pre><code class=\"python\">def file_exists(file_path):\n    if not file_path:\n        return False\n    else:\n        return os.path.isfile(file_path)\n</code></pre>\n<p>Adding a variant based on suggestion from Peter Wood\n</p>\n<pre><code class=\"python\">def file_exists(file_path):\n    return file_path and os.path.isfile(file_path):\n</code></pre>\n", "abstract": "Adding one more slight variation which isn't exactly reflected in the other answers. This will handle the case of the file_path being None or empty string.  Adding a variant based on suggestion from Shahbaz\n Adding a variant based on suggestion from Peter Wood\n"}, {"id": 32288118, "score": 16, "vote": 0, "content": "<p>Here's a one-line Python command for the Linux command line environment. I find this <em>very handy</em> since I'm not such a hot Bash guy.</p>\n<pre><code class=\"python\">python -c \"import os.path; print os.path.isfile('/path_to/file.xxx')\"\n</code></pre>\n", "abstract": "Here's a one-line Python command for the Linux command line environment. I find this very handy since I'm not such a hot Bash guy."}, {"id": 27581592, "score": 15, "vote": 0, "content": "<p>You can use the \"OS\" library of Python:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.path.exists(\"C:\\\\Users\\\\####\\\\Desktop\\\\test.txt\") \nTrue\n&gt;&gt;&gt; os.path.exists(\"C:\\\\Users\\\\####\\\\Desktop\\\\test.tx\")\nFalse\n</code></pre>\n", "abstract": "You can use the \"OS\" library of Python:"}, {"id": 40926284, "score": 15, "vote": 0, "content": "<blockquote>\n<p><strong>How do I check whether a file exists, without using the try statement?</strong></p>\n</blockquote>\n<p>In 2016, this is still arguably the easiest way to check if both a file exists and if it is a file:</p>\n<pre><code class=\"python\">import os\nos.path.isfile('./file.txt')    # Returns True if exists, else False\n</code></pre>\n<p><code>isfile</code> is actually just a helper method that internally uses <code>os.stat</code> and <code>stat.S_ISREG(mode)</code> underneath. This <code>os.stat</code> is a lower-level method that will provide you with detailed information about files, directories, sockets, buffers, and more. <a href=\"https://docs.python.org/2/library/os.html#os.stat\" rel=\"noreferrer\">More about os.stat here</a></p>\n<p><strong>Note:</strong> However, this approach will not lock the file in any way and therefore your code can become vulnerable to \"<strong>time of check to time of use</strong>\" (<em>TOCTTOU</em>) bugs.</p>\n<p>So raising exceptions is considered to be an acceptable, and Pythonic, approach for flow control in your program. And one should consider handling missing files with IOErrors, rather than <code>if</code> statements (<em>just an advice</em>).</p>\n", "abstract": "How do I check whether a file exists, without using the try statement? In 2016, this is still arguably the easiest way to check if both a file exists and if it is a file: isfile is actually just a helper method that internally uses os.stat and stat.S_ISREG(mode) underneath. This os.stat is a lower-level method that will provide you with detailed information about files, directories, sockets, buffers, and more. More about os.stat here Note: However, this approach will not lock the file in any way and therefore your code can become vulnerable to \"time of check to time of use\" (TOCTTOU) bugs. So raising exceptions is considered to be an acceptable, and Pythonic, approach for flow control in your program. And one should consider handling missing files with IOErrors, rather than if statements (just an advice)."}, {"id": 31824912, "score": 11, "vote": 0, "content": "<pre><code class=\"python\">import os.path\n\ndef isReadableFile(file_path, file_name):\n    full_path = file_path + \"/\" + file_name\n    try:\n        if not os.path.exists(file_path):\n            print \"File path is invalid.\"\n            return False\n        elif not os.path.isfile(full_path):\n            print \"File does not exist.\"\n            return False\n        elif not os.access(full_path, os.R_OK):\n            print \"File cannot be read.\"\n            return False\n        else:\n            print \"File can be read.\"\n            return True\n    except IOError as ex:\n        print \"I/O error({0}): {1}\".format(ex.errno, ex.strerror)\n    except Error as ex:\n        print \"Error({0}): {1}\".format(ex.errno, ex.strerror)\n    return False\n#------------------------------------------------------\n\npath = \"/usr/khaled/documents/puzzles\"\nfileName = \"puzzle_1.txt\"\n\nisReadableFile(path, fileName)\n</code></pre>\n", "abstract": ""}, {"id": 59923701, "score": 10, "vote": 0, "content": "<p><strong>exists()</strong> and <strong>is_file()</strong> methods of '<strong>Path</strong>' object can be used for checking if a given path exists and is a file.</p>\n<p><strong>Python 3 program to check if a file exists:</strong></p>\n<pre><code class=\"python\"># File name:  check-if-file-exists.py\n\nfrom pathlib import Path\n\nfilePath = Path(input(\"Enter path of the file to be found: \"))\n\nif filePath.exists() and filePath.is_file():\n    print(\"Success: File exists\")\nelse:\n    print(\"Error: File does not exist\")\n</code></pre>\n<p><strong>Output:</strong></p>\n<blockquote>\n<p><strong>$ python3 check-if-file-exists.py</strong> </p>\n<p>Enter path of the file to be found: <strong><em>/Users/macuser1/stack-overflow/index.html</em></strong> </p>\n<p>Success: <strong><em>File exists</em></strong></p>\n<p><strong>$ python3 check-if-file-exists.py</strong> </p>\n<p>Enter path of the file to be found: <strong><em>hghjg jghj</em></strong></p>\n<p>Error: <strong><em>File does not exist</em></strong></p>\n</blockquote>\n", "abstract": "exists() and is_file() methods of 'Path' object can be used for checking if a given path exists and is a file. Python 3 program to check if a file exists: Output: $ python3 check-if-file-exists.py  Enter path of the file to be found: /Users/macuser1/stack-overflow/index.html  Success: File exists $ python3 check-if-file-exists.py  Enter path of the file to be found: hghjg jghj Error: File does not exist"}, {"id": 7201731, "score": 8, "vote": 0, "content": "<pre><code class=\"python\">import os\npath = /path/to/dir\n\nroot,dirs,files = os.walk(path).next()\nif myfile in files:\n   print \"yes it exists\"\n</code></pre>\n<p>This is helpful when checking for several files. Or you want to do a set intersection/ subtraction with an existing list.</p>\n", "abstract": "This is helpful when checking for several files. Or you want to do a set intersection/ subtraction with an existing list."}, {"id": 61754517, "score": 8, "vote": 0, "content": "<p>Use <a href=\"https://www.geeksforgeeks.org/python-os-path-exists-method/\" rel=\"noreferrer\">os.path.exists()</a> to check whether file exists or not:</p>\n<pre><code class=\"python\">def fileAtLocation(filename,path):\n    return os.path.exists(path + filename)\n \n\nfilename=\"dummy.txt\"\npath = \"/home/ie/SachinSaga/scripts/subscription_unit_reader_file/\"\n\n\nif fileAtLocation(filename,path):\n   print('file found at location..')\nelse:\n   print('file not found at location..')\n</code></pre>\n", "abstract": "Use os.path.exists() to check whether file exists or not:"}, {"id": 23826292, "score": 7, "vote": 0, "content": "<p>You can use the following open method to check if a file exists + readable:</p>\n<pre><code class=\"python\">file = open(inputFile, 'r')\nfile.close()\n</code></pre>\n", "abstract": "You can use the following open method to check if a file exists + readable:"}, {"id": 26433646, "score": 7, "vote": 0, "content": "<p>To check if a file exists, </p>\n<pre><code class=\"python\">from sys import argv\n\nfrom os.path import exists\nscript, filename = argv\ntarget = open(filename)\nprint \"file exists: %r\" % exists(filename)\n</code></pre>\n", "abstract": "To check if a file exists, "}, {"id": 37702905, "score": 6, "vote": 0, "content": "<p>You can use os.listdir to check if a file is in a certain directory.</p>\n<pre><code class=\"python\">import os\nif 'file.ext' in os.listdir('dirpath'):\n    #code\n</code></pre>\n", "abstract": "You can use os.listdir to check if a file is in a certain directory."}, {"id": 53084404, "score": 5, "vote": 0, "content": "<p>Use:</p>\n<pre><code class=\"python\">import os\n\n# For testing purposes the arguments defaulted to the current folder and file.\n# returns True if file found\ndef file_exists(FOLDER_PATH='../', FILE_NAME=__file__):\n    return os.path.isdir(FOLDER_PATH) \\\n        and os.path.isfile(os.path.join(FOLDER_PATH, FILE_NAME))\n</code></pre>\n<p>It is basically a folder check, and then a file check with the proper directory separator using <em><a href=\"https://docs.python.org/3.8/library/os.path.html#os.path.join\" rel=\"nofollow noreferrer\">os.path.join</a></em>.</p>\n", "abstract": "Use: It is basically a folder check, and then a file check with the proper directory separator using os.path.join."}, {"id": 66993660, "score": 3, "vote": 0, "content": "<p>Another possible option is to check whether the filename is in the directory using os.listdir():</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import os\nif 'foo.txt' in os.listdir():\n    # Do things\n</code></pre>\n<p>This will return true if it is and false if not.</p>\n", "abstract": "Another possible option is to check whether the filename is in the directory using os.listdir(): This will return true if it is and false if not."}, {"id": 73083229, "score": 0, "vote": 0, "content": "<p>This is how I found a list of files (in these images) in one folder and searched it in a folder (with subfolders):</p>\n<pre><code class=\"python\"># This script concatenates JavaScript files into a unified JavaScript file to reduce server round-trips\n\nimport os\nimport string\nimport math\nimport ntpath\nimport sys\n\n#import pyodbc\n\nimport gzip\nimport shutil\n\nimport hashlib\n\n# BUF_SIZE is totally arbitrary, change for your app!\nBUF_SIZE = 65536  # Let\u2019s read stuff in 64 kilobyte chunks\n\n# Iterate over all JavaScript files in the folder and combine them\nfilenames = []\nshortfilenames = []\n\nimgfilenames = []\nimgshortfilenames = []\n\n# Get a unified path so we can stop dancing with user paths.\n# Determine where files are on this machine (%TEMP% directory and application installation directory)\nif '.exe' in sys.argv[0]: # if getattr(sys, 'frozen', False):\n    RootPath = os.path.abspath(os.path.join(__file__, \"..\\\\\"))\n\nelif __file__:\n    RootPath = os.path.abspath(os.path.join(__file__, \"..\\\\\"))\n\nprint (\"\\n storage of image files RootPath: %s\\n\" %RootPath)\n\nFolderPath = \"D:\\\\TFS-FARM1\\\\StoneSoup_STS\\\\SDLC\\\\Build\\\\Code\\\\StoneSoup_Refactor\\\\StoneSoupUI\\\\Images\"\nprint (\"\\n storage of image files in folder to search: %s\\n\" %FolderPath)\n\nfor root, directories, filenames2 in os.walk(FolderPath):\n    for filename in filenames2:\n        fullname = os.path.join(root, filename)\n        filenames.append(fullname)\n        shortfilenames.append(filename)\n\nfor i, fname in enumerate(shortfilenames):\n        print(\"%s - %s\" % (i+1, fname))\n\nfor root, directories, filenames2 in os.walk(RootPath):\n    for filename in filenames2:\n        fullname = os.path.join(root, filename)\n        imgfilenames.append(fullname)\n        imgshortfilenames.append(filename)\n\nfor i, fname in enumerate(imgshortfilenames):\n        print(\"%s - %s\" % (i+1, fname))\n\nfor i, fname in enumerate(imgshortfilenames):\n        if fname in shortfilenames:\n            print(\"%s - %s exists\" % (i+1, fname))\n        else:\n            print(\"%s - %s ABSENT\" % (i+1, fname))\n</code></pre>\n", "abstract": "This is how I found a list of files (in these images) in one folder and searched it in a folder (with subfolders):"}]}, {"link": "https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression", "question": {"id": "38987", "title": "How do I merge two dictionaries in a single expression?", "content": "<p>I want to merge two dictionaries into a new dictionary.</p>\n<pre><code class=\"python\">x = {'a': 1, 'b': 2}\ny = {'b': 3, 'c': 4}\nz = merge(x, y)\n\n&gt;&gt;&gt; z\n{'a': 1, 'b': 3, 'c': 4}\n</code></pre>\n<p>Whenever a key <code>k</code> is present in both dictionaries, only the value <code>y[k]</code> should be kept.</p>\n", "abstract": "I want to merge two dictionaries into a new dictionary. Whenever a key k is present in both dictionaries, only the value y[k] should be kept."}, "answers": [{"id": 26853961, "score": 8367, "vote": 0, "content": "<h2>How can I merge two Python dictionaries in a single expression?</h2>\n<p>For dictionaries <code>x</code> and <code>y</code>, their shallowly-merged dictionary <code>z</code> takes values from <code>y</code>, replacing those from <code>x</code>.</p>\n<ul>\n<li><p>In Python 3.9.0 or greater (released 17 October 2020, <a href=\"https://www.python.org/dev/peps/pep-0584/\" rel=\"noreferrer\"><code>PEP-584</code></a>, <a href=\"https://bugs.python.org/issue36144\" rel=\"noreferrer\">discussed here</a>):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = x | y\n</code></pre>\n</li>\n<li><p>In Python 3.5 or greater:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = {**x, **y}\n</code></pre>\n</li>\n<li><p>In Python 2, (or 3.4 or lower) write a function:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def merge_two_dicts(x, y):\n    z = x.copy()   # start with keys and values of x\n    z.update(y)    # modifies z with keys and values of y\n    return z\n</code></pre>\n<p>and now:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = merge_two_dicts(x, y)\n</code></pre>\n</li>\n</ul>\n<h3>Explanation</h3>\n<p>Say you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">x = {'a': 1, 'b': 2}\ny = {'b': 3, 'c': 4}\n</code></pre>\n<p>The desired result is to get a new dictionary (<code>z</code>) with the values merged, and the second dictionary's values overwriting those from the first.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; z\n{'a': 1, 'b': 3, 'c': 4}\n</code></pre>\n<p>A new syntax for this, proposed in <a href=\"https://www.python.org/dev/peps/pep-0448\" rel=\"noreferrer\">PEP 448</a> and <a href=\"https://mail.python.org/pipermail/python-dev/2015-February/138564.html\" rel=\"noreferrer\">available as of Python 3.5</a>, is</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = {**x, **y}\n</code></pre>\n<p>And it is indeed a single expression.</p>\n<p>Note that we can merge in with literal notation as well:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = {**x, 'foo': 1, 'bar': 2, **y}\n</code></pre>\n<p>and now:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; z\n{'a': 1, 'b': 3, 'foo': 1, 'bar': 2, 'c': 4}\n</code></pre>\n<p>It is now showing as implemented in the <a href=\"https://www.python.org/dev/peps/pep-0478/#features-for-3-5\" rel=\"noreferrer\">release schedule for 3.5, PEP 478</a>, and it has now made its way into the <a href=\"https://docs.python.org/dev/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations\" rel=\"noreferrer\">What's New in Python 3.5</a> document.</p>\n<p>However, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = x.copy()\nz.update(y) # which returns None since it mutates z\n</code></pre>\n<p>In both approaches, <code>y</code> will come second and its values will replace <code>x</code>'s values, thus <code>b</code> will point to <code>3</code> in our final result.</p>\n<h2>Not yet on Python 3.5, but want a <em>single expression</em></h2>\n<p>If you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a <em>single expression</em>, the most performant while the correct approach is to put it in a function:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def merge_two_dicts(x, y):\n    \"\"\"Given two dictionaries, merge them into a new dict as a shallow copy.\"\"\"\n    z = x.copy()\n    z.update(y)\n    return z\n</code></pre>\n<p>and then you have a single expression:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = merge_two_dicts(x, y)\n</code></pre>\n<p>You can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def merge_dicts(*dict_args):\n    \"\"\"\n    Given any number of dictionaries, shallow copy and merge into a new dict,\n    precedence goes to key-value pairs in latter dictionaries.\n    \"\"\"\n    result = {}\n    for dictionary in dict_args:\n        result.update(dictionary)\n    return result\n</code></pre>\n<p>This function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries <code>a</code> to <code>g</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = merge_dicts(a, b, c, d, e, f, g) \n</code></pre>\n<p>and key-value pairs in <code>g</code> will take precedence over dictionaries <code>a</code> to <code>f</code>, and so on.</p>\n<h2>Critiques of Other Answers</h2>\n<p>Don't use what you see in the formerly accepted answer:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = dict(x.items() + y.items())\n</code></pre>\n<p>In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. <strong>In Python 3, this will fail</strong> because you're adding two <code>dict_items</code> objects together, not two lists -</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; c = dict(a.items() + b.items())\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for +: 'dict_items' and 'dict_items'\n</code></pre>\n<p>and you would have to explicitly create them as lists, e.g. <code>z = dict(list(x.items()) + list(y.items()))</code>. This is a waste of resources and computation power.</p>\n<p>Similarly, taking the union of <code>items()</code> in Python 3 (<code>viewitems()</code> in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, <strong>since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; c = dict(a.items() | b.items())\n</code></pre>\n<p>This example demonstrates what happens when values are unhashable:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; x = {'a': []}\n&gt;&gt;&gt; y = {'b': []}\n&gt;&gt;&gt; dict(x.items() | y.items())\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\n</code></pre>\n<p>Here's an example where <code>y</code> should have precedence, but instead the value from <code>x</code> is retained due to the arbitrary order of sets:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; x = {'a': 2}\n&gt;&gt;&gt; y = {'a': 1}\n&gt;&gt;&gt; dict(x.items() | y.items())\n{'a': 2}\n</code></pre>\n<p>Another hack you should not use:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = dict(x, **y)\n</code></pre>\n<p>This uses the <code>dict</code> constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.</p>\n<p>Here's an example of the usage being <a href=\"https://code.djangoproject.com/attachment/ticket/13357/django-pypy.2.diff\" rel=\"noreferrer\">remediated in django</a>.</p>\n<p>Dictionaries are intended to take hashable keys (e.g. <code>frozenset</code>s or tuples), but <strong>this method fails in Python 3 when keys are not strings.</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; c = dict(a, **b)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: keyword arguments must be strings\n</code></pre>\n<p>From the <a href=\"https://mail.python.org/pipermail/python-dev/2010-April/099459.html\" rel=\"noreferrer\">mailing list</a>, Guido van Rossum, the creator of the language, wrote:</p>\n<blockquote>\n<p>I am fine with\ndeclaring dict({}, **{1:3}) illegal, since after all it is abuse of\nthe ** mechanism.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p>Apparently dict(x, **y) is going around as \"cool hack\" for \"call\nx.update(y) and return x\". Personally, I find it more despicable than\ncool.</p>\n</blockquote>\n<p>It is my understanding (as well as the understanding of the <a href=\"https://mail.python.org/pipermail/python-dev/2010-April/099485.html\" rel=\"noreferrer\">creator of the language</a>) that the intended usage for <code>dict(**y)</code> is for creating dictionaries for readability purposes, e.g.:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">dict(a=1, b=10, c=11)\n</code></pre>\n<p>instead of</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">{'a': 1, 'b': 10, 'c': 11}\n</code></pre>\n<h2>Response to comments</h2>\n<blockquote>\n<p>Despite what Guido says, <code>dict(x, **y)</code> is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords.</p>\n</blockquote>\n<p>Again, it doesn't work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. <code>dict</code> broke this consistency in Python 2:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; foo(**{('a', 'b'): None})\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: foo() keywords must be strings\n&gt;&gt;&gt; dict(**{('a', 'b'): None})\n{('a', 'b'): None}\n</code></pre>\n<p>This inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.</p>\n<p>I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.</p>\n<p>More comments:</p>\n<blockquote>\n<p><code>dict(x.items() + y.items())</code> is still the most readable solution for Python 2. Readability counts.</p>\n</blockquote>\n<p>My response: <code>merge_two_dicts(x, y)</code> actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.</p>\n<blockquote>\n<p><code>{**x, **y}</code> does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word \"merging\" these answers describe \"updating one dict with another\", and not merging.</p>\n</blockquote>\n<p>Yes. I must refer you back to the question, which is asking for a <em>shallow</em> merge of <em><strong>two</strong></em> dictionaries, with the first's values being overwritten by the second's - in a single expression.</p>\n<p>Assuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from copy import deepcopy\n\ndef dict_of_dicts_merge(x, y):\n    z = {}\n    overlapping_keys = x.keys() &amp; y.keys()\n    for key in overlapping_keys:\n        z[key] = dict_of_dicts_merge(x[key], y[key])\n    for key in x.keys() - overlapping_keys:\n        z[key] = deepcopy(x[key])\n    for key in y.keys() - overlapping_keys:\n        z[key] = deepcopy(y[key])\n    return z\n</code></pre>\n<p>Usage:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; x = {'a':{1:{}}, 'b': {2:{}}}\n&gt;&gt;&gt; y = {'b':{10:{}}, 'c': {11:{}}}\n&gt;&gt;&gt; dict_of_dicts_merge(x, y)\n{'b': {2: {}, 10: {}}, 'a': {1: {}}, 'c': {11: {}}}\n</code></pre>\n<p>Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at <a href=\"https://stackoverflow.com/a/24088493/541136\">my answer to the canonical question on a \"Dictionaries of dictionaries merge\"</a>.</p>\n<h2>Less Performant But Correct Ad-hocs</h2>\n<p>These approaches are less performant, but they will provide correct behavior.\nThey will be <em>much less</em> performant than <code>copy</code> and <code>update</code> or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they <em>do</em> respect the order of precedence (latter dictionaries have precedence)</p>\n<p>You can also chain the dictionaries manually inside a <a href=\"https://www.python.org/dev/peps/pep-0274/\" rel=\"noreferrer\">dict comprehension</a>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">{k: v for d in dicts for k, v in d.items()} # iteritems in Python 2.7\n</code></pre>\n<p>or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">dict((k, v) for d in dicts for k, v in d.items()) # iteritems in Python 2\n</code></pre>\n<p><code>itertools.chain</code> will chain the iterators over the key-value pairs in the correct order:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from itertools import chain\nz = dict(chain(x.items(), y.items())) # iteritems in Python 2\n</code></pre>\n<h2>Performance Analysis</h2>\n<p>I'm only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from timeit import repeat\nfrom itertools import chain\n\nx = dict.fromkeys('abcdefg')\ny = dict.fromkeys('efghijk')\n\ndef merge_two_dicts(x, y):\n    z = x.copy()\n    z.update(y)\n    return z\n\nmin(repeat(lambda: {**x, **y}))\nmin(repeat(lambda: merge_two_dicts(x, y)))\nmin(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\nmin(repeat(lambda: dict(chain(x.items(), y.items()))))\nmin(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n</code></pre>\n<p>In Python 3.8.1, NixOS:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; min(repeat(lambda: {**x, **y}))\n1.0804965235292912\n&gt;&gt;&gt; min(repeat(lambda: merge_two_dicts(x, y)))\n1.636518670246005\n&gt;&gt;&gt; min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\n3.1779992282390594\n&gt;&gt;&gt; min(repeat(lambda: dict(chain(x.items(), y.items()))))\n2.740647904574871\n&gt;&gt;&gt; min(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n4.266070580109954\n</code></pre>\n<pre class=\"lang-sh prettyprint-override\"><code class=\"python\">$ uname -a\nLinux nixos 4.19.113 #1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU/Linux\n</code></pre>\n<h2>Resources on Dictionaries</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented/44509302#44509302\">My explanation of Python's <strong>dictionary implementation</strong>, updated for 3.6.</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1024847/add-new-keys-to-a-dictionary/27208535#27208535\">Answer on how to add new keys to a dictionary</a></li>\n<li><a href=\"https://stackoverflow.com/questions/209840/map-two-lists-into-a-dictionary-in-python/33737067#33737067\">Mapping two lists into a dictionary</a></li>\n<li><a href=\"https://docs.python.org/3/tutorial/datastructures.html#dictionaries\" rel=\"noreferrer\">The official Python docs on dictionaries</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=66P5FMkWoVU\" rel=\"noreferrer\">The Dictionary Even Mightier</a> - talk by Brandon Rhodes at Pycon 2017</li>\n<li><a href=\"https://www.youtube.com/watch?v=npw4s1QTmPg\" rel=\"noreferrer\">Modern Python Dictionaries, A Confluence of Great Ideas</a> - talk by Raymond Hettinger at Pycon 2017</li>\n</ul>\n", "abstract": "For dictionaries x and y, their shallowly-merged dictionary z takes values from y, replacing those from x. In Python 3.9.0 or greater (released 17 October 2020, PEP-584, discussed here): In Python 3.5 or greater: In Python 2, (or 3.4 or lower) write a function: and now: Say you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries: The desired result is to get a new dictionary (z) with the values merged, and the second dictionary's values overwriting those from the first. A new syntax for this, proposed in PEP 448 and available as of Python 3.5, is And it is indeed a single expression. Note that we can merge in with literal notation as well: and now: It is now showing as implemented in the release schedule for 3.5, PEP 478, and it has now made its way into the What's New in Python 3.5 document. However, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process: In both approaches, y will come second and its values will replace x's values, thus b will point to 3 in our final result. If you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a single expression, the most performant while the correct approach is to put it in a function: and then you have a single expression: You can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number: This function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries a to g: and key-value pairs in g will take precedence over dictionaries a to f, and so on. Don't use what you see in the formerly accepted answer: In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. In Python 3, this will fail because you're adding two dict_items objects together, not two lists - and you would have to explicitly create them as lists, e.g. z = dict(list(x.items()) + list(y.items())). This is a waste of resources and computation power. Similarly, taking the union of items() in Python 3 (viewitems() in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, since sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this: This example demonstrates what happens when values are unhashable: Here's an example where y should have precedence, but instead the value from x is retained due to the arbitrary order of sets: Another hack you should not use: This uses the dict constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic. Here's an example of the usage being remediated in django. Dictionaries are intended to take hashable keys (e.g. frozensets or tuples), but this method fails in Python 3 when keys are not strings. From the mailing list, Guido van Rossum, the creator of the language, wrote: I am fine with\ndeclaring dict({}, **{1:3}) illegal, since after all it is abuse of\nthe ** mechanism. and Apparently dict(x, **y) is going around as \"cool hack\" for \"call\nx.update(y) and return x\". Personally, I find it more despicable than\ncool. It is my understanding (as well as the understanding of the creator of the language) that the intended usage for dict(**y) is for creating dictionaries for readability purposes, e.g.: instead of Despite what Guido says, dict(x, **y) is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords. Again, it doesn't work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. dict broke this consistency in Python 2: This inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change. I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints. More comments: dict(x.items() + y.items()) is still the most readable solution for Python 2. Readability counts. My response: merge_two_dicts(x, y) actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated. {**x, **y} does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word \"merging\" these answers describe \"updating one dict with another\", and not merging. Yes. I must refer you back to the question, which is asking for a shallow merge of two dictionaries, with the first's values being overwritten by the second's - in a single expression. Assuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them: Usage: Coming up with contingencies for other value types is far beyond the scope of this question, so I will point you at my answer to the canonical question on a \"Dictionaries of dictionaries merge\". These approaches are less performant, but they will provide correct behavior.\nThey will be much less performant than copy and update or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they do respect the order of precedence (latter dictionaries have precedence) You can also chain the dictionaries manually inside a dict comprehension: or in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced): itertools.chain will chain the iterators over the key-value pairs in the correct order: I'm only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.) In Python 3.8.1, NixOS:"}, {"id": 38990, "score": 1772, "vote": 0, "content": "<p>In your case, you can do:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">z = dict(list(x.items()) + list(y.items()))\n</code></pre>\n<p>This will, as you want it, put the final dict in <code>z</code>, and make the value for key <code>b</code> be properly overridden by the second (<code>y</code>) dict's value:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; z = dict(list(x.items()) + list(y.items()))\n&gt;&gt;&gt; z\n{'a': 1, 'c': 11, 'b': 10}\n\n</code></pre>\n<p>If you use Python 2, you can even remove the <code>list()</code> calls. To create z:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; z = dict(x.items() + y.items())\n&gt;&gt;&gt; z\n{'a': 1, 'c': 11, 'b': 10}\n</code></pre>\n<p>If you use Python version 3.9.0a4 or greater, then you can directly use:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">x = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\nz = x | y\nprint(z)\n</code></pre>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">{'a': 1, 'c': 11, 'b': 10}\n</code></pre>\n", "abstract": "In your case, you can do: This will, as you want it, put the final dict in z, and make the value for key b be properly overridden by the second (y) dict's value: If you use Python 2, you can even remove the list() calls. To create z: If you use Python version 3.9.0a4 or greater, then you can directly use:"}, {"id": 39437, "score": 735, "vote": 0, "content": "<p>An alternative:</p>\n<pre><code class=\"python\">z = x.copy()\nz.update(y)\n</code></pre>\n", "abstract": "An alternative:"}, {"id": 39858, "score": 426, "vote": 0, "content": "<p>Another, more concise, option:</p>\n<pre><code class=\"python\">z = dict(x, **y)\n</code></pre>\n<p><strong>Note</strong>: this has become a popular answer, but it is important to point out that if <code>y</code> has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, <a href=\"http://mail.python.org/pipermail/python-dev/2010-April/099459.html\" rel=\"noreferrer\">Guido is not a fan</a>. So I can't recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.</p>\n", "abstract": "Another, more concise, option: Note: this has become a popular answer, but it is important to point out that if y has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, Guido is not a fan. So I can't recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely."}, {"id": 49492, "score": 253, "vote": 0, "content": "<p>This probably won't be a popular answer, but you almost certainly do not want to do this.  If you want a copy that's a merge, then use copy (or <a href=\"https://docs.python.org/2/library/copy.html\" rel=\"noreferrer\">deepcopy</a>, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.</p>\n<p>In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.</p>\n<p>In terms of <a href=\"https://docs.python.org/2/library/timeit.html\" rel=\"noreferrer\">time</a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; timeit.Timer(\"dict(x, **y)\", \"x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\").timeit(100000)\n15.52571702003479\n&gt;&gt;&gt; timeit.Timer(\"temp = x.copy()\\ntemp.update(y)\", \"x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\").timeit(100000)\n15.694622993469238\n&gt;&gt;&gt; timeit.Timer(\"dict(x.items() + y.items())\", \"x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\").timeit(100000)\n41.484580039978027\n</code></pre>\n<p>IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.</p>\n", "abstract": "This probably won't be a popular answer, but you almost certainly do not want to do this.  If you want a copy that's a merge, then use copy (or deepcopy, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit. In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item. In terms of time: IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions."}, {"id": 228366, "score": 189, "vote": 0, "content": "<p>In a follow-up answer, you asked about the relative performance of these two alternatives:</p>\n<pre><code class=\"python\">z1 = dict(x.items() + y.items())\nz2 = dict(x, **y)\n</code></pre>\n<p>On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative <code>z2</code> is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the <code>timeit</code> module that comes with Python.</p>\n<p>Example 1: identical dictionaries mapping 20 consecutive integers to themselves:</p>\n<pre><code class=\"python\">% python -m timeit -s 'x=y=dict((i,i) for i in range(20))' 'z1=dict(x.items() + y.items())'\n100000 loops, best of 3: 5.67 usec per loop\n% python -m timeit -s 'x=y=dict((i,i) for i in range(20))' 'z2=dict(x, **y)' \n100000 loops, best of 3: 1.53 usec per loop\n</code></pre>\n<p><code>z2</code> wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but <code>z2</code> always seems to come out ahead.  (If you get inconsistent results for the <em>same</em> test, try passing in <code>-r</code> with a number larger than the default 3.)</p>\n<p>Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:</p>\n<pre><code class=\"python\">% python -m timeit -s 'from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z1=dict(x.items() + y.items())'\n1000 loops, best of 3: 260 usec per loop\n% python -m timeit -s 'from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z2=dict(x, **y)'               \n10000 loops, best of 3: 26.9 usec per loop\n</code></pre>\n<p><code>z2</code> wins by about a factor of 10.  That's a pretty big win in my book!</p>\n<p>After comparing those two, I wondered if <code>z1</code>'s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:</p>\n<pre><code class=\"python\">from itertools import chain\nz3 = dict(chain(x.iteritems(), y.iteritems()))\n</code></pre>\n<p>A few quick tests, e.g.</p>\n<pre><code class=\"python\">% python -m timeit -s 'from itertools import chain; from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z3=dict(chain(x.iteritems(), y.iteritems()))'\n10000 loops, best of 3: 66 usec per loop\n</code></pre>\n<p>lead me to conclude that <code>z3</code> is somewhat faster than <code>z1</code>, but not nearly as fast as <code>z2</code>.  Definitely not worth all the extra typing.</p>\n<p>This discussion is still missing something important, which is a performance comparison of these alternatives with the \"obvious\" way of merging two lists: using the <code>update</code> method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I'm going to make a copy of x instead of modifying it in-place, as follows:</p>\n<pre><code class=\"python\">z0 = dict(x)\nz0.update(y)\n</code></pre>\n<p>A typical result:</p>\n<pre><code class=\"python\">% python -m timeit -s 'from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z0=dict(x); z0.update(y)'\n10000 loops, best of 3: 26.9 usec per loop\n</code></pre>\n<p>In other words, <code>z0</code> and <code>z2</code> seem to have essentially identical performance.  Do you think this might be a coincidence?  I don't....</p>\n<p>In fact, I'd go so far as to claim that it's impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses <code>dict</code> in lots of places; optimizing its operations is a big deal.</p>\n<p>You could also write this as</p>\n<pre><code class=\"python\">z0 = x.copy()\nz0.update(y)\n</code></pre>\n<p>as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he's absolutely correct to point out that the two-statement version is much easier to understand.</p>\n", "abstract": "In a follow-up answer, you asked about the relative performance of these two alternatives: On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative z2 is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the timeit module that comes with Python. Example 1: identical dictionaries mapping 20 consecutive integers to themselves: z2 wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but z2 always seems to come out ahead.  (If you get inconsistent results for the same test, try passing in -r with a number larger than the default 3.) Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa: z2 wins by about a factor of 10.  That's a pretty big win in my book! After comparing those two, I wondered if z1's poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better: A few quick tests, e.g. lead me to conclude that z3 is somewhat faster than z1, but not nearly as fast as z2.  Definitely not worth all the extra typing. This discussion is still missing something important, which is a performance comparison of these alternatives with the \"obvious\" way of merging two lists: using the update method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I'm going to make a copy of x instead of modifying it in-place, as follows: A typical result: In other words, z0 and z2 seem to have essentially identical performance.  Do you think this might be a coincidence?  I don't.... In fact, I'd go so far as to claim that it's impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses dict in lots of places; optimizing its operations is a big deal. You could also write this as as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he's absolutely correct to point out that the two-statement version is much easier to understand."}, {"id": 16259217, "score": 185, "vote": 0, "content": "<p><strong>In Python 3.0 and later</strong>, you can use <a href=\"http://docs.python.org/3/library/collections.html#collections.ChainMap\" rel=\"noreferrer\"><code>collections.ChainMap</code></a> which groups multiple dicts or other mappings together to create a single, updateable view:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from collections import ChainMap\n&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; z = dict(ChainMap({}, y, x))\n&gt;&gt;&gt; for k, v in z.items():\n        print(k, '--&gt;', v)\n    \na --&gt; 1\nb --&gt; 10\nc --&gt; 11\n</code></pre>\n<p><strong>Update for Python 3.5 and later</strong>: You can use <a href=\"https://www.python.org/dev/peps/pep-0448/\" rel=\"noreferrer\">PEP 448</a> extended dictionary packing and unpacking.  This is fast and easy:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; {**x, **y}\n{'a': 1, 'b': 10, 'c': 11}\n</code></pre>\n<p><strong>Update for Python 3.9 and later</strong>:  You can use the <a href=\"https://www.python.org/dev/peps/pep-0584/\" rel=\"noreferrer\">PEP 584</a> union operator:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; x | y\n{'a': 1, 'b': 10, 'c': 11}\n</code></pre>\n", "abstract": "In Python 3.0 and later, you can use collections.ChainMap which groups multiple dicts or other mappings together to create a single, updateable view: Update for Python 3.5 and later: You can use PEP 448 extended dictionary packing and unpacking.  This is fast and easy: Update for Python 3.9 and later:  You can use the PEP 584 union operator:"}, {"id": 44512, "score": 153, "vote": 0, "content": "<p>I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.</p>\n<pre><code class=\"python\">def merge(d1, d2, merge_fn=lambda x,y:y):\n    \"\"\"\n    Merges two dictionaries, non-destructively, combining \n    values on duplicate keys as defined by the optional merge\n    function.  The default behavior replaces the values in d1\n    with corresponding values in d2.  (There is no other generally\n    applicable merge strategy, but often you'll have homogeneous \n    types in your dicts, so specifying a merge technique can be \n    valuable.)\n\n    Examples:\n\n    &gt;&gt;&gt; d1\n    {'a': 1, 'c': 3, 'b': 2}\n    &gt;&gt;&gt; merge(d1, d1)\n    {'a': 1, 'c': 3, 'b': 2}\n    &gt;&gt;&gt; merge(d1, d1, lambda x,y: x+y)\n    {'a': 2, 'c': 6, 'b': 4}\n\n    \"\"\"\n    result = dict(d1)\n    for k,v in d2.iteritems():\n        if k in result:\n            result[k] = merge_fn(result[k], v)\n        else:\n            result[k] = v\n    return result\n</code></pre>\n", "abstract": "I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call."}, {"id": 8310229, "score": 122, "vote": 0, "content": "<h1>Recursively/deep update a dict</h1>\n<pre><code class=\"python\">def deepupdate(original, update):\n    \"\"\"\n    Recursively update a dict.\n    Subdict's won't be overwritten but also updated.\n    \"\"\"\n    for key, value in original.iteritems(): \n        if key not in update:\n            update[key] = value\n        elif isinstance(value, dict):\n            deepupdate(value, update[key]) \n    return update</code></pre>\n<p>Demonstration:</p>\n<pre><code class=\"python\">pluto_original = {\n    'name': 'Pluto',\n    'details': {\n        'tail': True,\n        'color': 'orange'\n    }\n}\n\npluto_update = {\n    'name': 'Pluutoo',\n    'details': {\n        'color': 'blue'\n    }\n}\n\nprint deepupdate(pluto_original, pluto_update)</code></pre>\n<p>Outputs:</p>\n<pre><code class=\"python\">{\n    'name': 'Pluutoo',\n    'details': {\n        'color': 'blue',\n        'tail': True\n    }\n}</code></pre>\n<p>Thanks rednaw for edits.</p>\n", "abstract": "Demonstration: Outputs: Thanks rednaw for edits."}, {"id": 28753078, "score": 100, "vote": 0, "content": "<p>Python 3.5 (PEP 448) allows a nicer syntax option:</p>\n<pre><code class=\"python\">x = {'a': 1, 'b': 1}\ny = {'a': 2, 'c': 2}\nfinal = {**x, **y} \nfinal\n# {'a': 2, 'b': 1, 'c': 2}\n</code></pre>\n<p>Or even </p>\n<pre><code class=\"python\">final = {'a': 1, 'b': 1, **x, **y}\n</code></pre>\n<p>In Python 3.9 you also use | and |= with the below example from PEP 584</p>\n<pre><code class=\"python\">d = {'spam': 1, 'eggs': 2, 'cheese': 3}\ne = {'cheese': 'cheddar', 'aardvark': 'Ethel'}\nd | e\n# {'spam': 1, 'eggs': 2, 'cheese': 'cheddar', 'aardvark': 'Ethel'}\n</code></pre>\n", "abstract": "Python 3.5 (PEP 448) allows a nicer syntax option: Or even  In Python 3.9 you also use | and |= with the below example from PEP 584"}, {"id": 3936548, "score": 96, "vote": 0, "content": "<p>The best version I could think while not using copy would be:</p>\n<pre><code class=\"python\">from itertools import chain\nx = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\ndict(chain(x.iteritems(), y.iteritems()))\n</code></pre>\n<p>It's faster than <code>dict(x.items() + y.items())</code> but not as fast as <code>n = copy(a); n.update(b)</code>, at least on CPython. This version also works in Python 3 if you change <code>iteritems()</code> to <code>items()</code>, which is automatically done by the 2to3 tool.</p>\n<p>Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn't make completely obvious that values from y takes precedence over values from x, but I don't believe it's difficult to figure that out.</p>\n", "abstract": "The best version I could think while not using copy would be: It's faster than dict(x.items() + y.items()) but not as fast as n = copy(a); n.update(b), at least on CPython. This version also works in Python 3 if you change iteritems() to items(), which is automatically done by the 2to3 tool. Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn't make completely obvious that values from y takes precedence over values from x, but I don't believe it's difficult to figure that out."}, {"id": 38989, "score": 94, "vote": 0, "content": "<pre><code class=\"python\">x = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\nz = dict(x.items() + y.items())\nprint z\n</code></pre>\n<p>For items with keys in both dictionaries ('b'), you can control which one ends up in the output by putting that one last.</p>\n", "abstract": "For items with keys in both dictionaries ('b'), you can control which one ends up in the output by putting that one last."}, {"id": 7770473, "score": 73, "vote": 0, "content": "<p>While the question has already been answered several times,\nthis simple solution to the problem has not been listed yet.</p>\n<pre><code class=\"python\">x = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\nz4 = {}\nz4.update(x)\nz4.update(y)\n</code></pre>\n<p>It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.</p>\n", "abstract": "While the question has already been answered several times,\nthis simple solution to the problem has not been listed yet. It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change."}, {"id": 11825563, "score": 66, "vote": 0, "content": "<pre><code class=\"python\">def dict_merge(a, b):\n  c = a.copy()\n  c.update(b)\n  return c\n\nnew = dict_merge(old, extras)\n</code></pre>\n<p>Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life <em>Guido van Rossum</em> himself!  Someone else suggested half of this, but did not put it in a function.</p>\n<pre><code class=\"python\">print dict_merge(\n      {'color':'red', 'model':'Mini'},\n      {'model':'Ferrari', 'owner':'Carl'})\n</code></pre>\n<p>gives:</p>\n<pre><code class=\"python\">{'color': 'red', 'owner': 'Carl', 'model': 'Ferrari'}\n</code></pre>\n", "abstract": "Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life Guido van Rossum himself!  Someone else suggested half of this, but did not put it in a function. gives:"}, {"id": 8247023, "score": 59, "vote": 0, "content": "<p>If you think lambdas are evil then read no further.\nAs requested, you can write the fast and memory-efficient solution with one expression:</p>\n<pre><code class=\"python\">x = {'a':1, 'b':2}\ny = {'b':10, 'c':11}\nz = (lambda a, b: (lambda a_copy: a_copy.update(b) or a_copy)(a.copy()))(x, y)\nprint z\n{'a': 1, 'c': 11, 'b': 10}\nprint x\n{'a': 1, 'b': 2}\n</code></pre>\n<p>As suggested above, using two lines or writing a function is probably a better way to go.</p>\n", "abstract": "If you think lambdas are evil then read no further.\nAs requested, you can write the fast and memory-efficient solution with one expression: As suggested above, using two lines or writing a function is probably a better way to go."}, {"id": 34899183, "score": 59, "vote": 0, "content": "<p>Be Pythonic. Use a <a href=\"https://docs.python.org/2/tutorial/datastructures.html#dictionaries\" rel=\"nofollow noreferrer\">comprehension</a>:</p>\n<pre><code class=\"python\">z={k: v for d in [x,y] for k, v in d.items()}\n\n&gt;&gt;&gt; print z\n{'a': 1, 'c': 11, 'b': 10}\n</code></pre>\n", "abstract": "Be Pythonic. Use a comprehension:"}, {"id": 19279501, "score": 46, "vote": 0, "content": "<p>In python3, the <code>items</code> method <a href=\"http://docs.python.org/dev/whatsnew/3.0.html#views-and-iterators-instead-of-lists\" rel=\"noreferrer\">no longer returns a list</a>, but rather a <em>view</em>, which acts like a set. In this case you'll need to take the set union since concatenating with <code>+</code> won't work:</p>\n<pre><code class=\"python\">dict(x.items() | y.items())\n</code></pre>\n<p>For python3-like behavior in version 2.7, the <code>viewitems</code> method should work in place of <code>items</code>:</p>\n<pre><code class=\"python\">dict(x.viewitems() | y.viewitems())\n</code></pre>\n<p>I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).</p>\n<p><strong>Edit:</strong></p>\n<p>A couple more points for python 3. First, note that the <code>dict(x, **y)</code> trick won't work in python 3 unless the keys in <code>y</code> are strings.</p>\n<p>Also, Raymond Hettinger's Chainmap <a href=\"https://stackoverflow.com/a/16259217/386279\">answer</a> is pretty elegant, since it can take an arbitrary number of dicts as arguments, but <a href=\"http://docs.python.org/dev/library/collections\" rel=\"noreferrer\">from the docs</a> it looks like it sequentially looks through a list of all the dicts for each lookup:</p>\n<blockquote>\n<p>Lookups search the underlying mappings successively until a key is found.</p>\n</blockquote>\n<p>This can slow you down if you have a lot of lookups in your application:</p>\n<pre><code class=\"python\">In [1]: from collections import ChainMap\nIn [2]: from string import ascii_uppercase as up, ascii_lowercase as lo; x = dict(zip(lo, up)); y = dict(zip(up, lo))\nIn [3]: chainmap_dict = ChainMap(y, x)\nIn [4]: union_dict = dict(x.items() | y.items())\nIn [5]: timeit for k in union_dict: union_dict[k]\n100000 loops, best of 3: 2.15 \u00b5s per loop\nIn [6]: timeit for k in chainmap_dict: chainmap_dict[k]\n10000 loops, best of 3: 27.1 \u00b5s per loop\n</code></pre>\n<p>So about an order of magnitude slower for lookups. I'm a fan of Chainmap, but looks less practical where there may be many lookups.</p>\n", "abstract": "In python3, the items method no longer returns a list, but rather a view, which acts like a set. In this case you'll need to take the set union since concatenating with + won't work: For python3-like behavior in version 2.7, the viewitems method should work in place of items: I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows). Edit: A couple more points for python 3. First, note that the dict(x, **y) trick won't work in python 3 unless the keys in y are strings. Also, Raymond Hettinger's Chainmap answer is pretty elegant, since it can take an arbitrary number of dicts as arguments, but from the docs it looks like it sequentially looks through a list of all the dicts for each lookup: Lookups search the underlying mappings successively until a key is found. This can slow you down if you have a lot of lookups in your application: So about an order of magnitude slower for lookups. I'm a fan of Chainmap, but looks less practical where there may be many lookups."}, {"id": 62820532, "score": 45, "vote": 0, "content": "<p>I benchmarked the suggested with <a href=\"https://github.com/nschloe/perfplot\" rel=\"noreferrer\">perfplot</a> and found that the good old</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">temp = x.copy()\ntemp.update(y)\n</code></pre>\n<p>is the fastest solution together with the new (Python 3.9+)</p>\n<pre><code class=\"python\">x | y\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/z8pG1.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/z8pG1.png\"/></a></p>\n<hr/>\n<p>Code to reproduce the plot:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from collections import ChainMap\nfrom itertools import chain\nimport perfplot\n\n\ndef setup(n):\n    x = dict(zip(range(n), range(n)))\n    y = dict(zip(range(n, 2 * n), range(n, 2 * n)))\n    return x, y\n\n\ndef copy_update(x, y):\n    temp = x.copy()\n    temp.update(y)\n    return temp\n\n\ndef add_items(x, y):\n    return dict(list(x.items()) + list(y.items()))\n\n\ndef curly_star(x, y):\n    return {**x, **y}\n\n\ndef chain_map(x, y):\n    return dict(ChainMap({}, y, x))\n\n\ndef itertools_chain(x, y):\n    return dict(chain(x.items(), y.items()))\n\n\ndef python39_concat(x, y):\n    return x | y\n\n\nb = perfplot.bench(\n    setup=setup,\n    kernels=[\n        copy_update,\n        add_items,\n        curly_star,\n        chain_map,\n        itertools_chain,\n        python39_concat,\n    ],\n    labels=[\n        \"copy_update\",\n        \"dict(list(x.items()) + list(y.items()))\",\n        \"{**x, **y}\",\n        \"chain_map\",\n        \"itertools.chain\",\n        \"x | y\",\n    ],\n    n_range=[2 ** k for k in range(18)],\n    xlabel=\"len(x), len(y)\",\n    equality_check=None,\n)\nb.save(\"out.png\")\nb.show()\n</code></pre>\n", "abstract": "I benchmarked the suggested with perfplot and found that the good old is the fastest solution together with the new (Python 3.9+)  Code to reproduce the plot:"}, {"id": 12926103, "score": 36, "vote": 0, "content": "<p><strong>Two dictionaries</strong></p>\n<pre><code class=\"python\">def union2(dict1, dict2):\n    return dict(list(dict1.items()) + list(dict2.items()))\n</code></pre>\n<p><strong><em>n</em> dictionaries</strong></p>\n<pre><code class=\"python\">def union(*dicts):\n    return dict(itertools.chain.from_iterable(dct.items() for dct in dicts))\n</code></pre>\n<p><code>sum</code> has bad performance. See <a href=\"https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/\" rel=\"noreferrer\">https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/</a></p>\n", "abstract": "Two dictionaries n dictionaries sum has bad performance. See https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/"}, {"id": 31812635, "score": 33, "vote": 0, "content": "<p>Simple solution using itertools that preserves order (latter dicts have precedence)</p>\n<pre><code class=\"python\"># py2\nfrom itertools import chain, imap\nmerge = lambda *args: dict(chain.from_iterable(imap(dict.iteritems, args)))\n\n# py3\nfrom itertools import chain\nmerge = lambda *args: dict(chain.from_iterable(map(dict.items, args)))\n</code></pre>\n<p>And it's usage:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; merge(x, y)\n{'a': 1, 'b': 10, 'c': 11}\n\n&gt;&gt;&gt; z = {'c': 3, 'd': 4}\n&gt;&gt;&gt; merge(x, y, z)\n{'a': 1, 'b': 10, 'c': 3, 'd': 4}\n</code></pre>\n", "abstract": "Simple solution using itertools that preserves order (latter dicts have precedence) And it's usage:"}, {"id": 18114065, "score": 31, "vote": 0, "content": "<p>Abuse leading to a one-expression solution for <a href=\"https://stackoverflow.com/a/39437/15055\">Matthew's answer</a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; z = (lambda f=x.copy(): (f.update(y), f)[1])()\n&gt;&gt;&gt; z\n{'a': 1, 'c': 11, 'b': 10}\n</code></pre>\n<p>You said you wanted one expression, so I abused <code>lambda</code> to bind a name, and tuples to override lambda's one-expression limit. Feel free to cringe.</p>\n<p>You could also do this of course if you don't care about copying it:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; z = (x.update(y), x)[1]\n&gt;&gt;&gt; z\n{'a': 1, 'b': 10, 'c': 11}\n</code></pre>\n", "abstract": "Abuse leading to a one-expression solution for Matthew's answer: You said you wanted one expression, so I abused lambda to bind a name, and tuples to override lambda's one-expression limit. Feel free to cringe. You could also do this of course if you don't care about copying it:"}, {"id": 46356150, "score": 24, "vote": 0, "content": "<p>If you don't mind mutating <code>x</code>,</p>\n<pre><code class=\"python\">x.update(y) or x\n</code></pre>\n<p>Simple, readable, performant. You <em>know</em> <code>update()</code> always returns <code>None</code>, which is a false value. So the above expression will always evaluate to <code>x</code>, after updating it.</p>\n<p>Most mutating methods in the standard library (like <code>.update()</code>) return <code>None</code> by convention, so this kind of pattern will work on those too. However, if you're using a dict subclass or some other method that doesn't follow this convention, then <code>or</code> may return its left operand, which may not be what you want. Instead, you can use a tuple display and index, which works regardless of what the first element evaluates to (although it's not quite as pretty):</p>\n<pre><code class=\"python\">(x.update(y), x)[-1]\n</code></pre>\n<p>If you don't have <code>x</code> in a variable yet, you can use <code>lambda</code> to make a local without using an assignment statement. This amounts to using <code>lambda</code> as a <em>let expression</em>, which is a common technique in functional languages, but is maybe unpythonic.</p>\n<pre><code class=\"python\">(lambda x: x.update(y) or x)({'a': 1, 'b': 2})\n</code></pre>\n<p>Although it's not that different from the following use of the new walrus operator (Python 3.8+ only),</p>\n<pre><code class=\"python\">(x := {'a': 1, 'b': 2}).update(y) or x\n</code></pre>\n<p>especially if you use a default argument:</p>\n<pre><code class=\"python\">(lambda x={'a': 1, 'b': 2}: x.update(y) or x)()\n</code></pre>\n<p>If you do want a copy, <a href=\"https://www.python.org/dev/peps/pep-0584/\" rel=\"noreferrer\">PEP 584</a> style <code>x | y</code> is the most Pythonic on 3.9+. If you must support older versions, <a href=\"https://www.python.org/dev/peps/pep-0448/\" rel=\"noreferrer\">PEP 448</a> style <code>{**x, **y}</code> is easiest for 3.5+. But if that's not available in your (even older) Python version, the <em>let expression</em> pattern works here too.</p>\n<pre><code class=\"python\">(lambda z=x.copy(): z.update(y) or z)()\n</code></pre>\n<p>(That is, of course, nearly equivalent to <code>(z := x.copy()).update(y) or z</code>, but if your Python version is new enough for that, then the PEP 448 style will be available.)</p>\n", "abstract": "If you don't mind mutating x, Simple, readable, performant. You know update() always returns None, which is a false value. So the above expression will always evaluate to x, after updating it. Most mutating methods in the standard library (like .update()) return None by convention, so this kind of pattern will work on those too. However, if you're using a dict subclass or some other method that doesn't follow this convention, then or may return its left operand, which may not be what you want. Instead, you can use a tuple display and index, which works regardless of what the first element evaluates to (although it's not quite as pretty): If you don't have x in a variable yet, you can use lambda to make a local without using an assignment statement. This amounts to using lambda as a let expression, which is a common technique in functional languages, but is maybe unpythonic. Although it's not that different from the following use of the new walrus operator (Python 3.8+ only), especially if you use a default argument: If you do want a copy, PEP 584 style x | y is the most Pythonic on 3.9+. If you must support older versions, PEP 448 style {**x, **y} is easiest for 3.5+. But if that's not available in your (even older) Python version, the let expression pattern works here too. (That is, of course, nearly equivalent to (z := x.copy()).update(y) or z, but if your Python version is new enough for that, then the PEP 448 style will be available.)"}, {"id": 62141222, "score": 21, "vote": 0, "content": "<p><strong><a href=\"https://www.python.org/dev/peps/pep-0584/#specification\" rel=\"noreferrer\">New</a> in Python 3.9:</strong> Use the union operator (<code>|</code>) to merge <code>dict</code>s similar to <code>set</code>s:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d = {'a': 1, 'b': 2}\n&gt;&gt;&gt; e = {'a': 9, 'c': 3}\n&gt;&gt;&gt; d | e\n{'a': 9, 'b': 2, 'c': 3}\n</code></pre>\n<p>For matching keys, the <strong>right <code>dict</code> takes precedence</strong>.</p>\n<p>This also works for <code>|=</code> to modify a <code>dict</code> in-place:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; e |= d    # e = e | d\n&gt;&gt;&gt; e\n{'a': 1, 'c': 3, 'b': 2}\n</code></pre>\n", "abstract": "New in Python 3.9: Use the union operator (|) to merge dicts similar to sets: For matching keys, the right dict takes precedence. This also works for |= to modify a dict in-place:"}, {"id": 17738920, "score": 19, "vote": 0, "content": "<p>Drawing on ideas here and elsewhere I've comprehended a function:</p>\n<pre><code class=\"python\">def merge(*dicts, **kv): \n      return { k:v for d in list(dicts) + [kv] for k,v in d.items() }\n</code></pre>\n<p>Usage (tested in python 3):</p>\n<pre><code class=\"python\">assert (merge({1:11,'a':'aaa'},{1:99, 'b':'bbb'},foo='bar')==\\\n    {1: 99, 'foo': 'bar', 'b': 'bbb', 'a': 'aaa'})\n\nassert (merge(foo='bar')=={'foo': 'bar'})\n\nassert (merge({1:11},{1:99},foo='bar',baz='quux')==\\\n    {1: 99, 'foo': 'bar', 'baz':'quux'})\n\nassert (merge({1:11},{1:99})=={1: 99})\n</code></pre>\n<p>You could use a lambda instead.</p>\n", "abstract": "Drawing on ideas here and elsewhere I've comprehended a function: Usage (tested in python 3): You could use a lambda instead."}, {"id": 22122836, "score": 19, "vote": 0, "content": "<p>It's so silly that <code>.update</code> returns nothing.<br/>\nI just use a simple helper function to solve the problem:</p>\n<pre><code class=\"python\">def merge(dict1,*dicts):\n    for dict2 in dicts:\n        dict1.update(dict2)\n    return dict1\n</code></pre>\n<p>Examples:</p>\n<pre><code class=\"python\">merge(dict1,dict2)\nmerge(dict1,dict2,dict3)\nmerge(dict1,dict2,dict3,dict4)\nmerge({},dict1,dict2)  # this one returns a new copy\n</code></pre>\n", "abstract": "It's so silly that .update returns nothing.\nI just use a simple helper function to solve the problem: Examples:"}, {"id": 36263150, "score": 18, "vote": 0, "content": "<p>(For Python\u00a02.7* only; there are simpler solutions for Python\u00a03*.)</p>\n<p>If you're not averse to importing a standard library module, you can do</p>\n<pre><code class=\"python\">from functools import reduce\n\ndef merge_dicts(*dicts):\n    return reduce(lambda a, d: a.update(d) or a, dicts, {})\n</code></pre>\n<p>(The <code>or a</code> bit in the <code>lambda</code> is necessary because <code>dict.update</code> always returns <code>None</code> on success.)</p>\n", "abstract": "(For Python\u00a02.7* only; there are simpler solutions for Python\u00a03*.) If you're not averse to importing a standard library module, you can do (The or a bit in the lambda is necessary because dict.update always returns None on success.)"}, {"id": 20358548, "score": 17, "vote": 0, "content": "<p>The problem I have with solutions listed to date is that, in the merged dictionary, the value for key \"b\" is 10 but, to my way of thinking, it should be 12.\nIn that light, I present the following:</p>\n<pre><code class=\"python\">import timeit\n\nn=100000\nsu = \"\"\"\nx = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\n\"\"\"\n\ndef timeMerge(f,su,niter):\n    print \"{:4f} sec for: {:30s}\".format(timeit.Timer(f,setup=su).timeit(n),f)\n\ntimeMerge(\"dict(x, **y)\",su,n)\ntimeMerge(\"x.update(y)\",su,n)\ntimeMerge(\"dict(x.items() + y.items())\",su,n)\ntimeMerge(\"for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k] \",su,n)\n\n#confirm for loop adds b entries together\nx = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\nfor k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k]\nprint \"confirm b elements are added:\",x\n</code></pre>\n<h1>Results:</h1>\n<pre><code class=\"python\">0.049465 sec for: dict(x, **y)\n0.033729 sec for: x.update(y)                   \n0.150380 sec for: dict(x.items() + y.items())   \n0.083120 sec for: for k in y.keys(): x[k] = k in x and x[k]+y[k] or y[k]\n\nconfirm b elements are added: {'a': 1, 'c': 11, 'b': 12}\n</code></pre>\n", "abstract": "The problem I have with solutions listed to date is that, in the merged dictionary, the value for key \"b\" is 10 but, to my way of thinking, it should be 12.\nIn that light, I present the following:"}, {"id": 54930992, "score": 16, "vote": 0, "content": "<p>There will be a new option when Python 3.8 releases (<a href=\"https://www.python.org/dev/peps/pep-0569/#release-schedule\" rel=\"noreferrer\">scheduled for 20 October, 2019</a>), thanks to <a href=\"https://www.python.org/dev/peps/pep-0572/\" rel=\"noreferrer\">PEP 572: Assignment Expressions</a>. The new assignment expression operator <code>:=</code> allows you to assign the result of the <code>copy</code> and still use it to call <code>update</code>, leaving the combined code a single expression, rather than two statements, changing:</p>\n<pre><code class=\"python\">newdict = dict1.copy()\nnewdict.update(dict2)\n</code></pre>\n<p>to:</p>\n<pre><code class=\"python\">(newdict := dict1.copy()).update(dict2)\n</code></pre>\n<p>while behaving identically in every way. If you must also return the resulting <code>dict</code> (you asked for an expression returning the <code>dict</code>; the above creates and assigns to <code>newdict</code>, but doesn't return it, so you couldn't use it to pass an argument to a function as is, a la <code>myfunc((newdict := dict1.copy()).update(dict2))</code>), then just add <code>or newdict</code> to the end (since <code>update</code> returns <code>None</code>, which is falsy, it will then evaluate and return <code>newdict</code> as the result of the expression):</p>\n<pre><code class=\"python\">(newdict := dict1.copy()).update(dict2) or newdict\n</code></pre>\n<p><strong>Important caveat:</strong> In general, I'd discourage this approach in favor of:</p>\n<pre><code class=\"python\">newdict = {**dict1, **dict2}\n</code></pre>\n<p>The unpacking approach is clearer (to anyone who knows about generalized unpacking in the first place, <a href=\"https://www.python.org/dev/peps/pep-0448/\" rel=\"noreferrer\">which you should</a>), doesn't require a name for the result at all (so it's much more concise when constructing a temporary that is immediately passed to a function or included in a <code>list</code>/<code>tuple</code> literal or the like), and is almost certainly faster as well, being (on CPython) roughly equivalent to:</p>\n<pre><code class=\"python\">newdict = {}\nnewdict.update(dict1)\nnewdict.update(dict2)\n</code></pre>\n<p>but done at the C layer, using the concrete <code>dict</code> API, so no dynamic method lookup/binding or function call dispatch overhead is involved (where <code>(newdict := dict1.copy()).update(dict2)</code> is unavoidably identical to the original two-liner in behavior, performing the work in discrete steps, with dynamic lookup/binding/invocation of methods.</p>\n<p>It's also more extensible, as merging three <code>dict</code>s is obvious:</p>\n<pre><code class=\"python\"> newdict = {**dict1, **dict2, **dict3}\n</code></pre>\n<p>where using assignment expressions won't scale like that; the closest you could get would be:</p>\n<pre><code class=\"python\"> (newdict := dict1.copy()).update(dict2), newdict.update(dict3)\n</code></pre>\n<p>or without the temporary tuple of <code>None</code>s, but with truthiness testing of each <code>None</code> result:</p>\n<pre><code class=\"python\"> (newdict := dict1.copy()).update(dict2) or newdict.update(dict3)\n</code></pre>\n<p>either of which is obviously much uglier, and includes further inefficiencies (either a wasted temporary <code>tuple</code> of <code>None</code>s for comma separation, or pointless truthiness testing of each <code>update</code>'s <code>None</code> return for <code>or</code> separation).</p>\n<p><strong>The only real advantage to the assignment expression approach occurs if:</strong></p>\n<ol>\n<li><strong>You have generic code that needs handle both <code>set</code>s and <code>dict</code>s</strong> (both of them support <code>copy</code> and <code>update</code>, so the code works roughly as you'd expect it to)</li>\n<li><strong>You expect to receive arbitrary dict-like objects</strong>, not just <code>dict</code> itself, <strong>and must preserve the type and semantics of the left hand side</strong> (rather than ending up with a plain <code>dict</code>). While <code>myspecialdict({**speciala, **specialb})</code> might work, it would involve an extra temporary <code>dict</code>, and if <code>myspecialdict</code> has features plain <code>dict</code> can't preserve (e.g. regular <code>dict</code>s now preserve order based on the first appearance of a key, and value based on the last appearance of a key; you might want one that preserves order based on the <em>last</em> appearance of a key so updating a value also moves it to the end), then the semantics would be wrong. Since the assignment expression version uses the named methods (which are presumably overloaded to behave appropriately), it never creates a <code>dict</code> at all (unless <code>dict1</code> was already a <code>dict</code>), preserving the original type (and original type's semantics), all while avoiding any temporaries.</li>\n</ol>\n", "abstract": "There will be a new option when Python 3.8 releases (scheduled for 20 October, 2019), thanks to PEP 572: Assignment Expressions. The new assignment expression operator := allows you to assign the result of the copy and still use it to call update, leaving the combined code a single expression, rather than two statements, changing: to: while behaving identically in every way. If you must also return the resulting dict (you asked for an expression returning the dict; the above creates and assigns to newdict, but doesn't return it, so you couldn't use it to pass an argument to a function as is, a la myfunc((newdict := dict1.copy()).update(dict2))), then just add or newdict to the end (since update returns None, which is falsy, it will then evaluate and return newdict as the result of the expression): Important caveat: In general, I'd discourage this approach in favor of: The unpacking approach is clearer (to anyone who knows about generalized unpacking in the first place, which you should), doesn't require a name for the result at all (so it's much more concise when constructing a temporary that is immediately passed to a function or included in a list/tuple literal or the like), and is almost certainly faster as well, being (on CPython) roughly equivalent to: but done at the C layer, using the concrete dict API, so no dynamic method lookup/binding or function call dispatch overhead is involved (where (newdict := dict1.copy()).update(dict2) is unavoidably identical to the original two-liner in behavior, performing the work in discrete steps, with dynamic lookup/binding/invocation of methods. It's also more extensible, as merging three dicts is obvious: where using assignment expressions won't scale like that; the closest you could get would be: or without the temporary tuple of Nones, but with truthiness testing of each None result: either of which is obviously much uglier, and includes further inefficiencies (either a wasted temporary tuple of Nones for comma separation, or pointless truthiness testing of each update's None return for or separation). The only real advantage to the assignment expression approach occurs if:"}, {"id": 33999337, "score": 15, "vote": 0, "content": "<pre><code class=\"python\">from collections import Counter\ndict1 = {'a':1, 'b': 2}\ndict2 = {'b':10, 'c': 11}\nresult = dict(Counter(dict1) + Counter(dict2))\n</code></pre>\n<p>This should solve your problem.</p>\n", "abstract": "This should solve your problem."}, {"id": 31478567, "score": 13, "vote": 0, "content": "<p>This can be done with a single dict comprehension:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; { key: y[key] if key in y else x[key]\n      for key in set(x) + set(y)\n    }\n</code></pre>\n<p>In my view the best answer for the 'single expression' part as no extra functions are needed, and it is short.</p>\n", "abstract": "This can be done with a single dict comprehension: In my view the best answer for the 'single expression' part as no extra functions are needed, and it is short."}, {"id": 19950727, "score": 11, "vote": 0, "content": "<pre><code class=\"python\">&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; x, z = dict(x), x.update(y) or x\n&gt;&gt;&gt; x\n{'a': 1, 'b': 2}\n&gt;&gt;&gt; y\n{'c': 11, 'b': 10}\n&gt;&gt;&gt; z\n{'a': 1, 'c': 11, 'b': 10}\n</code></pre>\n", "abstract": ""}, {"id": 37304637, "score": 9, "vote": 0, "content": "<p>I know this does not really fit the specifics of the questions (\"one liner\"), but since <em>none</em> of the answers above went into this direction while lots and lots of answers addressed the performance issue, I felt I should contribute my thoughts.</p>\n<p>Depending on the use case it might not be necessary to create a \"real\" merged dictionary of the given input dictionaries.  A <em>view</em> which does this might be sufficient in many cases, i. e. an object which acts <em>like</em> the merged dictionary would without computing it completely.  A lazy version of the merged dictionary, so to speak.</p>\n<p>In Python, this is rather simple and can be done with the code shown at the end of my post.  This given, the answer to the original question would be:</p>\n<pre><code class=\"python\">z = MergeDict(x, y)\n</code></pre>\n<p>When using this new object, it will behave like a merged dictionary but it will have constant creation time and constant memory footprint while leaving the original dictionaries untouched.  Creating it is way cheaper than in the other solutions proposed.</p>\n<p>Of course, if you use the result a lot, then you will at some point reach the limit where creating a real merged dictionary would have been the faster solution.  As I said, it depends on your use case.</p>\n<p>If you ever felt you would prefer to have a real merged <code>dict</code>, then calling <code>dict(z)</code> would produce it (but way more costly than the other solutions of course, so this is just worth mentioning).</p>\n<p>You can also use this class to make a kind of copy-on-write dictionary:</p>\n<pre><code class=\"python\">a = { 'x': 3, 'y': 4 }\nb = MergeDict(a)  # we merge just one dict\nb['x'] = 5\nprint b  # will print {'x': 5, 'y': 4}\nprint a  # will print {'y': 4, 'x': 3}\n</code></pre>\n<p>Here's the straight-forward code of <code>MergeDict</code>:</p>\n<pre><code class=\"python\">class MergeDict(object):\n  def __init__(self, *originals):\n    self.originals = ({},) + originals[::-1]  # reversed\n\n  def __getitem__(self, key):\n    for original in self.originals:\n      try:\n        return original[key]\n      except KeyError:\n        pass\n    raise KeyError(key)\n\n  def __setitem__(self, key, value):\n    self.originals[0][key] = value\n\n  def __iter__(self):\n    return iter(self.keys())\n\n  def __repr__(self):\n    return '%s(%s)' % (\n      self.__class__.__name__,\n      ', '.join(repr(original)\n          for original in reversed(self.originals)))\n\n  def __str__(self):\n    return '{%s}' % ', '.join(\n        '%r: %r' % i for i in self.iteritems())\n\n  def iteritems(self):\n    found = set()\n    for original in self.originals:\n      for k, v in original.iteritems():\n        if k not in found:\n          yield k, v\n          found.add(k)\n\n  def items(self):\n    return list(self.iteritems())\n\n  def keys(self):\n    return list(k for k, _ in self.iteritems())\n\n  def values(self):\n    return list(v for _, v in self.iteritems())\n</code></pre>\n", "abstract": "I know this does not really fit the specifics of the questions (\"one liner\"), but since none of the answers above went into this direction while lots and lots of answers addressed the performance issue, I felt I should contribute my thoughts. Depending on the use case it might not be necessary to create a \"real\" merged dictionary of the given input dictionaries.  A view which does this might be sufficient in many cases, i. e. an object which acts like the merged dictionary would without computing it completely.  A lazy version of the merged dictionary, so to speak. In Python, this is rather simple and can be done with the code shown at the end of my post.  This given, the answer to the original question would be: When using this new object, it will behave like a merged dictionary but it will have constant creation time and constant memory footprint while leaving the original dictionaries untouched.  Creating it is way cheaper than in the other solutions proposed. Of course, if you use the result a lot, then you will at some point reach the limit where creating a real merged dictionary would have been the faster solution.  As I said, it depends on your use case. If you ever felt you would prefer to have a real merged dict, then calling dict(z) would produce it (but way more costly than the other solutions of course, so this is just worth mentioning). You can also use this class to make a kind of copy-on-write dictionary: Here's the straight-forward code of MergeDict:"}, {"id": 61116810, "score": 9, "vote": 0, "content": "<p><strong>Python 3.9+ only</strong></p>\n<p>Merge (|) and update (|=) operators have been added to the built-in <code>dict</code> class.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d = {'spam': 1, 'eggs': 2, 'cheese': 3}\n&gt;&gt;&gt; e = {'cheese': 'cheddar', 'aardvark': 'Ethel'}\n&gt;&gt;&gt; d | e\n{'spam': 1, 'eggs': 2, 'cheese': 'cheddar', 'aardvark': 'Ethel'}\n</code></pre>\n<p>The augmented assignment version operates in-place:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d |= e\n&gt;&gt;&gt; d\n{'spam': 1, 'eggs': 2, 'cheese': 'cheddar', 'aardvark': 'Ethel'}\n</code></pre>\n<p>See <a href=\"https://www.python.org/dev/peps/pep-0584/\" rel=\"noreferrer\">PEP 584</a></p>\n", "abstract": "Python 3.9+ only Merge (|) and update (|=) operators have been added to the built-in dict class. The augmented assignment version operates in-place: See PEP 584"}, {"id": 64228920, "score": 9, "vote": 0, "content": "<p><strong>In Python 3.9</strong></p>\n<p>Based on <a href=\"https://www.python.org/dev/peps/pep-0584/\" rel=\"nofollow noreferrer\">PEP 584</a>, the new version of Python introduces two new operators for dictionaries: union (|) and in-place union (|=). You can use | to merge two dictionaries, while |= will update a dictionary in place:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; pycon = {2016: \"Portland\", 2018: \"Cleveland\"}\n&gt;&gt;&gt; europython = {2017: \"Rimini\", 2018: \"Edinburgh\", 2019: \"Basel\"}\n\n&gt;&gt;&gt; pycon | europython\n{2016: 'Portland', 2018: 'Edinburgh', 2017: 'Rimini', 2019: 'Basel'}\n\n&gt;&gt;&gt; pycon |= europython\n&gt;&gt;&gt; pycon\n{2016: 'Portland', 2018: 'Edinburgh', 2017: 'Rimini', 2019: 'Basel'}\n\n</code></pre>\n<p>If d1 and d2 are two dictionaries, then <code>d1 | d2</code> does the same as <code>{**d1, **d2}</code>. The | operator is used for calculating the <a href=\"https://docs.python.org/3/library/stdtypes.html#frozenset.union\" rel=\"nofollow noreferrer\">union of sets</a>, so the notation may already be familiar to you.</p>\n<p>One advantage of using <code>|</code> is that it works on different dictionary-like types and keeps the type through the merge:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from collections import defaultdict\n&gt;&gt;&gt; europe = defaultdict(lambda: \"\", {\"Norway\": \"Oslo\", \"Spain\": \"Madrid\"})\n&gt;&gt;&gt; africa = defaultdict(lambda: \"\", {\"Egypt\": \"Cairo\", \"Zimbabwe\": \"Harare\"})\n\n&gt;&gt;&gt; europe | africa\ndefaultdict(&lt;function &lt;lambda&gt; at 0x7f0cb42a6700&gt;,\n  {'Norway': 'Oslo', 'Spain': 'Madrid', 'Egypt': 'Cairo', 'Zimbabwe': 'Harare'})\n\n&gt;&gt;&gt; {**europe, **africa}\n{'Norway': 'Oslo', 'Spain': 'Madrid', 'Egypt': 'Cairo', 'Zimbabwe': 'Harare'}\n</code></pre>\n<p>You can use a defaultdict when you want to effectively handle missing keys. Note that <code>|</code> preserves the defaultdict, while <code>{**europe, **africa}</code> does not.</p>\n<p>There are some similarities between how <code>|</code> works for dictionaries and how <code>+</code> works for lists. In fact, the <code>+</code> operator was <a href=\"https://www.python.org/dev/peps/pep-0584/#use-the-addition-operator\" rel=\"nofollow noreferrer\">originally proposed</a> to merge dictionaries as well. This correspondence becomes even more evident when you look at the in-place operator.</p>\n<p>The basic use of <code>|=</code> is to update a dictionary in place, similar to <code>.update()</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; libraries = {\n...     \"collections\": \"Container datatypes\",\n...     \"math\": \"Mathematical functions\",\n... }\n&gt;&gt;&gt; libraries |= {\"zoneinfo\": \"IANA time zone support\"}\n&gt;&gt;&gt; libraries\n{'collections': 'Container datatypes', 'math': 'Mathematical functions',\n 'zoneinfo': 'IANA time zone support'}\n</code></pre>\n<p>When you merge dictionaries with <code>|</code>, both dictionaries need to be of a proper dictionary type. On the other hand, the in-place operator (<code>|=</code>) is happy to work with any dictionary-like data structure:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; libraries |= [(\"graphlib\", \"Functionality for graph-like structures\")]\n&gt;&gt;&gt; libraries\n{'collections': 'Container datatypes', 'math': 'Mathematical functions',\n 'zoneinfo': 'IANA time zone support',\n 'graphlib': 'Functionality for graph-like structures'}\n</code></pre>\n", "abstract": "In Python 3.9 Based on PEP 584, the new version of Python introduces two new operators for dictionaries: union (|) and in-place union (|=). You can use | to merge two dictionaries, while |= will update a dictionary in place: If d1 and d2 are two dictionaries, then d1 | d2 does the same as {**d1, **d2}. The | operator is used for calculating the union of sets, so the notation may already be familiar to you. One advantage of using | is that it works on different dictionary-like types and keeps the type through the merge: You can use a defaultdict when you want to effectively handle missing keys. Note that | preserves the defaultdict, while {**europe, **africa} does not. There are some similarities between how | works for dictionaries and how + works for lists. In fact, the + operator was originally proposed to merge dictionaries as well. This correspondence becomes even more evident when you look at the in-place operator. The basic use of |= is to update a dictionary in place, similar to .update(): When you merge dictionaries with |, both dictionaries need to be of a proper dictionary type. On the other hand, the in-place operator (|=) is happy to work with any dictionary-like data structure:"}, {"id": 16769722, "score": 6, "vote": 0, "content": "<p>Using  a dict comprehension, you may</p>\n<pre><code class=\"python\">x = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\n\ndc = {xi:(x[xi] if xi not in list(y.keys()) \n           else y[xi]) for xi in list(x.keys())+(list(y.keys()))}\n</code></pre>\n<p>gives</p>\n<pre><code class=\"python\">&gt;&gt;&gt; dc\n{'a': 1, 'c': 11, 'b': 10}\n</code></pre>\n<p>Note the syntax for <code>if else</code> in comprehension </p>\n<pre><code class=\"python\">{ (some_key if condition else default_key):(something_if_true if condition \n          else something_if_false) for key, value in dict_.items() }\n</code></pre>\n", "abstract": "Using  a dict comprehension, you may gives Note the syntax for if else in comprehension "}, {"id": 49847631, "score": 6, "vote": 0, "content": "<p>This is an expression for Python 3.5 or greater that merges dictionaries using <code>reduce</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from functools import reduce\n&gt;&gt;&gt; l = [{'a': 1}, {'b': 2}, {'a': 100, 'c': 3}]\n&gt;&gt;&gt; reduce(lambda x, y: {**x, **y}, l, {})\n{'a': 100, 'b': 2, 'c': 3}\n</code></pre>\n<p>Note: this works even if the dictionary list is empty or contains only one element.</p>\n<p>For a more efficient merge on Python 3.9 or greater, the <code>lambda</code> can be replaced directly by <code>operator.ior</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from functools import reduce\n&gt;&gt;&gt; from operator import ior\n&gt;&gt;&gt; l = [{'a': 1}, {'b': 2}, {'a': 100, 'c': 3}]\n&gt;&gt;&gt; reduce(ior, l, {})\n{'a': 100, 'b': 2, 'c': 3}\n</code></pre>\n<p>For Python 3.8 or less, the following can be used as an alternative to <code>ior</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from functools import reduce\n&gt;&gt;&gt; l = [{'a': 1}, {'b': 2}, {'a': 100, 'c': 3}]\n&gt;&gt;&gt; reduce(lambda x, y: x.update(y) or x, l, {})\n{'a': 100, 'b': 2, 'c': 3}\n</code></pre>\n", "abstract": "This is an expression for Python 3.5 or greater that merges dictionaries using reduce: Note: this works even if the dictionary list is empty or contains only one element. For a more efficient merge on Python 3.9 or greater, the lambda can be replaced directly by operator.ior: For Python 3.8 or less, the following can be used as an alternative to ior:"}, {"id": 26111877, "score": 5, "vote": 0, "content": "<p>A union of the OP's two dictionaries would be something like:</p>\n<pre><code class=\"python\">{'a': 1, 'b': 2, 10, 'c': 11}\n</code></pre>\n<p>Specifically, the union of two entities(<code>x</code> and <code>y</code>) contains all the elements of <code>x</code> and/or <code>y</code>.\nUnfortunately, what the OP asks for is not a union, despite the title of the post.</p>\n<p>My code below is neither elegant nor a one-liner, but I believe it is consistent with the meaning of union.</p>\n<p>From the OP's example:</p>\n<pre><code class=\"python\">x = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\n\nz = {}\nfor k, v in x.items():\n    if not k in z:\n        z[k] = [(v)]\n    else:\n        z[k].append((v))\nfor k, v in y.items():\n    if not k in z:\n        z[k] = [(v)]\n    else:\n        z[k].append((v))\n\n{'a': [1], 'b': [2, 10], 'c': [11]}\n</code></pre>\n<p>Whether one wants lists could be changed, but the above will work if a dictionary contains lists (and nested lists) as values in either dictionary.</p>\n", "abstract": "A union of the OP's two dictionaries would be something like: Specifically, the union of two entities(x and y) contains all the elements of x and/or y.\nUnfortunately, what the OP asks for is not a union, despite the title of the post. My code below is neither elegant nor a one-liner, but I believe it is consistent with the meaning of union. From the OP's example: Whether one wants lists could be changed, but the above will work if a dictionary contains lists (and nested lists) as values in either dictionary."}, {"id": 40677646, "score": 5, "vote": 0, "content": "<p>You can use <a href=\"http://toolz.readthedocs.io/en/latest/api.html#toolz.dicttoolz.merge\" rel=\"nofollow noreferrer\"><code>toolz.merge([x, y])</code></a> for this.</p>\n", "abstract": "You can use toolz.merge([x, y]) for this."}, {"id": 49420387, "score": 5, "vote": 0, "content": "<p>I was curious if I could beat the accepted answer's time with a one line stringify approach:</p>\n<p>I tried 5 methods, none previously mentioned - all one liner - all producing correct answers - and I couldn't come close.</p>\n<p>So... to save you the trouble and perhaps fulfill curiosity:</p>\n<pre><code class=\"python\">import json\nimport yaml\nimport time\nfrom ast import literal_eval as literal\n\ndef merge_two_dicts(x, y):\n    z = x.copy()   # start with x's keys and values\n    z.update(y)    # modifies z with y's keys and values &amp; returns None\n    return z\n\nx = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\n\nstart = time.time()\nfor i in range(10000):\n    z = yaml.load((str(x)+str(y)).replace('}{',', '))\nelapsed = (time.time()-start)\nprint (elapsed, z, 'stringify yaml')\n\nstart = time.time()\nfor i in range(10000):\n    z = literal((str(x)+str(y)).replace('}{',', '))\nelapsed = (time.time()-start)\nprint (elapsed, z, 'stringify literal')\n\nstart = time.time()\nfor i in range(10000):\n    z = eval((str(x)+str(y)).replace('}{',', '))\nelapsed = (time.time()-start)\nprint (elapsed, z, 'stringify eval')\n\nstart = time.time()\nfor i in range(10000):\n    z = {k:int(v) for k,v in (dict(zip(\n            ((str(x)+str(y))\n            .replace('}',' ')\n            .replace('{',' ')\n            .replace(':',' ')\n            .replace(',',' ')\n            .replace(\"'\",'')\n            .strip()\n            .split('  '))[::2], \n            ((str(x)+str(y))\n            .replace('}',' ')\n            .replace('{',' ').replace(':',' ')\n            .replace(',',' ')\n            .replace(\"'\",'')\n            .strip()\n            .split('  '))[1::2]\n             ))).items()}\nelapsed = (time.time()-start)\nprint (elapsed, z, 'stringify replace')\n\nstart = time.time()\nfor i in range(10000):\n    z = json.loads(str((str(x)+str(y)).replace('}{',', ').replace(\"'\",'\"')))\nelapsed = (time.time()-start)\nprint (elapsed, z, 'stringify json')\n\nstart = time.time()\nfor i in range(10000):\n    z = merge_two_dicts(x, y)\nelapsed = (time.time()-start)\nprint (elapsed, z, 'accepted')\n</code></pre>\n<p>results:</p>\n<pre><code class=\"python\">7.693928956985474 {'c': 11, 'b': 10, 'a': 1} stringify yaml\n0.29134678840637207 {'c': 11, 'b': 10, 'a': 1} stringify literal\n0.2208399772644043 {'c': 11, 'b': 10, 'a': 1} stringify eval\n0.1106564998626709 {'c': 11, 'b': 10, 'a': 1} stringify replace\n0.07989692687988281 {'c': 11, 'b': 10, 'a': 1} stringify json\n0.005082368850708008 {'c': 11, 'b': 10, 'a': 1} accepted\n</code></pre>\n<p>What I did learn from this is that JSON approach is the fastest way (of those attempted) to return a dictionary from string-of-dictionary; much faster (about 1/4th of the time) of what I considered to be the normal method using <code>ast</code>.  I also learned that, the YAML approach should be avoided at all cost.</p>\n<p>Yes, I understand that this is not the best/correct way. I was curious if it was faster, and it isn't; I posted to prove it so.</p>\n", "abstract": "I was curious if I could beat the accepted answer's time with a one line stringify approach: I tried 5 methods, none previously mentioned - all one liner - all producing correct answers - and I couldn't come close. So... to save you the trouble and perhaps fulfill curiosity: results: What I did learn from this is that JSON approach is the fastest way (of those attempted) to return a dictionary from string-of-dictionary; much faster (about 1/4th of the time) of what I considered to be the normal method using ast.  I also learned that, the YAML approach should be avoided at all cost. Yes, I understand that this is not the best/correct way. I was curious if it was faster, and it isn't; I posted to prove it so."}, {"id": 69335330, "score": 3, "vote": 0, "content": "<p>Deep merge of dicts:</p>\n<pre><code class=\"python\">from typing import List, Dict\nfrom copy import deepcopy\n\ndef merge_dicts(*from_dicts: List[Dict], no_copy: bool=False) -&gt; Dict :\n    \"\"\" no recursion deep merge of two dicts\n\n    By default creates fresh Dict and merges all to it.\n\n    no_copy = True, will merge all dicts to a fist one in a list without copy.\n    Why? Sometime I need to combine one dictionary from \"layers\".\n    The \"layers\" are not in use and dropped immediately after merging.\n    \"\"\"\n\n    if no_copy:\n        xerox = lambda x:x\n    else:\n        xerox = deepcopy\n\n    result = xerox(from_dicts[0])\n\n    for _from in from_dicts[1:]:\n        merge_queue = [(result, _from)]\n        for _to, _from in merge_queue:\n            for k, v in _from.items():\n                if k in _to and isinstance(_to[k], dict) and isinstance(v, dict):\n                    # key collision add both are dicts.\n                    # add to merging queue\n                    merge_queue.append((_to[k], v))\n                    continue\n                _to[k] = xerox(v)\n\n    return result\n</code></pre>\n<p>Usage:</p>\n<pre><code class=\"python\">print(\"=============================\")\nprint(\"merge all dicts to first one without copy.\")\na0 = {\"a\":{\"b\":1}}\na1 = {\"a\":{\"c\":{\"d\":4}}}\na2 = {\"a\":{\"c\":{\"f\":5}, \"d\": 6}}\nprint(f\"a0 id[{id(a0)}] value:{a0}\")\nprint(f\"a1 id[{id(a1)}] value:{a1}\")\nprint(f\"a2 id[{id(a2)}] value:{a2}\")\nr = merge_dicts(a0, a1, a2, no_copy=True)\nprint(f\"r  id[{id(r)}] value:{r}\")\n\nprint(\"=============================\")\nprint(\"create fresh copy of all\")\na0 = {\"a\":{\"b\":1}}\na1 = {\"a\":{\"c\":{\"d\":4}}}\na2 = {\"a\":{\"c\":{\"f\":5}, \"d\": 6}}\nprint(f\"a0 id[{id(a0)}] value:{a0}\")\nprint(f\"a1 id[{id(a1)}] value:{a1}\")\nprint(f\"a2 id[{id(a2)}] value:{a2}\")\nr = merge_dicts(a0, a1, a2)\nprint(f\"r  id[{id(r)}] value:{r}\")\n</code></pre>\n", "abstract": "Deep merge of dicts: Usage:"}, {"id": 50289800, "score": 1, "vote": 0, "content": "<p>I think my ugly one-liners are just necessary here.</p>\n<pre><code class=\"python\">z = next(z.update(y) or z for z in [x.copy()])\n# or\nz = (lambda z: z.update(y) or z)(x.copy())\n</code></pre>\n<ol>\n<li>Dicts are merged.</li>\n<li>Single expression.</li>\n<li>Don't ever dare to use it.</li>\n</ol>\n<p><strong>P.S.</strong> This is a solution working in both versions of Python. I know that Python 3 has this <code>{**x, **y}</code> thing and it is the right thing to use (as well as moving to Python 3 if you still have Python 2 is the right thing to do).</p>\n", "abstract": "I think my ugly one-liners are just necessary here. P.S. This is a solution working in both versions of Python. I know that Python 3 has this {**x, **y} thing and it is the right thing to use (as well as moving to Python 3 if you still have Python 2 is the right thing to do)."}, {"id": 68883045, "score": 1, "vote": 0, "content": "<p>A method is deep merging. Making use of the <code>|</code> operator in 3.9+ for the use case of dict <code>new</code> being a set of default settings, and dict <code>existing</code> being a set of existing settings in use. My goal was to merge in any added settings from <code>new</code> without over writing existing settings in <code>existing</code>. I believe this recursive implementation will allow one to upgrade a dict with new values from another dict.</p>\n<pre><code class=\"python\">def merge_dict_recursive(new: dict, existing: dict):\n    merged = new | existing\n\n    for k, v in merged.items():\n        if isinstance(v, dict):\n            if k not in existing:\n                # The key is not in existing dict at all, so add entire value\n                existing[k] = new[k]\n\n            merged[k] = merge_dict_recursive(new[k], existing[k])\n    return merged\n</code></pre>\n<p>Example test data:</p>\n<pre><code class=\"python\">new\n{'dashboard': True,\n 'depth': {'a': 1, 'b': 22222, 'c': {'d': {'e': 69}}},\n 'intro': 'this is the dashboard',\n 'newkey': False,\n 'show_closed_sessions': False,\n 'version': None,\n 'visible_sessions_limit': 9999}\nexisting\n{'dashboard': True,\n 'depth': {'a': 5},\n 'intro': 'this is the dashboard',\n 'newkey': True,\n 'show_closed_sessions': False,\n 'version': '2021-08-22 12:00:30.531038+00:00'}\nmerged\n{'dashboard': True,\n 'depth': {'a': 5, 'b': 22222, 'c': {'d': {'e': 69}}},\n 'intro': 'this is the dashboard',\n 'newkey': True,\n 'show_closed_sessions': False,\n 'version': '2021-08-22 12:00:30.531038+00:00',\n 'visible_sessions_limit': 9999}\n</code></pre>\n", "abstract": "A method is deep merging. Making use of the | operator in 3.9+ for the use case of dict new being a set of default settings, and dict existing being a set of existing settings in use. My goal was to merge in any added settings from new without over writing existing settings in existing. I believe this recursive implementation will allow one to upgrade a dict with new values from another dict. Example test data:"}, {"id": 44262317, "score": 0, "vote": 0, "content": "<p>The question is tagged <code>python-3x</code> but, taking into account that it's a relatively recent addition and that the most voted, accepted answer deals extensively with a Python 2.x solution, I dare add a one liner that draws on an irritating feature of Python 2.x list comprehension, that is <em>name leaking</em>...</p>\n<pre><code class=\"python\">$ python2\nPython 2.7.13 (default, Jan 19 2017, 14:48:08) \n[GCC 6.3.0 20170118] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; [z.update(d) for z in [{}] for d in (x, y)]\n[None, None]\n&gt;&gt;&gt; z\n{'a': 1, 'c': 11, 'b': 10}\n&gt;&gt;&gt; ...\n</code></pre>\n<p>I'm happy to say that the above doesn't work any more on any version of Python 3.</p>\n", "abstract": "The question is tagged python-3x but, taking into account that it's a relatively recent addition and that the most voted, accepted answer deals extensively with a Python 2.x solution, I dare add a one liner that draws on an irritating feature of Python 2.x list comprehension, that is name leaking... I'm happy to say that the above doesn't work any more on any version of Python 3."}]}, {"link": "https://stackoverflow.com/questions/89228/how-do-i-execute-a-program-or-call-a-system-command", "question": {"id": "89228", "title": "How do I execute a program or call a system command?", "content": "<p>How do I call an external command within Python as if I'd typed it in a shell or command prompt?</p>\n", "abstract": "How do I call an external command within Python as if I'd typed it in a shell or command prompt?"}, "answers": [{"id": 89243, "score": 5522, "vote": 0, "content": "<p>Use the <a href=\"https://docs.python.org/library/subprocess.html\" rel=\"noreferrer\"><code>subprocess</code></a> module in the standard library:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import subprocess\nsubprocess.run([\"ls\", \"-l\"])\n</code></pre>\n<p>The advantage of <a href=\"https://docs.python.org/library/subprocess.html#subprocess.run\" rel=\"noreferrer\"><code>subprocess.run</code></a> over <a href=\"https://docs.python.org/library/os.html#os.system\" rel=\"noreferrer\"><code>os.system</code></a> is that it is more flexible (you can get the <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.stdout\" rel=\"noreferrer\"><code>stdout</code></a>, <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.stderr\" rel=\"noreferrer\"><code>stderr</code></a>, the <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CompletedProcess.returncode\" rel=\"noreferrer\">\"real\" status code</a>, better <a href=\"https://docs.python.org/library/subprocess.html#subprocess.CalledProcessError\" rel=\"noreferrer\">error handling</a>, etc...).</p>\n<p>Even <a href=\"https://docs.python.org/library/os.html#os.system\" rel=\"noreferrer\">the documentation for <code>os.system</code></a> recommends using <code>subprocess</code> instead:</p>\n<blockquote>\n<p>The <code>subprocess</code> module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function. See the <a href=\"https://docs.python.org/library/subprocess.html#subprocess-replacements\" rel=\"noreferrer\">Replacing Older Functions with the subprocess Module</a> section in the <a href=\"https://docs.python.org/library/subprocess.html\" rel=\"noreferrer\"><code>subprocess</code></a> documentation for some helpful recipes.</p>\n</blockquote>\n<p>On Python 3.4 and earlier, use <code>subprocess.call</code> instead of <code>.run</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">subprocess.call([\"ls\", \"-l\"])\n</code></pre>\n", "abstract": "Use the subprocess module in the standard library: The advantage of subprocess.run over os.system is that it is more flexible (you can get the stdout, stderr, the \"real\" status code, better error handling, etc...). Even the documentation for os.system recommends using subprocess instead: The subprocess module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function. See the Replacing Older Functions with the subprocess Module section in the subprocess documentation for some helpful recipes. On Python 3.4 and earlier, use subprocess.call instead of .run:"}, {"id": 92395, "score": 3369, "vote": 0, "content": "<p>Summary of ways to call external programs, including their advantages and disadvantages:</p>\n<ol>\n<li><p><a href=\"https://docs.python.org/3/library/os.html#os.system\" rel=\"noreferrer\"><code>os.system</code></a> passes the command and arguments to your system's shell. This is nice because you can actually run multiple commands at once in this manner and set up pipes and input/output redirection. For example:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">os.system(\"some_command &lt; input_file | another_command &gt; output_file\")  \n</code></pre>\n<p>However, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, et cetera. On the other hand, this also lets you run commands which are simply shell commands and not actually external programs.</p>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/os.html#os.popen\" rel=\"noreferrer\"><code>os.popen</code></a> will do the same thing as <code>os.system</code> except that it gives you a file-like object that you can use to access standard input/output for that process. There are 3 other variants of popen that all handle the i/o slightly differently. If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don't need to worry about escaping anything. Example:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">print(os.popen(\"ls -l\").read())\n</code></pre>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.Popen\" rel=\"noreferrer\"><code>subprocess.Popen</code></a>. This is intended as a replacement for <code>os.popen</code>, but has the downside of being slightly more complicated by virtue of being so comprehensive. For example, you'd say:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">print subprocess.Popen(\"echo Hello World\", shell=True, stdout=subprocess.PIPE).stdout.read()\n</code></pre>\n<p>instead of</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">print os.popen(\"echo Hello World\").read()\n</code></pre>\n<p>but it is nice to have all of the options there in one unified class instead of 4 different popen functions. See <a href=\"https://docs.python.org/3/library/subprocess.html#popen-constructor\" rel=\"noreferrer\">the documentation</a>.</p>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.call\" rel=\"noreferrer\"><code>subprocess.call</code></a>. This is basically just like the <code>Popen</code> class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code. For example:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">return_code = subprocess.call(\"echo Hello World\", shell=True)\n</code></pre>\n</li>\n<li><p><a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.run\" rel=\"noreferrer\"><code>subprocess.run</code></a>. Python 3.5+ only. Similar to the above but even more flexible and returns a <a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess\" rel=\"noreferrer\"><code>CompletedProcess</code></a> object when the command finishes executing.</p>\n</li>\n<li><p><code>os.fork</code>, <code>os.exec</code>, <code>os.spawn</code> are similar to their C language counterparts, but I don't recommend using them directly.</p>\n</li>\n</ol>\n<p>The <code>subprocess</code> module should probably be what you use.</p>\n<p>Finally, please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. <strong>There are serious security implications</strong> if any part of the string that you pass can not be fully trusted. For example, if a user is entering some/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">print subprocess.Popen(\"echo %s \" % user_input, stdout=PIPE).stdout.read()\n</code></pre>\n<p>and imagine that the user enters something \"<code>my mama didnt love me &amp;&amp; rm -rf /</code>\" which could erase the whole filesystem.</p>\n", "abstract": "Summary of ways to call external programs, including their advantages and disadvantages: os.system passes the command and arguments to your system's shell. This is nice because you can actually run multiple commands at once in this manner and set up pipes and input/output redirection. For example: However, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, et cetera. On the other hand, this also lets you run commands which are simply shell commands and not actually external programs. os.popen will do the same thing as os.system except that it gives you a file-like object that you can use to access standard input/output for that process. There are 3 other variants of popen that all handle the i/o slightly differently. If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don't need to worry about escaping anything. Example: subprocess.Popen. This is intended as a replacement for os.popen, but has the downside of being slightly more complicated by virtue of being so comprehensive. For example, you'd say: instead of but it is nice to have all of the options there in one unified class instead of 4 different popen functions. See the documentation. subprocess.call. This is basically just like the Popen class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code. For example: subprocess.run. Python 3.5+ only. Similar to the above but even more flexible and returns a CompletedProcess object when the command finishes executing. os.fork, os.exec, os.spawn are similar to their C language counterparts, but I don't recommend using them directly. The subprocess module should probably be what you use. Finally, please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. There are serious security implications if any part of the string that you pass can not be fully trusted. For example, if a user is entering some/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code: and imagine that the user enters something \"my mama didnt love me && rm -rf /\" which could erase the whole filesystem."}, {"id": 95246, "score": 421, "vote": 0, "content": "<p>Typical implementation:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import subprocess\n\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()\n</code></pre>\n<p>You are free to do what you want with the <code>stdout</code> data in the pipe.  In fact, you can simply omit those parameters (<code>stdout=</code> and <code>stderr=</code>) and it'll behave like <code>os.system()</code>.</p>\n", "abstract": "Typical implementation: You are free to do what you want with the stdout data in the pipe.  In fact, you can simply omit those parameters (stdout= and stderr=) and it'll behave like os.system()."}, {"id": 2251026, "score": 268, "vote": 0, "content": "<p>Some hints on detaching the child process from the calling one (starting the child process in background).</p>\n<p>Suppose you want to start a long task from a CGI script. That is, the child process should live longer than the CGI script execution process.</p>\n<p>The classical example from the subprocess module documentation is:</p>\n<pre><code class=\"python\">import subprocess\nimport sys\n\n# Some code here\n\npid = subprocess.Popen([sys.executable, \"longtask.py\"]) # Call subprocess\n\n# Some more code here\n</code></pre>\n<p>The idea here is that you do not want to wait in the line 'call subprocess' until the longtask.py is finished. But it is not clear what happens after the line 'some more code here' from the example.</p>\n<p>My target platform was FreeBSD, but the development was on Windows, so I faced the problem on Windows first.</p>\n<p>On Windows (Windows\u00a0XP), the parent process will not finish until the longtask.py has finished its work. It is not what you want in a CGI script. The problem is not specific to Python; in the PHP community the problems are the same.</p>\n<p>The solution is to pass DETACHED_PROCESS <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx\" rel=\"noreferrer\">Process Creation Flag</a> to the underlying CreateProcess function in Windows API.\nIf you happen to have installed pywin32, you can import the flag from the win32process module, otherwise you should define it yourself:</p>\n<pre><code class=\"python\">DETACHED_PROCESS = 0x00000008\n\npid = subprocess.Popen([sys.executable, \"longtask.py\"],\n                       creationflags=DETACHED_PROCESS).pid\n</code></pre>\n<p>/* <em>UPD 2015.10.27</em> @eryksun in a comment below notes, that the semantically correct flag is CREATE_NEW_CONSOLE (0x00000010) */</p>\n<p>On FreeBSD we have another problem: when the parent process is finished, it finishes the child processes as well. And that is not what you want in a CGI script either. Some experiments showed that the problem seemed to be in sharing sys.stdout. And the working solution was the following:</p>\n<pre><code class=\"python\">pid = subprocess.Popen([sys.executable, \"longtask.py\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n</code></pre>\n<p>I have not checked the code on other platforms and do not know the reasons of the behaviour on FreeBSD. If anyone knows, please share your ideas. Googling on starting background processes in Python does not shed any light yet.</p>\n", "abstract": "Some hints on detaching the child process from the calling one (starting the child process in background). Suppose you want to start a long task from a CGI script. That is, the child process should live longer than the CGI script execution process. The classical example from the subprocess module documentation is: The idea here is that you do not want to wait in the line 'call subprocess' until the longtask.py is finished. But it is not clear what happens after the line 'some more code here' from the example. My target platform was FreeBSD, but the development was on Windows, so I faced the problem on Windows first. On Windows (Windows\u00a0XP), the parent process will not finish until the longtask.py has finished its work. It is not what you want in a CGI script. The problem is not specific to Python; in the PHP community the problems are the same. The solution is to pass DETACHED_PROCESS Process Creation Flag to the underlying CreateProcess function in Windows API.\nIf you happen to have installed pywin32, you can import the flag from the win32process module, otherwise you should define it yourself: /* UPD 2015.10.27 @eryksun in a comment below notes, that the semantically correct flag is CREATE_NEW_CONSOLE (0x00000010) */ On FreeBSD we have another problem: when the parent process is finished, it finishes the child processes as well. And that is not what you want in a CGI script either. Some experiments showed that the problem seemed to be in sharing sys.stdout. And the working solution was the following: I have not checked the code on other platforms and do not know the reasons of the behaviour on FreeBSD. If anyone knows, please share your ideas. Googling on starting background processes in Python does not shed any light yet."}, {"id": 89237, "score": 203, "vote": 0, "content": "<pre><code class=\"python\">import os\nos.system(\"your command\")\n</code></pre>\n<p>Note that this is dangerous, since the command isn't cleaned. I leave it up to you to google for the relevant documentation on the 'os' and 'sys' modules. There are a bunch of functions (exec* and spawn*) that will do similar things.</p>\n", "abstract": "Note that this is dangerous, since the command isn't cleaned. I leave it up to you to google for the relevant documentation on the 'os' and 'sys' modules. There are a bunch of functions (exec* and spawn*) that will do similar things."}, {"id": 89255, "score": 171, "vote": 0, "content": "<p>I'd recommend using the <a href=\"http://docs.python.org/library/subprocess.html\" rel=\"noreferrer\">subprocess</a> module instead of os.system because it does shell escaping for you and is therefore much safer.</p>\n<pre><code class=\"python\">subprocess.call(['ping', 'localhost'])\n</code></pre>\n", "abstract": "I'd recommend using the subprocess module instead of os.system because it does shell escaping for you and is therefore much safer."}, {"id": 89238, "score": 165, "vote": 0, "content": "<pre><code class=\"python\">import os\ncmd = 'ls -al'\nos.system(cmd)\n</code></pre>\n<p>If you want to return the results of the command, you can use <a href=\"https://docs.python.org/2/library/os.html#os.popen\" rel=\"noreferrer\"><code>os.popen</code></a>. However, this is deprecated since version 2.6 in favor of the <a href=\"https://docs.python.org/2/library/subprocess.html#module-subprocess\" rel=\"noreferrer\">subprocess module</a>, which other answers have covered well.</p>\n", "abstract": "If you want to return the results of the command, you can use os.popen. However, this is deprecated since version 2.6 in favor of the subprocess module, which other answers have covered well."}, {"id": 40319875, "score": 130, "vote": 0, "content": "<p>There are lots of different libraries which allow you to call external commands with Python. For each library I've given a description and shown an example of calling an external command. The command I used as the example is <code>ls -l</code> (list all files). If you want to find out more about any of the libraries I've listed and linked the documentation for each of them.</p>\n<h3>Sources</h3>\n<ul>\n<li>subprocess: <a href=\"https://docs.python.org/3.5/library/subprocess.html\" rel=\"noreferrer\">https://docs.python.org/3.5/library/subprocess.html</a></li>\n<li>shlex: <a href=\"https://docs.python.org/3/library/shlex.html\" rel=\"noreferrer\">https://docs.python.org/3/library/shlex.html</a></li>\n<li>os: <a href=\"https://docs.python.org/3.5/library/os.html\" rel=\"noreferrer\">https://docs.python.org/3.5/library/os.html</a></li>\n<li>sh: <a href=\"https://amoffat.github.io/sh/\" rel=\"noreferrer\">https://amoffat.github.io/sh/</a></li>\n<li>plumbum: <a href=\"https://plumbum.readthedocs.io/en/latest/\" rel=\"noreferrer\">https://plumbum.readthedocs.io/en/latest/</a></li>\n<li>pexpect: <a href=\"https://pexpect.readthedocs.io/en/stable/\" rel=\"noreferrer\">https://pexpect.readthedocs.io/en/stable/</a></li>\n<li>fabric: <a href=\"http://www.fabfile.org/\" rel=\"noreferrer\">http://www.fabfile.org/</a></li>\n<li>envoy: <a href=\"https://github.com/kennethreitz/envoy\" rel=\"noreferrer\">https://github.com/kennethreitz/envoy</a></li>\n<li>commands: <a href=\"https://docs.python.org/2/library/commands.html\" rel=\"noreferrer\">https://docs.python.org/2/library/commands.html</a></li>\n</ul>\n<h3>These are all the libraries</h3>\n<p>Hopefully this will help you make a decision on which library to use :)</p>\n<h3><em>subprocess</em></h3>\n<p>Subprocess allows you to call external commands and connect them to their input/output/error pipes (stdin, stdout, and stderr). Subprocess is the default choice for running commands, but sometimes other modules are better.</p>\n<pre><code class=\"python\">subprocess.run([\"ls\", \"-l\"]) # Run command\nsubprocess.run([\"ls\", \"-l\"], stdout=subprocess.PIPE) # This will run the command and return any output\nsubprocess.run(shlex.split(\"ls -l\")) # You can also use the shlex library to split the command\n</code></pre>\n<h3><em>os</em></h3>\n<p>os is used for \"operating system dependent functionality\". It can also be used to call external commands with <code>os.system</code> and <code>os.popen</code> (Note: There is also a subprocess.popen). os will always run the shell and is a simple alternative for people who don't need to, or don't know how to use <code>subprocess.run</code>.</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">os.system(\"ls -l\") # Run command\nos.popen(\"ls -l\").read() # This will run the command and return any output\n</code></pre>\n<h3><em>sh</em></h3>\n<p>sh is a subprocess interface which lets you call programs as if they were functions. This is useful if you want to run a command multiple times.</p>\n<pre><code class=\"python\">sh.ls(\"-l\") # Run command normally\nls_cmd = sh.Command(\"ls\") # Save command as a variable\nls_cmd() # Run command as if it were a function\n</code></pre>\n<h3><em>plumbum</em></h3>\n<p>plumbum is a library for \"script-like\" Python programs. You can call programs like functions as in <code>sh</code>. Plumbum is useful if you want to run a pipeline without the shell.</p>\n<pre><code class=\"python\">ls_cmd = plumbum.local(\"ls -l\") # Get command\nls_cmd() # Run command\n</code></pre>\n<h3><em>pexpect</em></h3>\n<p>pexpect lets you spawn child applications, control them and find patterns in their output. This is a better alternative to subprocess for commands that expect a tty on Unix.</p>\n<pre><code class=\"python\">pexpect.run(\"ls -l\") # Run command as normal\nchild = pexpect.spawn('scp foo user@example.com:.') # Spawns child application\nchild.expect('Password:') # When this is the output\nchild.sendline('mypassword')\n</code></pre>\n<h3><em>fabric</em></h3>\n<p>fabric is a Python 2.5 and 2.7 library. It allows you to execute local and remote shell commands. Fabric is simple alternative for running commands in a secure shell (SSH)</p>\n<pre><code class=\"python\">fabric.operations.local('ls -l') # Run command as normal\nfabric.operations.local('ls -l', capture = True) # Run command and receive output\n</code></pre>\n<h3><em>envoy</em></h3>\n<p>envoy is known as \"subprocess for humans\". It is used as a convenience wrapper around the <code>subprocess</code> module.</p>\n<pre><code class=\"python\">r = envoy.run(\"ls -l\") # Run command\nr.std_out # Get output\n</code></pre>\n<h3><em>commands</em></h3>\n<p><code>commands</code> contains wrapper functions for <code>os.popen</code>, but it has been removed from Python 3 since <code>subprocess</code> is a better alternative.</p>\n", "abstract": "There are lots of different libraries which allow you to call external commands with Python. For each library I've given a description and shown an example of calling an external command. The command I used as the example is ls -l (list all files). If you want to find out more about any of the libraries I've listed and linked the documentation for each of them. Hopefully this will help you make a decision on which library to use :) Subprocess allows you to call external commands and connect them to their input/output/error pipes (stdin, stdout, and stderr). Subprocess is the default choice for running commands, but sometimes other modules are better. os is used for \"operating system dependent functionality\". It can also be used to call external commands with os.system and os.popen (Note: There is also a subprocess.popen). os will always run the shell and is a simple alternative for people who don't need to, or don't know how to use subprocess.run. sh is a subprocess interface which lets you call programs as if they were functions. This is useful if you want to run a command multiple times. plumbum is a library for \"script-like\" Python programs. You can call programs like functions as in sh. Plumbum is useful if you want to run a pipeline without the shell. pexpect lets you spawn child applications, control them and find patterns in their output. This is a better alternative to subprocess for commands that expect a tty on Unix. fabric is a Python 2.5 and 2.7 library. It allows you to execute local and remote shell commands. Fabric is simple alternative for running commands in a secure shell (SSH) envoy is known as \"subprocess for humans\". It is used as a convenience wrapper around the subprocess module. commands contains wrapper functions for os.popen, but it has been removed from Python 3 since subprocess is a better alternative."}, {"id": 15954964, "score": 86, "vote": 0, "content": "<h3>With the standard library</h3>\n<p>Use the <a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.run\" rel=\"noreferrer\">subprocess module</a> (Python 3):</p>\n<pre><code class=\"python\">import subprocess\nsubprocess.run(['ls', '-l'])\n</code></pre>\n<p>It is the recommended standard way. However, more complicated tasks (pipes, output, input, etc.) can be tedious to construct and write.</p>\n<p><em>Note on Python version: If you are still using Python 2, <a href=\"https://docs.python.org/2/library/subprocess.html#subprocess.call\" rel=\"noreferrer\">subprocess.call</a> works in a similar way.</em></p>\n<p><em>ProTip: <a href=\"https://docs.python.org/2/library/shlex.html#shlex.split\" rel=\"noreferrer\">shlex.split</a> can help you to parse the command for <code>run</code>, <code>call</code>, and other <code>subprocess</code> functions in case you don't want (or you can't!) provide them in form of lists:</em></p>\n<pre><code class=\"python\">import shlex\nimport subprocess\nsubprocess.run(shlex.split('ls -l'))\n</code></pre>\n<h3>With external dependencies</h3>\n<p>If you do not mind external dependencies, use <a href=\"https://pypi.python.org/pypi/plumbum\" rel=\"noreferrer\">plumbum</a>:</p>\n<pre><code class=\"python\">from plumbum.cmd import ifconfig\nprint(ifconfig['wlan0']())\n</code></pre>\n<p>It is the best <code>subprocess</code> wrapper. It's cross-platform, i.e. it works on both Windows and Unix-like systems. Install by <code>pip install plumbum</code>.</p>\n<p>Another popular library is <a href=\"https://pypi.python.org/pypi/sh\" rel=\"noreferrer\">sh</a>:</p>\n<pre><code class=\"python\">from sh import ifconfig\nprint(ifconfig('wlan0'))\n</code></pre>\n<p>However, <code>sh</code> dropped Windows support, so it's not as awesome as it used to be. Install by <code>pip install sh</code>.</p>\n", "abstract": "Use the subprocess module (Python 3): It is the recommended standard way. However, more complicated tasks (pipes, output, input, etc.) can be tedious to construct and write. Note on Python version: If you are still using Python 2, subprocess.call works in a similar way. ProTip: shlex.split can help you to parse the command for run, call, and other subprocess functions in case you don't want (or you can't!) provide them in form of lists: If you do not mind external dependencies, use plumbum: It is the best subprocess wrapper. It's cross-platform, i.e. it works on both Windows and Unix-like systems. Install by pip install plumbum. Another popular library is sh: However, sh dropped Windows support, so it's not as awesome as it used to be. Install by pip install sh."}, {"id": 9676642, "score": 83, "vote": 0, "content": "<p>I always use <code>fabric</code> for this things like:</p>\n<pre><code class=\"python\">from fabric.operations import local\nresult = local('ls', capture=True)\nprint \"Content:/n%s\" % (result, )\n</code></pre>\n<p>But this seem to be a good tool: <a href=\"https://github.com/amoffat/sh\" rel=\"noreferrer\"><code>sh</code> (Python subprocess interface)</a>.</p>\n<p>Look at an example:</p>\n<pre><code class=\"python\">from sh import vgdisplay\nprint vgdisplay()\nprint vgdisplay('-v')\nprint vgdisplay(v=True)\n</code></pre>\n", "abstract": "I always use fabric for this things like: But this seem to be a good tool: sh (Python subprocess interface). Look at an example:"}, {"id": 3879406, "score": 81, "vote": 0, "content": "<p>Check the \"pexpect\" Python library, too.</p>\n<p>It allows for interactive controlling of external programs/commands, even ssh, ftp, telnet, etc. You can just type something like:</p>\n<pre><code class=\"python\">child = pexpect.spawn('ftp 192.168.0.24')\n\nchild.expect('(?i)name .*: ')\n\nchild.sendline('anonymous')\n\nchild.expect('(?i)password')\n</code></pre>\n", "abstract": "Check the \"pexpect\" Python library, too. It allows for interactive controlling of external programs/commands, even ssh, ftp, telnet, etc. You can just type something like:"}, {"id": 5824565, "score": 79, "vote": 0, "content": "<p>If you need the output from the command you are calling,\nthen you can use <a href=\"https://docs.python.org/3.6/library/subprocess.html#subprocess.check_output\" rel=\"noreferrer\">subprocess.check_output</a> (Python 2.7+).</p>\n<pre><code class=\"python\">&gt;&gt;&gt; subprocess.check_output([\"ls\", \"-l\", \"/dev/null\"])\n'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\\n'\n</code></pre>\n<p>Also note the <a href=\"https://docs.python.org/3.6/library/subprocess.html#frequently-used-arguments\" rel=\"noreferrer\">shell</a> parameter.</p>\n<blockquote>\n<p>If shell is <code>True</code>, the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user\u2019s home directory. However, note that Python itself offers implementations of many shell-like features (in particular, <code>glob</code>, <code>fnmatch</code>, <code>os.walk()</code>, <code>os.path.expandvars()</code>, <code>os.path.expanduser()</code>, and <code>shutil</code>).</p>\n</blockquote>\n", "abstract": "If you need the output from the command you are calling,\nthen you can use subprocess.check_output (Python 2.7+). Also note the shell parameter. If shell is True, the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of ~ to a user\u2019s home directory. However, note that Python itself offers implementations of many shell-like features (in particular, glob, fnmatch, os.walk(), os.path.expandvars(), os.path.expanduser(), and shutil)."}, {"id": 13402722, "score": 66, "vote": 0, "content": "<h1>Update:</h1>\n<p><code>subprocess.run</code> is the recommended approach <a href=\"https://docs.python.org/3.6/whatsnew/3.5.html#whatsnew-subprocess\" rel=\"noreferrer\">as of Python 3.5</a> if your code does not need to maintain compatibility with earlier Python versions. It's more consistent and offers similar ease-of-use as Envoy. (Piping isn't as straightforward though. See <a href=\"https://stackoverflow.com/questions/7389662/link-several-popen-commands-with-pipes\">this question for how</a>.)</p>\n<p>Here's some examples from <a href=\"https://docs.python.org/3.6/library/subprocess.html#subprocess.run\" rel=\"noreferrer\">the documentation</a>.</p>\n<p>Run a process:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; subprocess.run([\"ls\", \"-l\"])  # Doesn't capture output\nCompletedProcess(args=['ls', '-l'], returncode=0)\n</code></pre>\n<p>Raise on failed run:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; subprocess.run(\"exit 1\", shell=True, check=True)\nTraceback (most recent call last):\n  ...\nsubprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1\n</code></pre>\n<p>Capture output:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; subprocess.run([\"ls\", \"-l\", \"/dev/null\"], stdout=subprocess.PIPE)\nCompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,\nstdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\\n')\n</code></pre>\n<h1>Original answer:</h1>\n<p>I recommend trying <a href=\"https://github.com/kennethreitz/envoy\" rel=\"noreferrer\">Envoy</a>. It's a wrapper for subprocess, which in turn <a href=\"http://docs.python.org/2/library/subprocess.html\" rel=\"noreferrer\">aims to replace</a> the older modules and functions. Envoy is subprocess for humans.</p>\n<p>Example usage from <a href=\"https://github.com/kennethreitz/envoy#readme\" rel=\"noreferrer\">the README</a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; r = envoy.run('git config', data='data to pipe in', timeout=2)\n\n&gt;&gt;&gt; r.status_code\n129\n&gt;&gt;&gt; r.std_out\n'usage: git config [options]'\n&gt;&gt;&gt; r.std_err\n''\n</code></pre>\n<p>Pipe stuff around too:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; r = envoy.run('uptime | pbcopy')\n\n&gt;&gt;&gt; r.command\n'pbcopy'\n&gt;&gt;&gt; r.status_code\n0\n\n&gt;&gt;&gt; r.history\n[&lt;Response 'uptime'&gt;]\n</code></pre>\n", "abstract": "subprocess.run is the recommended approach as of Python 3.5 if your code does not need to maintain compatibility with earlier Python versions. It's more consistent and offers similar ease-of-use as Envoy. (Piping isn't as straightforward though. See this question for how.) Here's some examples from the documentation. Run a process: Raise on failed run: Capture output: I recommend trying Envoy. It's a wrapper for subprocess, which in turn aims to replace the older modules and functions. Envoy is subprocess for humans. Example usage from the README: Pipe stuff around too:"}, {"id": 13106558, "score": 64, "vote": 0, "content": "<p>This is how I run my commands. This code has everything you need pretty much</p>\n<pre><code class=\"python\">from subprocess import Popen, PIPE\ncmd = \"ls -l ~/\"\np = Popen(cmd , shell=True, stdout=PIPE, stderr=PIPE)\nout, err = p.communicate()\nprint \"Return code: \", p.returncode\nprint out.rstrip(), err.rstrip()\n</code></pre>\n", "abstract": "This is how I run my commands. This code has everything you need pretty much"}, {"id": 46815111, "score": 54, "vote": 0, "content": "<blockquote>\n<h2>How to execute a program or call a system command from Python</h2>\n</blockquote>\n<p>Simple, use <code>subprocess.run</code>, which returns a <code>CompletedProcess</code> object:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from subprocess import run\n&gt;&gt;&gt; from shlex import split\n&gt;&gt;&gt; completed_process = run(split('python --version'))\nPython 3.8.8\n&gt;&gt;&gt; completed_process\nCompletedProcess(args=['python', '--version'], returncode=0)\n</code></pre>\n<p>(<code>run</code> wants a list of lexically parsed shell arguments - this is what you'd type in a shell, separated by spaces, but not where the spaces are quoted, so use a specialized function, <code>split</code>, to split up what you would literally type into your shell)</p>\n<h3>Why?</h3>\n<p>As of Python 3.5, the documentation recommends <a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.run\" rel=\"noreferrer\">subprocess.run</a>:</p>\n<blockquote>\n<p>The recommended approach to invoking subprocesses is to use the run() function for all use cases it can handle. For more advanced use cases, the underlying Popen interface can be used directly.</p>\n</blockquote>\n<p>Here's an example of the simplest possible usage - and it does exactly as asked:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from subprocess import run\n&gt;&gt;&gt; from shlex import split\n&gt;&gt;&gt; completed_process = run(split('python --version'))\nPython 3.8.8\n&gt;&gt;&gt; completed_process\nCompletedProcess(args=['python', '--version'], returncode=0)\n</code></pre>\n<p><code>run</code> waits for the command to successfully finish, then returns a <code>CompletedProcess</code> object. It may instead raise <code>TimeoutExpired</code> (if you give it a <code>timeout=</code> argument) or <code>CalledProcessError</code> (if it fails and you pass <code>check=True</code>).</p>\n<p>As you might infer from the above example, stdout and stderr both get piped to your own stdout and stderr by default.</p>\n<p>We can inspect the returned object and see the command that was given and the returncode:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; completed_process.args\n['python', '--version']\n&gt;&gt;&gt; completed_process.returncode\n0\n</code></pre>\n<h3>Capturing output</h3>\n<p>If you want to capture the output, you can pass <code>subprocess.PIPE</code> to the appropriate <code>stderr</code> or <code>stdout</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from subprocess import PIPE\n&gt;&gt;&gt; completed_process = run(shlex.split('python --version'), stdout=PIPE, stderr=PIPE)\n&gt;&gt;&gt; completed_process.stdout\nb'Python 3.8.8\\n'\n&gt;&gt;&gt; completed_process.stderr\nb''\n</code></pre>\n<p>And those respective attributes return bytes.</p>\n<h2>Pass a command list</h2>\n<p>One might easily move from manually providing a command string (like the question suggests) to providing a string built programmatically. <strong>Don't build strings programmatically.</strong> This is a potential security issue. It's better to assume you don't trust the input.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import textwrap\n&gt;&gt;&gt; args = ['python', textwrap.__file__]\n&gt;&gt;&gt; cp = run(args, stdout=subprocess.PIPE)\n&gt;&gt;&gt; cp.stdout\nb'Hello there.\\n  This is indented.\\n'\n</code></pre>\n<p>Note, only <code>args</code> should be passed positionally.</p>\n<h2>Full Signature</h2>\n<p>Here's the actual signature in the source and as shown by <code>help(run)</code>:</p>\n<blockquote>\n<pre><code class=\"python\">def run(*popenargs, input=None, timeout=None, check=False, **kwargs):\n</code></pre>\n</blockquote>\n<p>The <code>popenargs</code> and <code>kwargs</code> are given to the <code>Popen</code> constructor. <code>input</code> can be a string of bytes (or unicode, if specify encoding or <code>universal_newlines=True</code>) that will be piped to the subprocess's stdin.</p>\n<p>The documentation describes <code>timeout=</code> and <code>check=True</code> better than I could:</p>\n<blockquote>\n<p>The timeout argument is passed to Popen.communicate(). If the timeout\nexpires, the child process will be killed and waited for. The\nTimeoutExpired exception will be re-raised after the child process has\nterminated.</p>\n<p>If check is true, and the process exits with a non-zero exit code, a\nCalledProcessError exception will be raised. Attributes of that\nexception hold the arguments, the exit code, and stdout and stderr if\nthey were captured.</p>\n</blockquote>\n<p>and this example for <code>check=True</code> is better than one I could come up with:</p>\n<blockquote>\n<pre><code class=\"python\">&gt;&gt;&gt; subprocess.run(\"exit 1\", shell=True, check=True)\nTraceback (most recent call last):\n  ...\nsubprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1\n</code></pre>\n</blockquote>\n<h3>Expanded Signature</h3>\n<p>Here's an expanded signature, as given in the documentation:</p>\n<blockquote>\n<pre><code class=\"python\">subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, \nshell=False, cwd=None, timeout=None, check=False, encoding=None, \nerrors=None)\n</code></pre>\n</blockquote>\n<p>Note that this indicates that only the args list should be passed positionally. So pass the remaining arguments as keyword arguments.</p>\n<h3>Popen</h3>\n<p>When use <code>Popen</code> instead? I would struggle to find use-case based on the arguments alone. Direct usage of <code>Popen</code> would, however, give you access to its methods, including <code>poll</code>, 'send_signal', 'terminate', and 'wait'.</p>\n<p>Here's the <code>Popen</code> signature as given in <a href=\"https://github.com/python/cpython/blob/master/Lib/subprocess.py#L752\" rel=\"noreferrer\">the source</a>. I think this is the most precise encapsulation of the information (as opposed to <code>help(Popen)</code>):</p>\n<pre><code class=\"python\">\ndef __init__(self, args, bufsize=-1, executable=None,\n             stdin=None, stdout=None, stderr=None,\n             preexec_fn=None, close_fds=True,\n             shell=False, cwd=None, env=None, universal_newlines=None,\n             startupinfo=None, creationflags=0,\n             restore_signals=True, start_new_session=False,\n             pass_fds=(), *, user=None, group=None, extra_groups=None,\n             encoding=None, errors=None, text=None, umask=-1, pipesize=-1):\n\n</code></pre>\n<p>But more informative is <a href=\"https://docs.python.org/3/library/subprocess.html#popen-constructor\" rel=\"noreferrer\">the <code>Popen</code> documentation</a>:</p>\n<blockquote>\n<pre><code class=\"python\">subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, \nstderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None,\nenv=None, universal_newlines=None, startupinfo=None, creationflags=0, \nrestore_signals=True, start_new_session=False, pass_fds=(), *, group=None, \nextra_groups=None, user=None, umask=-1, encoding=None, errors=None, \ntext=None)\n</code></pre>\n<p>Execute a child program in a new process. On POSIX, the class uses\nos.execvp()-like behavior to execute the child program. On Windows,\nthe class uses the Windows CreateProcess() function. The arguments to\nPopen are as follows.</p>\n</blockquote>\n<p>Understanding the remaining documentation on <code>Popen</code> will be left as an exercise for the reader.</p>\n", "abstract": "Simple, use subprocess.run, which returns a CompletedProcess object: (run wants a list of lexically parsed shell arguments - this is what you'd type in a shell, separated by spaces, but not where the spaces are quoted, so use a specialized function, split, to split up what you would literally type into your shell) As of Python 3.5, the documentation recommends subprocess.run: The recommended approach to invoking subprocesses is to use the run() function for all use cases it can handle. For more advanced use cases, the underlying Popen interface can be used directly. Here's an example of the simplest possible usage - and it does exactly as asked: run waits for the command to successfully finish, then returns a CompletedProcess object. It may instead raise TimeoutExpired (if you give it a timeout= argument) or CalledProcessError (if it fails and you pass check=True). As you might infer from the above example, stdout and stderr both get piped to your own stdout and stderr by default. We can inspect the returned object and see the command that was given and the returncode: If you want to capture the output, you can pass subprocess.PIPE to the appropriate stderr or stdout: And those respective attributes return bytes. One might easily move from manually providing a command string (like the question suggests) to providing a string built programmatically. Don't build strings programmatically. This is a potential security issue. It's better to assume you don't trust the input. Note, only args should be passed positionally. Here's the actual signature in the source and as shown by help(run): The popenargs and kwargs are given to the Popen constructor. input can be a string of bytes (or unicode, if specify encoding or universal_newlines=True) that will be piped to the subprocess's stdin. The documentation describes timeout= and check=True better than I could: The timeout argument is passed to Popen.communicate(). If the timeout\nexpires, the child process will be killed and waited for. The\nTimeoutExpired exception will be re-raised after the child process has\nterminated. If check is true, and the process exits with a non-zero exit code, a\nCalledProcessError exception will be raised. Attributes of that\nexception hold the arguments, the exit code, and stdout and stderr if\nthey were captured. and this example for check=True is better than one I could come up with: Here's an expanded signature, as given in the documentation: Note that this indicates that only the args list should be passed positionally. So pass the remaining arguments as keyword arguments. When use Popen instead? I would struggle to find use-case based on the arguments alone. Direct usage of Popen would, however, give you access to its methods, including poll, 'send_signal', 'terminate', and 'wait'. Here's the Popen signature as given in the source. I think this is the most precise encapsulation of the information (as opposed to help(Popen)): But more informative is the Popen documentation: Execute a child program in a new process. On POSIX, the class uses\nos.execvp()-like behavior to execute the child program. On Windows,\nthe class uses the Windows CreateProcess() function. The arguments to\nPopen are as follows. Understanding the remaining documentation on Popen will be left as an exercise for the reader."}, {"id": 89262, "score": 53, "vote": 0, "content": "<p>Use <em><a href=\"https://docs.python.org/2/library/subprocess.html\" rel=\"noreferrer\">subprocess</a></em>.</p>\n<p>...or for a very simple command:</p>\n<pre><code class=\"python\">import os\nos.system('cat testfile')\n</code></pre>\n", "abstract": "Use subprocess. ...or for a very simple command:"}, {"id": 64341833, "score": 43, "vote": 0, "content": "<p><em>As of <strong>Python 3.7.0 released on June 27th 2018 (<a href=\"https://docs.python.org/3/whatsnew/3.7.html\" rel=\"noreferrer\">https://docs.python.org/3/whatsnew/3.7.html</a>)</strong>, you can achieve your desired result in the most powerful while equally simple way. This answer intends to show you the essential summary of various options in a short manner. For in-depth answers, please see the other ones.</em></p>\n<hr/>\n<h1>TL;DR in 2021</h1>\n<p>The big advantage of <code>os.system(...)</code> was its simplicity. <code>subprocess</code> is better and still easy to use, especially as of <strong>Python 3.5</strong>.</p>\n<pre><code class=\"python\">import subprocess\nsubprocess.run(\"ls -a\", shell=True)\n</code></pre>\n<p><em><strong>Note:</strong></em> This is the exact answer to your question - running a command</p>\n<blockquote>\n<p>like in a shell</p>\n</blockquote>\n<hr/>\n<h3>Preferred Way</h3>\n<p>If possible, remove the shell overhead and run the command directly (requires a list).</p>\n<pre><code class=\"python\">import subprocess\nsubprocess.run([\"help\"])\nsubprocess.run([\"ls\", \"-a\"])\n</code></pre>\n<p>Pass program arguments in a list. <strong>Don't include <code>\\\"</code>-escaping for arguments containing spaces.</strong></p>\n<hr/>\n<h1>Advanced Use Cases</h1>\n<h2>Checking The Output</h2>\n<p>The following code speaks for itself:</p>\n<pre><code class=\"python\">import subprocess\nresult = subprocess.run([\"ls\", \"-a\"], capture_output=True, text=True)\nif \"stackoverflow-logo.png\" in result.stdout:\n    print(\"You're a fan!\")\nelse:\n    print(\"You're not a fan?\")\n</code></pre>\n<p><code>result.stdout</code> is all normal program output <strong>excluding errors</strong>. Read <code>result.stderr</code> to get them.</p>\n<p><code>capture_output=True</code> - turns capturing on. Otherwise <code>result.stderr</code> and <code>result.stdout</code> would be <code>None</code>. Available from <em>Python 3.7</em>.</p>\n<p><code>text=True</code> - a convenience argument added in <em>Python 3.7</em> which converts the received binary data to Python strings you can easily work with.</p>\n<h2>Checking the returncode</h2>\n<p>Do</p>\n<pre><code class=\"python\">if result.returncode == 127: print(\"The program failed for some weird reason\")\nelif result.returncode == 0: print(\"The program succeeded\")\nelse: print(\"The program failed unexpectedly\")\n</code></pre>\n<p>If you just want to check if the program succeeded (returncode == 0) and otherwise throw an Exception, there is a more convenient function:</p>\n<pre><code class=\"python\">result.check_returncode()\n</code></pre>\n<p>But it's Python, so there's an even more convenient argument <code>check</code> which does the same thing automatically for you:</p>\n<pre><code class=\"python\">result = subprocess.run(..., check=True)\n</code></pre>\n<h2>stderr should be inside stdout</h2>\n<p>You might want to have all program output inside stdout, even errors. To accomplish this, run</p>\n<pre><code class=\"python\">result = subprocess.run(..., stderr=subprocess.STDOUT)\n</code></pre>\n<p><code>result.stderr</code> will then be <code>None</code> and <code>result.stdout</code> will contain everything.</p>\n<h2>Using shell=False with an argument string</h2>\n<p><code>shell=False</code> expects a <strong>list</strong> of arguments. You might however, split an argument string on your own using shlex.</p>\n<pre><code class=\"python\">import subprocess\nimport shlex\nsubprocess.run(shlex.split(\"ls -a\"))\n</code></pre>\n<p>That's it.</p>\n<h1>Common Problems</h1>\n<p>Chances are high you just started using Python when you come across this question. Let's look at some common problems.</p>\n<blockquote>\n<p>FileNotFoundError: [Errno 2] No such file or directory: 'ls -a': 'ls -a'</p>\n</blockquote>\n<p><em>You're running a subprocess without <code>shell=True</code> . Either use a list (<code>[\"ls\", \"-a\"]</code>) or set <code>shell=True</code>.</em></p>\n<blockquote>\n<p>TypeError: [...] NoneType [...]</p>\n</blockquote>\n<p><em>Check that you've set <code>capture_output=True</code>.</em></p>\n<blockquote>\n<p>TypeError: a bytes-like object is required, not [...]</p>\n</blockquote>\n<p><em>You always receive byte results from your program. If you want to work with it like a normal string, set <code>text=True</code>.</em></p>\n<blockquote>\n<p>subprocess.CalledProcessError: Command '[...]' returned non-zero exit status 1.</p>\n</blockquote>\n<p><em>Your command didn't run successfully. You could disable returncode checking or check your actual program's validity.</em></p>\n<blockquote>\n<p>TypeError: <strong>init</strong>() got an unexpected keyword argument [...]</p>\n</blockquote>\n<p><em>You're likely using a version of Python older than 3.7.0; update it to the most recent one available. Otherwise there are other answers in this Stack Overflow post showing you older alternative solutions.</em></p>\n", "abstract": "As of Python 3.7.0 released on June 27th 2018 (https://docs.python.org/3/whatsnew/3.7.html), you can achieve your desired result in the most powerful while equally simple way. This answer intends to show you the essential summary of various options in a short manner. For in-depth answers, please see the other ones. The big advantage of os.system(...) was its simplicity. subprocess is better and still easy to use, especially as of Python 3.5. Note: This is the exact answer to your question - running a command like in a shell If possible, remove the shell overhead and run the command directly (requires a list). Pass program arguments in a list. Don't include \\\"-escaping for arguments containing spaces. The following code speaks for itself: result.stdout is all normal program output excluding errors. Read result.stderr to get them. capture_output=True - turns capturing on. Otherwise result.stderr and result.stdout would be None. Available from Python 3.7. text=True - a convenience argument added in Python 3.7 which converts the received binary data to Python strings you can easily work with. Do If you just want to check if the program succeeded (returncode == 0) and otherwise throw an Exception, there is a more convenient function: But it's Python, so there's an even more convenient argument check which does the same thing automatically for you: You might want to have all program output inside stdout, even errors. To accomplish this, run result.stderr will then be None and result.stdout will contain everything. shell=False expects a list of arguments. You might however, split an argument string on your own using shlex. That's it. Chances are high you just started using Python when you come across this question. Let's look at some common problems. FileNotFoundError: [Errno 2] No such file or directory: 'ls -a': 'ls -a' You're running a subprocess without shell=True . Either use a list ([\"ls\", \"-a\"]) or set shell=True. TypeError: [...] NoneType [...] Check that you've set capture_output=True. TypeError: a bytes-like object is required, not [...] You always receive byte results from your program. If you want to work with it like a normal string, set text=True. subprocess.CalledProcessError: Command '[...]' returned non-zero exit status 1. Your command didn't run successfully. You could disable returncode checking or check your actual program's validity. TypeError: init() got an unexpected keyword argument [...] You're likely using a version of Python older than 3.7.0; update it to the most recent one available. Otherwise there are other answers in this Stack Overflow post showing you older alternative solutions."}, {"id": 89304, "score": 42, "vote": 0, "content": "<p><code>os.system</code> is OK, but kind of dated.  It's also not very secure.  Instead, try <code>subprocess</code>.  <code>subprocess</code> does not call sh directly and is therefore more secure than <code>os.system</code>.</p>\n<p>Get more information <a href=\"https://docs.python.org/library/subprocess.html\" rel=\"noreferrer\">here</a>.</p>\n", "abstract": "os.system is OK, but kind of dated.  It's also not very secure.  Instead, try subprocess.  subprocess does not call sh directly and is therefore more secure than os.system. Get more information here."}, {"id": 26305089, "score": 39, "vote": 0, "content": "<p>There is also <a href=\"http://plumbum.readthedocs.org/en/latest/\">Plumbum</a></p>\n<pre><code class=\"python\">&gt;&gt;&gt; from plumbum import local\n&gt;&gt;&gt; ls = local[\"ls\"]\n&gt;&gt;&gt; ls\nLocalCommand(&lt;LocalPath /bin/ls&gt;)\n&gt;&gt;&gt; ls()\nu'build.py\\ndist\\ndocs\\nLICENSE\\nplumbum\\nREADME.rst\\nsetup.py\\ntests\\ntodo.txt\\n'\n&gt;&gt;&gt; notepad = local[\"c:\\\\windows\\\\notepad.exe\"]\n&gt;&gt;&gt; notepad()                                   # Notepad window pops up\nu''                                             # Notepad window is closed by user, command returns\n</code></pre>\n", "abstract": "There is also Plumbum"}, {"id": 31114625, "score": 32, "vote": 0, "content": "<p>Use:</p>\n<pre><code class=\"python\">import os\n\ncmd = 'ls -al'\n\nos.system(cmd)\n</code></pre>\n<p><strong>os - This module provides a portable way of using operating system-dependent functionality.</strong></p>\n<p>For the more <code>os</code> functions, <a href=\"https://docs.python.org/2/library/os.html\" rel=\"noreferrer\">here</a> is the documentation.</p>\n", "abstract": "Use: os - This module provides a portable way of using operating system-dependent functionality. For the more os functions, here is the documentation."}, {"id": 50101887, "score": 32, "vote": 0, "content": "<p>It can be this simple:</p>\n<pre><code class=\"python\">import os\ncmd = \"your command\"\nos.system(cmd)\n</code></pre>\n", "abstract": "It can be this simple:"}, {"id": 2030768, "score": 26, "vote": 0, "content": "<p>There is another difference here which is not mentioned previously.</p>\n<p><code>subprocess.Popen</code> executes the &lt;command&gt; as a subprocess. In my case, I need to execute file &lt;a&gt; which needs to communicate with another program, &lt;b&gt;. </p>\n<p>I tried subprocess, and execution was successful. However &lt;b&gt; could not communicate with &lt;a&gt;.\nEverything is normal when I run both from the terminal.</p>\n<p>One more: \n(NOTE: kwrite behaves different from other applications. If you try the below with Firefox, the results will not be the same.)</p>\n<p>If you try <code>os.system(\"kwrite\")</code>, program flow freezes until the user closes kwrite. To overcome that I tried instead <code>os.system(konsole -e kwrite)</code>. This time program continued to flow, but kwrite became the subprocess of the console.</p>\n<p>Anyone runs the kwrite not being a subprocess (i.e. in the system monitor it must appear at the leftmost edge of the tree).</p>\n", "abstract": "There is another difference here which is not mentioned previously. subprocess.Popen executes the <command> as a subprocess. In my case, I need to execute file <a> which needs to communicate with another program, <b>.  I tried subprocess, and execution was successful. However <b> could not communicate with <a>.\nEverything is normal when I run both from the terminal. One more: \n(NOTE: kwrite behaves different from other applications. If you try the below with Firefox, the results will not be the same.) If you try os.system(\"kwrite\"), program flow freezes until the user closes kwrite. To overcome that I tried instead os.system(konsole -e kwrite). This time program continued to flow, but kwrite became the subprocess of the console. Anyone runs the kwrite not being a subprocess (i.e. in the system monitor it must appear at the leftmost edge of the tree)."}, {"id": 10988365, "score": 26, "vote": 0, "content": "<p><code>os.system</code> does not allow you to store results, so if you want to store results in some list or something, a <code>subprocess.call</code> works.</p>\n", "abstract": "os.system does not allow you to store results, so if you want to store results in some list or something, a subprocess.call works."}, {"id": 4728086, "score": 25, "vote": 0, "content": "<p><code>subprocess.check_call</code> is convenient if you don't want to test return values. It throws an exception on any error.</p>\n", "abstract": "subprocess.check_call is convenient if you don't want to test return values. It throws an exception on any error."}, {"id": 23391049, "score": 25, "vote": 0, "content": "<p>I tend to use <a href=\"https://docs.python.org/2/library/subprocess.html\" rel=\"noreferrer\">subprocess</a> together with <a href=\"https://docs.python.org/2/library/shlex.html\" rel=\"noreferrer\">shlex</a> (to handle escaping of quoted strings):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import subprocess, shlex\n&gt;&gt;&gt; command = 'ls -l \"/your/path/with spaces/\"'\n&gt;&gt;&gt; call_params = shlex.split(command)\n&gt;&gt;&gt; print call_params\n[\"ls\", \"-l\", \"/your/path/with spaces/\"]\n&gt;&gt;&gt; subprocess.call(call_params)\n</code></pre>\n", "abstract": "I tend to use subprocess together with shlex (to handle escaping of quoted strings):"}, {"id": 23416345, "score": 21, "vote": 0, "content": "<p>I wrote a library for this, <em><a href=\"https://github.com/houqp/shell.py\" rel=\"nofollow noreferrer\">shell.py</a></em>.</p>\n<p>It's basically a wrapper for popen and shlex for now. It also supports piping commands, so you can chain commands easier in Python. So you can do things like:</p>\n<pre><code class=\"python\">ex('echo hello shell.py') | \"awk '{print $2}'\"\n</code></pre>\n", "abstract": "I wrote a library for this, shell.py. It's basically a wrapper for popen and shlex for now. It also supports piping commands, so you can chain commands easier in Python. So you can do things like:"}, {"id": 37877635, "score": 19, "vote": 0, "content": "<p>In Windows you can just import the <code>subprocess</code> module and run external commands by calling <code>subprocess.Popen()</code>, <code>subprocess.Popen().communicate()</code> and <code>subprocess.Popen().wait()</code> as below:</p>\n<pre><code class=\"python\"># Python script to run a command line\nimport subprocess\n\ndef execute(cmd):\n    \"\"\"\n        Purpose  : To execute a command and return exit status\n        Argument : cmd - command to execute\n        Return   : exit_code\n    \"\"\"\n    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    (result, error) = process.communicate()\n\n    rc = process.wait()\n\n    if rc != 0:\n        print \"Error: failed to execute command:\", cmd\n        print error\n    return result\n# def\n\ncommand = \"tasklist | grep python\"\nprint \"This process detail: \\n\", execute(command)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">This process detail:\npython.exe                     604 RDP-Tcp#0                  4      5,660 K\n</code></pre>\n", "abstract": "In Windows you can just import the subprocess module and run external commands by calling subprocess.Popen(), subprocess.Popen().communicate() and subprocess.Popen().wait() as below: Output:"}, {"id": 40824514, "score": 19, "vote": 0, "content": "<p>Under Linux, in case you would like to call an external command that will execute independently (will keep running after the Python script terminates), you can use a simple queue as <a href=\"http://vicerveza.homeunix.net/%7Eviric/soft/ts/\" rel=\"nofollow noreferrer\">task spooler</a> or the <a href=\"https://linux.die.net/man/1/at\" rel=\"nofollow noreferrer\">at</a> command.</p>\n<p>An example with task spooler:</p>\n<pre><code class=\"python\">import os\nos.system('ts &lt;your-command&gt;')\n</code></pre>\n<p>Notes about task spooler (<code>ts</code>):</p>\n<ol>\n<li><p>You could set the number of concurrent processes to be run (\"slots\") with:</p>\n<p><code>ts -S &lt;number-of-slots&gt;</code></p>\n</li>\n<li><p>Installing <code>ts</code> doesn't requires admin privileges. You can download and compile it from source with a simple <code>make</code>, add it to your path and you're done.</p>\n</li>\n</ol>\n", "abstract": "Under Linux, in case you would like to call an external command that will execute independently (will keep running after the Python script terminates), you can use a simple queue as task spooler or the at command. An example with task spooler: Notes about task spooler (ts): You could set the number of concurrent processes to be run (\"slots\") with: ts -S <number-of-slots> Installing ts doesn't requires admin privileges. You can download and compile it from source with a simple make, add it to your path and you're done."}, {"id": 52339862, "score": 19, "vote": 0, "content": "<p><strong><a href=\"http://www.pyinvoke.org/\" rel=\"nofollow noreferrer\">Invoke</a></strong> is a Python (2.7 and 3.4+) task execution tool and library. It provides a clean, high-level API for running shell commands:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from invoke import run\n&gt;&gt;&gt; cmd = \"pip install -r requirements.txt\"\n&gt;&gt;&gt; result = run(cmd, hide=True, warn=True)\n&gt;&gt;&gt; print(result.ok)\nTrue\n&gt;&gt;&gt; print(result.stdout.splitlines()[-1])\nSuccessfully installed invocations-0.13.0 pep8-1.5.7 spec-1.3.1\n</code></pre>\n", "abstract": "Invoke is a Python (2.7 and 3.4+) task execution tool and library. It provides a clean, high-level API for running shell commands:"}, {"id": 11507283, "score": 18, "vote": 0, "content": "<p>You can use Popen, and then you can check the procedure's status:</p>\n<pre><code class=\"python\">from subprocess import Popen\n\nproc = Popen(['ls', '-l'])\nif proc.poll() is None:\n    proc.kill()\n</code></pre>\n<p>Check out <a href=\"http://docs.python.org/library/subprocess.html#popen-objects\" rel=\"noreferrer\">subprocess.Popen</a>.</p>\n", "abstract": "You can use Popen, and then you can check the procedure's status: Check out subprocess.Popen."}, {"id": 25476624, "score": 17, "vote": 0, "content": "<p>A simple way is to use the <a href=\"https://docs.python.org/2/library/os.html\" rel=\"noreferrer\">os module</a>:</p>\n<pre><code class=\"python\">import os\nos.system('ls')\n</code></pre>\n<p>Alternatively, you can also use the subprocess module:</p>\n<pre><code class=\"python\">import subprocess\nsubprocess.check_call('ls')\n</code></pre>\n<p>If you want the result to be stored in a variable try:</p>\n<pre><code class=\"python\">import subprocess\nr = subprocess.check_output('ls')\n</code></pre>\n", "abstract": "A simple way is to use the os module: Alternatively, you can also use the subprocess module: If you want the result to be stored in a variable try:"}, {"id": 38477871, "score": 17, "vote": 0, "content": "<p>To fetch the network id from the <a href=\"https://en.wikipedia.org/wiki/OpenStack\" rel=\"noreferrer\">OpenStack</a> <a href=\"https://en.wikipedia.org/wiki/OpenStack#Networking_(Neutron)\" rel=\"noreferrer\">Neutron</a>:</p>\n<pre><code class=\"python\">#!/usr/bin/python\nimport os\nnetid = \"nova net-list | awk '/ External / { print $2 }'\"\ntemp = os.popen(netid).read()  /* Here temp also contains new line (\\n) */\nnetworkId = temp.rstrip()\nprint(networkId)\n</code></pre>\n<p>Output of <strong>nova net-list</strong></p>\n<pre><code class=\"python\">+--------------------------------------+------------+------+\n| ID                                   | Label      | CIDR |\n+--------------------------------------+------------+------+\n| 431c9014-5b5d-4b51-a357-66020ffbb123 | test1      | None |\n| 27a74fcd-37c0-4789-9414-9531b7e3f126 | External   | None |\n| 5a2712e9-70dc-4b0e-9281-17e02f4684c9 | management | None |\n| 7aa697f5-0e60-4c15-b4cc-9cb659698512 | Internal   | None |\n+--------------------------------------+------------+------+\n</code></pre>\n<p>Output of <strong>print(networkId)</strong></p>\n<pre><code class=\"python\">27a74fcd-37c0-4789-9414-9531b7e3f126\n</code></pre>\n", "abstract": "To fetch the network id from the OpenStack Neutron: Output of nova net-list Output of print(networkId)"}, {"id": 11644161, "score": 15, "vote": 0, "content": "<p>Very simplest way to run any command and get the result back:</p>\n<pre><code class=\"python\">from commands import getstatusoutput\n\ntry:\n    return getstatusoutput(\"ls -ltr\")\nexcept Exception, e:\n    return None\n</code></pre>\n", "abstract": "Very simplest way to run any command and get the result back:"}, {"id": 59090212, "score": 14, "vote": 0, "content": "<p><em><strong>MOST OF THE CASES:</strong></em></p>\n<p><strong>For the most of cases, a short snippet of code like this is all you are going to need</strong>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import subprocess\nimport shlex\n\nsource = \"test.txt\"\ndestination = \"test_copy.txt\"\n\nbase = \"cp {source} {destination}'\"\ncmd = base.format(source=source, destination=destination)\nsubprocess.check_call(shlex.split(cmd))\n</code></pre>\n<p><strong>It is clean and simple</strong>.</p>\n<blockquote>\n<p><code>subprocess.check_call</code> run command with arguments and wait for\ncommand to complete.</p>\n<p><code>shlex.split</code> split the string cmd using shell-like syntax</p>\n</blockquote>\n<p><em><strong>REST OF THE CASES:</strong></em></p>\n<p>If this do not work for some specific command, most probably you have a problem with <a href=\"https://en.wikipedia.org/wiki/List_of_command-line_interpreters\" rel=\"nofollow noreferrer\"> <strong>command-line interpreters</strong></a>. The operating system chose the default one which is not suitable for your type of program or could not found an adequate one on the system executable path.</p>\n<p><strong>Example:</strong></p>\n<p>Using the redirection operator on a Unix system</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">input_1 = \"input_1.txt\"\ninput_2 = \"input_2.txt\"\noutput = \"merged.txt\"\nbase_command = \"/bin/bash -c 'cat {input} &gt;&gt; {output}'\"\n\nbase_command.format(input_1, output=output)\nsubprocess.check_call(shlex.split(base_command))\n\nbase_command.format(input_2, output=output)\nsubprocess.check_call(shlex.split(base_command))\n</code></pre>\n<blockquote>\n<p>As it is stated in <a href=\"https://www.python.org/dev/peps/pep-0020/\" rel=\"nofollow noreferrer\">The Zen of Python</a>: <strong>Explicit is better than\nimplicit</strong></p>\n</blockquote>\n<p>So if using a Python &gt;=3.6 function, it would look something like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import subprocess\nimport shlex\n\ndef run_command(cmd_interpreter: str, command: str) -&gt; None:\n    base_command = f\"{cmd_interpreter} -c '{command}'\"\n    subprocess.check_call(shlex.split(base_command)\n\n</code></pre>\n", "abstract": "MOST OF THE CASES: For the most of cases, a short snippet of code like this is all you are going to need: It is clean and simple. subprocess.check_call run command with arguments and wait for\ncommand to complete. shlex.split split the string cmd using shell-like syntax REST OF THE CASES: If this do not work for some specific command, most probably you have a problem with  command-line interpreters. The operating system chose the default one which is not suitable for your type of program or could not found an adequate one on the system executable path. Example: Using the redirection operator on a Unix system As it is stated in The Zen of Python: Explicit is better than\nimplicit So if using a Python >=3.6 function, it would look something like this:"}, {"id": 49441486, "score": 13, "vote": 0, "content": "<p>Often, I use the following function for external commands, and this is especially handy for <strong>long running processes</strong>. The below method <strong>tails process output</strong> <em>while</em> it is running and returns the output, <strong>raises an exception</strong> if process fails.</p>\n<p>It comes out if the process is done using the <strong>poll() method on the process</strong>.</p>\n<pre><code class=\"python\">import subprocess,sys\n\ndef exec_long_running_proc(command, args):\n    cmd = \"{} {}\".format(command, \" \".join(str(arg) if ' ' not in arg else arg.replace(' ','\\ ') for arg in args))\n    print(cmd)\n    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n\n    # Poll process for new output until finished\n    while True:\n        nextline = process.stdout.readline().decode('UTF-8')\n        if nextline == '' and process.poll() is not None:\n            break\n        sys.stdout.write(nextline)\n        sys.stdout.flush()\n\n    output = process.communicate()[0]\n    exitCode = process.returncode\n\n    if (exitCode == 0):\n        return output\n    else:\n        raise Exception(command, exitCode, output)\n</code></pre>\n<p><strong>You can invoke it like this:</strong></p>\n<pre><code class=\"python\">exec_long_running_proc(command = \"hive\", args=[\"-f\", hql_path])\n</code></pre>\n", "abstract": "Often, I use the following function for external commands, and this is especially handy for long running processes. The below method tails process output while it is running and returns the output, raises an exception if process fails. It comes out if the process is done using the poll() method on the process. You can invoke it like this:"}, {"id": 33118899, "score": 12, "vote": 0, "content": "<p>Here are my two cents: In my view, this is the best practice when dealing with external commands...</p>\n<p>These are the return values from the execute method...</p>\n<pre><code class=\"python\">pass, stdout, stderr = execute([\"ls\",\"-la\"],\"/home/user/desktop\")\n</code></pre>\n<p>This is the execute method...</p>\n<pre><code class=\"python\">def execute(cmdArray,workingDir):\n\n    stdout = ''\n    stderr = ''\n\n    try:\n        try:\n            process = subprocess.Popen(cmdArray,cwd=workingDir, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=1)\n        except OSError:\n            return [False, '', 'ERROR : command(' + ' '.join(cmdArray) + ') could not get executed!']\n\n        for line in iter(process.stdout.readline, b''):\n\n            try:\n                echoLine = line.decode(\"utf-8\")\n            except:\n                echoLine = str(line)\n\n            stdout += echoLine\n\n        for line in iter(process.stderr.readline, b''):\n\n            try:\n                echoLine = line.decode(\"utf-8\")\n            except:\n                echoLine = str(line)\n\n            stderr += echoLine\n\n    except (KeyboardInterrupt,SystemExit) as err:\n        return [False,'',str(err)]\n\n    process.stdout.close()\n\n    returnCode = process.wait()\n    if returnCode != 0 or stderr != '':\n        return [False, stdout, stderr]\n    else:\n        return [True, stdout, stderr]\n</code></pre>\n", "abstract": "Here are my two cents: In my view, this is the best practice when dealing with external commands... These are the return values from the execute method... This is the execute method..."}, {"id": 17202916, "score": 11, "vote": 0, "content": "<p>Just to add to the discussion, if you include using a Python console, you can call external commands from <a href=\"http://en.wikipedia.org/wiki/IPython\" rel=\"noreferrer\">IPython</a>. While in the IPython prompt, you can call shell commands by prefixing '!'. You can also combine Python code with the shell, and assign the output of shell scripts to Python variables.</p>\n<p>For instance:</p>\n<pre><code class=\"python\">In [9]: mylist = !ls\n\nIn [10]: mylist\nOut[10]:\n['file1',\n 'file2',\n 'file3',]\n</code></pre>\n", "abstract": "Just to add to the discussion, if you include using a Python console, you can call external commands from IPython. While in the IPython prompt, you can call shell commands by prefixing '!'. You can also combine Python code with the shell, and assign the output of shell scripts to Python variables. For instance:"}, {"id": 53063521, "score": 11, "vote": 0, "content": "<p>I wrote a small library to help with this use case:</p>\n<p><a href=\"https://pypi.org/project/citizenshell/\" rel=\"nofollow noreferrer\">https://pypi.org/project/citizenshell/</a></p>\n<p>It can be installed using</p>\n<pre><code class=\"python\">pip install citizenshell\n</code></pre>\n<p>And then used as follows:</p>\n<pre><code class=\"python\">from citizenshell import sh\nassert sh(\"echo Hello World\") == \"Hello World\"\n</code></pre>\n<p>You can separate standard output from standard error and extract the exit code as follows:</p>\n<pre><code class=\"python\">result = sh(\"&gt;&amp;2 echo error &amp;&amp; echo output &amp;&amp; exit 13\")\nassert result.stdout() == [\"output\"]\nassert result.stderr() == [\"error\"]\nassert result.exit_code() == 13\n</code></pre>\n<p>And the cool thing is that you don't have to wait for the underlying shell to exit before starting processing the output:</p>\n<pre><code class=\"python\">for line in sh(\"for i in 1 2 3 4; do echo -n 'It is '; date +%H:%M:%S; sleep 1; done\", wait=False)\n    print \"&gt;&gt;&gt;\", line + \"!\"\n</code></pre>\n<p>will print the lines as they are available thanks to the wait=False</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; It is 14:24:52!\n&gt;&gt;&gt; It is 14:24:53!\n&gt;&gt;&gt; It is 14:24:54!\n&gt;&gt;&gt; It is 14:24:55!\n</code></pre>\n<p>More examples can be found at <a href=\"https://github.com/meuter/citizenshell\" rel=\"nofollow noreferrer\">https://github.com/meuter/citizenshell</a></p>\n", "abstract": "I wrote a small library to help with this use case: https://pypi.org/project/citizenshell/ It can be installed using And then used as follows: You can separate standard output from standard error and extract the exit code as follows: And the cool thing is that you don't have to wait for the underlying shell to exit before starting processing the output: will print the lines as they are available thanks to the wait=False More examples can be found at https://github.com/meuter/citizenshell"}, {"id": 49644672, "score": 10, "vote": 0, "content": "<p><strong>Calling an external command in Python</strong></p>\n<p>A simple way to call an external command is using <code>os.system(...)</code>. And this function returns the exit value of the command. But the drawback is we won't get stdout and stderr.</p>\n<pre><code class=\"python\">ret = os.system('some_cmd.sh')\nif ret != 0 :\n    print 'some_cmd.sh execution returned failure'\n</code></pre>\n<p><strong>Calling an external command in Python in background</strong></p>\n<p><code>subprocess.Popen</code> provides more flexibility for running an external command rather than using <code>os.system</code>. We can start a command in the background and wait for it to finish. And after that we can get the stdout and stderr.</p>\n<pre><code class=\"python\">proc = subprocess.Popen([\"./some_cmd.sh\"], stdout=subprocess.PIPE)\nprint 'waiting for ' + str(proc.pid)\nproc.wait()\nprint 'some_cmd.sh execution finished'\n(out, err) = proc.communicate()\nprint 'some_cmd.sh output : ' + out\n</code></pre>\n<p><strong>Calling a long running external command in Python in the background and stop after some time</strong></p>\n<p>We can even start a long running process in the background using <code>subprocess.Popen</code> and kill it after sometime once its task is done.</p>\n<pre><code class=\"python\">proc = subprocess.Popen([\"./some_long_run_cmd.sh\"], stdout=subprocess.PIPE)\n# Do something else\n# Now some_long_run_cmd.sh exeuction is no longer needed, so kill it\nos.system('kill -15 ' + str(proc.pid))\nprint 'Output : ' proc.communicate()[0]\n</code></pre>\n", "abstract": "Calling an external command in Python A simple way to call an external command is using os.system(...). And this function returns the exit value of the command. But the drawback is we won't get stdout and stderr. Calling an external command in Python in background subprocess.Popen provides more flexibility for running an external command rather than using os.system. We can start a command in the background and wait for it to finish. And after that we can get the stdout and stderr. Calling a long running external command in Python in the background and stop after some time We can even start a long running process in the background using subprocess.Popen and kill it after sometime once its task is done."}, {"id": 16062355, "score": 9, "vote": 0, "content": "<p>There are a lot of different ways to run external commands in Python,\nand all of them have their own plus sides and drawbacks.</p>\n<p>My colleagues and me have been writing Python system administration tools, so we need to run a lot of external commands, and sometimes you want them to block or run asynchronously, time-out, update every second, etc.</p>\n<p>There are also different ways of handling the return code and errors,\nand you might want to parse the output, and provide new input (in an <a href=\"http://en.wikipedia.org/wiki/Expect\" rel=\"nofollow noreferrer\">expect</a> kind of style). Or you will need to redirect <a href=\"https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)\" rel=\"nofollow noreferrer\">standard input</a>, <a href=\"https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29\" rel=\"nofollow noreferrer\">standard output</a>, and <a href=\"https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\" rel=\"nofollow noreferrer\">standard error</a> to run in a different tty (e.g., when using <a href=\"https://en.wikipedia.org/wiki/GNU_Screen\" rel=\"nofollow noreferrer\">GNU Screen</a>).</p>\n<p>So you will probably have to write a lot of wrappers around the external command. So here is a Python module which we have written which can handle\nalmost anything you would want, and if not, it's very flexible so you can easily extend it:</p>\n<p><a href=\"https://github.com/hpcugent/vsc-base/blob/master/lib/vsc/utils/run.py\" rel=\"nofollow noreferrer\">https://github.com/hpcugent/vsc-base/blob/master/lib/vsc/utils/run.py</a></p>\n<p>It doesn't work stand-alone and requires some of our other tools, and got a lot of specialised functionality over the years, so it might not be a drop-in replacement for you, but it can give you a lot of information on how the internals of Python for running commands work and ideas on how to handle certain situations.</p>\n", "abstract": "There are a lot of different ways to run external commands in Python,\nand all of them have their own plus sides and drawbacks. My colleagues and me have been writing Python system administration tools, so we need to run a lot of external commands, and sometimes you want them to block or run asynchronously, time-out, update every second, etc. There are also different ways of handling the return code and errors,\nand you might want to parse the output, and provide new input (in an expect kind of style). Or you will need to redirect standard input, standard output, and standard error to run in a different tty (e.g., when using GNU Screen). So you will probably have to write a lot of wrappers around the external command. So here is a Python module which we have written which can handle\nalmost anything you would want, and if not, it's very flexible so you can easily extend it: https://github.com/hpcugent/vsc-base/blob/master/lib/vsc/utils/run.py It doesn't work stand-alone and requires some of our other tools, and got a lot of specialised functionality over the years, so it might not be a drop-in replacement for you, but it can give you a lot of information on how the internals of Python for running commands work and ideas on how to handle certain situations."}, {"id": 23030076, "score": 9, "vote": 0, "content": "<p>Use <a href=\"https://docs.python.org/2/library/subprocess.html\" rel=\"noreferrer\">subprocess.call</a>:</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">from subprocess import call\n\n# Using list\ncall([\"echo\", \"Hello\", \"world\"])\n\n# Single string argument varies across platforms so better split it\ncall(\"echo Hello world\".split(\" \"))\n</code></pre>\n", "abstract": "Use subprocess.call:"}, {"id": 38012358, "score": 9, "vote": 0, "content": "<p>Use:</p>\n<pre><code class=\"python\">import subprocess\n\np = subprocess.Popen(\"df -h\", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0]\nprint p.split(\"\\n\")\n</code></pre>\n<p>It gives nice output which is easier to work with:</p>\n<pre><code class=\"python\">['Filesystem      Size  Used Avail Use% Mounted on',\n '/dev/sda6        32G   21G   11G  67% /',\n 'none            4.0K     0  4.0K   0% /sys/fs/cgroup',\n 'udev            1.9G  4.0K  1.9G   1% /dev',\n 'tmpfs           387M  1.4M  386M   1% /run',\n 'none            5.0M     0  5.0M   0% /run/lock',\n 'none            1.9G   58M  1.9G   3% /run/shm',\n 'none            100M   32K  100M   1% /run/user',\n '/dev/sda5       340G  222G  100G  69% /home',\n '']\n</code></pre>\n", "abstract": "Use: It gives nice output which is easier to work with:"}, {"id": 48548332, "score": 9, "vote": 0, "content": "<p>As an example (in Linux):</p>\n<pre><code class=\"python\">import subprocess\nsubprocess.run('mkdir test.dir', shell=True)\n</code></pre>\n<p>This creates test.dir in the current directory.\nNote that this also works:</p>\n<pre><code class=\"python\">import subprocess\nsubprocess.call('mkdir test.dir', shell=True)\n</code></pre>\n<p>The equivalent code using os.system is:</p>\n<pre><code class=\"python\">import os\nos.system('mkdir test.dir')\n</code></pre>\n<p>Best practice would be to use subprocess instead of os, with .run favored over .call. \nAll you need to know about subprocess is <a href=\"https://docs.python.org/3.5/library/subprocess.html\" rel=\"noreferrer\">here</a>.\nAlso, note that all Python documentation is available for download from <a href=\"https://docs.python.org/3/download.html\" rel=\"noreferrer\">here</a>. I downloaded the PDF packed as .zip. I mention this because there's a nice overview of the os module in tutorial.pdf (page 81). Besides, it's an authoritative resource for Python coders.</p>\n", "abstract": "As an example (in Linux): This creates test.dir in the current directory.\nNote that this also works: The equivalent code using os.system is: Best practice would be to use subprocess instead of os, with .run favored over .call. \nAll you need to know about subprocess is here.\nAlso, note that all Python documentation is available for download from here. I downloaded the PDF packed as .zip. I mention this because there's a nice overview of the os module in tutorial.pdf (page 81). Besides, it's an authoritative resource for Python coders."}, {"id": 54414217, "score": 9, "vote": 0, "content": "<p>For using <code>subprocess</code> in Python\u00a03.5+, the following did the trick for me on Linux:</p>\n<pre><code class=\"python\">import subprocess\n\n# subprocess.run() returns a completed process object that can be inspected\nc = subprocess.run([\"ls\", \"-ltrh\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\nprint(c.stdout.decode('utf-8'))\n</code></pre>\n<p>As mentioned in <a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess\" rel=\"nofollow noreferrer\">the documentation</a>, <code>PIPE</code> values are byte sequences and for properly showing them decoding should be considered. For later versions of Python, <code>text=True</code> and <code>encoding='utf-8'</code> are added to kwargs of <a href=\"https://docs.python.org/3.6/library/subprocess.html#subprocess.run\" rel=\"nofollow noreferrer\"><code>subprocess.run()</code></a>.</p>\n<p>The output of the abovementioned code is:</p>\n<pre><code class=\"python\">total 113M\n-rwxr-xr-x  1 farzad farzad  307 Jan 15  2018 vpnscript\n-rwxrwxr-x  1 farzad farzad  204 Jan 15  2018 ex\ndrwxrwxr-x  4 farzad farzad 4.0K Jan 22  2018 scripts\n.... # Some other lines\n</code></pre>\n", "abstract": "For using subprocess in Python\u00a03.5+, the following did the trick for me on Linux: As mentioned in the documentation, PIPE values are byte sequences and for properly showing them decoding should be considered. For later versions of Python, text=True and encoding='utf-8' are added to kwargs of subprocess.run(). The output of the abovementioned code is:"}, {"id": 22395328, "score": 8, "vote": 0, "content": "<p>After some research, I have the following code which works very well for me. It basically prints both standard output and standard error in real time.</p>\n<pre><code class=\"python\">stdout_result = 1\nstderr_result = 1\n\n\ndef stdout_thread(pipe):\n    global stdout_result\n    while True:\n        out = pipe.stdout.read(1)\n        stdout_result = pipe.poll()\n        if out == '' and stdout_result is not None:\n            break\n\n        if out != '':\n            sys.stdout.write(out)\n            sys.stdout.flush()\n\n\ndef stderr_thread(pipe):\n    global stderr_result\n    while True:\n        err = pipe.stderr.read(1)\n        stderr_result = pipe.poll()\n        if err == '' and stderr_result is not None:\n            break\n\n        if err != '':\n            sys.stdout.write(err)\n            sys.stdout.flush()\n\n\ndef exec_command(command, cwd=None):\n    if cwd is not None:\n        print '[' + ' '.join(command) + '] in ' + cwd\n    else:\n        print '[' + ' '.join(command) + ']'\n\n    p = subprocess.Popen(\n        command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd\n    )\n\n    out_thread = threading.Thread(name='stdout_thread', target=stdout_thread, args=(p,))\n    err_thread = threading.Thread(name='stderr_thread', target=stderr_thread, args=(p,))\n\n    err_thread.start()\n    out_thread.start()\n\n    out_thread.join()\n    err_thread.join()\n\n    return stdout_result + stderr_result\n</code></pre>\n", "abstract": "After some research, I have the following code which works very well for me. It basically prints both standard output and standard error in real time."}, {"id": 39969619, "score": 8, "vote": 0, "content": "<p>Here is calling an external command and return or print the command's output:</p>\n<p>Python <a href=\"https://docs.python.org/2/library/subprocess.html\" rel=\"nofollow noreferrer\">Subprocess</a> check_output is good for</p>\n<blockquote>\n<p>Run command with arguments and return its output as a byte string.</p>\n</blockquote>\n<pre><code class=\"python\">import subprocess\nproc = subprocess.check_output('ipconfig /all')\nprint proc\n</code></pre>\n", "abstract": "Here is calling an external command and return or print the command's output: Python Subprocess check_output is good for Run command with arguments and return its output as a byte string."}, {"id": 50242060, "score": 8, "vote": 0, "content": "<p>If you need to call a shell command from a Python notebook (like <a href=\"https://en.wikipedia.org/wiki/IPython#Project_Jupyter\" rel=\"noreferrer\">Jupyter</a>, Zeppelin, Databricks, or Google Cloud Datalab) you can just use the <code>!</code> prefix.</p>\n<p>For example,</p>\n<pre><code class=\"python\">!ls -ilF\n</code></pre>\n", "abstract": "If you need to call a shell command from a Python notebook (like Jupyter, Zeppelin, Databricks, or Google Cloud Datalab) you can just use the ! prefix. For example,"}, {"id": 57696996, "score": 8, "vote": 0, "content": "<p>If you're writing a Python shell script and have <a href=\"http://en.wikipedia.org/wiki/IPython\" rel=\"nofollow noreferrer\">IPython</a> installed on your system, you can use the bang prefix to run a shell command inside IPython:</p>\n<pre><code class=\"python\">!ls\nfilelist = !ls\n</code></pre>\n", "abstract": "If you're writing a Python shell script and have IPython installed on your system, you can use the bang prefix to run a shell command inside IPython:"}, {"id": 16089689, "score": 7, "vote": 0, "content": "<p>Update 2015: Python 3.5 added <a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.run\" rel=\"nofollow noreferrer\">subprocess.run</a> which is much easier to use than subprocess.Popen. I recommend that.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; subprocess.run([\"ls\", \"-l\"])  # doesn't capture output\nCompletedProcess(args=['ls', '-l'], returncode=0)\n\n&gt;&gt;&gt; subprocess.run(\"exit 1\", shell=True, check=True)\nTraceback (most recent call last):\n  ...\nsubprocess.CalledProcessError: Command 'exit 1' returned non-zero exit status 1\n\n&gt;&gt;&gt; subprocess.run([\"ls\", \"-l\", \"/dev/null\"], capture_output=True)\nCompletedProcess(args=['ls', '-l', '/dev/null'], returncode=0,\nstdout=b'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\\n', stderr=b'')\n</code></pre>\n", "abstract": "Update 2015: Python 3.5 added subprocess.run which is much easier to use than subprocess.Popen. I recommend that."}, {"id": 36058314, "score": 6, "vote": 0, "content": "<p>For Python 3.5+ it is recommended that you use the <a href=\"https://docs.python.org/3.5/library/subprocess.html#subprocess.run\" rel=\"nofollow noreferrer\">run function from the subprocess module</a>. This returns a <code>CompletedProcess</code> object, from which you can easily obtain the output as well as return code.</p>\n<pre><code class=\"python\">from subprocess import PIPE, run\n\ncommand = ['echo', 'hello']\nresult = run(command, stdout=PIPE, stderr=PIPE, universal_newlines=True)\nprint(result.returncode, result.stdout, result.stderr)\n</code></pre>\n", "abstract": "For Python 3.5+ it is recommended that you use the run function from the subprocess module. This returns a CompletedProcess object, from which you can easily obtain the output as well as return code."}, {"id": 58297652, "score": 5, "vote": 0, "content": "<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import subprocess\n\np = subprocess.run([\"ls\", \"-ltr\"], capture_output=True)\nprint(p.stdout.decode(), p.stderr.decode())\n</code></pre>\n<p><strong><a href=\"https://code.labstack.com/GIzH7jnS\" rel=\"noreferrer\">Try online</a></strong></p>\n", "abstract": "Try online"}, {"id": 72216447, "score": 5, "vote": 0, "content": "<p>You can try using \"os.system()\" for running external commands.</p>\n<p>Example:</p>\n<pre><code class=\"python\">import os\n\ntry:\n  os.system('ls')\n  pass\nexcept:\n  print(\"Error running command\")\n  pass\n</code></pre>\n<p>In the example, the script imports \"os\" and trys to run the command listed in \"os.system()\". If the command was to fail then it would print \"Error running command\" without the script stopping due to the error.</p>\n<p>And yes, it\u2019s just that simple!</p>\n", "abstract": "You can try using \"os.system()\" for running external commands. Example: In the example, the script imports \"os\" and trys to run the command listed in \"os.system()\". If the command was to fail then it would print \"Error running command\" without the script stopping due to the error. And yes, it\u2019s just that simple!"}, {"id": 31618111, "score": 4, "vote": 0, "content": "<p>Using the <code>Popen</code> function of the <code>subprocess</code> Python module is the simplest way of running Linux commands. In that, the <code>Popen.communicate()</code> function will give your commands output. For example</p>\n<pre><code class=\"python\">import subprocess\n\n..\nprocess = subprocess.Popen(..)   # Pass command and arguments to the function\nstdout, stderr = process.communicate()   # Get command output and error\n..\n</code></pre>\n", "abstract": "Using the Popen function of the subprocess Python module is the simplest way of running Linux commands. In that, the Popen.communicate() function will give your commands output. For example"}, {"id": 39447501, "score": 4, "vote": 0, "content": "<p>There are many ways to call a command.</p>\n<ul>\n<li>For example:</li>\n</ul>\n<p>if <code>and.exe</code> needs two parameters. In cmd we can call <code>sample.exe</code> use this:\n   <code>and.exe 2 3</code> and it show <code>5</code> on screen.</p>\n<p>If we use a Python script to call <code>and.exe</code>, we should do like..</p>\n<ol>\n<li><p><code>os.system(cmd,...)</code></p>\n<ul>\n<li><code>os.system((\"and.exe\" + \" \" + \"2\" + \" \" + \"3\"))</code></li>\n</ul></li>\n<li><p><code>os.popen(cmd,...)</code></p>\n<ul>\n<li><code>os.popen((\"and.exe\" + \" \" + \"2\" + \" \" + \"3\"))</code></li>\n</ul></li>\n<li><code>subprocess.Popen(cmd,...)</code>\n<ul>\n<li><code>subprocess.Popen((\"and.exe\" + \" \" + \"2\" + \" \" + \"3\"))</code></li>\n</ul></li>\n</ol>\n<p>It's too hard, so we can join cmd with a space:</p>\n<pre><code class=\"python\">import os\ncmd = \" \".join(exename,parameters)\nos.popen(cmd)\n</code></pre>\n", "abstract": "There are many ways to call a command. if and.exe needs two parameters. In cmd we can call sample.exe use this:\n   and.exe 2 3 and it show 5 on screen. If we use a Python script to call and.exe, we should do like.. os.system(cmd,...) os.popen(cmd,...) It's too hard, so we can join cmd with a space:"}, {"id": 59050139, "score": 4, "vote": 0, "content": "<p><code>os.popen()</code> is the easiest and the most safest way to execute a command. You can execute any command that you run on the command line. In addition you will also be able to capture the output of the command using <code>os.popen().read()</code></p>\n<p>You can do it like this:</p>\n<pre><code class=\"python\">import os\noutput = os.popen('Your Command Here').read()\nprint (output)\n</code></pre>\n<p>An example where you list all the files in the current directory:</p>\n<pre><code class=\"python\">import os\noutput = os.popen('ls').read()\nprint (output)\n# Outputs list of files in the directory\n</code></pre>\n", "abstract": "os.popen() is the easiest and the most safest way to execute a command. You can execute any command that you run on the command line. In addition you will also be able to capture the output of the command using os.popen().read() You can do it like this: An example where you list all the files in the current directory:"}, {"id": 36913076, "score": 3, "vote": 0, "content": "<p>I would recommend the following method 'run' and it will help us in getting <a href=\"https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29\" rel=\"nofollow noreferrer\">standard output</a>, <a href=\"https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\" rel=\"nofollow noreferrer\">standard error</a> and exit status as a dictionary; the caller of this can read the dictionary return by 'run' method to know the actual state of the process.</p>\n<pre><code class=\"python\">  def run (cmd):\n       print \"+ DEBUG exec({0})\".format(cmd)\n       p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, shell=True)\n       (out, err) = p.communicate()\n       ret        = p.wait()\n       out        = filter(None, out.split('\\n'))\n       err        = filter(None, err.split('\\n'))\n       ret        = True if ret == 0 else False\n       return dict({'output': out, 'error': err, 'status': ret})\n  #end\n</code></pre>\n", "abstract": "I would recommend the following method 'run' and it will help us in getting standard output, standard error and exit status as a dictionary; the caller of this can read the dictionary return by 'run' method to know the actual state of the process."}, {"id": 55440842, "score": 3, "vote": 0, "content": "<p>If you are <strong>not</strong> using user input in the commands, you can use this:</p>\n<pre><code class=\"python\">from os import getcwd\nfrom subprocess import check_output\nfrom shlex import quote\n\ndef sh(command):\n    return check_output(quote(command), shell=True, cwd=getcwd(), universal_newlines=True).strip()\n</code></pre>\n<p>And use it as</p>\n<pre><code class=\"python\">branch = sh('git rev-parse --abbrev-ref HEAD')\n</code></pre>\n<p><code>shell=True</code> will spawn a shell, so you can use pipe and such shell things <code>sh('ps aux | grep python')</code>. This is very very handy for running hardcoded commands and processing its output. The <code>universal_lines=True</code> make sure the output is returned in a string instead of binary.</p>\n<p><code>cwd=getcwd()</code> will make sure that the command is run with the same working directory as the interpreter. This is handy for Git commands to work like the Git branch name example above.</p>\n<p>Some recipes</p>\n<ul>\n<li>free memory in megabytes: <code>sh('free -m').split('\\n')[1].split()[1]</code></li>\n<li>free space on / in percent <code>sh('df -m /').split('\\n')[1].split()[4][0:-1]</code></li>\n<li>CPU load <code>sum(map(float, sh('ps -ef -o pcpu').split('\\n')[1:])</code></li>\n</ul>\n<p>But this isn't safe for user input, from the documentation:</p>\n<blockquote>\n<p>Security Considerations</p>\n<p>Unlike some other popen functions, this implementation will never\nimplicitly call a system shell. This means that all characters,\nincluding shell metacharacters, can safely be passed to child\nprocesses. If the shell is invoked explicitly, via shell=True, it is\nthe application\u2019s responsibility to ensure that all whitespace and\nmetacharacters are quoted appropriately to avoid shell injection\nvulnerabilities.</p>\n<p>When using shell=True, the shlex.quote() function can be used to\nproperly escape whitespace and shell metacharacters in strings that\nare going to be used to construct shell commands.</p>\n</blockquote>\n<p>Even using the <code>shlex.quote()</code>, it is good to keep a little paranoid when using user inputs on shell commands. One option is using a hardcoded command to take some generic output and filtering by user input. Anyway using <code>shell=False</code> will make sure that only the exactly process that you want to execute will be executed or you get a <code>No such file or directory</code> error.</p>\n<p>Also there is some performance impact on <code>shell=True</code>, from my tests it seems about 20% slower than <code>shell=False</code> (the default).</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">In [50]: timeit(\"check_output('ls -l'.split(), universal_newlines=True)\", number=1000, globals=globals())\nOut[50]: 2.6801227919995654\n\nIn [51]: timeit(\"check_output('ls -l', universal_newlines=True, shell=True)\", number=1000, globals=globals())\nOut[51]: 3.243950183999914\n</code></pre>\n", "abstract": "If you are not using user input in the commands, you can use this: And use it as shell=True will spawn a shell, so you can use pipe and such shell things sh('ps aux | grep python'). This is very very handy for running hardcoded commands and processing its output. The universal_lines=True make sure the output is returned in a string instead of binary. cwd=getcwd() will make sure that the command is run with the same working directory as the interpreter. This is handy for Git commands to work like the Git branch name example above. Some recipes But this isn't safe for user input, from the documentation: Security Considerations Unlike some other popen functions, this implementation will never\nimplicitly call a system shell. This means that all characters,\nincluding shell metacharacters, can safely be passed to child\nprocesses. If the shell is invoked explicitly, via shell=True, it is\nthe application\u2019s responsibility to ensure that all whitespace and\nmetacharacters are quoted appropriately to avoid shell injection\nvulnerabilities. When using shell=True, the shlex.quote() function can be used to\nproperly escape whitespace and shell metacharacters in strings that\nare going to be used to construct shell commands. Even using the shlex.quote(), it is good to keep a little paranoid when using user inputs on shell commands. One option is using a hardcoded command to take some generic output and filtering by user input. Anyway using shell=False will make sure that only the exactly process that you want to execute will be executed or you get a No such file or directory error. Also there is some performance impact on shell=True, from my tests it seems about 20% slower than shell=False (the default)."}, {"id": 58212263, "score": 3, "vote": 0, "content": "<p>Python 3.5+</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import subprocess\n\np = subprocess.run([\"ls\", \"-ltr\"], capture_output=True)\nprint(p.stdout.decode(), p.stderr.decode())\n</code></pre>\n<p><a href=\"https://code.labstack.com/GIzH7jnS\" rel=\"nofollow noreferrer\"><strong>Try online</strong></a></p>\n", "abstract": "Python 3.5+ Try online"}, {"id": 60427071, "score": 3, "vote": 0, "content": "<p>There are a number of ways of <em>calling</em> an external <em>command</em> from Python. There are some functions and modules with the good helper functions that can make it really easy. But the recommended thing among all is the <code>subprocess</code> module.</p>\n<pre><code class=\"python\">import subprocess as s\ns.call([\"command.exe\", \"...\"])\n</code></pre>\n<p>The call function will start the external process, pass some command line arguments and wait for it to finish. When it finishes you continue executing. Arguments in <em>call</em> function are passed through the list. The first argument in the list is the command typically in the form of an executable file and subsequent arguments in the list whatever you want to pass.</p>\n<p>If you have called processes from the command line in the windows before, you'll be aware that you often need to quote arguments. You need to put quotations mark around it. If there's a space then there's a backslash and there are some complicated rules, but you can avoid a whole lot of that in Python by using <code>subprocess</code> module because it is a list and each item is known to be a distinct and python can get quoting correctly for you.</p>\n<p>In the end, after the list, there are a number of optional parameters one of these is a shell and if you set shell equals to true then your command is going to be run as if you have typed in at the command prompt.</p>\n<pre><code class=\"python\">s.call([\"command.exe\", \"...\"], shell=True)\n</code></pre>\n<p>This gives you access to functionality like piping, you can redirect to files, you can call multiple commands in one thing.</p>\n<p>One more thing, if your script relies on the process succeeding then you want to check the result and the result can be checked with the check call helper function.</p>\n<pre><code class=\"python\">s.check_call(...)\n</code></pre>\n<p>It is exactly the same as a call function, it takes the same arguments, takes the same list, you can pass in any of the extra arguments but it going to wait for the functions to complete. And if the exit code of the function is anything other then zero, it will through an exception in the python script.</p>\n<p>Finally, if you want tighter control <code>Popen</code> constructor which is also from the <code>subprocess</code> module. It also takes the same arguments as incall &amp; check_call function but it returns an object representing the running process.</p>\n<pre><code class=\"python\">p=s.Popen(\"...\")\n</code></pre>\n<p>It does not wait for the running process to finish also it's not going to throw any exception immediately but it gives you an object that will let you do things like wait for it to finish, let you communicate to it, you can redirect standard input, standard output if you want to display output somewhere else and a lot more.</p>\n", "abstract": "There are a number of ways of calling an external command from Python. There are some functions and modules with the good helper functions that can make it really easy. But the recommended thing among all is the subprocess module. The call function will start the external process, pass some command line arguments and wait for it to finish. When it finishes you continue executing. Arguments in call function are passed through the list. The first argument in the list is the command typically in the form of an executable file and subsequent arguments in the list whatever you want to pass. If you have called processes from the command line in the windows before, you'll be aware that you often need to quote arguments. You need to put quotations mark around it. If there's a space then there's a backslash and there are some complicated rules, but you can avoid a whole lot of that in Python by using subprocess module because it is a list and each item is known to be a distinct and python can get quoting correctly for you. In the end, after the list, there are a number of optional parameters one of these is a shell and if you set shell equals to true then your command is going to be run as if you have typed in at the command prompt. This gives you access to functionality like piping, you can redirect to files, you can call multiple commands in one thing. One more thing, if your script relies on the process succeeding then you want to check the result and the result can be checked with the check call helper function. It is exactly the same as a call function, it takes the same arguments, takes the same list, you can pass in any of the extra arguments but it going to wait for the functions to complete. And if the exit code of the function is anything other then zero, it will through an exception in the python script. Finally, if you want tighter control Popen constructor which is also from the subprocess module. It also takes the same arguments as incall & check_call function but it returns an object representing the running process. It does not wait for the running process to finish also it's not going to throw any exception immediately but it gives you an object that will let you do things like wait for it to finish, let you communicate to it, you can redirect standard input, standard output if you want to display output somewhere else and a lot more."}, {"id": 70789418, "score": 3, "vote": 0, "content": "<p>Here there are a lot of answers, but none fulfilled all my needs.</p>\n<ul>\n<li>I need to run the command and capture the <strong>output</strong> and <strong>exit code</strong>.</li>\n<li>I need to <strong>timeout</strong> the executed program and <strong>force</strong> it to exit if timeout is reached, and <strong>kill all its child processes</strong>.</li>\n<li>and I need that it works in <a href=\"https://en.wikipedia.org/wiki/Windows_XP\" rel=\"nofollow noreferrer\">Windows\u00a0XP</a> and later, <a href=\"https://en.wikipedia.org/wiki/Cygwin\" rel=\"nofollow noreferrer\">Cygwin</a> and Linux. In Python\u00a02 and 3.</li>\n</ul>\n<p>So I created this:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def _run(command, timeout_s=False, shell=False):\n    ### run a process, capture the output and wait for it to finish. if timeout is specified then Kill the subprocess and its children when the timeout is reached (if parent did not detach)\n    ## usage: _run(arg1, arg2, arg3)\n        # arg1: command + arguments. Always pass a string; the function will split it when needed\n        # arg2: (optional) timeout in seconds before force killing\n        # arg3: (optional) shell usage. default shell=False\n    ## return: a list containing: exit code, output, and if timeout was reached or not\n\n    # - Tested on Python 2 and 3 on Windows XP, Windows 7, Cygwin and Linux.\n    # - preexec_fn=os.setsid (py2) is equivalent to start_new_session (py3) (works on Linux only), in Windows and Cygwin we use TASKKILL\n    # - we use stderr=subprocess.STDOUT to merge standard error and standard output\n    import sys, subprocess, os, signal, shlex, time\n\n    def _runPY3(command, timeout_s=None, shell=False):\n        # py3.3+ because: timeout was added to communicate() in py3.3.\n        new_session=False\n        if sys.platform.startswith('linux'): new_session=True\n        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, start_new_session=new_session, shell=shell)\n\n        try:\n            out = p.communicate(timeout=timeout_s)[0].decode('utf-8')\n            is_timeout_reached = False\n        except subprocess.TimeoutExpired:\n            print('Timeout reached: Killing the whole process group...')\n            killAll(p.pid)\n            out = p.communicate()[0].decode('utf-8')\n            is_timeout_reached = True\n        return p.returncode, out, is_timeout_reached\n\n    def _runPY2(command, timeout_s=0, shell=False):\n        preexec=None\n        if sys.platform.startswith('linux'): preexec=os.setsid\n        p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, preexec_fn=preexec, shell=shell)\n\n        start_time = time.time()\n        is_timeout_reached = False\n        while timeout_s and p.poll() == None:\n            if time.time()-start_time &gt;= timeout_s:\n                print('Timeout reached: Killing the whole process group...')\n                killAll(p.pid)\n                is_timeout_reached = True\n                break\n            time.sleep(1)\n        out = p.communicate()[0].decode('utf-8')\n        return p.returncode, out, is_timeout_reached\n\n    def killAll(ParentPid):\n        if sys.platform.startswith('linux'):\n            os.killpg(os.getpgid(ParentPid), signal.SIGTERM)\n        elif sys.platform.startswith('cygwin'):\n            # subprocess.Popen(shlex.split('bash -c \"TASKKILL /F /PID $(&lt;/proc/{pid}/winpid) /T\"'.format(pid=ParentPid)))\n            winpid=int(open(\"/proc/{pid}/winpid\".format(pid=ParentPid)).read())\n            subprocess.Popen(['TASKKILL', '/F', '/PID', str(winpid), '/T'])\n        elif sys.platform.startswith('win32'):\n            subprocess.Popen(['TASKKILL', '/F', '/PID', str(ParentPid), '/T'])\n\n    # - In Windows, we never need to split the command, but in Cygwin and Linux we need to split if shell=False (default), shlex will split the command for us\n    if shell==False and (sys.platform.startswith('cygwin') or sys.platform.startswith('linux')):\n        command=shlex.split(command)\n\n    if sys.version_info &gt;= (3, 3): # py3.3+\n        if timeout_s==False:\n            returnCode, output, is_timeout_reached = _runPY3(command, timeout_s=None, shell=shell)\n        else:\n            returnCode, output, is_timeout_reached = _runPY3(command, timeout_s=timeout_s, shell=shell)\n    else:  # Python 2 and up to 3.2\n        if timeout_s==False:\n            returnCode, output, is_timeout_reached = _runPY2(command, timeout_s=0, shell=shell)\n        else:\n            returnCode, output, is_timeout_reached = _runPY2(command, timeout_s=timeout_s, shell=shell)\n\n    return returnCode, output, is_timeout_reached\n</code></pre>\n<p>Then use it like this:</p>\n<p>Always pass the command as one string (it is easier). You do not need to split it; the function will split it when needed.</p>\n<p>If your command works in your shell, it will work with this function, so test your command in your shell first cmd/Bash.</p>\n<p>So we can use it like this with a timeout:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">a=_run('cmd /c echo 11111 &amp; echo 22222 &amp; calc',3)\nfor i in a[1].splitlines(): print(i)\n</code></pre>\n<p>Or without a timeout:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">b=_run('cmd /c echo 11111 &amp; echo 22222 &amp; calc')\n</code></pre>\n<p>More examples:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">b=_run('''wmic nic where 'NetConnectionID=\"Local Area Connection\"' get NetConnectionStatus /value''')\nprint(b)\n\nc=_run('cmd /C netsh interface ip show address \"Local Area Connection\"')\nprint(c)\n\nd=_run('printf \"&lt;%s&gt;\\n\" \"{foo}\"')\nprint(d)\n</code></pre>\n<p>You can also specify shell=True, but it is useless in most cases with this function. I prefer to choose myself the shell I want, but here it is if you need it too:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># windows\ne=_run('echo 11111 &amp; echo 22222 &amp; calc',3, shell=True)\nprint(e)\n# Cygwin/Linux:\nf=_run('printf \"&lt;%s&gt;\\n\" \"{foo}\"', shell=True)\nprint(f)\n</code></pre>\n<hr/>\n<p><strong>Why did I not use the simpler new method <code>subprocess.run()</code>?</strong></p>\n<ul>\n<li>because it is supported in Python <em>3.7+</em>, but the last supported Python version in Windows\u00a0XP is <em>3.4</em>.</li>\n<li>and because the timeout argument of this function is useless in Windows, it does not kill the child processes of the executed command.</li>\n<li>if you use the <code>capture_output</code> + <code>timeout</code> argument, it will hang if there is a child process still running. And it is still broken in Windows, for which the <a href=\"https://bugs.python.org/issue31447\" rel=\"nofollow noreferrer\">issue 31447</a> is <a href=\"https://bugs.python.org/issue32795\" rel=\"nofollow noreferrer\">still open</a>.</li>\n</ul>\n", "abstract": "Here there are a lot of answers, but none fulfilled all my needs. So I created this: Then use it like this: Always pass the command as one string (it is easier). You do not need to split it; the function will split it when needed. If your command works in your shell, it will work with this function, so test your command in your shell first cmd/Bash. So we can use it like this with a timeout: Or without a timeout: More examples: You can also specify shell=True, but it is useless in most cases with this function. I prefer to choose myself the shell I want, but here it is if you need it too: Why did I not use the simpler new method subprocess.run()?"}, {"id": 46921537, "score": 2, "vote": 0, "content": "<p>I have written a wrapper to handle errors and redirecting output and other stuff.</p>\n<pre><code class=\"python\">import shlex\nimport psutil\nimport subprocess\n\ndef call_cmd(cmd, stdout=sys.stdout, quiet=False, shell=False, raise_exceptions=True, use_shlex=True, timeout=None):\n    \"\"\"Exec command by command line like 'ln -ls \"/var/log\"'\n    \"\"\"\n    if not quiet:\n        print(\"Run %s\", str(cmd))\n    if use_shlex and isinstance(cmd, (str, unicode)):\n        cmd = shlex.split(cmd)\n    if timeout is None:\n        process = subprocess.Popen(cmd, stdout=stdout, stderr=sys.stderr, shell=shell)\n        retcode = process.wait()\n    else:\n        process = subprocess.Popen(cmd, stdout=stdout, stderr=sys.stderr, shell=shell)\n        p = psutil.Process(process.pid)\n        finish, alive = psutil.wait_procs([p], timeout)\n        if len(alive) &gt; 0:\n            ps = p.children()\n            ps.insert(0, p)\n            print('waiting for timeout again due to child process check')\n            finish, alive = psutil.wait_procs(ps, 0)\n        if len(alive) &gt; 0:\n            print('process {} will be killed'.format([p.pid for p in alive]))\n            for p in alive:\n                p.kill()\n            if raise_exceptions:\n                print('External program timeout at {} {}'.format(timeout, cmd))\n                raise CalledProcessTimeout(1, cmd)\n        retcode = process.wait()\n    if retcode and raise_exceptions:\n        print(\"External program failed %s\", str(cmd))\n        raise subprocess.CalledProcessError(retcode, cmd)\n</code></pre>\n<p>You can call it like this:</p>\n<pre><code class=\"python\">cmd = 'ln -ls \"/var/log\"'\nstdout = 'out.txt'\ncall_cmd(cmd, stdout)\n</code></pre>\n", "abstract": "I have written a wrapper to handle errors and redirecting output and other stuff. You can call it like this:"}, {"id": 56842257, "score": 1, "vote": 0, "content": "<p><a href=\"https://github.com/aeroxis/sultan\" rel=\"nofollow noreferrer\">Sultan</a> is a recent-ish package meant for this purpose. It provides some niceties around managing user privileges and adding helpful error messages.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from sultan.api import Sultan\n\nwith Sultan.load(sudo=True, hostname=\"myserver.com\") as sultan:\n  sultan.yum(\"install -y tree\").run()\n</code></pre>\n", "abstract": "Sultan is a recent-ish package meant for this purpose. It provides some niceties around managing user privileges and adding helpful error messages."}, {"id": 69012133, "score": 1, "vote": 0, "content": "<p>You can run any command using <em><strong>Popen</strong></em> from the <em><strong>subprocess</strong></em> module.</p>\n<pre><code class=\"python\">from subprocess import Popen\n</code></pre>\n<p>First of all, a command object is created with all arguments which you want to run. For example, in the snippet below, the <em>gunicorm</em> command object has been formed with all the arguments:</p>\n<pre><code class=\"python\">cmd = (\n        \"gunicorn \"\n        \"-c gunicorn_conf.py \"\n        \"-w {workers} \"\n        \"--timeout {timeout} \"\n        \"-b {address}:{port} \"\n        \"--limit-request-line 0 \"\n        \"--limit-request-field_size 0 \"\n        \"--log-level debug \"\n        \"--max-requests {max_requests} \"\n        \"manage:app\").format(**locals())\n</code></pre>\n<p>Then this command object is used with <em><strong>Popen</strong></em> to instantiate a process:</p>\n<pre><code class=\"python\">process = Popen(cmd, shell=True)\n</code></pre>\n<p>This process can be terminated as well based upon any signal, using the code line below:</p>\n<pre><code class=\"python\">Popen.terminate(process)\n</code></pre>\n<p>And you can wait till the completion of above command's execution:</p>\n<pre><code class=\"python\">process.wait()\n</code></pre>\n", "abstract": "You can run any command using Popen from the subprocess module. First of all, a command object is created with all arguments which you want to run. For example, in the snippet below, the gunicorm command object has been formed with all the arguments: Then this command object is used with Popen to instantiate a process: This process can be terminated as well based upon any signal, using the code line below: And you can wait till the completion of above command's execution:"}, {"id": 61307412, "score": -2, "vote": 0, "content": "<p>I use this for Python 3.6+:</p>\n<pre><code class=\"python\">import subprocess\ndef execute(cmd):\n    \"\"\"\n        Purpose  : To execute a command and return exit status\n        Argument : cmd - command to execute\n        Return   : result, exit_code\n    \"\"\"\n    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    (result, error) = process.communicate()\n    rc = process.wait()\n    if rc != 0:\n        print (\"Error: failed to execute command: \", cmd)\n        print (error.rstrip().decode(\"utf-8\"))\n    return result.rstrip().decode(\"utf-8\"), serror.rstrip().decode(\"utf-8\")\n# def\n</code></pre>\n", "abstract": "I use this for Python 3.6+:"}]}, {"link": "https://stackoverflow.com/questions/273192/how-can-i-safely-create-a-nested-directory", "question": {"id": "273192", "title": "How can I safely create a nested directory?", "content": "<p>How do I check if the directory into which a file is going to be written does exist, and if it does not, create the directory using Python?</p>\n", "abstract": "How do I check if the directory into which a file is going to be written does exist, and if it does not, create the directory using Python?"}, "answers": [{"id": 273227, "score": 6693, "vote": 0, "content": "<p>On Python \u2265 3.5, use <a href=\"https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir\" rel=\"noreferrer\"><code>pathlib.Path.mkdir</code></a>:</p>\n<pre><code class=\"python\">from pathlib import Path\nPath(\"/my/directory\").mkdir(parents=True, exist_ok=True)\n</code></pre>\n<p>For older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it:</p>\n<p>Try <a href=\"https://docs.python.org/library/os.path.html#os.path.exists\" rel=\"noreferrer\"><code>os.path.exists</code></a>, and consider <a href=\"https://docs.python.org/library/os.html#os.makedirs\" rel=\"noreferrer\"><code>os.makedirs</code></a> for the creation.</p>\n<pre><code class=\"python\">import os\nif not os.path.exists(directory):\n    os.makedirs(directory)\n</code></pre>\n<p>As noted in comments and elsewhere, there's a race condition \u2013 if the directory is created between the <code>os.path.exists</code> and the <code>os.makedirs</code> calls, the <code>os.makedirs</code> will fail with an <code>OSError</code>. Unfortunately, blanket-catching <code>OSError</code> and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.</p>\n<p>One option would be to trap the <code>OSError</code> and examine the embedded error code (see <a href=\"https://stackoverflow.com/questions/273698/is-there-a-cross-platform-way-of-getting-information-from-pythons-oserror\">Is there a cross-platform way of getting information from Python\u2019s OSError</a>):</p>\n<pre><code class=\"python\">import os, errno\n\ntry:\n    os.makedirs(directory)\nexcept OSError as e:\n    if e.errno != errno.EEXIST:\n        raise\n</code></pre>\n<p>Alternatively, there could be a second <code>os.path.exists</code>, but suppose another created the directory after the first check, then removed it before the second one \u2013 we could still be fooled. </p>\n<p>Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.</p>\n<p>Modern versions of Python improve this code quite a bit, both by exposing <a href=\"https://docs.python.org/3.3/library/exceptions.html?#FileExistsError\" rel=\"noreferrer\"><code>FileExistsError</code></a> (in 3.3+)...</p>\n<pre><code class=\"python\">try:\n    os.makedirs(\"path/to/directory\")\nexcept FileExistsError:\n    # directory already exists\n    pass\n</code></pre>\n<p>...and by allowing <a href=\"https://docs.python.org/3.2/library/os.html#os.makedirs\" rel=\"noreferrer\">a keyword argument to <code>os.makedirs</code> called <code>exist_ok</code></a> (in 3.2+).</p>\n<pre><code class=\"python\">os.makedirs(\"path/to/directory\", exist_ok=True)  # succeeds even if directory exists.\n</code></pre>\n", "abstract": "On Python \u2265 3.5, use pathlib.Path.mkdir: For older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it: Try os.path.exists, and consider os.makedirs for the creation. As noted in comments and elsewhere, there's a race condition \u2013 if the directory is created between the os.path.exists and the os.makedirs calls, the os.makedirs will fail with an OSError. Unfortunately, blanket-catching OSError and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc. One option would be to trap the OSError and examine the embedded error code (see Is there a cross-platform way of getting information from Python\u2019s OSError): Alternatively, there could be a second os.path.exists, but suppose another created the directory after the first check, then removed it before the second one \u2013 we could still be fooled.  Depending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation. Modern versions of Python improve this code quite a bit, both by exposing FileExistsError (in 3.3+)... ...and by allowing a keyword argument to os.makedirs called exist_ok (in 3.2+)."}, {"id": 14364249, "score": 1465, "vote": 0, "content": "<h2>Python 3.5+:</h2>\n<pre><code class=\"python\">import pathlib\npathlib.Path('/my/directory').mkdir(parents=True, exist_ok=True) \n</code></pre>\n<p><a href=\"https://docs.python.org/library/pathlib.html#pathlib.Path.mkdir\" rel=\"noreferrer\"><code>pathlib.Path.mkdir</code></a> as used above recursively creates the directory and does not raise an exception if the directory already exists. If you don't need or want the parents to be created, skip the <code>parents</code> argument.</p>\n<h2>Python 3.2+:</h2>\n<p><strong>Using <code>pathlib</code>:</strong></p>\n<p>If you can, install the current <code>pathlib</code> backport named <a href=\"https://pypi.python.org/pypi/pathlib2/\" rel=\"noreferrer\"><code>pathlib2</code></a>. Do not install the older unmaintained backport named <a href=\"https://pypi.python.org/pypi/pathlib/\" rel=\"noreferrer\"><code>pathlib</code></a>. Next, refer to the Python 3.5+ section above and use it the same.</p>\n<p>If using Python 3.4, even though it comes with <code>pathlib</code>, it is missing the useful <code>exist_ok</code> option. The backport is intended to offer a newer and superior implementation of <code>mkdir</code> which includes this missing option.</p>\n<p><strong>Using <code>os</code>:</strong></p>\n<pre><code class=\"python\">import os\nos.makedirs(path, exist_ok=True)\n</code></pre>\n<p><a href=\"https://docs.python.org/library/os.html#os.makedirs\" rel=\"noreferrer\"><code>os.makedirs</code></a> as used above recursively creates the directory and does not raise an exception if the directory already exists. It has the optional <code>exist_ok</code> argument only if using Python 3.2+, with a default value of <code>False</code>. This argument does not exist in Python 2.x up to 2.7. As such, there is no need for manual exception handling as with Python 2.7.</p>\n<h2>Python 2.7+:</h2>\n<p><strong>Using <code>pathlib</code>:</strong></p>\n<p>If you can, install the current <code>pathlib</code> backport named <a href=\"https://pypi.python.org/pypi/pathlib2/\" rel=\"noreferrer\"><code>pathlib2</code></a>. Do not install the older unmaintained backport named <a href=\"https://pypi.python.org/pypi/pathlib/\" rel=\"noreferrer\"><code>pathlib</code></a>. Next, refer to the Python 3.5+ section above and use it the same.</p>\n<p><strong>Using <code>os</code>:</strong></p>\n<pre><code class=\"python\">import os\ntry: \n    os.makedirs(path)\nexcept OSError:\n    if not os.path.isdir(path):\n        raise\n</code></pre>\n<p>While a naive solution may first use <a href=\"https://docs.python.org/2/library/os.path.html#os.path.isdir\" rel=\"noreferrer\" title=\"os.path.isdir\"><code>os.path.isdir</code></a> followed by <a href=\"https://docs.python.org/2/library/os.html#os.makedirs\" rel=\"noreferrer\" title=\"os.makedirs\"><code>os.makedirs</code></a>, the solution above reverses the order of the two operations. In doing so, it prevents a common race condition having to do with a duplicated attempt at creating the directory, and also disambiguates files from directories.</p>\n<p>Note that capturing the exception and using <code>errno</code> is of limited usefulness because <code>OSError: [Errno 17] File exists</code>, i.e. <code>errno.EEXIST</code>, is raised for both files and directories. It is more reliable simply to check if the directory exists.</p>\n<h2>Alternative:</h2>\n<p><a href=\"https://docs.python.org/distutils/apiref.html#distutils.dir_util.mkpath\" rel=\"noreferrer\"><code>mkpath</code></a> creates the nested directory, and does nothing if the directory already exists. This works in both Python 2 and 3.</p>\n<pre><code class=\"python\">import distutils.dir_util\ndistutils.dir_util.mkpath(path)\n</code></pre>\n<p>Per <a href=\"http://bugs.python.org/issue10948\" rel=\"noreferrer\">Bug 10948</a>, a severe limitation of this alternative is that it works only once per python process for a given path. In other words, if you use it to create a directory, then delete the directory from inside or outside Python, then use <code>mkpath</code> again to recreate the same directory, <code>mkpath</code> will simply silently use its invalid cached info of having previously created the directory, and will not actually make the directory again. In contrast, <code>os.makedirs</code> doesn't rely on any such cache. This limitation may be okay for some applications.</p>\n<hr/>\n<p>With regard to the directory's <em>mode</em>, please refer to the documentation if you care about it.</p>\n", "abstract": "pathlib.Path.mkdir as used above recursively creates the directory and does not raise an exception if the directory already exists. If you don't need or want the parents to be created, skip the parents argument. Using pathlib: If you can, install the current pathlib backport named pathlib2. Do not install the older unmaintained backport named pathlib. Next, refer to the Python 3.5+ section above and use it the same. If using Python 3.4, even though it comes with pathlib, it is missing the useful exist_ok option. The backport is intended to offer a newer and superior implementation of mkdir which includes this missing option. Using os: os.makedirs as used above recursively creates the directory and does not raise an exception if the directory already exists. It has the optional exist_ok argument only if using Python 3.2+, with a default value of False. This argument does not exist in Python 2.x up to 2.7. As such, there is no need for manual exception handling as with Python 2.7. Using pathlib: If you can, install the current pathlib backport named pathlib2. Do not install the older unmaintained backport named pathlib. Next, refer to the Python 3.5+ section above and use it the same. Using os: While a naive solution may first use os.path.isdir followed by os.makedirs, the solution above reverses the order of the two operations. In doing so, it prevents a common race condition having to do with a duplicated attempt at creating the directory, and also disambiguates files from directories. Note that capturing the exception and using errno is of limited usefulness because OSError: [Errno 17] File exists, i.e. errno.EEXIST, is raised for both files and directories. It is more reliable simply to check if the directory exists. mkpath creates the nested directory, and does nothing if the directory already exists. This works in both Python 2 and 3. Per Bug 10948, a severe limitation of this alternative is that it works only once per python process for a given path. In other words, if you use it to create a directory, then delete the directory from inside or outside Python, then use mkpath again to recreate the same directory, mkpath will simply silently use its invalid cached info of having previously created the directory, and will not actually make the directory again. In contrast, os.makedirs doesn't rely on any such cache. This limitation may be okay for some applications. With regard to the directory's mode, please refer to the documentation if you care about it."}, {"id": 5032238, "score": 655, "vote": 0, "content": "<p>Using try except and the right error code from errno module gets rid of the race condition and is cross-platform:</p>\n<pre><code class=\"python\">import os\nimport errno\n\ndef make_sure_path_exists(path):\n    try:\n        os.makedirs(path)\n    except OSError as exception:\n        if exception.errno != errno.EEXIST:\n            raise\n</code></pre>\n<p>In other words, we try to create the directories, but if they already exist we ignore the error. On the other hand, any other error gets reported. For example, if you create dir 'a' beforehand and remove all permissions from it, you will get an <code>OSError</code> raised with <code>errno.EACCES</code> (Permission denied, error 13).</p>\n", "abstract": "Using try except and the right error code from errno module gets rid of the race condition and is cross-platform: In other words, we try to create the directories, but if they already exist we ignore the error. On the other hand, any other error gets reported. For example, if you create dir 'a' beforehand and remove all permissions from it, you will get an OSError raised with errno.EACCES (Permission denied, error 13)."}, {"id": 41147087, "score": 130, "vote": 0, "content": "<p>Starting from Python 3.5, <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir\" rel=\"noreferrer\"><code>pathlib.Path.mkdir</code></a> has an <code>exist_ok</code> flag:</p>\n<pre><code class=\"python\">from pathlib import Path\npath = Path('/my/directory/filename.txt')\npath.parent.mkdir(parents=True, exist_ok=True) \n# path.parent ~ os.path.dirname(path)\n</code></pre>\n<p>This recursively creates the directory and does not raise an exception if the directory already exists.</p>\n<p>(just as <a href=\"https://docs.python.org/3/library/os.html?highlight=makedirs#os.makedirs\" rel=\"noreferrer\"><code>os.makedirs</code></a> got an <code>exist_ok</code> flag starting from python 3.2 e.g <code>os.makedirs(path, exist_ok=True)</code>)</p>\n<hr/>\n<p>Note: when i posted this answer none of the other answers mentioned <code>exist_ok</code>...</p>\n", "abstract": "Starting from Python 3.5, pathlib.Path.mkdir has an exist_ok flag: This recursively creates the directory and does not raise an exception if the directory already exists. (just as os.makedirs got an exist_ok flag starting from python 3.2 e.g os.makedirs(path, exist_ok=True)) Note: when i posted this answer none of the other answers mentioned exist_ok..."}, {"id": 444023, "score": 123, "vote": 0, "content": "<p>I would personally recommend that you use <code>os.path.isdir()</code> to test instead of <code>os.path.exists()</code>.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; os.path.exists('/tmp/dirname')\nTrue\n&gt;&gt;&gt; os.path.exists('/tmp/dirname/filename.etc')\nTrue\n&gt;&gt;&gt; os.path.isdir('/tmp/dirname/filename.etc')\nFalse\n&gt;&gt;&gt; os.path.isdir('/tmp/fakedirname')\nFalse\n</code></pre>\n<p>If you have:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; dir = raw_input(\":: \")\n</code></pre>\n<p>And a foolish user input:</p>\n<pre><code class=\"python\">:: /tmp/dirname/filename.etc\n</code></pre>\n<p>... You're going to end up with a directory named <code>filename.etc</code> when you pass that argument to <code>os.makedirs()</code> if you test with <code>os.path.exists()</code>.</p>\n", "abstract": "I would personally recommend that you use os.path.isdir() to test instead of os.path.exists(). If you have: And a foolish user input: ... You're going to end up with a directory named filename.etc when you pass that argument to os.makedirs() if you test with os.path.exists()."}, {"id": 273208, "score": 102, "vote": 0, "content": "<p>Check <a href=\"https://docs.python.org/3/library/os.html#os.makedirs\" rel=\"noreferrer\"><code>os.makedirs</code></a>:  (It makes sure the complete path exists.)<br/>\n To handle the fact the directory might exist, catch <code>OSError</code>.\n(If <code>exist_ok</code> is <code>False</code> (the default), an <code>OSError</code> is raised if the target directory already exists.)</p>\n<pre><code class=\"python\">import os\ntry:\n    os.makedirs('./path/to/somewhere')\nexcept OSError:\n    pass\n</code></pre>\n", "abstract": "Check os.makedirs:  (It makes sure the complete path exists.)\n To handle the fact the directory might exist, catch OSError.\n(If exist_ok is False (the default), an OSError is raised if the target directory already exists.)"}, {"id": 273206, "score": 75, "vote": 0, "content": "<p>Try the <a href=\"https://docs.python.org/2/library/os.path.html#os.path.exists\" rel=\"noreferrer\" title=\"os.path.exists\"><code>os.path.exists</code></a> function</p>\n<pre><code class=\"python\">if not os.path.exists(dir):\n    os.mkdir(dir)\n</code></pre>\n", "abstract": "Try the os.path.exists function"}, {"id": 28100757, "score": 58, "vote": 0, "content": "<h1>Insights on the specifics of this situation</h1>\n<p>You give a particular file at a certain path and you pull the directory from the file path. Then after making sure you have the directory, you attempt to open a file for reading. To comment on this code:</p>\n<blockquote>\n<pre><code class=\"python\">filename = \"/my/directory/filename.txt\"\ndir = os.path.dirname(filename)\n</code></pre>\n</blockquote>\n<p>We want to avoid overwriting the builtin function, <code>dir</code>. Also, <code>filepath</code> or perhaps <code>fullfilepath</code> is probably a better semantic name than <code>filename</code> so this would be better written:</p>\n<pre><code class=\"python\">import os\nfilepath = '/my/directory/filename.txt'\ndirectory = os.path.dirname(filepath)\n</code></pre>\n<p>Your end goal is to open this file, you initially state, for writing, but you're essentially approaching this goal (based on your code) like this, which opens the file for <strong>reading</strong>:</p>\n<blockquote>\n<pre><code class=\"python\">if not os.path.exists(directory):\n    os.makedirs(directory)\nf = file(filename)\n</code></pre>\n</blockquote>\n<h2>Assuming opening for reading</h2>\n<p>Why would you make a directory for a file that you expect to be there and be able to read? </p>\n<p>Just attempt to open the file.</p>\n<pre><code class=\"python\">with open(filepath) as my_file:\n    do_stuff(my_file)\n</code></pre>\n<p>If the directory or file isn't there, you'll get an <code>IOError</code> with an associated error number: <code>errno.ENOENT</code> will point to the correct error number regardless of your platform. You can catch it if you want, for example:</p>\n<pre><code class=\"python\">import errno\ntry:\n    with open(filepath) as my_file:\n        do_stuff(my_file)\nexcept IOError as error:\n    if error.errno == errno.ENOENT:\n        print 'ignoring error because directory or file is not there'\n    else:\n        raise\n</code></pre>\n<h2>Assuming we're opening for writing</h2>\n<p>This is <em>probably</em> what you're wanting.</p>\n<p>In this case, we probably aren't facing any race conditions. So just do as you were, but note that for writing, you need to open with the <code>w</code> mode (or <code>a</code> to append). It's also a Python best practice to use the context manager for opening files.</p>\n<pre><code class=\"python\">import os\nif not os.path.exists(directory):\n    os.makedirs(directory)\nwith open(filepath, 'w') as my_file:\n    do_stuff(my_file)\n</code></pre>\n<p>However, say we have several Python processes that attempt to put all their data into the same directory. Then we may have contention over creation of the directory. In that case it's best to wrap the <code>makedirs</code> call in a try-except block.</p>\n<pre><code class=\"python\">import os\nimport errno\nif not os.path.exists(directory):\n    try:\n        os.makedirs(directory)\n    except OSError as error:\n        if error.errno != errno.EEXIST:\n            raise\nwith open(filepath, 'w') as my_file:\n    do_stuff(my_file)\n</code></pre>\n", "abstract": "You give a particular file at a certain path and you pull the directory from the file path. Then after making sure you have the directory, you attempt to open a file for reading. To comment on this code: We want to avoid overwriting the builtin function, dir. Also, filepath or perhaps fullfilepath is probably a better semantic name than filename so this would be better written: Your end goal is to open this file, you initially state, for writing, but you're essentially approaching this goal (based on your code) like this, which opens the file for reading: Why would you make a directory for a file that you expect to be there and be able to read?  Just attempt to open the file. If the directory or file isn't there, you'll get an IOError with an associated error number: errno.ENOENT will point to the correct error number regardless of your platform. You can catch it if you want, for example: This is probably what you're wanting. In this case, we probably aren't facing any race conditions. So just do as you were, but note that for writing, you need to open with the w mode (or a to append). It's also a Python best practice to use the context manager for opening files. However, say we have several Python processes that attempt to put all their data into the same directory. Then we may have contention over creation of the directory. In that case it's best to wrap the makedirs call in a try-except block."}, {"id": 273679, "score": 42, "vote": 0, "content": "<p>I have put the following down. It's not totally foolproof though.</p>\n<pre><code class=\"python\">import os\n\ndirname = 'create/me'\n\ntry:\n    os.makedirs(dirname)\nexcept OSError:\n    if os.path.exists(dirname):\n        # We are nearly safe\n        pass\n    else:\n        # There was an error on creation, so make sure we know about it\n        raise\n</code></pre>\n<p>Now as I say, this is not really foolproof, because we have the possiblity of failing to create the directory, and another process creating it during that period.</p>\n", "abstract": "I have put the following down. It's not totally foolproof though. Now as I say, this is not really foolproof, because we have the possiblity of failing to create the directory, and another process creating it during that period."}, {"id": 28100717, "score": 34, "vote": 0, "content": "<blockquote>\n<p><strong>Check if a directory exists and create it if necessary?</strong></p>\n</blockquote>\n<p>The direct answer to this is, assuming a simple situation where you don't expect other users or processes to be messing with your directory:</p>\n<pre><code class=\"python\">if not os.path.exists(d):\n    os.makedirs(d)\n</code></pre>\n<p><strong>or</strong> if making the directory is subject to race conditions (i.e. if after checking the path exists, something else may have already made it) do this:</p>\n<pre><code class=\"python\">import errno\ntry:\n    os.makedirs(d)\nexcept OSError as exception:\n    if exception.errno != errno.EEXIST:\n        raise\n</code></pre>\n<p>But perhaps an even better approach is to sidestep the resource contention issue, by using temporary directories via <a href=\"https://docs.python.org/library/tempfile.html#tempfile.mkdtemp\" rel=\"noreferrer\" title=\"tempfile.mkdtemp\"><code>tempfile</code></a>:</p>\n<pre><code class=\"python\">import tempfile\n\nd = tempfile.mkdtemp()\n</code></pre>\n<p>Here's the essentials from the online doc:</p>\n<blockquote>\n<pre><code class=\"python\">mkdtemp(suffix='', prefix='tmp', dir=None)\n    User-callable function to create and return a unique temporary\n    directory.  The return value is the pathname of the directory.\n\n    The directory is readable, writable, and searchable only by the\n    creating user.\n\n    Caller is responsible for deleting the directory when done with it.\n</code></pre>\n</blockquote>\n<h2>New in Python 3.5: <code>pathlib.Path</code> with <code>exist_ok</code></h2>\n<p>There's a new <code>Path</code> object (as of 3.4) with lots of methods one would want to use with paths - one of which is <code>mkdir</code>.</p>\n<p>(For context, I'm tracking my weekly rep with a script. Here's the relevant parts of code from the script that allow me to avoid hitting Stack Overflow more than once a day for the same data.)</p>\n<p>First the relevant imports:</p>\n<pre><code class=\"python\">from pathlib import Path\nimport tempfile\n</code></pre>\n<p>We don't have to deal with <code>os.path.join</code> now - just join path parts with a <code>/</code>:</p>\n<pre><code class=\"python\">directory = Path(tempfile.gettempdir()) / 'sodata'\n</code></pre>\n<p>Then I idempotently ensure the directory exists - the <code>exist_ok</code> argument shows up in Python 3.5:</p>\n<pre><code class=\"python\">directory.mkdir(exist_ok=True)\n</code></pre>\n<p>Here's the relevant part of the <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir\" rel=\"noreferrer\">documentation</a>:</p>\n<blockquote>\n<p>If <code>exist_ok</code> is true, <code>FileExistsError</code> exceptions will be ignored (same behavior as the <code>POSIX mkdir -p</code> command), but only if the last path component is not an existing non-directory file.</p>\n</blockquote>\n<p>Here's a little more of the script - in my case, I'm not subject to a race condition, I only have one process that expects the directory (or contained files) to be there, and I don't have anything trying to remove the directory. </p>\n<pre><code class=\"python\">todays_file = directory / str(datetime.datetime.utcnow().date())\nif todays_file.exists():\n    logger.info(\"todays_file exists: \" + str(todays_file))\n    df = pd.read_json(str(todays_file))\n</code></pre>\n<p><code>Path</code> objects have to be coerced to <code>str</code> before other APIs that expect <code>str</code> paths can use them.</p>\n<p>Perhaps Pandas should be updated to accept instances of the abstract base class, <code>os.PathLike</code>.</p>\n", "abstract": "Check if a directory exists and create it if necessary? The direct answer to this is, assuming a simple situation where you don't expect other users or processes to be messing with your directory: or if making the directory is subject to race conditions (i.e. if after checking the path exists, something else may have already made it) do this: But perhaps an even better approach is to sidestep the resource contention issue, by using temporary directories via tempfile: Here's the essentials from the online doc: There's a new Path object (as of 3.4) with lots of methods one would want to use with paths - one of which is mkdir. (For context, I'm tracking my weekly rep with a script. Here's the relevant parts of code from the script that allow me to avoid hitting Stack Overflow more than once a day for the same data.) First the relevant imports: We don't have to deal with os.path.join now - just join path parts with a /: Then I idempotently ensure the directory exists - the exist_ok argument shows up in Python 3.5: Here's the relevant part of the documentation: If exist_ok is true, FileExistsError exceptions will be ignored (same behavior as the POSIX mkdir -p command), but only if the last path component is not an existing non-directory file. Here's a little more of the script - in my case, I'm not subject to a race condition, I only have one process that expects the directory (or contained files) to be there, and I don't have anything trying to remove the directory.  Path objects have to be coerced to str before other APIs that expect str paths can use them. Perhaps Pandas should be updated to accept instances of the abstract base class, os.PathLike."}, {"id": 28997083, "score": 26, "vote": 0, "content": "<p>In Python 3.4 you can also use the <a href=\"https://docs.python.org/3/library/pathlib.html\">brand new <code>pathlib</code> module</a>:</p>\n<pre><code class=\"python\">from pathlib import Path\npath = Path(\"/my/directory/filename.txt\")\ntry:\n    if not path.parent.exists():\n        path.parent.mkdir(parents=True)\nexcept OSError:\n    # handle error; you can also catch specific errors like\n    # FileExistsError and so on.\n</code></pre>\n", "abstract": "In Python 3.4 you can also use the brand new pathlib module:"}, {"id": 36289129, "score": 25, "vote": 0, "content": "<p>For a one-liner solution, you can use <a href=\"https://github.com/ipython/ipython/blob/b70b3f21749ca969088fdb54edcc36bb8a2267b9/IPython/utils/path.py#L423-L438\" rel=\"noreferrer\"><code>IPython.utils.path.ensure_dir_exists()</code></a>:</p>\n<pre><code class=\"python\">from IPython.utils.path import ensure_dir_exists\nensure_dir_exists(dir)\n</code></pre>\n<p>From the <a href=\"https://ipython.org/ipython-doc/3/api/generated/IPython.utils.path.html#IPython.utils.path.ensure_dir_exists\" rel=\"noreferrer\">documentation</a>: <em>Ensure that a directory exists. If it doesn\u2019t exist, try to create it and protect against a race condition if another process is doing the same.</em></p>\n<p>IPython is an extension package, not part of the standard library.</p>\n", "abstract": "For a one-liner solution, you can use IPython.utils.path.ensure_dir_exists(): From the documentation: Ensure that a directory exists. If it doesn\u2019t exist, try to create it and protect against a race condition if another process is doing the same. IPython is an extension package, not part of the standard library."}, {"id": 41453417, "score": 24, "vote": 0, "content": "<p>In <strong>Python3</strong>, <code>os.makedirs</code> supports setting <code>exist_ok</code>. The default setting is <code>False</code>, which means an <code>OSError</code> will be raised if the target directory already exists. By setting <code>exist_ok</code> to <code>True</code>, <code>OSError</code> (directory exists) will be ignored and the directory will not be created.</p>\n<pre><code class=\"python\">os.makedirs(path,exist_ok=True)\n</code></pre>\n<p>In <strong>Python2</strong>, <code>os.makedirs</code> doesn't support setting <code>exist_ok</code>. You can use the approach in <a href=\"https://stackoverflow.com/a/5032238/3109254\">heikki-toivonen's answer</a>:</p>\n<pre><code class=\"python\">import os\nimport errno\n\ndef make_sure_path_exists(path):\n    try:\n        os.makedirs(path)\n    except OSError as exception:\n        if exception.errno != errno.EEXIST:\n            raise\n</code></pre>\n", "abstract": "In Python3, os.makedirs supports setting exist_ok. The default setting is False, which means an OSError will be raised if the target directory already exists. By setting exist_ok to True, OSError (directory exists) will be ignored and the directory will not be created. In Python2, os.makedirs doesn't support setting exist_ok. You can use the approach in heikki-toivonen's answer:"}, {"id": 71029280, "score": 24, "vote": 0, "content": "<p><strong>Best way to do this in python</strong></p>\n<pre><code class=\"python\">#Devil\nimport os\ndirectory = \"./out_dir/subdir1/subdir2\"\nif not os.path.exists(directory):\n    os.makedirs(directory)\n</code></pre>\n", "abstract": "Best way to do this in python"}, {"id": 24740135, "score": 19, "vote": 0, "content": "<p>The <a href=\"https://docs.python.org/2/library/os.html#files-and-directories\" rel=\"noreferrer\">relevant Python documentation</a> suggests the use of the <a href=\"https://docs.python.org/2/library/os.html#files-and-directories\" rel=\"noreferrer\">EAFP coding style (Easier to Ask for Forgiveness than Permission)</a>. This means that the code</p>\n<pre><code class=\"python\">try:\n    os.makedirs(path)\nexcept OSError as exception:\n    if exception.errno != errno.EEXIST:\n        raise\n    else:\n        print \"\\nBE CAREFUL! Directory %s already exists.\" % path\n</code></pre>\n<p>is better than the alternative</p>\n<pre><code class=\"python\">if not os.path.exists(path):\n    os.makedirs(path)\nelse:\n    print \"\\nBE CAREFUL! Directory %s already exists.\" % path\n</code></pre>\n<p>The documentation suggests this exactly because of the race condition discussed in this question. In addition, as others mention here, there is a performance advantage in querying once instead of twice the OS. Finally, the argument placed forward, potentially, in favour of the second code in some cases --when the developer knows the environment the application is running-- can only be advocated in the special case that the program has set up a private environment for itself (and other instances of the same program).</p>\n<p>Even in that case, this is a bad practice and can lead to long useless debugging. For example, the fact we set the permissions for a directory should not leave us with the impression permissions are set appropriately for our purposes. A parent directory could be mounted with other permissions. In general, a program should always work correctly and the programmer should not expect one specific environment.</p>\n", "abstract": "The relevant Python documentation suggests the use of the EAFP coding style (Easier to Ask for Forgiveness than Permission). This means that the code is better than the alternative The documentation suggests this exactly because of the race condition discussed in this question. In addition, as others mention here, there is a performance advantage in querying once instead of twice the OS. Finally, the argument placed forward, potentially, in favour of the second code in some cases --when the developer knows the environment the application is running-- can only be advocated in the special case that the program has set up a private environment for itself (and other instances of the same program). Even in that case, this is a bad practice and can lead to long useless debugging. For example, the fact we set the permissions for a directory should not leave us with the impression permissions are set appropriately for our purposes. A parent directory could be mounted with other permissions. In general, a program should always work correctly and the programmer should not expect one specific environment."}, {"id": 71466038, "score": 19, "vote": 0, "content": "<p>fastest safest way to do it is:\nit will create if not exists and skip if exists:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from pathlib import Path\nPath(\"path/with/childs/.../\").mkdir(parents=True, exist_ok=True)\n</code></pre>\n", "abstract": "fastest safest way to do it is:\nit will create if not exists and skip if exists:"}, {"id": 47842472, "score": 14, "vote": 0, "content": "<p>I found this Q/A after I was puzzled by some of the failures and errors I was getting while working with directories in Python. I am working in Python 3 (v.3.5 in an Anaconda virtual environment on an Arch Linux x86_64 system).</p>\n<p>Consider this directory structure:</p>\n<pre><code class=\"python\">\u2514\u2500\u2500 output/         ## dir\n   \u251c\u2500\u2500 corpus       ## file\n   \u251c\u2500\u2500 corpus2/     ## dir\n   \u2514\u2500\u2500 subdir/      ## dir\n</code></pre>\n<p>Here are my experiments/notes, which provides clarification:</p>\n<pre><code class=\"python\"># ----------------------------------------------------------------------------\n# [1] https://stackoverflow.com/questions/273192/how-can-i-create-a-directory-if-it-does-not-exist\n\nimport pathlib\n\n\"\"\" Notes:\n        1.  Include a trailing slash at the end of the directory path\n            (\"Method 1,\" below).\n        2.  If a subdirectory in your intended path matches an existing file\n            with same name, you will get the following error:\n            \"NotADirectoryError: [Errno 20] Not a directory:\" ...\n\"\"\"\n# Uncomment and try each of these \"out_dir\" paths, singly:\n\n# ----------------------------------------------------------------------------\n# METHOD 1:\n# Re-running does not overwrite existing directories and files; no errors.\n\n# out_dir = 'output/corpus3'                ## no error but no dir created (missing tailing /)\n# out_dir = 'output/corpus3/'               ## works\n# out_dir = 'output/corpus3/doc1'           ## no error but no dir created (missing tailing /)\n# out_dir = 'output/corpus3/doc1/'          ## works\n# out_dir = 'output/corpus3/doc1/doc.txt'   ## no error but no file created (os.makedirs creates dir, not files!  ;-)\n# out_dir = 'output/corpus2/tfidf/'         ## fails with \"Errno 20\" (existing file named \"corpus2\")\n# out_dir = 'output/corpus3/tfidf/'         ## works\n# out_dir = 'output/corpus3/a/b/c/d/'       ## works\n\n# [2] https://docs.python.org/3/library/os.html#os.makedirs\n\n# Uncomment these to run \"Method 1\":\n\n#directory = os.path.dirname(out_dir)\n#os.makedirs(directory, mode=0o777, exist_ok=True)\n\n# ----------------------------------------------------------------------------\n# METHOD 2:\n# Re-running does not overwrite existing directories and files; no errors.\n\n# out_dir = 'output/corpus3'                ## works\n# out_dir = 'output/corpus3/'               ## works\n# out_dir = 'output/corpus3/doc1'           ## works\n# out_dir = 'output/corpus3/doc1/'          ## works\n# out_dir = 'output/corpus3/doc1/doc.txt'   ## no error but creates a .../doc.txt./ dir\n# out_dir = 'output/corpus2/tfidf/'         ## fails with \"Errno 20\" (existing file named \"corpus2\")\n# out_dir = 'output/corpus3/tfidf/'         ## works\n# out_dir = 'output/corpus3/a/b/c/d/'       ## works\n\n# Uncomment these to run \"Method 2\":\n\n#import os, errno\n#try:\n#       os.makedirs(out_dir)\n#except OSError as e:\n#       if e.errno != errno.EEXIST:\n#               raise\n# ----------------------------------------------------------------------------\n</code></pre>\n<p>Conclusion: in my opinion, \"Method 2\" is more robust.</p>\n<p>[1] <a href=\"https://stackoverflow.com/questions/273192/how-can-i-create-a-directory-if-it-does-not-exist\">How can I safely create a nested directory?</a></p>\n<p>[2] <a href=\"https://docs.python.org/3/library/os.html#os.makedirs\" rel=\"nofollow noreferrer\">https://docs.python.org/3/library/os.html#os.makedirs</a></p>\n", "abstract": "I found this Q/A after I was puzzled by some of the failures and errors I was getting while working with directories in Python. I am working in Python 3 (v.3.5 in an Anaconda virtual environment on an Arch Linux x86_64 system). Consider this directory structure: Here are my experiments/notes, which provides clarification: Conclusion: in my opinion, \"Method 2\" is more robust. [1] How can I safely create a nested directory? [2] https://docs.python.org/3/library/os.html#os.makedirs"}, {"id": 39479473, "score": 13, "vote": 0, "content": "<p>You can use <a href=\"https://docs.python.org/2/distutils/apiref.html#distutils.dir_util.mkpath\" rel=\"noreferrer\"><code>mkpath</code></a></p>\n<pre><code class=\"python\"># Create a directory and any missing ancestor directories. \n# If the directory already exists, do nothing.\n\nfrom distutils.dir_util import mkpath\nmkpath(\"test\")    \n</code></pre>\n<p>Note that it will create the ancestor directories as well. </p>\n<p>It works for Python 2 and 3.</p>\n", "abstract": "You can use mkpath Note that it will create the ancestor directories as well.  It works for Python 2 and 3."}, {"id": 52282050, "score": 10, "vote": 0, "content": "<p>Why not use subprocess module if running on a machine that supports command \n<code>mkdir</code> with <code>-p</code> option ? \nWorks on python 2.7 and python 3.6</p>\n<pre><code class=\"python\">from subprocess import call\ncall(['mkdir', '-p', 'path1/path2/path3'])\n</code></pre>\n<p>Should do the trick on most systems.</p>\n<p>In situations where portability doesn't matter (ex, using docker) the solution is a clean 2 lines. You also don't have to add logic to check if directories exist or not. Finally, it is safe to re-run without any side effects</p>\n<p>If you need error handling:</p>\n<pre><code class=\"python\">from subprocess import check_call\ntry:\n    check_call(['mkdir', '-p', 'path1/path2/path3'])\nexcept:\n    handle...\n</code></pre>\n", "abstract": "Why not use subprocess module if running on a machine that supports command \nmkdir with -p option ? \nWorks on python 2.7 and python 3.6 Should do the trick on most systems. In situations where portability doesn't matter (ex, using docker) the solution is a clean 2 lines. You also don't have to add logic to check if directories exist or not. Finally, it is safe to re-run without any side effects If you need error handling:"}, {"id": 56203876, "score": 10, "vote": 0, "content": "<p>You have to set the full path before creating the directory:</p>\n<pre><code class=\"python\">import os,sys,inspect\nimport pathlib\n\ncurrentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))\nyour_folder = currentdir + \"/\" + \"your_folder\"\n\nif not os.path.exists(your_folder):\n   pathlib.Path(your_folder).mkdir(parents=True, exist_ok=True)\n</code></pre>\n<p>This works for me and hopefully, it will works for you as well</p>\n", "abstract": "You have to set the full path before creating the directory: This works for me and hopefully, it will works for you as well"}, {"id": 68821616, "score": 10, "vote": 0, "content": "<p>In case you're writing a file to a variable path, you can use this on the file's path to make sure that the parent directories are created.</p>\n<pre><code class=\"python\">from pathlib import Path\n\npath_to_file = Path(\"zero/or/more/directories/file.ext\")\nparent_directory_of_file = path_to_file.parent\nparent_directory_of_file.mkdir(parents=True, exist_ok=True)\n</code></pre>\n<p>Works even if <code>path_to_file</code> is <code>file.ext</code> (zero directories deep).</p>\n<p>See <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.parent\" rel=\"noreferrer\">pathlib.PurePath.parent</a> and <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir\" rel=\"noreferrer\">pathlib.Path.mkdir</a>.</p>\n", "abstract": "In case you're writing a file to a variable path, you can use this on the file's path to make sure that the parent directories are created. Works even if path_to_file is file.ext (zero directories deep). See pathlib.PurePath.parent and pathlib.Path.mkdir."}, {"id": 35262209, "score": 9, "vote": 0, "content": "<p>I saw <a href=\"https://stackoverflow.com/a/5032238/3051142\">Heikki Toivonen</a> and <a href=\"https://stackoverflow.com/a/14364249\">A-B-B</a>'s answers and thought of this variation.</p>\n<pre><code class=\"python\">import os\nimport errno\n\ndef make_sure_path_exists(path):\n    try:\n        os.makedirs(path)\n    except OSError as exception:\n        if exception.errno != errno.EEXIST or not os.path.isdir(path):\n            raise\n</code></pre>\n", "abstract": "I saw Heikki Toivonen and A-B-B's answers and thought of this variation."}, {"id": 42127930, "score": 9, "vote": 0, "content": "<p>I use <code>os.path.exists()</code>, <a href=\"http://pastebin.com/vnVk2rY5\" rel=\"noreferrer\">here</a> is a Python 3 script that can be used to check if a directory exists, create one if it does not exist, and delete it if it does exist (if desired).</p>\n<p>It prompts users for input of the directory and can be easily modified.</p>\n", "abstract": "I use os.path.exists(), here is a Python 3 script that can be used to check if a directory exists, create one if it does not exist, and delete it if it does exist (if desired). It prompts users for input of the directory and can be easily modified."}, {"id": 49851755, "score": 9, "vote": 0, "content": "<p>Use this command check and create dir</p>\n<pre><code class=\"python\"> if not os.path.isdir(test_img_dir):\n     os.mkdir(test_img_dir)\n</code></pre>\n", "abstract": "Use this command check and create dir"}, {"id": 50078422, "score": 8, "vote": 0, "content": "<p>Call the function <code>create_dir()</code> at the entry point of your program/project.</p>\n<pre><code class=\"python\">import os\n\ndef create_dir(directory):\n    if not os.path.exists(directory):\n        print('Creating Directory '+directory)\n        os.makedirs(directory)\n\ncreate_dir('Project directory')\n</code></pre>\n", "abstract": "Call the function create_dir() at the entry point of your program/project."}, {"id": 37703074, "score": 6, "vote": 0, "content": "<p>You can use <code>os.listdir</code> for this:</p>\n<pre><code class=\"python\">import os\nif 'dirName' in os.listdir('parentFolderPath')\n    print('Directory Exists')\n</code></pre>\n", "abstract": "You can use os.listdir for this:"}, {"id": 40949679, "score": 6, "vote": 0, "content": "<p>If you consider the following: </p>\n<pre><code class=\"python\">os.path.isdir('/tmp/dirname')\n</code></pre>\n<p>means a directory (path) exists AND is a directory. So for me this way does what I need. So I can make sure it is folder (not a file) and exists.</p>\n", "abstract": "If you consider the following:  means a directory (path) exists AND is a directory. So for me this way does what I need. So I can make sure it is folder (not a file) and exists."}, {"id": 64474894, "score": 3, "vote": 0, "content": "<p>This may not exactly answer the question. But I guess your real intention is to create a file and its parent directories, given its content all in 1 command.</p>\n<p>You can do that with <code>fastcore</code> extension to pathlib: <code>path.mk_write(data)</code></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from fastcore.utils import Path\nPath('/dir/to/file.txt').mk_write('Hello World')\n</code></pre>\n<p>See more in <a href=\"https://fastcore.fast.ai/xtras.html#Path.mk_write\" rel=\"nofollow noreferrer\">fastcore documentation</a></p>\n", "abstract": "This may not exactly answer the question. But I guess your real intention is to create a file and its parent directories, given its content all in 1 command. You can do that with fastcore extension to pathlib: path.mk_write(data) See more in fastcore documentation"}, {"id": 63822489, "score": -7, "vote": 0, "content": "<p>You can create nested directories <code>dir1/dir2/...</code> using system call. Say under Linux this can be done as follows:</p>\n<pre><code class=\"python\">import os\ndirs='dir1/dir2/dir3'\nos.system(\"mkdir -p {0}\".format(dirs))\n</code></pre>\n<p>The flag <code>-p</code> checks whether the directory exists and in that case does not generate any error message.</p>\n<p>Let me mention, that thought this looks like done not completely by Python methods, any Python library which does the same, should use internally a system call of the above type.</p>\n", "abstract": "You can create nested directories dir1/dir2/... using system call. Say under Linux this can be done as follows: The flag -p checks whether the directory exists and in that case does not generate any error message. Let me mention, that thought this looks like done not completely by Python methods, any Python library which does the same, should use internally a system call of the above type."}]}, {"link": "https://stackoverflow.com/questions/522563/accessing-the-index-in-for-loops", "question": {"id": "522563", "title": "Accessing the index in &#39;for&#39; loops", "content": "<p>How do I access the index while iterating over a sequence with a <code>for</code> loop?</p>\n<pre><code class=\"python\">xs = [8, 23, 45]\n\nfor x in xs:\n    print(\"item #{} = {}\".format(index, x))\n</code></pre>\n<p>Desired output:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">item #1 = 8\nitem #2 = 23\nitem #3 = 45\n</code></pre>\n", "abstract": "How do I access the index while iterating over a sequence with a for loop? Desired output:"}, "answers": [{"id": 522578, "score": 8068, "vote": 0, "content": "<p>Use the built-in function <a href=\"https://docs.python.org/3/library/functions.html#enumerate\" rel=\"noreferrer\" title=\"enumerate\"><code>enumerate()</code></a>:</p>\n<pre><code class=\"python\">for idx, x in enumerate(xs):\n    print(idx, x)\n</code></pre>\n<p>It is <em><a href=\"https://stackoverflow.com/questions/25011078/what-does-pythonic-mean\">non-pythonic</a></em> to manually index via <code>for i in range(len(xs)): x = xs[i]</code> or manually manage an additional state variable.</p>\n<p>Check out <a href=\"https://www.python.org/dev/peps/pep-0279/\" rel=\"noreferrer\" title=\"PEP 279\">PEP 279</a> for more.</p>\n", "abstract": "Use the built-in function enumerate(): It is non-pythonic to manually index via for i in range(len(xs)): x = xs[i] or manually manage an additional state variable. Check out PEP 279 for more."}, {"id": 28072982, "score": 1180, "vote": 0, "content": "<blockquote>\n<h1>Using a for loop, how do I access the loop index, from 1 to 5 in this case?</h1>\n</blockquote>\n<p>Use <code>enumerate</code> to get the index with the element as you iterate:</p>\n<pre><code class=\"python\">for index, item in enumerate(items):\n    print(index, item)\n</code></pre>\n<p>And note that Python's indexes start at zero, so you would get 0 to 4 with the above. If you want the count, 1 to 5, do this:</p>\n<pre><code class=\"python\">count = 0 # in case items is empty and you need it after the loop\nfor count, item in enumerate(items, start=1):\n    print(count, item)\n</code></pre>\n<h1>Unidiomatic control flow</h1>\n<p>What you are asking for is the Pythonic equivalent of the following, which is the algorithm most programmers of lower-level languages would use:</p>\n<blockquote>\n<pre><code class=\"python\">index = 0            # Python's indexing starts at zero\nfor item in items:   # Python's for loops are a \"for each\" loop \n    print(index, item)\n    index += 1\n</code></pre>\n</blockquote>\n<p>Or in languages that do not have a for-each loop:</p>\n<blockquote>\n<pre><code class=\"python\">index = 0\nwhile index &lt; len(items):\n    print(index, items[index])\n    index += 1\n</code></pre>\n</blockquote>\n<p>or sometimes more commonly (but unidiomatically) found in Python:</p>\n<blockquote>\n<pre><code class=\"python\">for index in range(len(items)):\n    print(index, items[index])\n</code></pre>\n</blockquote>\n<h1>Use the Enumerate Function</h1>\n<p>Python's <a href=\"https://docs.python.org/2/library/functions.html#enumerate\" rel=\"noreferrer\"><code>enumerate</code> function</a> reduces the visual clutter by hiding the accounting for the indexes, and encapsulating the iterable into another iterable (an <code>enumerate</code> object) that yields a two-item tuple of the index and the item that the original iterable would provide. That looks like this:</p>\n<pre><code class=\"python\">for index, item in enumerate(items, start=0):   # default is zero\n    print(index, item)\n</code></pre>\n<p>This code sample is fairly well the <a href=\"http://python.net/%7Egoodger/projects/pycon/2007/idiomatic/handout.html#index-item-2-enumerate\" rel=\"noreferrer\">canonical</a> example of the difference between code that is idiomatic of Python and code that is not. Idiomatic code is sophisticated (but not complicated) Python, written in the way that it was intended to be used. Idiomatic code is expected by the designers of the language, which means that usually this code is not just more readable, but also more efficient.</p>\n<h2>Getting a count</h2>\n<p>Even if you don't need indexes as you go, but you need a count of the iterations (sometimes desirable) you can start with <code>1</code> and the final number will be your count.</p>\n<pre><code class=\"python\">count = 0 # in case items is empty\nfor count, item in enumerate(items, start=1):   # default is zero\n    print(item)\n\nprint('there were {0} items printed'.format(count))\n</code></pre>\n<p>The count seems to be more what you intend to ask for (as opposed to index) when you said you wanted from 1 to 5.</p>\n<hr/>\n<h2>Breaking it down - a step by step explanation</h2>\n<p>To break these examples down, say we have a list of items that we want to iterate over with an index:</p>\n<pre><code class=\"python\">items = ['a', 'b', 'c', 'd', 'e']\n</code></pre>\n<p>Now we pass this iterable to enumerate, creating an enumerate object:</p>\n<pre><code class=\"python\">enumerate_object = enumerate(items) # the enumerate object\n</code></pre>\n<p>We can pull the first item out of this iterable that we would get in a loop with the <code>next</code> function:</p>\n<pre><code class=\"python\">iteration = next(enumerate_object) # first iteration from enumerate\nprint(iteration)\n</code></pre>\n<p>And we see we get a tuple of <code>0</code>, the first index, and <code>'a'</code>, the first item:</p>\n<pre><code class=\"python\">(0, 'a')\n</code></pre>\n<p>we can use what is referred to as \"<a href=\"https://docs.python.org/2/tutorial/datastructures.html#tuples-and-sequences\" rel=\"noreferrer\">sequence unpacking</a>\" to extract the elements from this two-tuple:</p>\n<pre><code class=\"python\">index, item = iteration\n#   0,  'a' = (0, 'a') # essentially this.\n</code></pre>\n<p>and when we inspect <code>index</code>, we find it refers to the first index, 0, and <code>item</code> refers to the first item, <code>'a'</code>.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print(index)\n0\n&gt;&gt;&gt; print(item)\na\n</code></pre>\n<h1>Conclusion</h1>\n<ul>\n<li>Python indexes start at zero</li>\n<li>To get these indexes from an iterable as you iterate over it, use the enumerate function</li>\n<li>Using enumerate in the idiomatic way (along with tuple unpacking) creates code that is more readable and maintainable:</li>\n</ul>\n<p>So do this:</p>\n<pre><code class=\"python\">for index, item in enumerate(items, start=0):   # Python indexes start at zero\n    print(index, item)\n</code></pre>\n", "abstract": "Use enumerate to get the index with the element as you iterate: And note that Python's indexes start at zero, so you would get 0 to 4 with the above. If you want the count, 1 to 5, do this: What you are asking for is the Pythonic equivalent of the following, which is the algorithm most programmers of lower-level languages would use: Or in languages that do not have a for-each loop: or sometimes more commonly (but unidiomatically) found in Python: Python's enumerate function reduces the visual clutter by hiding the accounting for the indexes, and encapsulating the iterable into another iterable (an enumerate object) that yields a two-item tuple of the index and the item that the original iterable would provide. That looks like this: This code sample is fairly well the canonical example of the difference between code that is idiomatic of Python and code that is not. Idiomatic code is sophisticated (but not complicated) Python, written in the way that it was intended to be used. Idiomatic code is expected by the designers of the language, which means that usually this code is not just more readable, but also more efficient. Even if you don't need indexes as you go, but you need a count of the iterations (sometimes desirable) you can start with 1 and the final number will be your count. The count seems to be more what you intend to ask for (as opposed to index) when you said you wanted from 1 to 5. To break these examples down, say we have a list of items that we want to iterate over with an index: Now we pass this iterable to enumerate, creating an enumerate object: We can pull the first item out of this iterable that we would get in a loop with the next function: And we see we get a tuple of 0, the first index, and 'a', the first item: we can use what is referred to as \"sequence unpacking\" to extract the elements from this two-tuple: and when we inspect index, we find it refers to the first index, 0, and item refers to the first item, 'a'. So do this:"}, {"id": 23886515, "score": 223, "vote": 0, "content": "<p>It's pretty simple to start it from <code>1</code> other than <code>0</code>:</p>\n<pre><code class=\"python\">for index, item in enumerate(iterable, start=1):\n   print index, item  # Used to print in python&lt;3.x\n   print(index, item) # Migrate to print() after 3.x+\n   \n</code></pre>\n", "abstract": "It's pretty simple to start it from 1 other than 0:"}, {"id": 522569, "score": 122, "vote": 0, "content": "<pre><code class=\"python\">for i in range(len(ints)):\n   print(i, ints[i]) # print updated to print() in Python 3.x+ \n</code></pre>\n", "abstract": ""}, {"id": 45685598, "score": 62, "vote": 0, "content": "<p>As is the norm in Python, there are several ways to do this. In all examples assume: <code>lst = [1, 2, 3, 4, 5]</code></p>\n<ol>\n<li>Using enumerate (<em>considered most idiomatic</em>)</li>\n</ol>\n<hr/>\n<pre><code class=\"python\">for index, element in enumerate(lst):\n    # Do the things that need doing here\n</code></pre>\n<p>This is also the safest option in my opinion because the chance of going into infinite recursion has been eliminated. Both the item and its index are held in variables and there is no need to write any further code to access the item.</p>\n<ol start=\"2\">\n<li>Creating a variable to hold the index (<em>using <code>for</code></em>)</li>\n</ol>\n<hr/>\n<pre><code class=\"python\">for index in range(len(lst)):   # or xrange\n    # you will have to write extra code to get the element\n</code></pre>\n<ol start=\"3\">\n<li>Creating a variable to hold the index (<em>using <code>while</code></em>)</li>\n</ol>\n<hr/>\n<pre><code class=\"python\">index = 0\nwhile index &lt; len(lst):\n    # You will have to write extra code to get the element\n    index += 1  # escape infinite recursion\n</code></pre>\n<ol start=\"4\">\n<li>There is always another way</li>\n</ol>\n<hr/>\n<p>As explained before, there are other ways to do this that have not been explained here and they may even apply more in other situations. <em>For example</em>, using <code>itertools.chain</code> with for. It handles nested loops better than the other examples.</p>\n", "abstract": "As is the norm in Python, there are several ways to do this. In all examples assume: lst = [1, 2, 3, 4, 5] This is also the safest option in my opinion because the chance of going into infinite recursion has been eliminated. Both the item and its index are held in variables and there is no need to write any further code to access the item. As explained before, there are other ways to do this that have not been explained here and they may even apply more in other situations. For example, using itertools.chain with for. It handles nested loops better than the other examples."}, {"id": 54227634, "score": 59, "vote": 0, "content": "<p>Here's how you can access the indices and array's elements using for-in loops.</p>\n<h3>1. Looping elements with counter and <code>+=</code> operator.</h3>\n<pre><code class=\"python\">items = [8, 23, 45, 12, 78]\ncounter = 0\n\nfor value in items:\n    print(counter, value)\n    counter += 1\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">#    0 8\n#    1 23\n#    2 45\n#    3 12\n#    4 78\n</code></pre>\n<h3>2. Looping elements using <code>enumerate()</code> method.</h3>\n<pre><code class=\"python\">items = [8, 23, 45, 12, 78]\n\nfor i in enumerate(items):\n    print(\"index/value\", i)\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">#    index/value (0, 8)\n#    index/value (1, 23)\n#    index/value (2, 45)\n#    index/value (3, 12)\n#    index/value (4, 78)\n</code></pre>\n<h3>3. Using <code>index</code> and <code>value</code> separately.</h3>\n<pre><code class=\"python\">items = [8, 23, 45, 12, 78]\n\nfor index, value in enumerate(items):\n    print(\"index\", index, \"for value\", value)\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">#    index 0 for value 8\n#    index 1 for value 23\n#    index 2 for value 45\n#    index 3 for value 12\n#    index 4 for value 78\n</code></pre>\n<h3>4. You can change the <code>index</code> number to any increment.</h3>\n<pre><code class=\"python\">items = [8, 23, 45, 12, 78]\n\nfor i, value in enumerate(items, start=1000):\n    print(i, value)\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">#    1000 8\n#    1001 23\n#    1002 45\n#    1003 12\n#    1004 78\n</code></pre>\n<h3>5. Automatic counter incrementation with <code>range(len(...))</code>.</h3>\n<pre><code class=\"python\">items = [8, 23, 45, 12, 78]\n\nfor i in range(len(items)):\n    print(\"Index:\", i, \"Value:\", items[i])\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">#    ('Index:', 0, 'Value:', 8)\n#    ('Index:', 1, 'Value:', 23)\n#    ('Index:', 2, 'Value:', 45)\n#    ('Index:', 3, 'Value:', 12)\n#    ('Index:', 4, 'Value:', 78)\n</code></pre>\n<h3>6. Using for-in loop inside function.</h3>\n<pre><code class=\"python\">items = [8, 23, 45, 12, 78]\n\ndef enum(items, start=0):\n    counter = start\n\n    for value in items:\n        print(counter, value)\n        counter += 1\n    \nenum(items)\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">#    0 8\n#    1 23\n#    2 45\n#    3 12\n#    4 78\n</code></pre>\n<h3>7. Of course, we can't forget about <code>while</code> loop.</h3>\n<pre><code class=\"python\">items = [8, 23, 45, 12, 78]\ncounter = 0\n\nwhile counter &lt; len(items):\n    print(counter, items[counter])\n    counter += 1\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">#    0 8\n#    1 23\n#    2 45\n#    3 12\n#    4 78\n</code></pre>\n<h3>8. <code>yield</code> statement returning a generator object.</h3>\n<pre><code class=\"python\">def createGenerator():        \n    items = [8, 23, 45, 12, 78]\n\n    for (j, k) in enumerate(items):\n        yield (j, k)\n        \n\ngenerator = createGenerator()\n\nfor i in generator:\n    print(i)\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">#    (0, 8)\n#    (1, 23)\n#    (2, 45)\n#    (3, 12)\n#    (4, 78)\n</code></pre>\n<h3>9. Inline expression with for-in loop and <code>lambda</code>.</h3>\n<pre><code class=\"python\">items = [8, 23, 45, 12, 78]\n\nxerox = lambda upperBound: [(i, items[i]) for i in range(0, upperBound)]\nprint(xerox(5))\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">#    [(0, 8), (1, 23), (2, 45), (3, 12), (4, 78)]\n</code></pre>\n", "abstract": "Here's how you can access the indices and array's elements using for-in loops. Result: Result: Result: Result: Result: Result: Result: Result: Result:"}, {"id": 522576, "score": 44, "vote": 0, "content": "<p>Old fashioned way:</p>\n<pre><code class=\"python\">for ix in range(len(ints)):\n    print(ints[ix])\n</code></pre>\n<p>List comprehension:</p>\n<pre><code class=\"python\">[ (ix, ints[ix]) for ix in range(len(ints))]\n\n&gt;&gt;&gt; ints\n[1, 2, 3, 4, 5]\n&gt;&gt;&gt; for ix in range(len(ints)): print ints[ix]\n... \n1\n2\n3\n4\n5\n&gt;&gt;&gt; [ (ix, ints[ix]) for ix in range(len(ints))]\n[(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]\n&gt;&gt;&gt; lc = [ (ix, ints[ix]) for ix in range(len(ints))]\n&gt;&gt;&gt; for tup in lc:\n...     print(tup)\n... \n(0, 1)\n(1, 2)\n(2, 3)\n(3, 4)\n(4, 5)\n&gt;&gt;&gt; \n</code></pre>\n", "abstract": "Old fashioned way: List comprehension:"}, {"id": 38764000, "score": 44, "vote": 0, "content": "<h1>Accessing indexes &amp; Performance Benchmarking of approaches</h1>\n<p>The fastest way to access indexes of list within loop in <strong>Python 3.7</strong> is to use the <a href=\"https://docs.python.org/2/library/functions.html#enumerate\" rel=\"noreferrer\">enumerate method</a> for small, medium and huge lists.</p>\n<p>Please see <strong>different approaches</strong> which can be used to iterate over list and access index value and <strong>their performance metrics</strong> (which I suppose would be useful for you) in code samples below:</p>\n<pre><code class=\"python\"># Using range\ndef range_loop(iterable):\n    for i in range(len(iterable)):\n        1 + iterable[i]\n\n# Using enumerate\ndef enumerate_loop(iterable):\n    for i, val in enumerate(iterable):\n        1 + val\n\n# Manual indexing\ndef manual_indexing_loop(iterable):\n    index = 0\n    for item in iterable:\n        1 + item\n        index += 1\n</code></pre>\n<p>See performance metrics for each method below:</p>\n<pre><code class=\"python\">from timeit import timeit\n\ndef measure(l, number=10000):\n    print(\"Measure speed for list with %d items\" % len(l))\n    print(\"range: \", timeit(lambda :range_loop(l), number=number))\n    print(\"enumerate: \", timeit(lambda :enumerate_loop(l), number=number))\n    print(\"manual_indexing: \", timeit(lambda :manual_indexing_loop(l), number=number))\n\n# Measure speed for list with 1000 items\nmeasure(range(1000))\n# range:  1.161622366\n# enumerate:  0.5661940879999996\n# manual_indexing:  0.610455682\n\n# Measure speed for list with 100000 items\nmeasure(range(10000))\n# range:  11.794482958\n# enumerate:  6.197628574000001\n# manual_indexing:  6.935181098000001\n\n# Measure speed for list with 10000000 items\nmeasure(range(10000000), number=100)\n# range:  121.416859069\n# enumerate:  62.718909123\n# manual_indexing:  69.59575057400002\n</code></pre>\n<p>As the result, using <code>enumerate</code> method is the fastest method for iteration when the index needed.</p>\n<p>Adding some useful links below:</p>\n<ul>\n<li><p><em><a href=\"https://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x\">What is the difference between range and xrange functions in Python 2.X?</a></em></p>\n</li>\n<li><p><em><a href=\"https://stackoverflow.com/questions/4852944/what-is-faster-for-loop-using-enumerate-or-for-loop-using-xrange-in-python\">What is faster for loop using enumerate or for loop using xrange in Python?</a></em></p>\n</li>\n<li><p><em><a href=\"https://stackoverflow.com/questions/11990105/rangelenlist-or-enumeratelist\">range(len(list)) or enumerate(list)?</a></em></p>\n</li>\n</ul>\n", "abstract": "The fastest way to access indexes of list within loop in Python 3.7 is to use the enumerate method for small, medium and huge lists. Please see different approaches which can be used to iterate over list and access index value and their performance metrics (which I suppose would be useful for you) in code samples below: See performance metrics for each method below: As the result, using enumerate method is the fastest method for iteration when the index needed. Adding some useful links below: What is the difference between range and xrange functions in Python 2.X? What is faster for loop using enumerate or for loop using xrange in Python? range(len(list)) or enumerate(list)?"}, {"id": 70404966, "score": 39, "vote": 0, "content": "<p>You can use <code>enumerate</code> and embed expressions inside string literals to obtain the solution.</p>\n<p>This is a simple way:</p>\n<pre><code class=\"python\">a=[4,5,6,8]\nfor b, val in enumerate(a):\n    print('item #{} = {}'.format(b+1, val))\n</code></pre>\n", "abstract": "You can use enumerate and embed expressions inside string literals to obtain the solution. This is a simple way:"}, {"id": 30441272, "score": 20, "vote": 0, "content": "<p>First of all, the indexes will be from 0 to 4. Programming languages start counting from 0; don't forget that or you will come across an index-out-of-bounds exception. All you need in the <em>for</em> loop is a variable counting from 0 to 4 like so:</p>\n<pre><code class=\"python\">for x in range(0, 5):\n</code></pre>\n<p>Keep in mind that I wrote 0 to 5 because the loop stops one number before the maximum. :)</p>\n<p>To get the value of an index, use</p>\n<pre><code class=\"python\">list[index]\n</code></pre>\n", "abstract": "First of all, the indexes will be from 0 to 4. Programming languages start counting from 0; don't forget that or you will come across an index-out-of-bounds exception. All you need in the for loop is a variable counting from 0 to 4 like so: Keep in mind that I wrote 0 to 5 because the loop stops one number before the maximum. :) To get the value of an index, use"}, {"id": 10459739, "score": 18, "vote": 0, "content": "<p>According to this discussion: <em><a href=\"http://bytes.com/topic/python/answers/464012-objects-list-index\" rel=\"nofollow noreferrer\">object's list index</a></em></p>\n<p>Loop counter iteration</p>\n<p>The current idiom for looping over the indices makes use of the built-in <code>range</code> function:</p>\n<pre><code class=\"python\">for i in range(len(sequence)):\n    # Work with index i\n</code></pre>\n<p>Looping over both elements and indices can be achieved either by the old idiom or by using the new <code>zip</code> built-in function:</p>\n<pre><code class=\"python\">for i in range(len(sequence)):\n    e = sequence[i]\n    # Work with index i and element e\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">for i, e in zip(range(len(sequence)), sequence):\n    # Work with index i and element e\n</code></pre>\n<p>via <em><a href=\"http://www.python.org/dev/peps/pep-0212/\" rel=\"nofollow noreferrer\">PEP 212 \u2013 Loop Counter Iteration</a></em>.</p>\n", "abstract": "According to this discussion: object's list index Loop counter iteration The current idiom for looping over the indices makes use of the built-in range function: Looping over both elements and indices can be achieved either by the old idiom or by using the new zip built-in function: or via PEP 212 \u2013 Loop Counter Iteration."}, {"id": 30441543, "score": 18, "vote": 0, "content": "<p>You can do it with this code:</p>\n<pre><code class=\"python\">ints = [8, 23, 45, 12, 78]\nindex = 0\n\nfor value in (ints):\n    index +=1\n    print index, value\n</code></pre>\n<p>Use this code if you need to reset the index value at the end of the loop:</p>\n<pre><code class=\"python\">ints = [8, 23, 45, 12, 78]\nindex = 0\n\nfor value in (ints):\n    index +=1\n    print index, value\n    if index &gt;= len(ints)-1:\n        index = 0\n</code></pre>\n", "abstract": "You can do it with this code: Use this code if you need to reset the index value at the end of the loop:"}, {"id": 50672647, "score": 17, "vote": 0, "content": "<p>If I were to iterate <code>nums = [1, 2, 3, 4, 5]</code> I would do</p>\n<pre><code class=\"python\">for i, num in enumerate(nums, start=1):\n    print(i, num)\n</code></pre>\n<p>Or get the length as <code>l = len(nums)</code></p>\n<pre><code class=\"python\">for i in range(l):\n    print(i+1, nums[i])\n</code></pre>\n", "abstract": "If I were to iterate nums = [1, 2, 3, 4, 5] I would do Or get the length as l = len(nums)"}, {"id": 51863929, "score": 17, "vote": 0, "content": "<p>In your question, you write <em>\"how do I access the loop index, from 1 to 5 in this case?\"</em></p>\n<p>However, the index for a list runs from zero.  So, then we need to know if what you actually want is the index and item for each item in a list, or whether you really want numbers starting from 1.  Fortunately, in Python, it is easy to do either or both.</p>\n<p>First, to clarify, the <code>enumerate</code> function iteratively returns the index and corresponding item for each item in a list.</p>\n<pre><code class=\"python\">alist = [1, 2, 3, 4, 5]\n\nfor n, a in enumerate(alist):\n    print(\"%d %d\" % (n, a))\n</code></pre>\n<p>The output for the above is then,</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">0 1\n1 2\n2 3\n3 4\n4 5\n</code></pre>\n<p>Notice that the index runs from 0. This kind of indexing is common among modern programming languages including Python and C.</p>\n<p>If you want your loop to span a part of the list, you can use the standard Python syntax for a part of the list. For example, to loop from the second item in a list up to but not including the last item, you could use</p>\n<pre><code class=\"python\">for n, a in enumerate(alist[1:-1]):\n    print(\"%d %d\" % (n, a))\n</code></pre>\n<p>Note that once again, the output index runs from 0,</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">0 2\n1 3\n2 4\n</code></pre>\n<p>That brings us to the <code>start=n</code> switch for <code>enumerate()</code>.  This simply offsets the index, you can equivalently simply add a number to the index inside the loop.</p>\n<pre><code class=\"python\">for n, a in enumerate(alist, start=1):\n    print(\"%d %d\" % (n, a))\n</code></pre>\n<p>for which the output is</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">1 1\n2 2\n3 3\n4 4\n5 5\n</code></pre>\n", "abstract": "In your question, you write \"how do I access the loop index, from 1 to 5 in this case?\" However, the index for a list runs from zero.  So, then we need to know if what you actually want is the index and item for each item in a list, or whether you really want numbers starting from 1.  Fortunately, in Python, it is easy to do either or both. First, to clarify, the enumerate function iteratively returns the index and corresponding item for each item in a list. The output for the above is then, Notice that the index runs from 0. This kind of indexing is common among modern programming languages including Python and C. If you want your loop to span a part of the list, you can use the standard Python syntax for a part of the list. For example, to loop from the second item in a list up to but not including the last item, you could use Note that once again, the output index runs from 0, That brings us to the start=n switch for enumerate().  This simply offsets the index, you can equivalently simply add a number to the index inside the loop. for which the output is"}, {"id": 50780432, "score": 13, "vote": 0, "content": "<p>If there is no duplicate value in the list:</p>\n<pre><code class=\"python\">for i in ints:\n    indx = ints.index(i)\n    print(i, indx)\n</code></pre>\n", "abstract": "If there is no duplicate value in the list:"}, {"id": 48665823, "score": 10, "vote": 0, "content": "<p>You can also try this:</p>\n<pre><code class=\"python\">data = ['itemA.ABC', 'itemB.defg', 'itemC.drug', 'itemD.ashok']\nx = []\nfor (i, item) in enumerate(data):\n      a = (i, str(item).split('.'))\n      x.append(a)\nfor index, value in x:\n     print(index, value)\n</code></pre>\n<p>The output is </p>\n<pre><code class=\"python\">0 ['itemA', 'ABC']\n1 ['itemB', 'defg']\n2 ['itemC', 'drug']\n3 ['itemD', 'ashok']\n</code></pre>\n", "abstract": "You can also try this: The output is "}, {"id": 50613659, "score": 8, "vote": 0, "content": "<p>You can use the <code>index</code> method:</p>\n<pre><code class=\"python\">ints = [8, 23, 45, 12, 78]\ninds = [ints.index(i) for i in ints]\n</code></pre>\n<p>It is highlighted in a comment that this method doesn\u2019t work if there are duplicates in <code>ints</code>. The method below should work for any values in <code>ints</code>:</p>\n<pre><code class=\"python\">ints = [8, 8, 8, 23, 45, 12, 78]\ninds = [tup[0] for tup in enumerate(ints)]\n</code></pre>\n<p>Or alternatively</p>\n<pre><code class=\"python\">ints = [8, 8, 8, 23, 45, 12, 78]\ninds = [tup for tup in enumerate(ints)]\n</code></pre>\n<p>if you want to get both the index and the value in <code>ints</code> as a list of tuples.</p>\n<p>It uses the method of <code>enumerate</code> in the selected answer to this question, but with list comprehension, making it faster with less code.</p>\n", "abstract": "You can use the index method: It is highlighted in a comment that this method doesn\u2019t work if there are duplicates in ints. The method below should work for any values in ints: Or alternatively if you want to get both the index and the value in ints as a list of tuples. It uses the method of enumerate in the selected answer to this question, but with list comprehension, making it faster with less code."}, {"id": 61295753, "score": 7, "vote": 0, "content": "<p>A simple answer using a <em>while</em> loop:</p>\n<pre><code class=\"python\">arr = [8, 23, 45, 12, 78]\ni = 0\nwhile i &lt; len(arr):\n    print(\"Item \", i + 1, \" = \", arr[i])\n    i += 1\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">Item  1  =  8\nItem  2  =  23\nItem  3  =  45\nItem  4  =  12\nItem  5  =  78\n</code></pre>\n", "abstract": "A simple answer using a while loop: Output:"}, {"id": 49999897, "score": 5, "vote": 0, "content": "<p>To print a tuple of (index, value) in a list comprehension using a <em>for</em> loop:</p>\n<pre><code class=\"python\">ints = [8, 23, 45, 12, 78]\nprint [(i,ints[i]) for i in range(len(ints))]\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">[(0, 8), (1, 23), (2, 45), (3, 12), (4, 78)]\n</code></pre>\n", "abstract": "To print a tuple of (index, value) in a list comprehension using a for loop: Output:"}, {"id": 67461537, "score": 5, "vote": 0, "content": "<p>You can simply use a variable such as <code>count</code> to count the number of elements in the list:</p>\n<pre><code class=\"python\">ints = [8, 23, 45, 12, 78]\ncount = 0\nfor i in ints:\n    count = count + 1\n    print('item #{} = {}'.format(count, i))\n</code></pre>\n", "abstract": "You can simply use a variable such as count to count the number of elements in the list:"}, {"id": 72542661, "score": 1, "vote": 0, "content": "<p>You can use <code>range(len(some_list))</code> and then lookup the index like this</p>\n<pre><code class=\"python\">xs = [8, 23, 45]\nfor i in range(len(xs)):\n    print(\"item #{} = {}\".format(i + 1, xs[i]))\n</code></pre>\n<p>Or use the Python\u2019s built-in <code>enumerate</code> function which allows you to loop over a list and retrieve the index and the value of each item in the list</p>\n<pre><code class=\"python\">xs = [8, 23, 45]\nfor idx, val in enumerate(xs, start=1):\n    print(\"item #{} = {}\".format(idx, val))\n</code></pre>\n", "abstract": "You can use range(len(some_list)) and then lookup the index like this Or use the Python\u2019s built-in enumerate function which allows you to loop over a list and retrieve the index and the value of each item in the list"}, {"id": 72216703, "score": 0, "vote": 0, "content": "<p>It can be achieved with the following code:</p>\n<pre><code class=\"python\">xs = [8, 23, 45]\nfor x, n in zip(xs, range(1, len(xs)+1)):\n    print(\"item #{} = {}\".format(n, x))\n</code></pre>\n<p>Here, range(1, len(xs)+1); If you expect the output to start from 1 instead of 0, you need to start the range from 1 and add 1 to the total length estimated since python starts indexing the number from 0 by default.</p>\n<pre><code class=\"python\">Final Output:\nitem #1 = 8\nitem #2 = 23\nitem #3 = 45\n</code></pre>\n", "abstract": "It can be achieved with the following code: Here, range(1, len(xs)+1); If you expect the output to start from 1 instead of 0, you need to start the range from 1 and add 1 to the total length estimated since python starts indexing the number from 0 by default."}, {"id": 70595306, "score": -4, "vote": 0, "content": "<p>A loop with a \"counter\" variable set as an initialiser that will be a parameter, in formatting the string, as the item number.</p>\n<p>The <em>for</em> loop accesses the \"listos\" variable which is the list. As we access the list by \"i\", \"i\" is formatted as the item price (or whatever it is).</p>\n<pre><code class=\"python\">listos = [8, 23, 45, 12, 78]\ncounter = 1\nfor i in listos:\n    print('Item #{} = {}'.format(counter, i))\n    counter += 1\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">Item #1 = 8\nItem #2 = 23\nItem #3 = 45\nItem #4 = 12\nItem #5 = 78\n</code></pre>\n", "abstract": "A loop with a \"counter\" variable set as an initialiser that will be a parameter, in formatting the string, as the item number. The for loop accesses the \"listos\" variable which is the list. As we access the list by \"i\", \"i\" is formatted as the item price (or whatever it is). Output:"}, {"id": 49999727, "score": -5, "vote": 0, "content": "<p>This serves the purpose well enough:</p>\n<pre><code class=\"python\">list1 = [10, 'sumit', 43.21, 'kumar', '43', 'test', 3]\nfor x in list1:\n    print('index:', list1.index(x), 'value:', x)\n</code></pre>\n", "abstract": "This serves the purpose well enough:"}]}, {"link": "https://stackoverflow.com/questions/952914/how-do-i-make-a-flat-list-out-of-a-list-of-lists", "question": {"id": "952914", "title": "How do I make a flat list out of a list of lists?", "content": "<p>I have a list of lists like <code>[[1, 2, 3], [4, 5, 6], [7], [8, 9]]</code>. How can I flatten it to get <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>?</p>\n<hr/>\n<p><sub>If your list of lists comes from a nested list comprehension, the problem can be solved more simply/directly by fixing the comprehension; please see <a href=\"https://stackoverflow.com/questions/1077015\">python list comprehensions; compressing a list of lists?</a>.</sub></p>\n<p><sub>The most popular solutions here generally only flatten one \"level\" of the nested list. See <a href=\"https://stackoverflow.com/questions/2158395\">Flatten an irregular (arbitrarily nested) list of lists</a> for solutions that completely flatten a deeply nested structure (recursively, in general).</sub></p>\n", "abstract": "I have a list of lists like [[1, 2, 3], [4, 5, 6], [7], [8, 9]]. How can I flatten it to get [1, 2, 3, 4, 5, 6, 7, 8, 9]? If your list of lists comes from a nested list comprehension, the problem can be solved more simply/directly by fixing the comprehension; please see python list comprehensions; compressing a list of lists?. The most popular solutions here generally only flatten one \"level\" of the nested list. See Flatten an irregular (arbitrarily nested) list of lists for solutions that completely flatten a deeply nested structure (recursively, in general)."}, "answers": [{"id": 952952, "score": 6737, "vote": 0, "content": "<p>Given a list of lists <code>l</code>,</p>\n<pre><code class=\"python\">flat_list = [item for sublist in l for item in sublist]\n</code></pre>\n<p>which means:</p>\n<pre><code class=\"python\">flat_list = []\nfor sublist in l:\n    for item in sublist:\n        flat_list.append(item)\n</code></pre>\n<p>is faster than the shortcuts posted so far. (<code>l</code> is the list to flatten.)</p>\n<p>Here is the corresponding function:</p>\n<pre><code class=\"python\">def flatten(l):\n    return [item for sublist in l for item in sublist]\n</code></pre>\n<p>As evidence, you can use the <code>timeit</code> module in the standard library:</p>\n<pre><code class=\"python\">$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' '[item for sublist in l for item in sublist]'\n10000 loops, best of 3: 143 usec per loop\n$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'sum(l, [])'\n1000 loops, best of 3: 969 usec per loop\n$ python -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'reduce(lambda x,y: x+y,l)'\n1000 loops, best of 3: 1.1 msec per loop\n</code></pre>\n<p>Explanation: the shortcuts based on <code>+</code> (including the implied use in <code>sum</code>) are, of necessity, <code>O(L**2)</code> when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of I items each: the first I items are copied back and forth L-1 times, the second I items L-2 times, and so on; total number of copies is I times the sum of x for x from 1 to L excluded, i.e., <code>I * (L**2)/2</code>.</p>\n<p>The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.</p>\n", "abstract": "Given a list of lists l, which means: is faster than the shortcuts posted so far. (l is the list to flatten.) Here is the corresponding function: As evidence, you can use the timeit module in the standard library: Explanation: the shortcuts based on + (including the implied use in sum) are, of necessity, O(L**2) when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of I items each: the first I items are copied back and forth L-1 times, the second I items L-2 times, and so on; total number of copies is I times the sum of x for x from 1 to L excluded, i.e., I * (L**2)/2. The list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once."}, {"id": 953097, "score": 2136, "vote": 0, "content": "<p>You can use <a href=\"http://docs.python.org/library/itertools.html#itertools.chain\" rel=\"noreferrer\"><code>itertools.chain()</code></a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; list2d = [[1,2,3], [4,5,6], [7], [8,9]]\n&gt;&gt;&gt; merged = list(itertools.chain(*list2d))\n</code></pre>\n<p>Or you can use <a href=\"http://docs.python.org/library/itertools.html#itertools.chain.from_iterable\" rel=\"noreferrer\"><code>itertools.chain.from_iterable()</code></a> which doesn't require unpacking the list with the <code>*</code> operator:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; list2d = [[1,2,3], [4,5,6], [7], [8,9]]\n&gt;&gt;&gt; merged = list(itertools.chain.from_iterable(list2d))\n</code></pre>\n<p>This approach is arguably more readable than <code>[item for sublist in l for item in sublist]</code> and appears to be faster too:</p>\n<pre><code class=\"python\">$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99;import itertools' 'list(itertools.chain.from_iterable(l))'\n20000 loops, best of 5: 10.8 usec per loop\n$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' '[item for sublist in l for item in sublist]'\n10000 loops, best of 5: 21.7 usec per loop\n$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'sum(l, [])'\n1000 loops, best of 5: 258 usec per loop\n$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99;from functools import reduce' 'reduce(lambda x,y: x+y,l)'\n1000 loops, best of 5: 292 usec per loop\n$ python3 --version\nPython 3.7.5rc1\n</code></pre>\n", "abstract": "You can use itertools.chain(): Or you can use itertools.chain.from_iterable() which doesn't require unpacking the list with the * operator: This approach is arguably more readable than [item for sublist in l for item in sublist] and appears to be faster too:"}, {"id": 952946, "score": 1255, "vote": 0, "content": "<p><strong>Note from the author</strong>: This is very inefficient. But fun, because <a href=\"https://en.wikipedia.org/wiki/Monoid#Monoids_in_computer_science\" rel=\"noreferrer\">monoids</a> are awesome.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; xss = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\n&gt;&gt;&gt; sum(xss, [])\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<p><code>sum</code> sums the elements of the iterable <code>xss</code>, and uses the second argument as the initial value <code>[]</code> for the sum. (The default initial value is <code>0</code>, which is not a list.)</p>\n<p>Because you are summing nested lists, you actually get <code>[1,3]+[2,4]</code> as a result of <code>sum([[1,3],[2,4]],[])</code>, which is equal to <code>[1,3,2,4]</code>.</p>\n<p>Note that only works on lists of lists. For lists of lists of lists, you'll need another solution.</p>\n", "abstract": "Note from the author: This is very inefficient. But fun, because monoids are awesome. sum sums the elements of the iterable xss, and uses the second argument as the initial value [] for the sum. (The default initial value is 0, which is not a list.) Because you are summing nested lists, you actually get [1,3]+[2,4] as a result of sum([[1,3],[2,4]],[]), which is equal to [1,3,2,4]. Note that only works on lists of lists. For lists of lists of lists, you'll need another solution."}, {"id": 45323085, "score": 821, "vote": 0, "content": "<p>I tested most suggested solutions with <a href=\"https://github.com/nschloe/perfplot\" rel=\"noreferrer\">perfplot</a> (a pet project of mine, essentially a wrapper around <code>timeit</code>), and found</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import functools\nimport operator\nfunctools.reduce(operator.iconcat, a, [])\n</code></pre>\n<p>to be the fastest solution, both when many small lists and few long lists are concatenated. (<code>operator.iadd</code> is equally fast.)</p>\n<p>A simpler and also acceptable variant is</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">out = []\nfor sublist in a:\n    out.extend(sublist)\n</code></pre>\n<p>If the number of sublists is large, this performs a little worse than the above suggestion.</p>\n<p><a href=\"https://i.stack.imgur.com/82YEG.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/82YEG.png\"/></a></p>\n<p><a href=\"https://i.stack.imgur.com/Mo7iy.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Mo7iy.png\"/></a></p>\n<hr/>\n<p>Code to reproduce the plot:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import functools\nimport itertools\nimport operator\n\nimport numpy as np\nimport perfplot\n\n\ndef forfor(a):\n    return [item for sublist in a for item in sublist]\n\n\ndef sum_brackets(a):\n    return sum(a, [])\n\n\ndef functools_reduce(a):\n    return functools.reduce(operator.concat, a)\n\n\ndef functools_reduce_iconcat(a):\n    return functools.reduce(operator.iconcat, a, [])\n\n\ndef itertools_chain(a):\n    return list(itertools.chain.from_iterable(a))\n\n\ndef numpy_flat(a):\n    return list(np.array(a).flat)\n\n\ndef numpy_concatenate(a):\n    return list(np.concatenate(a))\n\n\ndef extend(a):\n    out = []\n    for sublist in a:\n        out.extend(sublist)\n    return out\n\n\nb = perfplot.bench(\n    setup=lambda n: [list(range(10))] * n,\n    # setup=lambda n: [list(range(n))] * 10,\n    kernels=[\n        forfor,\n        sum_brackets,\n        functools_reduce,\n        functools_reduce_iconcat,\n        itertools_chain,\n        numpy_flat,\n        numpy_concatenate,\n        extend,\n    ],\n    n_range=[2 ** k for k in range(16)],\n    xlabel=\"num lists (of length 10)\",\n    # xlabel=\"len lists (10 lists total)\"\n)\nb.save(\"out.png\")\nb.show()\n</code></pre>\n", "abstract": "I tested most suggested solutions with perfplot (a pet project of mine, essentially a wrapper around timeit), and found to be the fastest solution, both when many small lists and few long lists are concatenated. (operator.iadd is equally fast.) A simpler and also acceptable variant is If the number of sublists is large, this performs a little worse than the above suggestion.   Code to reproduce the plot:"}, {"id": 952943, "score": 310, "vote": 0, "content": "<p>Using <a href=\"https://docs.python.org/3/library/functools.html#functools.reduce\" rel=\"noreferrer\"><code>functools.reduce</code></a>, which adds an accumulated list <code>xs</code> to the next list <code>ys</code>:</p>\n<pre><code class=\"python\">from functools import reduce\nxss = [[1,2,3], [4,5,6], [7], [8,9]]\nout = reduce(lambda xs, ys: xs + ys, xss)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<hr/>\n<p>A faster way using <a href=\"https://docs.python.org/3/library/operator.html#operator.concat\" rel=\"noreferrer\"><code>operator.concat</code></a>:</p>\n<pre><code class=\"python\">from functools import reduce\nimport operator\nxss = [[1,2,3], [4,5,6], [7], [8,9]]\nout = reduce(operator.concat, xss)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n", "abstract": "Using functools.reduce, which adds an accumulated list xs to the next list ys: Output: A faster way using operator.concat: Output:"}, {"id": 40857703, "score": 174, "vote": 0, "content": "<p>Here is a general approach that applies to <strong>numbers</strong>, <strong>strings</strong>, <strong>nested</strong> lists and <strong>mixed</strong> containers.  This can flatten both simple and complicated containers (see also <em>Demo</em>).</p>\n<p><strong>Code</strong></p>\n<pre><code class=\"python\">from typing import Iterable \n#from collections import Iterable                            # &lt; py38\n\n\ndef flatten(items):\n    \"\"\"Yield items from any nested iterable; see Reference.\"\"\"\n    for x in items:\n        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):\n            for sub_x in flatten(x):\n                yield sub_x\n        else:\n            yield x\n</code></pre>\n<p><em>Notes</em>:</p>\n<ul>\n<li>In Python 3, <code>yield from flatten(x)</code> can replace <code>for sub_x in flatten(x): yield sub_x</code></li>\n<li>In Python 3.8, <a href=\"https://docs.python.org/3/library/collections.abc.html#module-collections.abc\" rel=\"noreferrer\">abstract base classes</a> are <a href=\"https://docs.python.org/3/whatsnew/3.7.html#id3\" rel=\"noreferrer\">moved</a> from <code>collection.abc</code> to the <code>typing</code> module.</li>\n</ul>\n<p><strong>Demo</strong></p>\n<pre><code class=\"python\">simple = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nlist(flatten(simple))\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\ncomplicated = [[1, [2]], (3, 4, {5, 6}, 7), 8, \"9\"]              # numbers, strs, nested &amp; mixed\nlist(flatten(complicated))\n# [1, 2, 3, 4, 5, 6, 7, 8, '9']\n</code></pre>\n<p><strong>Reference</strong></p>\n<ul>\n<li>This solution is modified from a recipe in <em>Beazley, D. and B. Jones.  Recipe 4.14, Python Cookbook 3rd Ed., O'Reilly Media Inc. Sebastopol, CA: 2013.</em></li>\n<li>Found an earlier <a href=\"https://stackoverflow.com/a/2158532/4531270\">SO post</a>, possibly the original demonstration.</li>\n</ul>\n", "abstract": "Here is a general approach that applies to numbers, strings, nested lists and mixed containers.  This can flatten both simple and complicated containers (see also Demo). Code Notes: Demo Reference"}, {"id": 40813764, "score": 111, "vote": 0, "content": "<p>To flatten a data-structure that is deeply nested, use <a href=\"https://iteration-utilities.readthedocs.io/en/latest/generated/deepflatten.html\" rel=\"noreferrer\"><code>iteration_utilities.deepflatten</code></a><sup>1</sup>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from iteration_utilities import deepflatten\n\n&gt;&gt;&gt; l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\n&gt;&gt;&gt; list(deepflatten(l, depth=1))\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n&gt;&gt;&gt; l = [[1, 2, 3], [4, [5, 6]], 7, [8, 9]]\n&gt;&gt;&gt; list(deepflatten(l))\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<p>It's a generator so you need to cast the result to a <code>list</code> or explicitly iterate over it.</p>\n<hr/>\n<p>To flatten only one level and if each of the items is itself iterable you can also use <a href=\"https://iteration-utilities.readthedocs.io/en/latest/generated/flatten.html\" rel=\"noreferrer\"><code>iteration_utilities.flatten</code></a> which itself is just a thin wrapper around <a href=\"https://docs.python.org/library/itertools.html#itertools.chain.from_iterable\" rel=\"noreferrer\"><code>itertools.chain.from_iterable</code></a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from iteration_utilities import flatten\n&gt;&gt;&gt; l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\n&gt;&gt;&gt; list(flatten(l))\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<hr/>\n<p>Just to add some timings (based on <a href=\"https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-a-list-of-lists/45323085#45323085\">Nico Schl\u00f6mer's answer</a> that didn't include the function presented in this answer):</p>\n<p><a href=\"https://i.stack.imgur.com/3D8uN.png\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/3D8uN.png\"/></a></p>\n<p>It's a log-log plot to accommodate for the huge range of values spanned. For qualitative reasoning: Lower is better.</p>\n<p>The results show that if the iterable contains only a few inner iterables then <code>sum</code> will be fastest, however for long iterables only the <code>itertools.chain.from_iterable</code>, <code>iteration_utilities.deepflatten</code> or the nested comprehension have reasonable performance with <code>itertools.chain.from_iterable</code> being the fastest (as already noticed by Nico Schl\u00f6mer).</p>\n<pre><code class=\"python\">from itertools import chain\nfrom functools import reduce\nfrom collections import Iterable  # or from collections.abc import Iterable\nimport operator\nfrom iteration_utilities import deepflatten\n\ndef nested_list_comprehension(lsts):\n    return [item for sublist in lsts for item in sublist]\n\ndef itertools_chain_from_iterable(lsts):\n    return list(chain.from_iterable(lsts))\n\ndef pythons_sum(lsts):\n    return sum(lsts, [])\n\ndef reduce_add(lsts):\n    return reduce(lambda x, y: x + y, lsts)\n\ndef pylangs_flatten(lsts):\n    return list(flatten(lsts))\n\ndef flatten(items):\n    \"\"\"Yield items from any nested iterable; see REF.\"\"\"\n    for x in items:\n        if isinstance(x, Iterable) and not isinstance(x, (str, bytes)):\n            yield from flatten(x)\n        else:\n            yield x\n\ndef reduce_concat(lsts):\n    return reduce(operator.concat, lsts)\n\ndef iteration_utilities_deepflatten(lsts):\n    return list(deepflatten(lsts, depth=1))\n\n\nfrom simple_benchmark import benchmark\n\nb = benchmark(\n    [nested_list_comprehension, itertools_chain_from_iterable, pythons_sum, reduce_add,\n     pylangs_flatten, reduce_concat, iteration_utilities_deepflatten],\n    arguments={2**i: [[0]*5]*(2**i) for i in range(1, 13)},\n    argument_name='number of inner lists'\n)\n\nb.plot()\n</code></pre>\n<hr/>\n<p><sup>1 Disclaimer: I'm the author of that library</sup></p>\n", "abstract": "To flatten a data-structure that is deeply nested, use iteration_utilities.deepflatten1: It's a generator so you need to cast the result to a list or explicitly iterate over it. To flatten only one level and if each of the items is itself iterable you can also use iteration_utilities.flatten which itself is just a thin wrapper around itertools.chain.from_iterable: Just to add some timings (based on Nico Schl\u00f6mer's answer that didn't include the function presented in this answer):  It's a log-log plot to accommodate for the huge range of values spanned. For qualitative reasoning: Lower is better. The results show that if the iterable contains only a few inner iterables then sum will be fastest, however for long iterables only the itertools.chain.from_iterable, iteration_utilities.deepflatten or the nested comprehension have reasonable performance with itertools.chain.from_iterable being the fastest (as already noticed by Nico Schl\u00f6mer). 1 Disclaimer: I'm the author of that library"}, {"id": 44917489, "score": 45, "vote": 0, "content": "<p>The following seems simplest to me:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\n&gt;&gt;&gt; print(np.concatenate(l))\n[1 2 3 4 5 6 7 8 9]\n</code></pre>\n", "abstract": "The following seems simplest to me:"}, {"id": 40938883, "score": 43, "vote": 0, "content": "<p>Consider installing the <a href=\"https://github.com/erikrose/more-itertools\" rel=\"noreferrer\"><code>more_itertools</code></a> package.</p>\n<pre><code class=\"python\">&gt; pip install more_itertools\n</code></pre>\n<p>It ships with an implementation for <a href=\"https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.flatten\" rel=\"noreferrer\"><code>flatten</code></a> (<a href=\"https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/recipes.html#flatten\" rel=\"noreferrer\">source</a>, from the <a href=\"https://docs.python.org/3/library/itertools.html#itertools-recipes\" rel=\"noreferrer\">itertools recipes</a>):</p>\n<pre><code class=\"python\">import more_itertools\n\n\nlst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nlist(more_itertools.flatten(lst))\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<p><em>Note: as mentioned in the <a href=\"https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.flatten\" rel=\"noreferrer\">docs</a>, <code>flatten</code> requires a list of lists.  See below on flattening more irregular inputs.</em></p>\n<hr/>\n<p>As of version 2.4, you can flatten more complicated, nested iterables with <a href=\"https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.collapse\" rel=\"noreferrer\"><code>more_itertools.collapse</code></a> (<a href=\"https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html#collapse\" rel=\"noreferrer\">source</a>, contributed by  abarnet).</p>\n<pre><code class=\"python\">lst = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nlist(more_itertools.collapse(lst)) \n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nlst = [[1, 2, 3], [[4, 5, 6]], [[[7]]], 8, 9]              # complex nesting\nlist(more_itertools.collapse(lst))\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n", "abstract": "Consider installing the more_itertools package. It ships with an implementation for flatten (source, from the itertools recipes): Note: as mentioned in the docs, flatten requires a list of lists.  See below on flattening more irregular inputs. As of version 2.4, you can flatten more complicated, nested iterables with more_itertools.collapse (source, contributed by  abarnet)."}, {"id": 952997, "score": 36, "vote": 0, "content": "<p>The reason your function didn't work is because the <em>extend</em> extends an array in-place and doesn't return it. You can still return x from lambda, using something like this:</p>\n<pre><code class=\"python\">reduce(lambda x,y: x.extend(y) or x, l)\n</code></pre>\n<p>Note: extend is more efficient than + on lists.</p>\n", "abstract": "The reason your function didn't work is because the extend extends an array in-place and doesn't return it. You can still return x from lambda, using something like this: Note: extend is more efficient than + on lists."}, {"id": 48569389, "score": 29, "vote": 0, "content": "<p><code>matplotlib.cbook.flatten()</code> will work for nested lists even if they nest more deeply than the example.</p>\n<pre><code class=\"python\">import matplotlib\nl = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nprint(list(matplotlib.cbook.flatten(l)))\nl2 = [[1, 2, 3], [4, 5, 6], [7], [8, [9, 10, [11, 12, [13]]]]]\nprint(list(matplotlib.cbook.flatten(l2)))\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n</code></pre>\n<p>This is 18x faster than underscore._.flatten:</p>\n<pre><code class=\"python\">Average time over 1000 trials of matplotlib.cbook.flatten: 2.55e-05 sec\nAverage time over 1000 trials of underscore._.flatten: 4.63e-04 sec\n(time for underscore._)/(time for matplotlib.cbook) = 18.1233394636\n</code></pre>\n", "abstract": "matplotlib.cbook.flatten() will work for nested lists even if they nest more deeply than the example. Result: This is 18x faster than underscore._.flatten:"}, {"id": 70287313, "score": 27, "vote": 0, "content": "<p>According your list <code>[[1, 2, 3], [4, 5, 6], [7], [8, 9]]</code> which is 1 list level, we can simply use <code>sum(list,[])</code> without using any libraries</p>\n<pre><code class=\"python\">sum([[1, 2, 3], [4, 5, 6], [7], [8, 9]],[])\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<p>To extend the advantage of this method when there is a tuple or number existing inside. Simply adding a mapping function for each element by <code>map</code> to the list</p>\n<pre><code class=\"python\">#For only tuple\nsum(list(map(list,[[1, 2, 3], (4, 5, 6), (7,), [8, 9]])),[])\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n#In general\n\ndef convert(x):\n    if type(x) is int or type(x) is float:\n           return [x]\n    else:\n           return list(x)\n\nsum(list(map(convert,[[1, 2, 3], (4, 5, 6), 7, [8, 9]])),[])\n# [1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<p>In <a href=\"https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python\" rel=\"nofollow noreferrer\">here</a>, there is a clear explanation of the drawback in terms of memory for this approach. In short, it recursively creates list objects, which should be avoided :(</p>\n", "abstract": "According your list [[1, 2, 3], [4, 5, 6], [7], [8, 9]] which is 1 list level, we can simply use sum(list,[]) without using any libraries To extend the advantage of this method when there is a tuple or number existing inside. Simply adding a mapping function for each element by map to the list In here, there is a clear explanation of the drawback in terms of memory for this approach. In short, it recursively creates list objects, which should be avoided :("}, {"id": 38421470, "score": 20, "vote": 0, "content": "<p>One can also use NumPy's <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flat.html\" rel=\"noreferrer\">flat</a>:</p>\n<pre><code class=\"python\">import numpy as np\nlist(np.array(l).flat)\n</code></pre>\n<p>It only works when sublists have identical dimensions.</p>\n", "abstract": "One can also use NumPy's flat: It only works when sublists have identical dimensions."}, {"id": 59913424, "score": 14, "vote": 0, "content": "<p>You can use the <code>list</code> <code>extend</code> method. It shows to be the fastest:</p>\n<pre><code class=\"python\">flat_list = []\nfor sublist in l:\n    flat_list.extend(sublist)\n</code></pre>\n<p>Performance:</p>\n<pre><code class=\"python\">import functools\nimport itertools\nimport numpy\nimport operator\nimport perfplot\n\n\ndef functools_reduce_iconcat(a):\n    return functools.reduce(operator.iconcat, a, [])\n\n\ndef itertools_chain(a):\n    return list(itertools.chain.from_iterable(a))\n\n\ndef numpy_flat(a):\n    return list(numpy.array(a).flat)\n\n\ndef extend(a):\n    n = []\n\n    list(map(n.extend, a))\n\n    return n\n\n\nperfplot.show(\n    setup = lambda n: [list(range(10))] * n,\n    kernels = [\n        functools_reduce_iconcat, extend, itertools_chain, numpy_flat\n        ],\n    n_range = [2**k for k in range(16)],\n    xlabel = 'num lists',\n    )\n</code></pre>\n<p><strong>Output:</strong></p>\n<p><a href=\"https://i.stack.imgur.com/xMrjA.png\" rel=\"nofollow noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/xMrjA.png\"/></a></p>\n", "abstract": "You can use the list extend method. It shows to be the fastest: Performance: Output: "}, {"id": 70630568, "score": 14, "vote": 0, "content": "<p>Use two <code>for</code> in list comprehension:</p>\n<pre><code class=\"python\">l = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nflat_l = [e for v in l for e in v]\nprint(flat_l)\n</code></pre>\n", "abstract": "Use two for in list comprehension:"}, {"id": 63316751, "score": 10, "vote": 0, "content": "<p>There are several answers with the same recursive appending scheme as below, but none makes use of <code>try</code>, which makes the solution more robust and <em>Pythonic</em>.</p>\n<pre><code class=\"python\">def flatten(itr):\n    for x in itr:\n        try:\n            yield from flatten(x)\n        except TypeError:\n            yield x\n</code></pre>\n<p><strong>Usage</strong>: this is a generator, and you typically want to enclose it in an iterable builder like <code>list()</code> or <code>tuple()</code> or use it in a <code>for</code> loop.</p>\n<p>Advantages of this solution are:</p>\n<ul>\n<li>works with any kind of iterable (even future ones!)</li>\n<li>works with any combination and deepness of nesting</li>\n<li>works also if top level contains bare items</li>\n<li>no dependencies</li>\n<li>fast and efficient (you can flatten the nested iterable partially, without wasting time on the remaining part you don't need)</li>\n<li>versatile (you can use it to build an iterable of your choice or in a loop)</li>\n</ul>\n<p>N.B.: Since <em>all</em> iterables are flattened, strings are decomposed into sequences of single characters. If you don't like/want such behavior, you can use the following version which filters out from flattening iterables like strings and bytes:</p>\n<pre><code class=\"python\">def flatten(itr):\n    if type(itr) in (str,bytes):\n        yield itr\n    else:\n        for x in itr:\n            try:\n                yield from flatten(x)\n            except TypeError:\n                yield x\n</code></pre>\n", "abstract": "There are several answers with the same recursive appending scheme as below, but none makes use of try, which makes the solution more robust and Pythonic. Usage: this is a generator, and you typically want to enclose it in an iterable builder like list() or tuple() or use it in a for loop. Advantages of this solution are: N.B.: Since all iterables are flattened, strings are decomposed into sequences of single characters. If you don't like/want such behavior, you can use the following version which filters out from flattening iterables like strings and bytes:"}, {"id": 40275594, "score": 9, "vote": 0, "content": "<p>If you are willing to give up a tiny amount of speed for a cleaner look, then you could use <code>numpy.concatenate().tolist()</code> or <code>numpy.concatenate().ravel().tolist()</code>:</p>\n<pre><code class=\"python\">import numpy\n\nl = [[1, 2, 3], [4, 5, 6], [7], [8, 9]] * 99\n\n%timeit numpy.concatenate(l).ravel().tolist()\n1000 loops, best of 3: 313 \u00b5s per loop\n\n%timeit numpy.concatenate(l).tolist()\n1000 loops, best of 3: 312 \u00b5s per loop\n\n%timeit [item for sublist in l for item in sublist]\n1000 loops, best of 3: 31.5 \u00b5s per loop\n</code></pre>\n<p>You can find out more here in the documentation, <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.concatenate.html\" rel=\"nofollow noreferrer\">numpy.concatenate</a> and <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html\" rel=\"nofollow noreferrer\">numpy.ravel</a>.</p>\n", "abstract": "If you are willing to give up a tiny amount of speed for a cleaner look, then you could use numpy.concatenate().tolist() or numpy.concatenate().ravel().tolist(): You can find out more here in the documentation, numpy.concatenate and numpy.ravel."}, {"id": 48569551, "score": 8, "vote": 0, "content": "<p><strong>Note</strong>: Below applies to Python 3.3+ because it uses <a href=\"https://docs.python.org/3/whatsnew/3.3.html\" rel=\"noreferrer\"><code>yield_from</code></a>.  <code>six</code> is also a third-party package, though it is stable.  Alternately, you could use <code>sys.version</code>.</p>\n<hr/>\n<p>In the case of <code>obj = [[1, 2,], [3, 4], [5, 6]]</code>, all of the solutions here are good, including list comprehension and <code>itertools.chain.from_iterable</code>.</p>\n<p>However, consider this slightly more complex case:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; obj = [[1, 2, 3], [4, 5], 6, 'abc', [7], [8, [9, 10]]]\n</code></pre>\n<p>There are several problems here:</p>\n<ul>\n<li>One element, <code>6</code>, is just a scalar; it's not iterable, so the above routes will fail here.</li>\n<li>One element, <code>'abc'</code>, <em>is</em> technically iterable (all <code>str</code>s are).  However, reading between the lines a bit, you don't want to treat it as such--you want to treat it as a single element.</li>\n<li>The final element, <code>[8, [9, 10]]</code> is itself a nested iterable.  Basic list comprehension and <code>chain.from_iterable</code> only extract \"1 level down.\"</li>\n</ul>\n<p>You can remedy this as follows:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from collections import Iterable\n&gt;&gt;&gt; from six import string_types\n\n&gt;&gt;&gt; def flatten(obj):\n...     for i in obj:\n...         if isinstance(i, Iterable) and not isinstance(i, string_types):\n...             yield from flatten(i)\n...         else:\n...             yield i\n\n\n&gt;&gt;&gt; list(flatten(obj))\n[1, 2, 3, 4, 5, 6, 'abc', 7, 8, 9, 10]\n</code></pre>\n<p>Here, you check that the sub-element (1) is iterable with <a href=\"https://github.com/python/cpython/blob/master/Lib/_collections_abc.py#L243\" rel=\"noreferrer\"><code>Iterable</code></a>, an ABC from <code>itertools</code>, but also want to ensure that (2) the element is <em>not</em> \"string-like.\"</p>\n", "abstract": "Note: Below applies to Python 3.3+ because it uses yield_from.  six is also a third-party package, though it is stable.  Alternately, you could use sys.version. In the case of obj = [[1, 2,], [3, 4], [5, 6]], all of the solutions here are good, including list comprehension and itertools.chain.from_iterable. However, consider this slightly more complex case: There are several problems here: You can remedy this as follows: Here, you check that the sub-element (1) is iterable with Iterable, an ABC from itertools, but also want to ensure that (2) the element is not \"string-like.\""}, {"id": 45571781, "score": 5, "vote": 0, "content": "<pre><code class=\"python\">def flatten(alist):\n    if alist == []:\n        return []\n    elif type(alist) is not list:\n        return [alist]\n    else:\n        return flatten(alist[0]) + flatten(alist[1:])\n</code></pre>\n", "abstract": ""}, {"id": 50367409, "score": 4, "vote": 0, "content": "<p>This may not be the most efficient way, but I thought to put a one-liner (actually a two-liner). Both versions will work on arbitrary hierarchy nested lists, and exploits language features (Python\u00a03.5) and recursion.</p>\n<pre><code class=\"python\">def make_list_flat (l):\n    flist = []\n    flist.extend ([l]) if (type (l) is not list) else [flist.extend (make_list_flat (e)) for e in l]\n    return flist\n\na = [[1, 2], [[[[3, 4, 5], 6]]], 7, [8, [9, [10, 11], 12, [13, 14, [15, [[16, 17], 18]]]]]]\nflist = make_list_flat(a)\nprint (flist)\n</code></pre>\n<p>The output is</p>\n<pre><code class=\"python\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n</code></pre>\n<p>This works in a depth first manner. The recursion goes down until it finds a non-list element, then extends the local variable <code>flist</code> and then rolls back it to the parent. Whenever <code>flist</code> is returned, it is extended to the parent's <code>flist</code> in the list comprehension. Therefore, at the root, a flat list is returned.</p>\n<p>The above one creates several local lists and returns them which are used to extend the parent's list. I think the way around for this may be creating a gloabl <code>flist</code>, like below.</p>\n<pre><code class=\"python\">a = [[1, 2], [[[[3, 4, 5], 6]]], 7, [8, [9, [10, 11], 12, [13, 14, [15, [[16, 17], 18]]]]]]\nflist = []\ndef make_list_flat (l):\n    flist.extend ([l]) if (type (l) is not list) else [make_list_flat (e) for e in l]\n\nmake_list_flat(a)\nprint (flist)\n</code></pre>\n<p>The output is again</p>\n<pre><code class=\"python\">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n</code></pre>\n<p>Although I am not sure at this time about the efficiency.</p>\n", "abstract": "This may not be the most efficient way, but I thought to put a one-liner (actually a two-liner). Both versions will work on arbitrary hierarchy nested lists, and exploits language features (Python\u00a03.5) and recursion. The output is This works in a depth first manner. The recursion goes down until it finds a non-list element, then extends the local variable flist and then rolls back it to the parent. Whenever flist is returned, it is extended to the parent's flist in the list comprehension. Therefore, at the root, a flat list is returned. The above one creates several local lists and returns them which are used to extend the parent's list. I think the way around for this may be creating a gloabl flist, like below. The output is again Although I am not sure at this time about the efficiency."}, {"id": 69485553, "score": 4, "vote": 0, "content": "<p>I wanted a solution which can deal with multiple nesting (<code>[[1], [[[2]], [3]]], [1, 2, 3]</code> for example), but would also not be recursive (I had a big level of recursion and I got a recursion error.</p>\n<p>This is what I came up with:</p>\n<pre><code class=\"python\">def _flatten(l) -&gt; Iterator[Any]:\n    stack = l.copy()\n    while stack:\n        item = stack.pop()\n        if isinstance(item, list):\n            stack.extend(item)\n        else:\n            yield item\n\n\ndef flatten(l) -&gt; Iterator[Any]:\n    return reversed(list(_flatten(l)))\n</code></pre>\n<p>and tests:</p>\n<pre><code class=\"python\">@pytest.mark.parametrize('input_list, expected_output', [\n    ([1, 2, 3], [1, 2, 3]),\n    ([[1], 2, 3], [1, 2, 3]),\n    ([[1], [2], 3], [1, 2, 3]),\n    ([[1], [2], [3]], [1, 2, 3]),\n    ([[1], [[2]], [3]], [1, 2, 3]),\n    ([[1], [[[2]], [3]]], [1, 2, 3]),\n])\ndef test_flatten(input_list, expected_output):\n    assert list(flatten(input_list)) == expected_output\n</code></pre>\n", "abstract": "I wanted a solution which can deal with multiple nesting ([[1], [[[2]], [3]]], [1, 2, 3] for example), but would also not be recursive (I had a big level of recursion and I got a recursion error. This is what I came up with: and tests:"}, {"id": 71468284, "score": 3, "vote": 0, "content": "<p>Not a one-liner, but seeing all the answers here, I guess this long list missed some pattern matching, so here it is :)</p>\n<p>The two methods are probably not efficient, but anyway, it's easy to read (to me at least; perhaps I'm spoiled by functional programming):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def flat(x):\n    match x:\n        case []:\n            return []\n        case [[*sublist], *r]:\n            return [*sublist, *flat(r)]\n</code></pre>\n<p>The second version considers lists of lists of lists... whatever the nesting:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def flat(x):\n    match x:\n        case []:\n            return []\n        case [[*sublist], *r]:\n            return [*flat(sublist), *flat(r)]\n        case [h, *r]:\n            return [h, *flat(r)]\n</code></pre>\n", "abstract": "Not a one-liner, but seeing all the answers here, I guess this long list missed some pattern matching, so here it is :) The two methods are probably not efficient, but anyway, it's easy to read (to me at least; perhaps I'm spoiled by functional programming): The second version considers lists of lists of lists... whatever the nesting:"}, {"id": 48170454, "score": 2, "vote": 0, "content": "<p>Another unusual approach that works for hetero- and homogeneous lists of integers:</p>\n<pre><code class=\"python\">from typing import List\n\n\ndef flatten(l: list) -&gt; List[int]:\n    \"\"\"Flatten an arbitrary deep nested list of lists of integers.\n\n    Examples:\n        &gt;&gt;&gt; flatten([1, 2, [1, [10]]])\n        [1, 2, 1, 10]\n\n    Args:\n        l: Union[l, Union[int, List[int]]\n\n    Returns:\n        Flatted list of integer\n    \"\"\"\n    return [int(i.strip('[ ]')) for i in str(l).split(',')]\n</code></pre>\n", "abstract": "Another unusual approach that works for hetero- and homogeneous lists of integers:"}, {"id": 70285413, "score": 2, "vote": 0, "content": "<p>A non-recursive function to flatten lists of lists of any depth:</p>\n<pre><code class=\"python\">def flatten_list(list1):\n    out = []\n    inside = list1\n    while inside:\n        x = inside.pop(0)\n        if isinstance(x, list):\n            inside[0:0] = x\n        else:\n            out.append(x)\n    return out\n\nl = [[[1,2],3,[4,[[5,6],7],[8]]],[9,10,11]]\nflatten_list(l)\n# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n</code></pre>\n", "abstract": "A non-recursive function to flatten lists of lists of any depth:"}, {"id": 73106867, "score": 2, "vote": 0, "content": "<p>If you want to unnest everything and keep a distinct list of elements, you could use this as well.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">list_of_lists = [[1,2], [2,3], [3,4]]\nlist(set.union(*[set(s) for s in list_of_lists]))\n</code></pre>\n", "abstract": "If you want to unnest everything and keep a distinct list of elements, you could use this as well."}, {"id": 73304338, "score": 1, "vote": 0, "content": "<p>For a list containing multiple list here a recursive solution that work for me and that i hope is correct:</p>\n<pre><code class=\"python\"># Question 4\ndef flatten(input_ls=[]) -&gt; []:\n    res_ls = []\n    res_ls = flatten_recursive(input_ls, res_ls)\n\n    print(\"Final flatten list solution is: \\n\", res_ls)\n\n    return res_ls\n\n\ndef flatten_recursive(input_ls=[], res_ls=[]) -&gt; []:\n    tmp_ls = []\n\n    for i in input_ls:\n        if isinstance(i, int):\n            res_ls.append(i)\n        else:\n            tmp_ls = i\n            tmp_ls.append(flatten_recursive(i, res_ls))\n\n    print(res_ls)\n    return res_ls\n\n\nflatten([0, 1, [2, 3], 4, [5, 6]])  # test\nflatten([0, [[[1]]], [[2, 3], [4, [[5, 6]]]]])\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">[0, 1, 2, 3]\n[0, 1, 2, 3, 4, 5, 6]\n[0, 1, 2, 3, 4, 5, 6]\nFinal flatten list solution is: \n [0, 1, 2, 3, 4, 5, 6]\n[0, 1]\n[0, 1]\n[0, 1]\n[0, 1, 2, 3]\n[0, 1, 2, 3, 4, 5, 6]\n[0, 1, 2, 3, 4, 5, 6]\n[0, 1, 2, 3, 4, 5, 6]\n[0, 1, 2, 3, 4, 5, 6]\n[0, 1, 2, 3, 4, 5, 6]\nFinal flatten list solution is: \n [0, 1, 2, 3, 4, 5, 6]\n</code></pre>\n", "abstract": "For a list containing multiple list here a recursive solution that work for me and that i hope is correct: Output:"}, {"id": 69484358, "score": 0, "vote": 0, "content": "<p>You can use the following:</p>\n<pre><code class=\"python\">def flatlst(lista):\n    listaplana = []\n    for k in lista: listaplana = listaplana + k\n    return listaplana\n</code></pre>\n", "abstract": "You can use the following:"}, {"id": 70669715, "score": 0, "vote": 0, "content": "<p>If I want to add something to the great previous answers, here is my recursive <code>flatten</code> function which can flatten not only nested lists, but also any given container or any generally any object which can throw out items. This does also work for any depth of nesting and it is a lazy iterator which yields the items as requested:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def flatten(iterable):\n    # These types won't considered a sequence or generally a container\n    exclude = str, bytes\n\n    for i in iterable:\n        try:\n            if isinstance(i, exclude):\n                raise TypeError\n            iter(i)\n        except TypeError:\n            yield i\n        else:\n            yield from flatten(i)\n</code></pre>\n<p>This way, you can exclude types you don't want to be flattened, like <code>str</code> or what else.</p>\n<p>The idea is if an object can pass the <code>iter()</code> it's ready to yield items. So the iterable can have even generator expressions as an item.</p>\n<p>Someone could argue: Why did you write this that generic when the OP didn't ask for it? OK, you're right. I just felt like this might help someone (like it did for myself).</p>\n<p>Test cases:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">lst1 = [1, {3}, (1, 6), [[3, 8]], [[[5]]], 9, ((((2,),),),)]\nlst2 = ['3', B'A', [[[(i ** 2 for i in range(3))]]], range(3)]\n\nprint(list(flatten(lst1)))\nprint(list(flatten(lst2)))\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">[1, 3, 1, 6, 3, 8, 5, 9, 2]\n['3', b'A', 0, 1, 4, 0, 1, 2]\n</code></pre>\n", "abstract": "If I want to add something to the great previous answers, here is my recursive flatten function which can flatten not only nested lists, but also any given container or any generally any object which can throw out items. This does also work for any depth of nesting and it is a lazy iterator which yields the items as requested: This way, you can exclude types you don't want to be flattened, like str or what else. The idea is if an object can pass the iter() it's ready to yield items. So the iterable can have even generator expressions as an item. Someone could argue: Why did you write this that generic when the OP didn't ask for it? OK, you're right. I just felt like this might help someone (like it did for myself). Test cases: Output:"}, {"id": 72250465, "score": 0, "vote": 0, "content": "<p>I would suggest using generators with <strong>yield</strong> statement and <strong>yield from</strong>.\nHere's an example:</p>\n<pre><code class=\"python\">from collections.abc import Iterable\n\ndef flatten(items, ignore_types=(bytes, str)):\n    \"\"\"\n       Flatten all of the nested lists to the one. Ignoring flatting of iterable types str and bytes by default.\n    \"\"\"\n    for x in items:\n        if isinstance(x, Iterable) and not isinstance(x, ignore_types):\n            yield from flatten(x)\n        else:\n            yield x\n\nvalues = [7, [4, 3, 5, [7, 3], (3, 4), ('A', {'B', 'C'})]]\n\nfor v in flatten(values):\n    print(v)\n</code></pre>\n", "abstract": "I would suggest using generators with yield statement and yield from.\nHere's an example:"}, {"id": 71718885, "score": -1, "vote": 0, "content": "<p>Considering the list has just integers:</p>\n<pre><code class=\"python\">import re\nl = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nlist(map(int,re.sub('(\\[|\\])','',str(l)).split(',')))\n</code></pre>\n", "abstract": "Considering the list has just integers:"}, {"id": 72064062, "score": -1, "vote": 0, "content": "<pre><code class=\"python\">def flatten_array(arr):\n  result = []\n  for item in arr:\n    if isinstance(item, list):\n      for num in item:\n        result.append(num)\n    else:\n      result.append(item)\n  return result\n\nprint(flatten_array([1, 2, [3, 4, 5], 6, [7, 8], 9]))\n// output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n", "abstract": ""}, {"id": 73304966, "score": -1, "vote": 0, "content": "<p><strong>Simplest Way to do in python without any library</strong></p>\n<p><em>This function will work for even multidimensional list also</em></p>\n<p>using recursion we can achieve any combination of list inside list, we can flatten it without using any library.</p>\n<pre><code class=\"python\">#Devil\nx = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\n\n\noutput = []\ndef flatten(v):\n    if isinstance(v, int):\n        output.append(v)\n    if isinstance(v, list):\n        for i in range(0, len(v)):\n            flatten(v[i])\n\nflatten(x)\nprint(\"Output:\", output)\n#Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n#Adding more dimensions \nx = [ [1, [2, 3, [4, 5], [6]], 7 ], [8, [9, [10]]] ]\nflatten(x)\nprint(\"Output:\", output)\n#Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre>\n", "abstract": "Simplest Way to do in python without any library This function will work for even multidimensional list also using recursion we can achieve any combination of list inside list, we can flatten it without using any library."}, {"id": 73576067, "score": -2, "vote": 0, "content": "<p>I created a little function which can basically flatten anything.\nYou can get it with pip: <strong>pip install flatten-everything</strong></p>\n<pre><code class=\"python\">from flatten_everything import flatten_everything\nwithoutprotection=list(\n    flatten_everything(\n        [\n            1,\n            1,\n            2,\n            [3, 4, 5, [6, 3, [2, 5, [\"sfs\", \"sdfsfdsf\",]]]],\n            1,\n            3,\n            34,\n            [\n                55,\n                {\"brand\": \"Ford\", \"model\": \"Mustang\", \"year\": 1964, \"yearxx\": 2020},\n                pd.DataFrame({\"col1\": [1, 2], \"col2\": [3, 4]}),\n                {\"col1\": [1, 2], \"col2\": [3, 4]},\n                55,\n                {\"k32\", 34},\n                np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),\n                (np.arange(22), np.eye(2, 2), 33),\n            ],\n        ]\n    )\n)\nprint(withoutprotection)\noutput:\n[1, 1, 2, 3, 4, 5, 6, 3, 2, 5, 'sfs', 'sdfsfdsf', 1, 3, 34, 55, 'Ford', 'Mustang', 1964, 2020, 1, 2, 3, 4, 1, 2, 3, 4, 55, 34, 'k32', 1, 2, 3, 4, 5, 6, 7, 8, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 1.0, 0.0, 0.0, 1.0, 33]\n</code></pre>\n<p>You can even protect objects from getting flattened:</p>\n<pre><code class=\"python\">from flatten_everything import ProtectedDict,ProtectedList,ProtectedTuple\nwithprotection=list(\n    flatten_everything(\n        [\n            1,\n            1,\n            2,\n            [3, 4, 5, [6, 3, [2, 5, ProtectedList([\"sfs\", \"sdfsfdsf\",])]]],\n            1,\n            3,\n            34,\n            [\n                55,\n                ProtectedDict({\"brand\": \"Ford\", \"model\": \"Mustang\", \"year\": 1964, \"yearxx\": 2020}),\n                pd.DataFrame({\"col1\": [1, 2], \"col2\": [3, 4]}),\n                {\"col1\": [1, 2], \"col2\": [3, 4]},\n                55,\n                {\"k32\", 34},\n                np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]),\n                ProtectedTuple((np.arange(22), np.eye(2, 2), 33)),\n            ],\n        ]\n    )\n)\nprint(withprotection)\noutput:\n[1, 1, 2, 3, 4, 5, 6, 3, 2, 5, ['sfs', 'sdfsfdsf'], 1, 3, 34, 55, {'brand': 'Ford', 'model': 'Mustang', 'year': 1964, 'yearxx': 2020}, 1, 2, 3, 4, 1, 2, 3, 4, 55, 34, 'k32', 1, 2, 3, 4, 5, 6, 7, 8, (array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,17, 18, 19, 20, 21]), array([[1., 0.], [0., 1.]]), 33)]\n</code></pre>\n", "abstract": "I created a little function which can basically flatten anything.\nYou can get it with pip: pip install flatten-everything You can even protect objects from getting flattened:"}, {"id": 64718802, "score": -3, "vote": 0, "content": "<pre><code class=\"python\">np.hstack(listoflist).tolist()\n</code></pre>\n", "abstract": ""}]}, {"link": "https://stackoverflow.com/questions/136097/difference-between-staticmethod-and-classmethod", "question": {"id": "136097", "title": "Difference between @staticmethod and @classmethod", "content": "<p>What is the difference between a function decorated with <a href=\"http://docs.python.org/library/functions.html#staticmethod\" rel=\"noreferrer\"><code>@staticmethod</code></a> and one decorated with <a href=\"http://docs.python.org/library/functions.html#classmethod\" rel=\"noreferrer\"><code>@classmethod</code></a>?</p>\n", "abstract": "What is the difference between a function decorated with @staticmethod and one decorated with @classmethod?"}, "answers": [{"id": 1669524, "score": 3740, "vote": 0, "content": "<p>Maybe a bit of example code will help: Notice the difference in the call signatures of <code>foo</code>, <code>class_foo</code> and <code>static_foo</code>:</p>\n<pre><code class=\"python\">class A(object):\n    def foo(self, x):\n        print(f\"executing foo({self}, {x})\")\n\n    @classmethod\n    def class_foo(cls, x):\n        print(f\"executing class_foo({cls}, {x})\")\n\n    @staticmethod\n    def static_foo(x):\n        print(f\"executing static_foo({x})\")\n\na = A()\n</code></pre>\n<p>Below is the usual way an object instance calls a method. The object instance, <code>a</code>, is implicitly passed as the first argument.</p>\n<pre><code class=\"python\">a.foo(1)\n# executing foo(&lt;__main__.A object at 0xb7dbef0c&gt;, 1)\n</code></pre>\n<hr/>\n<p><strong>With classmethods</strong>, the class of the object instance is implicitly passed as the first argument instead of <code>self</code>.</p>\n<pre><code class=\"python\">a.class_foo(1)\n# executing class_foo(&lt;class '__main__.A'&gt;, 1)\n</code></pre>\n<p>You can also call <code>class_foo</code> using the class. In fact, if you define something to be\na classmethod, it is probably because you intend to call it from the class rather than from a class instance. <code>A.foo(1)</code> would have raised a TypeError, but <code>A.class_foo(1)</code> works just fine:</p>\n<pre><code class=\"python\">A.class_foo(1)\n# executing class_foo(&lt;class '__main__.A'&gt;, 1)\n</code></pre>\n<p>One use people have found for class methods is to create <a href=\"https://stackoverflow.com/a/1950927/190597\">inheritable alternative constructors</a>.</p>\n<hr/>\n<p><strong>With staticmethods</strong>, neither <code>self</code> (the object instance) nor  <code>cls</code> (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class:</p>\n<pre><code class=\"python\">a.static_foo(1)\n# executing static_foo(1)\n\nA.static_foo('hi')\n# executing static_foo(hi)\n</code></pre>\n<p>Staticmethods are used to group functions which have some logical connection with a class to the class.</p>\n<hr/>\n<p><code>foo</code> is just a function, but when you call <code>a.foo</code> you don't just get the function,\nyou get a \"partially applied\" version of the function with the object instance <code>a</code> bound as the first argument to the function. <code>foo</code> expects 2 arguments, while <code>a.foo</code> only expects 1 argument.</p>\n<p><code>a</code> is bound to <code>foo</code>. That is what is meant by the term \"bound\" below:</p>\n<pre><code class=\"python\">print(a.foo)\n# &lt;bound method A.foo of &lt;__main__.A object at 0xb7d52f0c&gt;&gt;\n</code></pre>\n<p>With <code>a.class_foo</code>, <code>a</code> is not bound to <code>class_foo</code>, rather the class <code>A</code> is bound to <code>class_foo</code>.</p>\n<pre><code class=\"python\">print(a.class_foo)\n# &lt;bound method type.class_foo of &lt;class '__main__.A'&gt;&gt;\n</code></pre>\n<p>Here, with a staticmethod, even though it is a method, <code>a.static_foo</code> just returns\na good 'ole function with no arguments bound. <code>static_foo</code> expects 1 argument, and\n<code>a.static_foo</code> expects 1 argument too.</p>\n<pre><code class=\"python\">print(a.static_foo)\n# &lt;function static_foo at 0xb7d479cc&gt;\n</code></pre>\n<p>And of course the same thing happens when you call <code>static_foo</code> with the class <code>A</code> instead.</p>\n<pre><code class=\"python\">print(A.static_foo)\n# &lt;function static_foo at 0xb7d479cc&gt;\n</code></pre>\n", "abstract": "Maybe a bit of example code will help: Notice the difference in the call signatures of foo, class_foo and static_foo: Below is the usual way an object instance calls a method. The object instance, a, is implicitly passed as the first argument. With classmethods, the class of the object instance is implicitly passed as the first argument instead of self. You can also call class_foo using the class. In fact, if you define something to be\na classmethod, it is probably because you intend to call it from the class rather than from a class instance. A.foo(1) would have raised a TypeError, but A.class_foo(1) works just fine: One use people have found for class methods is to create inheritable alternative constructors. With staticmethods, neither self (the object instance) nor  cls (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class: Staticmethods are used to group functions which have some logical connection with a class to the class. foo is just a function, but when you call a.foo you don't just get the function,\nyou get a \"partially applied\" version of the function with the object instance a bound as the first argument to the function. foo expects 2 arguments, while a.foo only expects 1 argument. a is bound to foo. That is what is meant by the term \"bound\" below: With a.class_foo, a is not bound to class_foo, rather the class A is bound to class_foo. Here, with a staticmethod, even though it is a method, a.static_foo just returns\na good 'ole function with no arguments bound. static_foo expects 1 argument, and\na.static_foo expects 1 argument too. And of course the same thing happens when you call static_foo with the class A instead."}, {"id": 136138, "score": 926, "vote": 0, "content": "<p>A <strong>staticmethod</strong> is a method that knows nothing about the class or instance it was called on. It just gets the arguments that were passed, no implicit first argument. It is basically useless in Python -- you can just use a module function instead of a staticmethod.</p>\n<p>A <strong>classmethod</strong>, on the other hand, is a method that gets passed the class it was called on, or the class of the instance it was called on, as first argument. This is useful when you want the method to be a factory for the class: since it gets the actual class it was called on as first argument, you can always instantiate the right class, even when subclasses are involved. Observe for instance how <code>dict.fromkeys()</code>, a classmethod, returns an instance of the subclass when called on a subclass:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class DictSubclass(dict):\n...     def __repr__(self):\n...         return \"DictSubclass\"\n... \n&gt;&gt;&gt; dict.fromkeys(\"abc\")\n{'a': None, 'c': None, 'b': None}\n&gt;&gt;&gt; DictSubclass.fromkeys(\"abc\")\nDictSubclass\n&gt;&gt;&gt; \n</code></pre>\n", "abstract": "A staticmethod is a method that knows nothing about the class or instance it was called on. It just gets the arguments that were passed, no implicit first argument. It is basically useless in Python -- you can just use a module function instead of a staticmethod. A classmethod, on the other hand, is a method that gets passed the class it was called on, or the class of the instance it was called on, as first argument. This is useful when you want the method to be a factory for the class: since it gets the actual class it was called on as first argument, you can always instantiate the right class, even when subclasses are involved. Observe for instance how dict.fromkeys(), a classmethod, returns an instance of the subclass when called on a subclass:"}, {"id": 136149, "score": 190, "vote": 0, "content": "<p>Basically <code>@classmethod</code> makes a method whose first argument is the class it's called from (rather than the class instance), <code>@staticmethod</code> does not have any implicit arguments.</p>\n", "abstract": "Basically @classmethod makes a method whose first argument is the class it's called from (rather than the class instance), @staticmethod does not have any implicit arguments."}, {"id": 1669579, "score": 128, "vote": 0, "content": "<p><strong>Official python docs:</strong></p>\n<p><a href=\"http://docs.python.org/library/functions.html#classmethod\" rel=\"noreferrer\">@classmethod</a></p>\n<blockquote>\n<p>A class method receives the class as\n  implicit first argument, just like an\n  instance method receives the instance.\n  To declare a class method, use this\n  idiom:</p>\n<pre><code class=\"python\">class C:\n    @classmethod\n    def f(cls, arg1, arg2, ...): ... \n</code></pre>\n<p>The <code>@classmethod</code> form is a function\n  <a href=\"http://docs.python.org/2/glossary.html#term-decorator\" rel=\"noreferrer\"><em>decorator</em></a> \u2013 see the description of\n  function definitions in <a href=\"http://docs.python.org/2/reference/compound_stmts.html#function\" rel=\"noreferrer\"><em>Function\n  definitions</em></a> for details.</p>\n<p>It can be called either on the class\n  (such as <code>C.f()</code>) or on an instance\n  (such as <code>C().f()</code>). The instance is\n  ignored except for its class. If a\n  class method is called for a derived\n  class, the derived class object is\n  passed as the implied first argument.</p>\n<p>Class methods are different than C++\n  or Java static methods. If you want\n  those, see <a href=\"http://docs.python.org/2/library/functions.html#staticmethod\" rel=\"noreferrer\"><code>staticmethod()</code></a> in this\n  section.</p>\n</blockquote>\n<p><a href=\"http://docs.python.org/library/functions.html#staticmethod\" rel=\"noreferrer\">@staticmethod</a></p>\n<blockquote>\n<p>A static method does not receive an\n  implicit first argument. To declare a\n  static method, use this idiom:</p>\n<pre><code class=\"python\">class C:\n    @staticmethod\n    def f(arg1, arg2, ...): ... \n</code></pre>\n<p>The <code>@staticmethod</code> form is a function\n  <a href=\"http://docs.python.org/2/glossary.html#term-decorator\" rel=\"noreferrer\"><em>decorator</em></a> \u2013 see the description of\n  function definitions in <a href=\"http://docs.python.org/2/reference/compound_stmts.html#function\" rel=\"noreferrer\"><em>Function\n  definitions</em></a> for details.</p>\n<p>It can be called either on the class\n  (such as <code>C.f()</code>) or on an instance\n  (such as <code>C().f()</code>). The instance is\n  ignored except for its class.</p>\n<p>Static methods in Python are similar\n  to those found in Java or C++. For a\n  more advanced concept, see\n  <a href=\"http://docs.python.org/2/library/functions.html#classmethod\" rel=\"noreferrer\"><code>classmethod()</code></a> in this section.</p>\n</blockquote>\n", "abstract": "Official python docs: @classmethod A class method receives the class as\n  implicit first argument, just like an\n  instance method receives the instance.\n  To declare a class method, use this\n  idiom: The @classmethod form is a function\n  decorator \u2013 see the description of\n  function definitions in Function\n  definitions for details. It can be called either on the class\n  (such as C.f()) or on an instance\n  (such as C().f()). The instance is\n  ignored except for its class. If a\n  class method is called for a derived\n  class, the derived class object is\n  passed as the implied first argument. Class methods are different than C++\n  or Java static methods. If you want\n  those, see staticmethod() in this\n  section. @staticmethod A static method does not receive an\n  implicit first argument. To declare a\n  static method, use this idiom: The @staticmethod form is a function\n  decorator \u2013 see the description of\n  function definitions in Function\n  definitions for details. It can be called either on the class\n  (such as C.f()) or on an instance\n  (such as C().f()). The instance is\n  ignored except for its class. Static methods in Python are similar\n  to those found in Java or C++. For a\n  more advanced concept, see\n  classmethod() in this section."}, {"id": 36798076, "score": 127, "vote": 0, "content": "<p>To decide whether to use <a href=\"https://docs.python.org/3/library/functions.html?highlight=staticmethod#staticmethod\" rel=\"noreferrer\">@staticmethod</a> or <a href=\"https://docs.python.org/3.5/library/functions.html?highlight=classmethod#classmethod\" rel=\"noreferrer\">@classmethod</a> you have to look inside your method. <strong>If your method accesses other variables/methods in your class then use @classmethod</strong>. On the other hand, if your method does not touches any other parts of the class then use @staticmethod.</p>\n<pre><code class=\"python\">class Apple:\n\n    _counter = 0\n\n    @staticmethod\n    def about_apple():\n        print('Apple is good for you.')\n\n        # note you can still access other member of the class\n        # but you have to use the class instance \n        # which is not very nice, because you have repeat yourself\n        # \n        # For example:\n        # @staticmethod\n        #    print('Number of apples have been juiced: %s' % Apple._counter)\n        #\n        # @classmethod\n        #    print('Number of apples have been juiced: %s' % cls._counter)\n        #\n        #    @classmethod is especially useful when you move your function to another class,\n        #       you don't have to rename the referenced class \n\n    @classmethod\n    def make_apple_juice(cls, number_of_apples):\n        print('Making juice:')\n        for i in range(number_of_apples):\n            cls._juice_this(i)\n\n    @classmethod\n    def _juice_this(cls, apple):\n        print('Juicing apple %d...' % apple)\n        cls._counter += 1\n</code></pre>\n", "abstract": "To decide whether to use @staticmethod or @classmethod you have to look inside your method. If your method accesses other variables/methods in your class then use @classmethod. On the other hand, if your method does not touches any other parts of the class then use @staticmethod."}, {"id": 1669457, "score": 99, "vote": 0, "content": "<p><a href=\"http://rapd.wordpress.com/2008/07/02/python-staticmethod-vs-classmethod/\" rel=\"noreferrer\">Here</a> is a short article on this question</p>\n<blockquote>\n<p>@staticmethod function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It\u2019s definition is immutable via inheritance.</p>\n<p>@classmethod function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance. That\u2019s because the first argument for @classmethod function must always be cls (class).</p>\n</blockquote>\n", "abstract": "Here is a short article on this question @staticmethod function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It\u2019s definition is immutable via inheritance. @classmethod function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance. That\u2019s because the first argument for @classmethod function must always be cls (class)."}, {"id": 28117800, "score": 71, "vote": 0, "content": "<blockquote>\n<h2>What is the difference between @staticmethod and @classmethod in Python?</h2>\n</blockquote>\n<p>You may have seen Python code like this pseudocode, which demonstrates the signatures of the various method types and provides a docstring to explain each:</p>\n<pre><code class=\"python\">class Foo(object):\n\n    def a_normal_instance_method(self, arg_1, kwarg_2=None):\n        '''\n        Return a value that is a function of the instance with its\n        attributes, and other arguments such as arg_1 and kwarg2\n        '''\n\n    @staticmethod\n    def a_static_method(arg_0):\n        '''\n        Return a value that is a function of arg_0. It does not know the \n        instance or class it is called from.\n        '''\n\n    @classmethod\n    def a_class_method(cls, arg1):\n        '''\n        Return a value that is a function of the class and other arguments.\n        respects subclassing, it is called with the class it is called from.\n        '''\n</code></pre>\n<h1>The Normal Instance Method</h1>\n<p>First I'll explain <code>a_normal_instance_method</code>. This is precisely called an \"<strong>instance method</strong>\". When an instance method is used, it is used as a partial function (as opposed to a total function, defined for all values when viewed in source code) that is, when used, the first of the arguments is predefined as the instance of the object, with all of its given attributes. It has the instance of the object bound to it, and it must be called from an instance of the object. Typically, it will access various attributes of the instance.</p>\n<p>For example, this is an instance of a string:</p>\n<pre><code class=\"python\">', '\n</code></pre>\n<p>if we use the instance method, <code>join</code> on this string, to join another iterable,\nit quite obviously is a function of the instance, in addition to being a function of the iterable list, <code>['a', 'b', 'c']</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; ', '.join(['a', 'b', 'c'])\n'a, b, c'\n</code></pre>\n<h3>Bound methods</h3>\n<p>Instance methods can be bound via a dotted lookup for use later.</p>\n<p>For example, this binds the <code>str.join</code> method to the <code>':'</code> instance:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; join_with_colons = ':'.join \n</code></pre>\n<p>And later we can use this as a function that already has the first argument bound to it. In this way, it works like a partial function on the instance:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; join_with_colons('abcde')\n'a:b:c:d:e'\n&gt;&gt;&gt; join_with_colons(['FF', 'FF', 'FF', 'FF', 'FF', 'FF'])\n'FF:FF:FF:FF:FF:FF'\n</code></pre>\n<h1>Static Method</h1>\n<p>The static method does <em>not</em> take the instance as an argument.</p>\n<p>It is very similar to a module level function.</p>\n<p>However, a module level function must live in the module and be specially imported to other places where it is used.</p>\n<p>If it is attached to the object, however, it will follow the object conveniently through importing and inheritance as well.</p>\n<p>An example of a static method is <code>str.maketrans</code>, moved from the <code>string</code> module in Python 3.  It makes a translation table suitable for consumption by <code>str.translate</code>. It does seem rather silly when used from an instance of a string, as demonstrated below, but importing the function from the <code>string</code> module is rather clumsy, and it's nice to be able to call it from the class, as in <code>str.maketrans</code></p>\n<pre><code class=\"python\"># demonstrate same function whether called from instance or not:\n&gt;&gt;&gt; ', '.maketrans('ABC', 'abc')\n{65: 97, 66: 98, 67: 99}\n&gt;&gt;&gt; str.maketrans('ABC', 'abc')\n{65: 97, 66: 98, 67: 99}\n</code></pre>\n<p>In python 2, you have to import this function from the increasingly less useful string module:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import string\n&gt;&gt;&gt; 'ABCDEFG'.translate(string.maketrans('ABC', 'abc'))\n'abcDEFG'\n</code></pre>\n<h1>Class Method</h1>\n<p>A class method is a similar to an instance method in that it takes an implicit first argument, but instead of taking the instance, it takes the class. Frequently these are used as alternative constructors for better semantic usage and it will support inheritance.</p>\n<p>The most canonical example of a builtin classmethod is <code>dict.fromkeys</code>. It is used as an alternative constructor of dict, (well suited for when you know what your keys are and want a default value for them.)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; dict.fromkeys(['a', 'b', 'c'])\n{'c': None, 'b': None, 'a': None}\n</code></pre>\n<p>When we subclass dict, we can use the same constructor, which creates an instance of the subclass.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class MyDict(dict): 'A dict subclass, use to demo classmethods'\n&gt;&gt;&gt; md = MyDict.fromkeys(['a', 'b', 'c'])\n&gt;&gt;&gt; md\n{'a': None, 'c': None, 'b': None}\n&gt;&gt;&gt; type(md)\n&lt;class '__main__.MyDict'&gt;\n</code></pre>\n<p>See the <a href=\"https://github.com/pydata/pandas/blob/master/pandas/core/frame.py\" rel=\"noreferrer\">pandas source code</a> for other similar examples of alternative constructors, and see also the official Python documentation on <a href=\"https://docs.python.org/library/functions.html#classmethod\" rel=\"noreferrer\"><code>classmethod</code></a> and <a href=\"https://docs.python.org/library/functions.html#staticmethod\" rel=\"noreferrer\"><code>staticmethod</code></a>.</p>\n", "abstract": "You may have seen Python code like this pseudocode, which demonstrates the signatures of the various method types and provides a docstring to explain each: First I'll explain a_normal_instance_method. This is precisely called an \"instance method\". When an instance method is used, it is used as a partial function (as opposed to a total function, defined for all values when viewed in source code) that is, when used, the first of the arguments is predefined as the instance of the object, with all of its given attributes. It has the instance of the object bound to it, and it must be called from an instance of the object. Typically, it will access various attributes of the instance. For example, this is an instance of a string: if we use the instance method, join on this string, to join another iterable,\nit quite obviously is a function of the instance, in addition to being a function of the iterable list, ['a', 'b', 'c']: Instance methods can be bound via a dotted lookup for use later. For example, this binds the str.join method to the ':' instance: And later we can use this as a function that already has the first argument bound to it. In this way, it works like a partial function on the instance: The static method does not take the instance as an argument. It is very similar to a module level function. However, a module level function must live in the module and be specially imported to other places where it is used. If it is attached to the object, however, it will follow the object conveniently through importing and inheritance as well. An example of a static method is str.maketrans, moved from the string module in Python 3.  It makes a translation table suitable for consumption by str.translate. It does seem rather silly when used from an instance of a string, as demonstrated below, but importing the function from the string module is rather clumsy, and it's nice to be able to call it from the class, as in str.maketrans In python 2, you have to import this function from the increasingly less useful string module: A class method is a similar to an instance method in that it takes an implicit first argument, but instead of taking the instance, it takes the class. Frequently these are used as alternative constructors for better semantic usage and it will support inheritance. The most canonical example of a builtin classmethod is dict.fromkeys. It is used as an alternative constructor of dict, (well suited for when you know what your keys are and want a default value for them.) When we subclass dict, we can use the same constructor, which creates an instance of the subclass. See the pandas source code for other similar examples of alternative constructors, and see also the official Python documentation on classmethod and staticmethod."}, {"id": 46664125, "score": 60, "vote": 0, "content": "<p>I started learning programming language with C++ and then Java and then Python and so this question bothered me a lot as well, until I understood the simple usage of each. </p>\n<p><strong>Class Method:</strong> Python unlike Java and C++ doesn't have constructor overloading.  And so to achieve this you could use <code>classmethod</code>. Following example will explain this </p>\n<p>Let's consider we have a <code>Person</code> class which takes two arguments <code>first_name</code> and <code>last_name</code> and creates the instance of <code>Person</code>. </p>\n<pre><code class=\"python\">class Person(object):\n\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n</code></pre>\n<p>Now, if the requirement comes where you need to create a class using a single name only, just a <code>first_name</code>, you <strong>can't</strong> do something like this in Python. </p>\n<p>This will give you an error when you will try to create an object (instance).</p>\n<pre><code class=\"python\">class Person(object):\n\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n\n    def __init__(self, first_name):\n        self.first_name = first_name\n</code></pre>\n<p>However, you could achieve the same thing using <code>@classmethod</code> as mentioned below </p>\n<pre><code class=\"python\">class Person(object):\n\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n\n    @classmethod\n    def get_person(cls, first_name):\n        return cls(first_name, \"\")\n</code></pre>\n<p><strong>Static Method:</strong> This is rather simple, it's not bound to instance or class and you can simply call that using class name. </p>\n<p>So let's say in above example you need a validation that <code>first_name</code> should not exceed 20 characters, you can simply do this. </p>\n<pre><code class=\"python\">@staticmethod  \ndef validate_name(name):\n    return len(name) &lt;= 20\n</code></pre>\n<p>and you could simply call using <code>class name</code></p>\n<pre><code class=\"python\">Person.validate_name(\"Gaurang Shah\")\n</code></pre>\n", "abstract": "I started learning programming language with C++ and then Java and then Python and so this question bothered me a lot as well, until I understood the simple usage of each.  Class Method: Python unlike Java and C++ doesn't have constructor overloading.  And so to achieve this you could use classmethod. Following example will explain this  Let's consider we have a Person class which takes two arguments first_name and last_name and creates the instance of Person.  Now, if the requirement comes where you need to create a class using a single name only, just a first_name, you can't do something like this in Python.  This will give you an error when you will try to create an object (instance). However, you could achieve the same thing using @classmethod as mentioned below  Static Method: This is rather simple, it's not bound to instance or class and you can simply call that using class name.  So let's say in above example you need a validation that first_name should not exceed 20 characters, you can simply do this.  and you could simply call using class name"}, {"id": 56236639, "score": 52, "vote": 0, "content": "<p><strong>Only the first argument differs</strong>:</p>\n<ul>\n<li>normal method: <strong>the current object</strong> is automatically passed as an (additional) first argument</li>\n<li>classmethod: <strong>the class of the current object</strong> is automatically passed as an (additional) fist argument</li>\n<li>staticmethod: <strong>no extra arguments</strong> are automatically passed. What you passed to the function is what you get.</li>\n</ul>\n<p>In more detail...</p>\n<h2>normal method</h2>\n<p>The \"standard\" method, as in every object oriented language. When an object's method is called, it is automatically given an extra argument <code>self</code> as its first argument. That is, method</p>\n<pre><code class=\"python\">def f(self, x, y)\n</code></pre>\n<p>must be called with 2 arguments. <code>self</code> is automatically passed, and it is <em>the object itself</em>. Similar to the <code>this</code> that magically appears in eg. java/c++, only in python it is shown explicitly.</p>\n<blockquote>\n<p>actually, the first argument does not <em>have to</em> be called <code>self</code>, but it's the standard convention, so keep it</p>\n</blockquote>\n<h2>class method</h2>\n<p>When the method is decorated</p>\n<pre><code class=\"python\">@classmethod\ndef f(cls, x, y)\n</code></pre>\n<p>the automatically provided argument <em>is not</em> <code>self</code>, but <em>the class of</em> <code>self</code>.</p>\n<h2>static method</h2>\n<p>When the method is decorated</p>\n<pre><code class=\"python\">@staticmethod\ndef f(x, y)\n</code></pre>\n<p>the method <em>is not given</em> any automatic argument at all. It is only given the parameters that it is called with.</p>\n<h1>usages</h1>\n<ul>\n<li><code>classmethod</code> is mostly used for alternative constructors.</li>\n<li><code>staticmethod</code> does not use the state of the object, or even the structure of the class itself. It could be a function external to a class. It only put inside the class for grouping functions with similar functionality (for example, like Java's <code>Math</code> class static methods)</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class Point\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    @classmethod\n    def frompolar(cls, radius, angle):\n        \"\"\"The `cls` argument is the `Point` class itself\"\"\"\n        return cls(radius * cos(angle), radius * sin(angle))\n\n    @staticmethod\n    def angle(x, y):\n        \"\"\"this could be outside the class, but we put it here \njust because we think it is logically related to the class.\"\"\"\n        return atan(y, x)\n\n\np1 = Point(3, 2)\np2 = Point.frompolar(3, pi/4)\n\nangle = Point.angle(3, 2)\n\n</code></pre>\n", "abstract": "Only the first argument differs: In more detail... The \"standard\" method, as in every object oriented language. When an object's method is called, it is automatically given an extra argument self as its first argument. That is, method must be called with 2 arguments. self is automatically passed, and it is the object itself. Similar to the this that magically appears in eg. java/c++, only in python it is shown explicitly. actually, the first argument does not have to be called self, but it's the standard convention, so keep it When the method is decorated the automatically provided argument is not self, but the class of self. When the method is decorated the method is not given any automatic argument at all. It is only given the parameters that it is called with."}, {"id": 30329887, "score": 46, "vote": 0, "content": "<p>I think a better question is \"When would you use <code>@classmethod</code> vs <code>@staticmethod</code>?\"</p>\n<p><code>@classmethod</code> allows you easy access to private members that are associated to the class definition. this is a great way to do singletons, or factory classes that control the number of instances of the created objects exist.</p>\n<p><code>@staticmethod</code> provides marginal performance gains, but I have yet to see a productive use of a static method within a class that couldn't be achieved as a standalone function outside the class.</p>\n", "abstract": "I think a better question is \"When would you use @classmethod vs @staticmethod?\" @classmethod allows you easy access to private members that are associated to the class definition. this is a great way to do singletons, or factory classes that control the number of instances of the created objects exist. @staticmethod provides marginal performance gains, but I have yet to see a productive use of a static method within a class that couldn't be achieved as a standalone function outside the class."}, {"id": 39829692, "score": 40, "vote": 0, "content": "<p><strong>Static Methods:</strong></p>\n<ul>\n<li>Simple functions with no self argument. </li>\n<li>Work on class attributes; not on instance attributes.</li>\n<li>Can be called through both class and instance.</li>\n<li>The built-in function staticmethod()is used to create them.</li>\n</ul>\n<p><strong>Benefits of Static Methods:</strong></p>\n<ul>\n<li>It localizes the function name in the classscope</li>\n<li>It moves the function code closer to where it is used</li>\n<li><p>More convenient to import versus module-level functions since each method does not have to be specially imported</p>\n<pre><code class=\"python\">@staticmethod\ndef some_static_method(*args, **kwds):\n    pass\n</code></pre></li>\n</ul>\n<p><strong>Class Methods:</strong></p>\n<ul>\n<li>Functions that have first argument as classname.</li>\n<li>Can be called through both class and instance.</li>\n<li><p>These are created with classmethod in-built function.</p>\n<pre><code class=\"python\"> @classmethod\n def some_class_method(cls, *args, **kwds):\n     pass\n</code></pre></li>\n</ul>\n", "abstract": "Static Methods: Benefits of Static Methods: More convenient to import versus module-level functions since each method does not have to be specially imported Class Methods: These are created with classmethod in-built function."}, {"id": 9428384, "score": 38, "vote": 0, "content": "<p>@decorators were added in python 2.4 If you're using python &lt; 2.4 you can use the classmethod() and staticmethod() function.</p>\n<p>For example, if you want to create a factory method (A function returning an instance of a different implementation of a class depending on what argument it gets) you can do something like:</p>\n<pre><code class=\"python\">class Cluster(object):\n\n    def _is_cluster_for(cls, name):\n        \"\"\"\n        see if this class is the cluster with this name\n        this is a classmethod\n        \"\"\" \n        return cls.__name__ == name\n    _is_cluster_for = classmethod(_is_cluster_for)\n\n    #static method\n    def getCluster(name):\n        \"\"\"\n        static factory method, should be in Cluster class\n        returns a cluster object for the given name\n        \"\"\"\n        for cls in Cluster.__subclasses__():\n            if cls._is_cluster_for(name):\n                return cls()\n    getCluster = staticmethod(getCluster)\n</code></pre>\n<p>Also observe that this is a good example for using a classmethod and a static method,\nThe static method clearly belongs to the class, since it uses the class Cluster internally.\nThe classmethod only needs information about the class, and no instance of the object.</p>\n<p>Another benefit of making the <code>_is_cluster_for</code> method a classmethod is so a subclass can decide to change it's implementation, maybe because it is pretty generic and can handle more than one type of cluster, so just checking the name of the class would not be enough.</p>\n", "abstract": "@decorators were added in python 2.4 If you're using python < 2.4 you can use the classmethod() and staticmethod() function. For example, if you want to create a factory method (A function returning an instance of a different implementation of a class depending on what argument it gets) you can do something like: Also observe that this is a good example for using a classmethod and a static method,\nThe static method clearly belongs to the class, since it uses the class Cluster internally.\nThe classmethod only needs information about the class, and no instance of the object. Another benefit of making the _is_cluster_for method a classmethod is so a subclass can decide to change it's implementation, maybe because it is pretty generic and can handle more than one type of cluster, so just checking the name of the class would not be enough."}, {"id": 48250384, "score": 34, "vote": 0, "content": "<p>Let me tell the similarity between a method decorated with @classmethod vs @staticmethod first.</p>\n<p><strong>Similarity:</strong> Both of them can be called on the <em>Class</em> itself, rather than just the <em>instance</em> of the class. So, both of them in a sense are <em>Class's methods</em>. </p>\n<p><strong>Difference:</strong> A classmethod will receive the class itself as the first argument, while a staticmethod does not.</p>\n<p>So a static method is, in a sense, not bound to the Class itself and is just hanging in there just because it may have a related functionality. </p>\n<pre><code class=\"python\">&gt;&gt;&gt; class Klaus:\n        @classmethod\n        def classmthd(*args):\n            return args\n\n        @staticmethod\n        def staticmthd(*args):\n            return args\n\n# 1. Call classmethod without any arg\n&gt;&gt;&gt; Klaus.classmthd()  \n(__main__.Klaus,)  # the class gets passed as the first argument\n\n# 2. Call classmethod with 1 arg\n&gt;&gt;&gt; Klaus.classmthd('chumma')\n(__main__.Klaus, 'chumma')\n\n# 3. Call staticmethod without any arg\n&gt;&gt;&gt; Klaus.staticmthd()  \n()\n\n# 4. Call staticmethod with 1 arg\n&gt;&gt;&gt; Klaus.staticmthd('chumma')\n('chumma',)\n</code></pre>\n", "abstract": "Let me tell the similarity between a method decorated with @classmethod vs @staticmethod first. Similarity: Both of them can be called on the Class itself, rather than just the instance of the class. So, both of them in a sense are Class's methods.  Difference: A classmethod will receive the class itself as the first argument, while a staticmethod does not. So a static method is, in a sense, not bound to the Class itself and is just hanging in there just because it may have a related functionality. "}, {"id": 136246, "score": 31, "vote": 0, "content": "<p><code>@staticmethod</code> just disables the default function as method descriptor.  classmethod wraps your function in a container callable that passes a reference to the owning class as first argument:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class C(object):\n...  pass\n... \n&gt;&gt;&gt; def f():\n...  pass\n... \n&gt;&gt;&gt; staticmethod(f).__get__(None, C)\n&lt;function f at 0x5c1cf0&gt;\n&gt;&gt;&gt; classmethod(f).__get__(None, C)\n&lt;bound method type.f of &lt;class '__main__.C'&gt;&gt;\n</code></pre>\n<p>As a matter of fact, <code>classmethod</code> has a runtime overhead but makes it possible to access the owning class.  Alternatively I recommend using a metaclass and putting the class methods on that metaclass:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class CMeta(type):\n...  def foo(cls):\n...   print cls\n... \n&gt;&gt;&gt; class C(object):\n...  __metaclass__ = CMeta\n... \n&gt;&gt;&gt; C.foo()\n&lt;class '__main__.C'&gt;\n</code></pre>\n", "abstract": "@staticmethod just disables the default function as method descriptor.  classmethod wraps your function in a container callable that passes a reference to the owning class as first argument: As a matter of fact, classmethod has a runtime overhead but makes it possible to access the owning class.  Alternatively I recommend using a metaclass and putting the class methods on that metaclass:"}, {"id": 33727452, "score": 27, "vote": 0, "content": "<p><a href=\"https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods\" rel=\"noreferrer\">The definitive guide on how to use static, class or abstract methods in Python</a> is one good link for this topic, and summary it as following.</p>\n<p><strong><code>@staticmethod</code></strong> function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It\u2019s definition is immutable via inheritance.</p>\n<ul>\n<li>Python does not have to instantiate a bound-method for object.</li>\n<li>It eases the readability of the code, and it does not depend on the state of object itself;</li>\n</ul>\n<p><strong><code>@classmethod</code></strong> function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance, can be overridden by subclass. That\u2019s because the first argument for <code>@classmethod</code> function must always be <em>cls</em> (class).</p>\n<ul>\n<li><em>Factory methods</em>, that are used to create an instance for a class using for example some sort of pre-processing.</li>\n<li><em>Static methods calling static methods</em>: if you split a static methods in several static methods, you shouldn't hard-code the class name but use class methods</li>\n</ul>\n", "abstract": "The definitive guide on how to use static, class or abstract methods in Python is one good link for this topic, and summary it as following. @staticmethod function is nothing more than a function defined inside a class. It is callable without instantiating the class first. It\u2019s definition is immutable via inheritance. @classmethod function also callable without instantiating the class, but its definition follows Sub class, not Parent class, via inheritance, can be overridden by subclass. That\u2019s because the first argument for @classmethod function must always be cls (class)."}, {"id": 39776104, "score": 26, "vote": 0, "content": "<p>Another consideration with respect to staticmethod vs classmethod comes up with inheritance.  Say you have the following class:</p>\n<pre><code class=\"python\">class Foo(object):\n    @staticmethod\n    def bar():\n        return \"In Foo\"\n</code></pre>\n<p>And you then want to override <code>bar()</code> in a child class:</p>\n<pre><code class=\"python\">class Foo2(Foo):\n    @staticmethod\n    def bar():\n        return \"In Foo2\"\n</code></pre>\n<p>This works, but note that now the <code>bar()</code> implementation in the child class (<code>Foo2</code>) can no longer take advantage of anything specific to that class.  For example, say <code>Foo2</code> had a method called <code>magic()</code> that you want to use in the <code>Foo2</code> implementation of <code>bar()</code>:</p>\n<pre><code class=\"python\">class Foo2(Foo):\n    @staticmethod\n    def bar():\n        return \"In Foo2\"\n    @staticmethod\n    def magic():\n        return \"Something useful you'd like to use in bar, but now can't\" \n</code></pre>\n<p>The workaround here would be to call <code>Foo2.magic()</code> in <code>bar()</code>, but then you're repeating yourself (if the name of <code>Foo2</code> changes, you'll have to remember to update that <code>bar()</code> method).</p>\n<p>To me, this is a slight violation of the <a href=\"https://en.wikipedia.org/wiki/Open/closed_principle\" rel=\"noreferrer\">open/closed principle</a>, since a decision made in <code>Foo</code> is impacting your ability to refactor common code in a derived class (ie it's less open to extension).  If <code>bar()</code> were a <code>classmethod</code> we'd be fine:</p>\n<pre><code class=\"python\">class Foo(object):\n    @classmethod\n    def bar(cls):\n        return \"In Foo\"\n\nclass Foo2(Foo):\n    @classmethod\n    def bar(cls):\n        return \"In Foo2 \" + cls.magic()\n    @classmethod\n    def magic(cls):\n        return \"MAGIC\"\n\nprint Foo2().bar()\n</code></pre>\n<p>Gives: <code>In Foo2 MAGIC</code></p>\n<p>Also: historical note: Guido Van Rossum (Python's creator) once referred to <code>staticmethod</code>'s as \"an accident\": <a href=\"https://mail.python.org/pipermail/python-ideas/2012-May/014969.html\" rel=\"noreferrer\">https://mail.python.org/pipermail/python-ideas/2012-May/014969.html</a></p>\n<blockquote>\n<p>we all know how limited static methods are. (They're basically an accident -- back in the Python 2.2 days when I was inventing new-style classes and descriptors, I meant to implement class methods but at first I didn't understand them and accidentally implemented static methods first. Then it was too late to remove them and only provide class methods.</p>\n</blockquote>\n<p>Also: <a href=\"https://mail.python.org/pipermail/python-ideas/2016-July/041189.html\" rel=\"noreferrer\">https://mail.python.org/pipermail/python-ideas/2016-July/041189.html</a></p>\n<blockquote>\n<p>Honestly, staticmethod was something of a mistake -- I was trying to do something like Java class methods but once it was released I found what was really needed was classmethod. But it was too late to get rid of staticmethod.</p>\n</blockquote>\n", "abstract": "Another consideration with respect to staticmethod vs classmethod comes up with inheritance.  Say you have the following class: And you then want to override bar() in a child class: This works, but note that now the bar() implementation in the child class (Foo2) can no longer take advantage of anything specific to that class.  For example, say Foo2 had a method called magic() that you want to use in the Foo2 implementation of bar(): The workaround here would be to call Foo2.magic() in bar(), but then you're repeating yourself (if the name of Foo2 changes, you'll have to remember to update that bar() method). To me, this is a slight violation of the open/closed principle, since a decision made in Foo is impacting your ability to refactor common code in a derived class (ie it's less open to extension).  If bar() were a classmethod we'd be fine: Gives: In Foo2 MAGIC Also: historical note: Guido Van Rossum (Python's creator) once referred to staticmethod's as \"an accident\": https://mail.python.org/pipermail/python-ideas/2012-May/014969.html we all know how limited static methods are. (They're basically an accident -- back in the Python 2.2 days when I was inventing new-style classes and descriptors, I meant to implement class methods but at first I didn't understand them and accidentally implemented static methods first. Then it was too late to remove them and only provide class methods. Also: https://mail.python.org/pipermail/python-ideas/2016-July/041189.html Honestly, staticmethod was something of a mistake -- I was trying to do something like Java class methods but once it was released I found what was really needed was classmethod. But it was too late to get rid of staticmethod."}, {"id": 39589894, "score": 13, "vote": 0, "content": "<p>I will try to explain the basic difference using an example.</p>\n<pre><code class=\"python\">class A(object):\n    x = 0\n\n    def say_hi(self):\n        pass\n\n    @staticmethod\n    def say_hi_static():\n        pass\n\n    @classmethod\n    def say_hi_class(cls):\n        pass\n\n    def run_self(self):\n        self.x += 1\n        print self.x # outputs 1\n        self.say_hi()\n        self.say_hi_static()\n        self.say_hi_class()\n\n    @staticmethod\n    def run_static():\n        print A.x  # outputs 0\n        # A.say_hi() #  wrong\n        A.say_hi_static()\n        A.say_hi_class()\n\n    @classmethod\n    def run_class(cls):\n        print cls.x # outputs 0\n        # cls.say_hi() #  wrong\n        cls.say_hi_static()\n        cls.say_hi_class()\n</code></pre>\n<p>1 - we can directly call static and classmethods without initializing</p>\n<pre><code class=\"python\"># A.run_self() #  wrong\nA.run_static()\nA.run_class()\n</code></pre>\n<p>2- Static method cannot call self method but can call other static and classmethod</p>\n<p>3- Static method belong to class and will not use object at all.</p>\n<p>4- Class method are not bound to an object but to a class.</p>\n", "abstract": "I will try to explain the basic difference using an example. 1 - we can directly call static and classmethods without initializing 2- Static method cannot call self method but can call other static and classmethod 3- Static method belong to class and will not use object at all. 4- Class method are not bound to an object but to a class."}, {"id": 65754079, "score": 12, "vote": 0, "content": "<p>Python comes with several built-in decorators. The big three are:</p>\n<pre><code class=\"python\">@classmethod\n@staticmethod\n@property\n</code></pre>\n<p>First let's note that any function of a class can be called with instance of this class (after we initialized this class).</p>\n<p><strong>@classmethod</strong> is the way to <strong>call function</strong> not only as an instance of a class but also <strong>directly by the class itself</strong> as its first argument.</p>\n<p><strong>@staticmethod</strong> is a way of putting a function into a class (because it logically belongs there), while indicating that it does not require access to the class (so we <strong>don't need to use <code>self</code></strong> in function definition).</p>\n<p>Let's consider the following class:</p>\n<pre><code class=\"python\">class DecoratorTest(object):\n\n    def __init__(self):\n        pass\n\n    def doubler(self, x):\n        return x*2\n\n    @classmethod\n    def class_doubler(cls, x): # we need to use 'cls' instead of 'self'; 'cls' reference to the class instead of an instance of the class\n        return x*2\n\n    @staticmethod\n    def static_doubler(x): # no need adding 'self' here; static_doubler() could be just a function not inside the class\n        return x*2\n</code></pre>\n<p>Let's see how it works:</p>\n<pre><code class=\"python\">decor = DecoratorTest()\n\nprint(decor.doubler(5))\n# 10\n\nprint(decor.class_doubler(5)) # a call with an instance of a class\n# 10\nprint(DecoratorTest.class_doubler(5)) # a direct call by the class itself\n# 10\n\n# staticmethod could be called in the same way as classmethod.\nprint(decor.static_doubler(5)) # as an instance of the class\n# 10\nprint(DecoratorTest.static_doubler(5)) # or as a direct call \n# 10\n</code></pre>\n<p><a href=\"https://www.codearmo.com/python-tutorial/object-orientated-programming-static-class-methods\" rel=\"nofollow noreferrer\">Here</a> you can see some use cases for those methods.</p>\n<p>Bonus: you can read about <code>@property</code> decorator <a href=\"https://www.programiz.com/python-programming/property\" rel=\"nofollow noreferrer\">here</a></p>\n", "abstract": "Python comes with several built-in decorators. The big three are: First let's note that any function of a class can be called with instance of this class (after we initialized this class). @classmethod is the way to call function not only as an instance of a class but also directly by the class itself as its first argument. @staticmethod is a way of putting a function into a class (because it logically belongs there), while indicating that it does not require access to the class (so we don't need to use self in function definition). Let's consider the following class: Let's see how it works: Here you can see some use cases for those methods. Bonus: you can read about @property decorator here"}, {"id": 66672138, "score": 11, "vote": 0, "content": "<p><strong>The difference occurs when there is inheritance.</strong></p>\n<p>Suppose that there are two classes-- Parent and Child. If one wants to use @staticmethod, print_name method should be written twice because the name of the class should be written in the print line.</p>\n<pre><code class=\"python\">class Parent:\n   _class_name = \"Parent\"\n\n   @staticmethod\n   def print_name():\n       print(Parent._class_name)\n\n\nclass Child(Parent):\n   _class_name = \"Child\"\n\n   @staticmethod\n   def print_name():\n       print(Child._class_name)\n\n\nParent.print_name()\nChild.print_name()\n</code></pre>\n<p>However, for @classmethod, it is not required to write print_name method twice.</p>\n<pre><code class=\"python\">class Parent:\n    _class_name = \"Parent\"\n\n    @classmethod\n    def print_name(cls):\n        print(cls._class_name)\n\n\nclass Child(Parent):\n    _class_name = \"Child\"\n\n\nParent.print_name()\nChild.print_name()\n</code></pre>\n", "abstract": "The difference occurs when there is inheritance. Suppose that there are two classes-- Parent and Child. If one wants to use @staticmethod, print_name method should be written twice because the name of the class should be written in the print line. However, for @classmethod, it is not required to write print_name method twice."}, {"id": 64732009, "score": 10, "vote": 0, "content": "<p><strong><em>Instance Method</em></strong>:</p>\n<p><code>+</code> <em>Can</em> modify object instance state</p>\n<p><code>+</code> <em>Can</em> modify class state</p>\n<p><strong><em>Class Method</em></strong>:</p>\n<p><code>-</code> <em>Can't</em> modify object instance state</p>\n<p><code>+</code> <em>Can</em> modify class state</p>\n<p><strong><em>Static Method</em></strong>:</p>\n<p><code>-</code> <em>Can't</em> modify object instance state</p>\n<p><code>-</code> <em>Can't</em> modify class state</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class MyClass:\n    ''' \n    Instance method has a mandatory first attribute self which represent the instance itself. \n    Instance method must be called by a instantiated instance.\n    '''\n    def method(self):\n        return 'instance method called', self\n    \n    '''\n    Class method has a mandatory first attribute cls which represent the class itself. \n    Class method can be called by an instance or by the class directly. \n    Its most common using scenario is to define a factory method.\n    '''\n    @classmethod\n    def class_method(cls):\n        return 'class method called', cls\n    \n    '''\n    Static method doesn\u2019t have any attributes of instances or the class. \n    It also can be called by an instance or by the class directly. \n    Its most common using scenario is to define some helper or utility functions which are closely relative to the class.\n    '''\n    @staticmethod\n    def static_method():\n        return 'static method called'\n\n\nobj = MyClass()\nprint(obj.method())\nprint(obj.class_method()) # MyClass.class_method()\nprint(obj.static_method()) # MyClass.static_method()\n</code></pre>\n<p>output:</p>\n<pre class=\"lang-sh prettyprint-override\"><code class=\"python\">('instance method called', &lt;__main__.MyClass object at 0x100fb3940&gt;)\n('class method called', &lt;class '__main__.MyClass'&gt;)\nstatic method called\n</code></pre>\n<p>The instance method we actually had access to the object instance , right so this was an instance off a my class object whereas with the class method we have access to the class itself. But not to any of the objects,  because the class method doesn't really care about an object existing. However you can both call a class method and static method on an object instance. This is going to work it doesn't really make a difference, so again when you call static method here it's going to work and it's going to know which method you want to call.</p>\n<p>The Static methods are used to do some utility tasks, and class methods are used for factory methods. The factory methods can return class objects for different use cases.</p>\n<p>And finally, a short example for better understanding:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class Student:\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n\n    @classmethod\n    def get_from_string(cls, name_string: str):\n        first_name, last_name = name_string.split()\n        if Student.validate_name(first_name) and Student.validate_name(last_name):\n            return cls(first_name, last_name)\n        else:\n            print('Invalid Names')\n\n    @staticmethod\n    def validate_name(name):\n        return len(name) &lt;= 10\n\n\nstackoverflow_student = Student.get_from_string('Name Surname')\nprint(stackoverflow_student.first_name) # Name\nprint(stackoverflow_student.last_name) # Surname\n</code></pre>\n", "abstract": "Instance Method: + Can modify object instance state + Can modify class state Class Method: - Can't modify object instance state + Can modify class state Static Method: - Can't modify object instance state - Can't modify class state output: The instance method we actually had access to the object instance , right so this was an instance off a my class object whereas with the class method we have access to the class itself. But not to any of the objects,  because the class method doesn't really care about an object existing. However you can both call a class method and static method on an object instance. This is going to work it doesn't really make a difference, so again when you call static method here it's going to work and it's going to know which method you want to call. The Static methods are used to do some utility tasks, and class methods are used for factory methods. The factory methods can return class objects for different use cases. And finally, a short example for better understanding:"}, {"id": 46327819, "score": 8, "vote": 0, "content": "<p>@classmethod : can be used to create a shared global access to all the instances created of that class..... like updating a record by multiple users....\nI particulary found it use ful when creating singletons as well..:)</p>\n<p>@static method:  has nothing to do with the class or instance being associated with ...but for readability can use static method</p>\n", "abstract": "@classmethod : can be used to create a shared global access to all the instances created of that class..... like updating a record by multiple users....\nI particulary found it use ful when creating singletons as well..:) @static method:  has nothing to do with the class or instance being associated with ...but for readability can use static method"}, {"id": 51015649, "score": 8, "vote": 0, "content": "<p>My contribution demonstrates the difference amongst <code>@classmethod</code>, <code>@staticmethod</code>, and instance methods, including how an instance can indirectly call a <code>@staticmethod</code>. But instead of indirectly calling a <code>@staticmethod</code> from an instance, making it private may be more \"pythonic.\" Getting something from a private method isn't demonstrated here but it's basically the same concept.</p>\n<pre><code class=\"python\">#!python3\n\nfrom os import system\nsystem('cls')\n# %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %\n\nclass DemoClass(object):\n    # instance methods need a class instance and\n    # can access the instance through 'self'\n    def instance_method_1(self):\n        return 'called from inside the instance_method_1()'\n\n    def instance_method_2(self):\n        # an instance outside the class indirectly calls the static_method\n        return self.static_method() + ' via instance_method_2()'\n\n    # class methods don't need a class instance, they can't access the\n    # instance (self) but they have access to the class itself via 'cls'\n    @classmethod\n    def class_method(cls):\n        return 'called from inside the class_method()'\n\n    # static methods don't have access to 'cls' or 'self', they work like\n    # regular functions but belong to the class' namespace\n    @staticmethod\n    def static_method():\n        return 'called from inside the static_method()'\n# %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %\n\n# works even if the class hasn't been instantiated\nprint(DemoClass.class_method() + '\\n')\n''' called from inside the class_method() '''\n\n# works even if the class hasn't been instantiated\nprint(DemoClass.static_method() + '\\n')\n''' called from inside the static_method() '''\n# %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %   %\n\n# &gt;&gt;&gt;&gt;&gt; all methods types can be called on a class instance &lt;&lt;&lt;&lt;&lt;\n# instantiate the class\ndemoclassObj = DemoClass()\n\n# call instance_method_1()\nprint(democlassObj.instance_method_1() + '\\n')\n''' called from inside the instance_method_1() '''\n\n# # indirectly call static_method through instance_method_2(), there's really no use\n# for this since a @staticmethod can be called whether the class has been\n# instantiated or not\nprint(democlassObj.instance_method_2() + '\\n')\n''' called from inside the static_method() via instance_method_2() '''\n\n# call class_method()\nprint(democlassObj.class_method() + '\\n')\n'''  called from inside the class_method() '''\n\n# call static_method()\nprint(democlassObj.static_method())\n''' called from inside the static_method() '''\n\n\"\"\"\n# whether the class is instantiated or not, this doesn't work\nprint(DemoClass.instance_method_1() + '\\n')\n'''\nTypeError: TypeError: unbound method instancemethod() must be called with\nDemoClass instance as first argument (got nothing instead)\n'''\n\"\"\"\n</code></pre>\n", "abstract": "My contribution demonstrates the difference amongst @classmethod, @staticmethod, and instance methods, including how an instance can indirectly call a @staticmethod. But instead of indirectly calling a @staticmethod from an instance, making it private may be more \"pythonic.\" Getting something from a private method isn't demonstrated here but it's basically the same concept."}, {"id": 54347204, "score": 8, "vote": 0, "content": "<p>You might want to consider the difference between:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class A:\n    def foo():  # no self parameter, no decorator\n        pass\n</code></pre>\n<p>and</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class B:\n    @staticmethod\n    def foo():  # no self parameter\n        pass\n</code></pre>\n<p>This has changed between python2 and python3:</p>\n<p>python2:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; A.foo()\nTypeError\n&gt;&gt;&gt; A().foo()\nTypeError\n&gt;&gt;&gt; B.foo()\n&gt;&gt;&gt; B().foo()\n</code></pre>\n<p>python3:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; A.foo()\n&gt;&gt;&gt; A().foo()\nTypeError\n&gt;&gt;&gt; B.foo()\n&gt;&gt;&gt; B().foo()\n</code></pre>\n<p>So using  <code>@staticmethod</code> for methods only called directly from the class has become optional in python3. If you want to call them from both class and instance, you still need to use the <code>@staticmethod</code> decorator.</p>\n<p>The other cases have been well covered by unutbus answer.</p>\n", "abstract": "You might want to consider the difference between: and This has changed between python2 and python3: python2: python3: So using  @staticmethod for methods only called directly from the class has become optional in python3. If you want to call them from both class and instance, you still need to use the @staticmethod decorator. The other cases have been well covered by unutbus answer."}, {"id": 58953655, "score": 8, "vote": 0, "content": "<p>A class method receives the class as implicit first argument, just like an instance method receives the instance. It is a method which is bound to the class and not the object of the class.It has access to the state of the class as it takes a class parameter that points to the class and not the object instance. It can modify a class state that would apply across all the instances of the class. For example it can modify a class variable that will be applicable to all the instances. </p>\n<p>On the other hand, a static method does not receive an implicit first argument, compared to class methods or instance methods. And can\u2019t access or modify class state. It only belongs to the class because from design point of view that is the correct way. But in terms of functionality is not bound, at runtime, to the class.</p>\n<p>as a guideline, use static methods as utilities, use class methods for example as factory . Or maybe to define a singleton. And use instance methods to model the state and behavior of instances.</p>\n<p>Hope I was clear ! </p>\n", "abstract": "A class method receives the class as implicit first argument, just like an instance method receives the instance. It is a method which is bound to the class and not the object of the class.It has access to the state of the class as it takes a class parameter that points to the class and not the object instance. It can modify a class state that would apply across all the instances of the class. For example it can modify a class variable that will be applicable to all the instances.  On the other hand, a static method does not receive an implicit first argument, compared to class methods or instance methods. And can\u2019t access or modify class state. It only belongs to the class because from design point of view that is the correct way. But in terms of functionality is not bound, at runtime, to the class. as a guideline, use static methods as utilities, use class methods for example as factory . Or maybe to define a singleton. And use instance methods to model the state and behavior of instances. Hope I was clear ! "}, {"id": 47591541, "score": 5, "vote": 0, "content": "<p>Class methods, as the name suggests, are used to make changes to classes and not the objects. To make changes to classes, they will modify the class attributes(not object attributes), since that is how you update classes.\nThis is the reason that class methods take the class(conventionally denoted by 'cls') as the first argument.</p>\n<pre><code class=\"python\">class A(object):\n    m=54\n\n    @classmethod\n    def class_method(cls):\n        print \"m is %d\" % cls.m\n</code></pre>\n<p>Static methods on the other hand, are used to perform functionalities that are not bound to the class i.e. they will not read or write class variables. Hence, static methods do not take classes as arguments. They are used so that classes can perform functionalities that are not directly related to the purpose of the class.</p>\n<pre><code class=\"python\">class X(object):\n    m=54 #will not be referenced\n\n    @staticmethod\n    def static_method():\n        print \"Referencing/calling a variable or function outside this class. E.g. Some global variable/function.\"\n</code></pre>\n", "abstract": "Class methods, as the name suggests, are used to make changes to classes and not the objects. To make changes to classes, they will modify the class attributes(not object attributes), since that is how you update classes.\nThis is the reason that class methods take the class(conventionally denoted by 'cls') as the first argument. Static methods on the other hand, are used to perform functionalities that are not bound to the class i.e. they will not read or write class variables. Hence, static methods do not take classes as arguments. They are used so that classes can perform functionalities that are not directly related to the purpose of the class."}, {"id": 58951325, "score": 5, "vote": 0, "content": "<p>I think giving a purely Python version of <code>staticmethod</code> and <code>classmethod</code> would help to understand the difference between them at language level (Refers to <a href=\"https://docs.python.org/2/howto/descriptor.html#static-methods-and-class-methods\" rel=\"nofollow noreferrer\">Descriptor Howto Guide</a>).</p>\n<p>Both of them are non-data descriptors (It would be easier to understand them if you are familiar with <a href=\"https://docs.python.org/3/reference/datamodel.html#implementing-descriptors\" rel=\"nofollow noreferrer\">descriptors</a> first).</p>\n<pre><code class=\"python\">class StaticMethod(object):\n    \"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"\n\n    def __init__(self, f):\n        self.f = f\n\n    def __get__(self, obj, objtype=None):\n        return self.f\n\n\nclass ClassMethod(object):\n    \"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\n    def __init__(self, f):\n        self.f = f\n\n    def __get__(self, obj, cls=None):\n        def inner(*args, **kwargs):\n            if cls is None:\n                cls = type(obj)\n            return self.f(cls, *args, **kwargs)\n        return inner\n</code></pre>\n", "abstract": "I think giving a purely Python version of staticmethod and classmethod would help to understand the difference between them at language level (Refers to Descriptor Howto Guide). Both of them are non-data descriptors (It would be easier to understand them if you are familiar with descriptors first)."}, {"id": 47769396, "score": 3, "vote": 0, "content": "<p>Analyze @staticmethod <strong>literally</strong> providing different insights.</p>\n<p>A normal method of a class is an implicit <strong>dynamic</strong> method which takes the instance as first argument.<br/>\nIn contrast, a staticmethod does not take the instance as first argument, so is called <strong>'static'</strong>.</p>\n<p>A staticmethod is indeed such a normal function the same as those outside a class definition.<br/>\nIt is luckily grouped into the class just in order to stand closer where it is applied, or you might scroll around to find it.</p>\n", "abstract": "Analyze @staticmethod literally providing different insights. A normal method of a class is an implicit dynamic method which takes the instance as first argument.\nIn contrast, a staticmethod does not take the instance as first argument, so is called 'static'. A staticmethod is indeed such a normal function the same as those outside a class definition.\nIt is luckily grouped into the class just in order to stand closer where it is applied, or you might scroll around to find it."}, {"id": 63197044, "score": 3, "vote": 0, "content": "<p>One pretty important practical difference occurs when subclassing. If you don't mind, I'll hijack @unutbu's example:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class A: \n    def foo(self, x): \n        print(\"executing foo(%s, %s)\" % (self, x)) \n \n    @classmethod\n    def class_foo(cls, x): \n        print(\"executing class_foo(%s, %s)\" % (cls, x))\n \n    @staticmethod \n    def static_foo(x): \n        print(\"executing static_foo(%s)\" % x)\n\nclass B(A):\n    pass\n</code></pre>\n<p>In <code>class_foo</code>, the method knows which class it is called on:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">A.class_foo(1)\n# =&gt; executing class_foo(&lt;class '__main__.A'&gt;, 1)\nB.class_foo(1)\n# =&gt; executing class_foo(&lt;class '__main__.B'&gt;, 1)\n</code></pre>\n<p>In <code>static_foo</code>, there is no way to determine whether it is called on <code>A</code> or <code>B</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">A.static_foo(1)\n# =&gt; executing static_foo(1)\nB.static_foo(1)\n# =&gt; executing static_foo(1)\n</code></pre>\n<p>Note that this doesn't mean you can't use other methods in a <code>staticmethod</code>, you just have to reference the class directly, which means subclasses' staticmethods will still reference the parent class:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class A:\n    @classmethod\n    def class_qux(cls, x):\n        print(f\"executing class_qux({cls}, {x})\")\n    \n    @classmethod\n    def class_bar(cls, x):\n        cls.class_qux(x)\n\n    @staticmethod\n    def static_bar(x):\n        A.class_qux(x)\n\nclass B(A):\n    pass\n\nA.class_bar(1)\n# =&gt; executing class_qux(&lt;class '__main__.A'&gt;, 1)\nB.class_bar(1)\n# =&gt; executing class_qux(&lt;class '__main__.B'&gt;, 1)\nA.static_bar(1)\n# =&gt; executing class_qux(&lt;class '__main__.A'&gt;, 1)\nB.static_bar(1)\n# =&gt; executing class_qux(&lt;class '__main__.A'&gt;, 1)\n</code></pre>\n", "abstract": "One pretty important practical difference occurs when subclassing. If you don't mind, I'll hijack @unutbu's example: In class_foo, the method knows which class it is called on: In static_foo, there is no way to determine whether it is called on A or B: Note that this doesn't mean you can't use other methods in a staticmethod, you just have to reference the class directly, which means subclasses' staticmethods will still reference the parent class:"}, {"id": 66020869, "score": 3, "vote": 0, "content": "<p>tldr;</p>\n<p>A <code>staticmethod</code> is essentially a function bound to a class (and consequently its instances)</p>\n<p>A <code>classmethod</code> is essentially an inheritable <code>staticmethod</code>.</p>\n<p>For details, see the excellent answers by others.</p>\n", "abstract": "tldr; A staticmethod is essentially a function bound to a class (and consequently its instances) A classmethod is essentially an inheritable staticmethod. For details, see the excellent answers by others."}, {"id": 66049235, "score": 3, "vote": 0, "content": "<p>First let's start with an example code that we'll use to understand both concepts:</p>\n<pre><code class=\"python\">class Employee:\n\n    NO_OF_EMPLOYEES = 0\n  \n    def __init__(self, first_name, last_name, salary):\n        self.first_name = first_name\n        self.last_name = last_name\n        self.salary = salary\n        self.increment_employees()\n\n    def give_raise(self, amount):\n        self.salary += amount\n\n    @classmethod\n    def employee_from_full_name(cls, full_name, salary):\n        split_name = full_name.split(' ')\n        first_name = split_name[0]\n        last_name = split_name[1]\n        return cls(first_name, last_name, salary)\n\n    @classmethod\n    def increment_employees(cls):\n        cls.NO_OF_EMPLOYEES += 1\n\n    @staticmethod\n    def get_employee_legal_obligations_txt():\n        legal_obligations = \"\"\"\n        1. An employee must complete 8 hours per working day\n        2. ...\n        \"\"\"\n        return legal_obligations\n</code></pre>\n<hr/>\n<p><strong>Class method</strong></p>\n<p>A class method accepts the class itself as an implicit argument and -optionally- any other arguments specified in the definition. It\u2019s important to understand that a class method, does not have access to object instances (like instance methods do). Therefore, class methods cannot be used to alter the state of an instantiated object but instead, they are capable of changing the class state which is shared amongst all the instances of that class.\nClass methods are typically useful when we need to access the class itself \u2014 for example, when we want to create a factory method, that is a method that creates instances of the class. In other words, class methods can serve as alternative constructors.</p>\n<p>In our example code, an instance of <code>Employee</code> can be constructed by providing three arguments; <code>first_name</code> , <code>last_name</code> and <code>salary</code>.</p>\n<pre><code class=\"python\">employee_1 = Employee('Andrew', 'Brown', 85000)\nprint(employee_1.first_name)\nprint(employee_1.salary)\n\n'Andrew'\n85000\n</code></pre>\n<p>Now let\u2019s assume that there\u2019s a chance that the name of an Employee can be provided in a single field in which the first and last names are separated by a whitespace. In this case, we could possibly use our class method called <code>employee_from_full_name</code> that accepts three arguments in total. The first one, is the class itself, which is an implicit argument which means that it won\u2019t be provided when calling the method \u2014 Python will automatically do this for us:</p>\n<pre><code class=\"python\">employee_2 = Employee.employee_from_full_name('John Black', 95000)\nprint(employee_2.first_name)\nprint(employee_2.salary)\n\n'John'\n95000\n</code></pre>\n<p>Note that it is also possible to call <code>employee_from_full_name</code> from object instances although in this context it doesn\u2019t make a lot of sense:</p>\n<pre><code class=\"python\">employee_1 = Employee('Andrew', 'Brown', 85000)\nemployee_2 = employee_1.employee_from_full_name('John Black', 95000)\n</code></pre>\n<p>Another reason why we might want to create a class method, is when we need to change the state of the class. In our example, the class variable <code>NO_OF_EMPLOYEES</code> keeps track of the number of employees currently working for the company. This method is called every time a new instance of Employee is created and it updates the count accordingly:</p>\n<pre><code class=\"python\">employee_1 = Employee('Andrew', 'Brown', 85000)\nprint(f'Number of employees: {Employee.NO_OF_EMPLOYEES}')\nemployee_2 = Employee.employee_from_full_name('John Black', 95000)\nprint(f'Number of employees: {Employee.NO_OF_EMPLOYEES}')\n\nNumber of employees: 1\nNumber of employees: 2\n</code></pre>\n<hr/>\n<p><strong>Static methods</strong></p>\n<p>On the other hand, in static methods neither the instance (i.e. <code>self</code>) nor the class itself (i.e. <code>cls</code>) is passed as an implicit argument. This means that such methods, are not capable of accessing the class itself or its instances.\nNow one could argue that static methods are not useful in the context of classes as they can also be placed in helper modules instead of adding them as members of the class. In object oriented programming, it is important to structure your classes into logical chunks and thus, static methods are quite useful when we need to add a method under a class simply because it logically belongs to the class.\nIn our example, the static method named <code>get_employee_legal_obligations_txt</code> simply returns a string that contains the legal obligations of every single employee of a company. This function, does not interact with the class itself nor with any instance. It could have been placed into a different helper module however, it is only relevant to this class and therefore we have to place it under the Employee class.</p>\n<p>A static method can be access directly from the class itself</p>\n<pre><code class=\"python\">print(Employee.get_employee_legal_obligations_txt())\n\n\n    1. An employee must complete 8 hours per working day\n    2. ...\n</code></pre>\n<p>or from an instance of the class:</p>\n<pre><code class=\"python\">employee_1 = Employee('Andrew', 'Brown', 85000)\nprint(employee_1.get_employee_legal_obligations_txt())\n\n\n    1. An employee must complete 8 hours per working day\n    2. ...\n</code></pre>\n<hr/>\n<p><strong>References</strong></p>\n<ul>\n<li><a href=\"https://towardsdatascience.com/whats-the-difference-between-static-and-class-methods-in-python-1ef581de4351\" rel=\"nofollow noreferrer\">What's the difference between static and class methods in Python?</a></li>\n</ul>\n", "abstract": "First let's start with an example code that we'll use to understand both concepts: Class method A class method accepts the class itself as an implicit argument and -optionally- any other arguments specified in the definition. It\u2019s important to understand that a class method, does not have access to object instances (like instance methods do). Therefore, class methods cannot be used to alter the state of an instantiated object but instead, they are capable of changing the class state which is shared amongst all the instances of that class.\nClass methods are typically useful when we need to access the class itself \u2014 for example, when we want to create a factory method, that is a method that creates instances of the class. In other words, class methods can serve as alternative constructors. In our example code, an instance of Employee can be constructed by providing three arguments; first_name , last_name and salary. Now let\u2019s assume that there\u2019s a chance that the name of an Employee can be provided in a single field in which the first and last names are separated by a whitespace. In this case, we could possibly use our class method called employee_from_full_name that accepts three arguments in total. The first one, is the class itself, which is an implicit argument which means that it won\u2019t be provided when calling the method \u2014 Python will automatically do this for us: Note that it is also possible to call employee_from_full_name from object instances although in this context it doesn\u2019t make a lot of sense: Another reason why we might want to create a class method, is when we need to change the state of the class. In our example, the class variable NO_OF_EMPLOYEES keeps track of the number of employees currently working for the company. This method is called every time a new instance of Employee is created and it updates the count accordingly: Static methods On the other hand, in static methods neither the instance (i.e. self) nor the class itself (i.e. cls) is passed as an implicit argument. This means that such methods, are not capable of accessing the class itself or its instances.\nNow one could argue that static methods are not useful in the context of classes as they can also be placed in helper modules instead of adding them as members of the class. In object oriented programming, it is important to structure your classes into logical chunks and thus, static methods are quite useful when we need to add a method under a class simply because it logically belongs to the class.\nIn our example, the static method named get_employee_legal_obligations_txt simply returns a string that contains the legal obligations of every single employee of a company. This function, does not interact with the class itself nor with any instance. It could have been placed into a different helper module however, it is only relevant to this class and therefore we have to place it under the Employee class. A static method can be access directly from the class itself or from an instance of the class: References"}, {"id": 60492563, "score": 0, "vote": 0, "content": "<p>staticmethod has no access to attibutes of the object, of the class, or of parent classes in the inheritance hierarchy.\nIt can be called at the class directly (without creating an object).</p>\n<p>classmethod has no access to attributes of the object. It however can access attributes of the class and of parent classes in the inheritance hierarchy.\nIt can be called at the class directly (without creating an object). If called at the object then it is the same as normal method which doesn't access <code>self.&lt;attribute(s)&gt;</code> and accesses <code>self.__class__.&lt;attribute(s)&gt;</code> only.</p>\n<p>Think we have a class with <code>b=2</code>, we will create an object and re-set this to <code>b=4</code> in it.\nStaticmethod cannot access nothing from previous.\nClassmethod can access <code>.b==2</code> only, via <code>cls.b</code>.\nNormal method can access both: <code>.b==4</code> via <code>self.b</code> and <code>.b==2</code> via <code>self.__class__.b</code>.</p>\n<p>We could follow the KISS style (keep it simple, stupid): Don't use staticmethods and classmethods, don't use classes without instantiating them, access only the object's attributes <code>self.attribute(s)</code>. There are languages where the OOP is implemented that way and I think it is not bad idea. :)</p>\n", "abstract": "staticmethod has no access to attibutes of the object, of the class, or of parent classes in the inheritance hierarchy.\nIt can be called at the class directly (without creating an object). classmethod has no access to attributes of the object. It however can access attributes of the class and of parent classes in the inheritance hierarchy.\nIt can be called at the class directly (without creating an object). If called at the object then it is the same as normal method which doesn't access self.<attribute(s)> and accesses self.__class__.<attribute(s)> only. Think we have a class with b=2, we will create an object and re-set this to b=4 in it.\nStaticmethod cannot access nothing from previous.\nClassmethod can access .b==2 only, via cls.b.\nNormal method can access both: .b==4 via self.b and .b==2 via self.__class__.b. We could follow the KISS style (keep it simple, stupid): Don't use staticmethods and classmethods, don't use classes without instantiating them, access only the object's attributes self.attribute(s). There are languages where the OOP is implemented that way and I think it is not bad idea. :)"}, {"id": 68459641, "score": 0, "vote": 0, "content": "<p><strong>Definition of static method and class method from it's documentation. and When to use static method and when to use class method.</strong></p>\n<ul>\n<li><p><strong>Static method</strong> are like static method in java and C#, it won't use any initialize value of the class, all it need from outside to work fine.</p>\n</li>\n<li><p><strong>class method</strong>: are generally used for inheritance override, when we over-ride a method, and then we use CLS instance to tell if we want to call method of child or parent class. in case you want to use both the methods with same name and different signature.</p>\n</li>\n</ul>\n<p>staticmethod(function) -&gt; method</p>\n<pre><code class=\"python\">Convert a function to be a static method.\n\nA static method does not receive an implicit first argument.\nTo declare a static method, use this idiom:\n\n     class C:\n         @staticmethod\n         def f(arg1, arg2, ...):\n             ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\n\nStatic methods in Python are similar to those found in Java or C++.\nFor a more advanced concept, see the classmethod builtin.\n\"\"\"\n</code></pre>\n<p>classmethod(function) -&gt; method</p>\n<pre><code class=\"python\">Convert a function to be a class method.\n\nA class method receives the class as implicit first argument,\njust like an instance method receives the instance.\nTo declare a class method, use this idiom:\n\n  class C:\n      @classmethod\n      def f(cls, arg1, arg2, ...):\n          ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\nIf a class method is called for a derived class, the derived class\nobject is passed as the implied first argument.\n\nClass methods are different than C++ or Java static methods.\nIf you want those, see the staticmethod builtin.\n</code></pre>\n", "abstract": "Definition of static method and class method from it's documentation. and When to use static method and when to use class method. Static method are like static method in java and C#, it won't use any initialize value of the class, all it need from outside to work fine. class method: are generally used for inheritance override, when we over-ride a method, and then we use CLS instance to tell if we want to call method of child or parent class. in case you want to use both the methods with same name and different signature. staticmethod(function) -> method classmethod(function) -> method"}, {"id": 73852182, "score": 0, "vote": 0, "content": "<p>I'd like to add on top of all the previous answers the following, which is not official, but adheres to standards.</p>\n<p>First of all you can look at always giving the least amount of privilege necessary. So if you don't need something specific to the instance, make it a class method. If you don't need something specific to the class, make it a static method.</p>\n<p>Second thing is consider what you can communicate by the type of method that you make it. Static Method - helper function meant to be used outside of the class itself. Class function - can be called without instantiation however is meant to be used with that class only - otherwise would've been a static method ! Instance method - meant to be used only by instances.</p>\n<p>This can help you in communicating patterns and how your code should be used.</p>\n<pre><code class=\"python\">class Foo:\n    @classmethod\n    def bar(cls, id: int = None):\n        query = session.query(\n            a.id,\n            a.name,\n            a.address,\n        )\n\n        if id is not None:\n            query = query.filter(a.id == id)\n\n        return query\n</code></pre>\n<p>For example the above -- there is no reason why the method bar could not be static. However by making it a class method you communicate that it should be used by the class itself, as opposed it being a helper function meant to be used elsewhere !</p>\n<p>Remember the above is not official, rather my personal preference</p>\n", "abstract": "I'd like to add on top of all the previous answers the following, which is not official, but adheres to standards. First of all you can look at always giving the least amount of privilege necessary. So if you don't need something specific to the instance, make it a class method. If you don't need something specific to the class, make it a static method. Second thing is consider what you can communicate by the type of method that you make it. Static Method - helper function meant to be used outside of the class itself. Class function - can be called without instantiation however is meant to be used with that class only - otherwise would've been a static method ! Instance method - meant to be used only by instances. This can help you in communicating patterns and how your code should be used. For example the above -- there is no reason why the method bar could not be static. However by making it a class method you communicate that it should be used by the class itself, as opposed it being a helper function meant to be used elsewhere ! Remember the above is not official, rather my personal preference"}, {"id": 13920259, "score": -5, "vote": 0, "content": "<p>A quick hack-up ofotherwise identical methods in iPython reveals that <code>@staticmethod</code> yields marginal performance gains (in the nanoseconds), but otherwise it seems to serve no function. Also, any performance gains will probably be wiped out by the additional work of processing the method through <code>staticmethod()</code> during compilation (which happens prior to any code execution when you run a script).</p>\n<p>For the sake of code readability I'd avoid <code>@staticmethod</code> unless your method will be used for loads of work, where the nanoseconds count.</p>\n", "abstract": "A quick hack-up ofotherwise identical methods in iPython reveals that @staticmethod yields marginal performance gains (in the nanoseconds), but otherwise it seems to serve no function. Also, any performance gains will probably be wiped out by the additional work of processing the method through staticmethod() during compilation (which happens prior to any code execution when you run a script). For the sake of code readability I'd avoid @staticmethod unless your method will be used for loads of work, where the nanoseconds count."}]}, {"link": "https://stackoverflow.com/questions/509211/understanding-slicing", "question": {"id": "509211", "title": "Understanding slicing", "content": "<p>I need a good explanation (references are a plus) on Python slicing.</p>\n", "abstract": "I need a good explanation (references are a plus) on Python slicing."}, "answers": [{"id": 509295, "score": 6151, "vote": 0, "content": "<p>The syntax is:</p>\n<pre><code class=\"python\">a[start:stop]  # items start through stop-1\na[start:]      # items start through the rest of the array\na[:stop]       # items from the beginning through stop-1\na[:]           # a copy of the whole array\n</code></pre>\n<p>There is also the <code>step</code> value, which can be used with any of the above:</p>\n<pre><code class=\"python\">a[start:stop:step] # start through not past stop, by step\n</code></pre>\n<p>The key point to remember is that the <code>:stop</code> value represents the first value that is <em>not</em> in the selected slice. So, the difference between <code>stop</code> and <code>start</code> is the number of elements selected (if <code>step</code> is 1, the default).</p>\n<p>The other feature is that <code>start</code> or <code>stop</code> may be a <em>negative</em> number, which means it counts from the end of the array instead of the beginning. So:</p>\n<pre><code class=\"python\">a[-1]    # last item in the array\na[-2:]   # last two items in the array\na[:-2]   # everything except the last two items\n</code></pre>\n<p>Similarly, <code>step</code> may be a negative number:</p>\n<pre><code class=\"python\">a[::-1]    # all items in the array, reversed\na[1::-1]   # the first two items, reversed\na[:-3:-1]  # the last two items, reversed\na[-3::-1]  # everything except the last two items, reversed\n</code></pre>\n<p>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for <code>a[:-2]</code> and <code>a</code> only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.</p>\n<h3>Relationship with the <code>slice</code> object</h3>\n<p>A <a href=\"https://www.w3schools.com/python/ref_func_slice.asp\" rel=\"noreferrer\"><code>slice</code> object</a> can represent a slicing operation, i.e.:</p>\n<pre><code class=\"python\">a[start:stop:step]\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code class=\"python\">a[slice(start, stop, step)]\n</code></pre>\n<p>Slice objects also behave slightly differently depending on the number of arguments, similarly to <code>range()</code>, i.e. both <code>slice(stop)</code> and <code>slice(start, stop[, step])</code> are supported.\nTo skip specifying a given argument, one might use <code>None</code>, so that e.g. <code>a[start:]</code> is equivalent to <code>a[slice(start, None)]</code> or <code>a[::-1]</code> is equivalent to <code>a[slice(None, None, -1)]</code>.</p>\n<p>While the <code>:</code>-based notation is very helpful for simple slicing, the explicit use of <code>slice()</code> objects simplifies the programmatic generation of slicing.</p>\n", "abstract": "The syntax is: There is also the step value, which can be used with any of the above: The key point to remember is that the :stop value represents the first value that is not in the selected slice. So, the difference between stop and start is the number of elements selected (if step is 1, the default). The other feature is that start or stop may be a negative number, which means it counts from the end of the array instead of the beginning. So: Similarly, step may be a negative number: Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for a[:-2] and a only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen. A slice object can represent a slicing operation, i.e.: is equivalent to: Slice objects also behave slightly differently depending on the number of arguments, similarly to range(), i.e. both slice(stop) and slice(start, stop[, step]) are supported.\nTo skip specifying a given argument, one might use None, so that e.g. a[start:] is equivalent to a[slice(start, None)] or a[::-1] is equivalent to a[slice(None, None, -1)]. While the :-based notation is very helpful for simple slicing, the explicit use of slice() objects simplifies the programmatic generation of slicing."}, {"id": 509297, "score": 667, "vote": 0, "content": "<p>The <a href=\"http://docs.python.org/tutorial/introduction.html#strings\" rel=\"noreferrer\">Python tutorial</a> talks about it (scroll down a bit until you get to the part about slicing).</p>\n<p>The ASCII art diagram is helpful too for remembering how slices work:</p>\n<pre><code class=\"python\"> +---+---+---+---+---+---+\n | P | y | t | h | o | n |\n +---+---+---+---+---+---+\n 0   1   2   3   4   5   6\n-6  -5  -4  -3  -2  -1\n</code></pre>\n<blockquote>\n<p>One way to remember how slices work is to think of the indices as pointing <em>between</em> characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of <em>n</em> characters has index <em>n</em>.</p>\n</blockquote>\n", "abstract": "The Python tutorial talks about it (scroll down a bit until you get to the part about slicing). The ASCII art diagram is helpful too for remembering how slices work: One way to remember how slices work is to think of the indices as pointing between characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of n characters has index n."}, {"id": 509377, "score": 508, "vote": 0, "content": "<p>Enumerating the possibilities allowed by the grammar for the sequence <code>x</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x[:]                # [x[0],   x[1],          ..., x[-1]    ]\n&gt;&gt;&gt; x[low:]             # [x[low], x[low+1],      ..., x[-1]    ]\n&gt;&gt;&gt; x[:high]            # [x[0],   x[1],          ..., x[high-1]]\n&gt;&gt;&gt; x[low:high]         # [x[low], x[low+1],      ..., x[high-1]]\n&gt;&gt;&gt; x[::stride]         # [x[0],   x[stride],     ..., x[-1]    ]\n&gt;&gt;&gt; x[low::stride]      # [x[low], x[low+stride], ..., x[-1]    ]\n&gt;&gt;&gt; x[:high:stride]     # [x[0],   x[stride],     ..., x[high-1]]\n&gt;&gt;&gt; x[low:high:stride]  # [x[low], x[low+stride], ..., x[high-1]]\n</code></pre>\n<p>Of course, if <code>(high-low)%stride != 0</code>, then the end point will be a little lower than <code>high-1</code>.</p>\n<p>If <code>stride</code> is negative, the ordering is changed a bit since we're counting down:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x[::-stride]        # [x[-1],   x[-1-stride],   ..., x[0]    ]\n&gt;&gt;&gt; x[high::-stride]    # [x[high], x[high-stride], ..., x[0]    ]\n&gt;&gt;&gt; x[:low:-stride]     # [x[-1],   x[-1-stride],   ..., x[low+1]]\n&gt;&gt;&gt; x[high:low:-stride] # [x[high], x[high-stride], ..., x[low+1]]\n</code></pre>\n<p>Extended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class slicee:\n...     def __getitem__(self, item):\n...         return repr(item)\n...\n&gt;&gt;&gt; slicee()[0, 1:2, ::5, ...]\n'(0, slice(1, 2, None), slice(None, None, 5), Ellipsis)'\n</code></pre>\n", "abstract": "Enumerating the possibilities allowed by the grammar for the sequence x: Of course, if (high-low)%stride != 0, then the end point will be a little lower than high-1. If stride is negative, the ordering is changed a bit since we're counting down: Extended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them."}, {"id": 4729334, "score": 423, "vote": 0, "content": "<p>The answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art:</p>\n<pre><code class=\"python\">                +---+---+---+---+---+---+\n                | P | y | t | h | o | n |\n                +---+---+---+---+---+---+\nSlice position: 0   1   2   3   4   5   6\nIndex position:   0   1   2   3   4   5\n\n&gt;&gt;&gt; p = ['P','y','t','h','o','n']\n# Why the two sets of numbers:\n# indexing gives items, not lists\n&gt;&gt;&gt; p[0]\n 'P'\n&gt;&gt;&gt; p[5]\n 'n'\n\n# Slicing gives lists\n&gt;&gt;&gt; p[0:1]\n ['P']\n&gt;&gt;&gt; p[0:2]\n ['P','y']\n</code></pre>\n<p>One heuristic is, for a slice from zero to n, think: \"zero is the beginning, start at the beginning and take n items in a list\".</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p[5] # the last of six items, indexed from zero\n 'n'\n&gt;&gt;&gt; p[0:5] # does NOT include the last item!\n ['P','y','t','h','o']\n&gt;&gt;&gt; p[0:6] # not p[0:5]!!!\n ['P','y','t','h','o','n']\n</code></pre>\n<p>Another heuristic is, \"for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning\"</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p[0:4] # Start at the beginning and count out 4 items\n ['P','y','t','h']\n&gt;&gt;&gt; p[1:4] # Take one item off the front\n ['y','t','h']\n&gt;&gt;&gt; p[2:4] # Take two items off the front\n ['t','h']\n# etc.\n</code></pre>\n<p>The first rule of slice assignment is that since slicing <em>returns</em> a list, slice assignment <em>requires</em> a list (or other iterable):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p[2:3]\n ['t']\n&gt;&gt;&gt; p[2:3] = ['T']\n&gt;&gt;&gt; p\n ['P','y','T','h','o','n']\n&gt;&gt;&gt; p[2:3] = 't'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: can only assign an iterable\n</code></pre>\n<p>The second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p[2:4]\n ['T','h']\n&gt;&gt;&gt; p[2:4] = ['t','r']\n&gt;&gt;&gt; p\n ['P','y','t','r','o','n']\n</code></pre>\n<p>The third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = ['P','y','t','h','o','n'] # Start over\n&gt;&gt;&gt; p[2:4] = ['s','p','a','m']\n&gt;&gt;&gt; p\n ['P','y','s','p','a','m','o','n']\n</code></pre>\n<p>The trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around <em>indexing</em> an empty slice:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = ['P','y','t','h','o','n']\n&gt;&gt;&gt; p[0:4]\n ['P','y','t','h']\n&gt;&gt;&gt; p[1:4]\n ['y','t','h']\n&gt;&gt;&gt; p[2:4]\n ['t','h']\n&gt;&gt;&gt; p[3:4]\n ['h']\n&gt;&gt;&gt; p[4:4]\n []\n</code></pre>\n<p>And then once you've seen that, slice assignment to the empty slice makes sense too:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = ['P','y','t','h','o','n']\n&gt;&gt;&gt; p[2:4] = ['x','y'] # Assigned list is same length as slice\n&gt;&gt;&gt; p\n ['P','y','x','y','o','n'] # Result is same length\n&gt;&gt;&gt; p = ['P','y','t','h','o','n']\n&gt;&gt;&gt; p[3:4] = ['x','y'] # Assigned list is longer than slice\n&gt;&gt;&gt; p\n ['P','y','t','x','y','o','n'] # The result is longer\n&gt;&gt;&gt; p = ['P','y','t','h','o','n']\n&gt;&gt;&gt; p[4:4] = ['x','y']\n&gt;&gt;&gt; p\n ['P','y','t','h','x','y','o','n'] # The result is longer still\n</code></pre>\n<p>Note that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments.</p>\n<p>Backing up a little bit, what happens when you keep going with our procession of counting up the slice beginning?</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p = ['P','y','t','h','o','n']\n&gt;&gt;&gt; p[0:4]\n ['P','y','t','h']\n&gt;&gt;&gt; p[1:4]\n ['y','t','h']\n&gt;&gt;&gt; p[2:4]\n ['t','h']\n&gt;&gt;&gt; p[3:4]\n ['h']\n&gt;&gt;&gt; p[4:4]\n []\n&gt;&gt;&gt; p[5:4]\n []\n&gt;&gt;&gt; p[6:4]\n []\n</code></pre>\n<p>With slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p[5:3:-1]\n ['n','o']\n</code></pre>\n<p>There are some weird consequences to the \"once you're done, you're done\" rule:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p[4:4]\n []\n&gt;&gt;&gt; p[5:4]\n []\n&gt;&gt;&gt; p[6:4]\n []\n&gt;&gt;&gt; p[6]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nIndexError: list index out of range\n</code></pre>\n<p>In fact, compared to indexing, Python slicing is bizarrely error-proof:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p[100:200]\n []\n&gt;&gt;&gt; p[int(2e99):int(1e99)]\n []\n</code></pre>\n<p>This can come in handy sometimes, but it can also lead to somewhat strange behavior:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; p\n ['P', 'y', 't', 'h', 'o', 'n']\n&gt;&gt;&gt; p[int(2e99):int(1e99)] = ['p','o','w','e','r']\n&gt;&gt;&gt; p\n ['P', 'y', 't', 'h', 'o', 'n', 'p', 'o', 'w', 'e', 'r']\n</code></pre>\n<p>Depending on your application, that might... or might not... be what you were hoping for there!</p>\n<hr/>\n<p>Below is the text of my original answer. It has been useful to many people, so I didn't want to delete it.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; r=[1,2,3,4]\n&gt;&gt;&gt; r[1:1]\n[]\n&gt;&gt;&gt; r[1:1]=[9,8]\n&gt;&gt;&gt; r\n[1, 9, 8, 2, 3, 4]\n&gt;&gt;&gt; r[1:1]=['blah']\n&gt;&gt;&gt; r\n[1, 'blah', 9, 8, 2, 3, 4]\n</code></pre>\n<p>This may also clarify the difference between slicing and indexing.</p>\n", "abstract": "The answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art: One heuristic is, for a slice from zero to n, think: \"zero is the beginning, start at the beginning and take n items in a list\". Another heuristic is, \"for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning\" The first rule of slice assignment is that since slicing returns a list, slice assignment requires a list (or other iterable): The second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment: The third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned: The trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around indexing an empty slice: And then once you've seen that, slice assignment to the empty slice makes sense too: Note that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments. Backing up a little bit, what happens when you keep going with our procession of counting up the slice beginning? With slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number. There are some weird consequences to the \"once you're done, you're done\" rule: In fact, compared to indexing, Python slicing is bizarrely error-proof: This can come in handy sometimes, but it can also lead to somewhat strange behavior: Depending on your application, that might... or might not... be what you were hoping for there! Below is the text of my original answer. It has been useful to many people, so I didn't want to delete it. This may also clarify the difference between slicing and indexing."}, {"id": 24713353, "score": 283, "vote": 0, "content": "<blockquote>\n<h2>Explain Python's slice notation</h2>\n</blockquote>\n<p>In short, the colons (<code>:</code>) in subscript notation (<code>subscriptable[subscriptarg]</code>) make slice notation, which has the optional arguments <code>start</code>, <code>stop</code>, and <code>step</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">sliceable[start:stop:step]\n</code></pre>\n<p>Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with.</p>\n<h2>Important Definitions</h2>\n<p>To begin with, let's define a few terms:</p>\n<blockquote>\n<p><strong><code>start</code>:</strong> the beginning index of the slice, it will include the element at this index unless it is the same as <em>stop</em>, defaults to 0, i.e. the first index. If it's negative, it means to start <code>n</code> items from the end.</p>\n<p><strong><code>stop</code>:</strong> the ending index of the slice, it does <em>not</em> include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.</p>\n<p><strong><code>step</code>:</strong> the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse.</p>\n</blockquote>\n<h2>How Indexing Works</h2>\n<p>You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the <em>start</em> and <em>stop</em>, and for the <em>step</em>, you simply decrement your index. This example is <a href=\"https://docs.python.org/2/tutorial/introduction.html\" rel=\"noreferrer\">from the documentation's tutorial</a>, but I've modified it slightly to indicate which item in a sequence each index references:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"> +---+---+---+---+---+---+\n | P | y | t | h | o | n |\n +---+---+---+---+---+---+\n   0   1   2   3   4   5 \n  -6  -5  -4  -3  -2  -1\n</code></pre>\n<h2>How Slicing Works</h2>\n<p>To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually <a href=\"https://docs.python.org/2/reference/datamodel.html#object.__getitem__\" rel=\"noreferrer\">implement the <code>__getitem__</code> method of the sequence, according to the Python data model</a>.)</p>\n<p>Slice notation works like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">sequence[start:stop:step]\n</code></pre>\n<p>And recall that there are defaults for <em>start</em>, <em>stop</em>, and <em>step</em>, so to access the defaults, simply leave out the argument.</p>\n<p>Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">my_list[-9:]\n</code></pre>\n<p>When I see this, I read the part in the brackets as \"9th from the end, to the end.\" (Actually, I abbreviate it mentally as \"-9, on\")</p>\n<h2>Explanation:</h2>\n<p>The full notation is</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">my_list[-9:None:None]\n</code></pre>\n<p>and to substitute the defaults (actually when <code>step</code> is negative, <code>stop</code>'s default is <code>-len(my_list) - 1</code>, so <code>None</code> for stop really just means it goes to whichever end step takes it to):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">my_list[-9:len(my_list):1]\n</code></pre>\n<p>The <strong>colon</strong>, <code>:</code>,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">list_copy = sequence[:]\n</code></pre>\n<p>And clearing them is with:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">del my_list[:]\n</code></pre>\n<p>(Python 3 gets a <code>list.copy</code> and <code>list.clear</code> method.)</p>\n<h3>When <code>step</code> is negative, the defaults for <code>start</code> and <code>stop</code> change</h3>\n<p>By default, when the <code>step</code> argument is empty (or <code>None</code>), it is assigned to <code>+1</code>.</p>\n<p>But you can pass in a negative integer, and the list (or most other standard sliceables) will be sliced from the end to the beginning.</p>\n<p>Thus a negative slice will change the defaults for <code>start</code> and <code>stop</code>!</p>\n<h3>Confirming this in the source</h3>\n<p>I like to encourage users to read the source as well as the documentation. The <a href=\"https://github.com/python/cpython/blob/master/Objects/sliceobject.c\" rel=\"noreferrer\">source code for slice objects and this logic is found here</a>. First we determine if <code>step</code> is negative:</p>\n<blockquote>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">step_is_negative = step_sign &lt; 0;\n</code></pre>\n</blockquote>\n<p>If so, the lower bound is <code>-1</code>  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this <code>-1</code> is <em>different</em> from a <code>-1</code> that users may pass indexes in Python indicating the last item.)</p>\n<blockquote>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">if (step_is_negative) {\n    lower = PyLong_FromLong(-1L);\n    if (lower == NULL)\n        goto error;\n\n    upper = PyNumber_Add(length, lower);\n    if (upper == NULL)\n        goto error;\n}\n</code></pre>\n</blockquote>\n<p>Otherwise <code>step</code> is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list.</p>\n<blockquote>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">else {\n    lower = _PyLong_Zero;\n    Py_INCREF(lower);\n    upper = length;\n    Py_INCREF(upper);\n}\n</code></pre>\n</blockquote>\n<p>Then, we may need to apply the defaults for <code>start</code> and <code>stop</code>\u2014the default then for <code>start</code> is calculated as the upper bound when <code>step</code> is negative:</p>\n<blockquote>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">if (self-&gt;start == Py_None) {\n    start = step_is_negative ? upper : lower;\n    Py_INCREF(start);\n}\n</code></pre>\n</blockquote>\n<p>and <code>stop</code>, the lower bound:</p>\n<blockquote>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">if (self-&gt;stop == Py_None) {\n    stop = step_is_negative ? lower : upper;\n    Py_INCREF(stop);\n}\n</code></pre>\n</blockquote>\n<h1>Give your slices a descriptive name!</h1>\n<p>You may find it useful to separate forming the slice from passing it to the <code>list.__getitem__</code> method (<a href=\"https://docs.python.org/2/reference/datamodel.html#object.__getitem__\" rel=\"noreferrer\">that's what the square brackets do</a>). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing.</p>\n<p>However, you can't just assign some integers separated by colons to a variable. You need to use the slice object:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">last_nine_slice = slice(-9, None)\n</code></pre>\n<p>The second argument, <code>None</code>, is required, so that the first argument is interpreted as the <code>start</code> argument <a href=\"https://docs.python.org/2/library/functions.html#slice\" rel=\"noreferrer\">otherwise it would be the <code>stop</code> argument</a>.</p>\n<p>You can then pass the slice object to your sequence:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; list(range(100))[last_nine_slice]\n[91, 92, 93, 94, 95, 96, 97, 98, 99]\n</code></pre>\n<p>It's interesting that ranges also take slices:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; range(100)[last_nine_slice]\nrange(91, 100)\n</code></pre>\n<h1>Memory Considerations:</h1>\n<p>Since slices of Python lists create new objects in memory, another important function to be aware of is <code>itertools.islice</code>. Typically you'll want to iterate over a slice, not just have it created statically in memory. <code>islice</code> is perfect for this. A caveat, it doesn't support negative arguments to <code>start</code>, <code>stop</code>, or <code>step</code>, so if that's an issue you may need to calculate indices or reverse the iterable in advance.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">length = 100\nlast_nine_iter = itertools.islice(list(range(length)), length-9, None, 1)\nlist_last_nine = list(last_nine_iter)\n</code></pre>\n<p>and now:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; list_last_nine\n[91, 92, 93, 94, 95, 96, 97, 98, 99]\n</code></pre>\n<p>The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy.</p>\n", "abstract": "In short, the colons (:) in subscript notation (subscriptable[subscriptarg]) make slice notation, which has the optional arguments start, stop, and step: Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with. To begin with, let's define a few terms: start: the beginning index of the slice, it will include the element at this index unless it is the same as stop, defaults to 0, i.e. the first index. If it's negative, it means to start n items from the end. stop: the ending index of the slice, it does not include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end. step: the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse. You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the start and stop, and for the step, you simply decrement your index. This example is from the documentation's tutorial, but I've modified it slightly to indicate which item in a sequence each index references: To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually implement the __getitem__ method of the sequence, according to the Python data model.) Slice notation works like this: And recall that there are defaults for start, stop, and step, so to access the defaults, simply leave out the argument. Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this: When I see this, I read the part in the brackets as \"9th from the end, to the end.\" (Actually, I abbreviate it mentally as \"-9, on\") The full notation is and to substitute the defaults (actually when step is negative, stop's default is -len(my_list) - 1, so None for stop really just means it goes to whichever end step takes it to): The colon, :,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is And clearing them is with: (Python 3 gets a list.copy and list.clear method.) By default, when the step argument is empty (or None), it is assigned to +1. But you can pass in a negative integer, and the list (or most other standard sliceables) will be sliced from the end to the beginning. Thus a negative slice will change the defaults for start and stop! I like to encourage users to read the source as well as the documentation. The source code for slice objects and this logic is found here. First we determine if step is negative: If so, the lower bound is -1  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this -1 is different from a -1 that users may pass indexes in Python indicating the last item.) Otherwise step is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list. Then, we may need to apply the defaults for start and stop\u2014the default then for start is calculated as the upper bound when step is negative: and stop, the lower bound: You may find it useful to separate forming the slice from passing it to the list.__getitem__ method (that's what the square brackets do). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing. However, you can't just assign some integers separated by colons to a variable. You need to use the slice object: The second argument, None, is required, so that the first argument is interpreted as the start argument otherwise it would be the stop argument. You can then pass the slice object to your sequence: It's interesting that ranges also take slices: Since slices of Python lists create new objects in memory, another important function to be aware of is itertools.islice. Typically you'll want to iterate over a slice, not just have it created statically in memory. islice is perfect for this. A caveat, it doesn't support negative arguments to start, stop, or step, so if that's an issue you may need to calculate indices or reverse the iterable in advance. and now: The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy."}, {"id": 509415, "score": 157, "vote": 0, "content": "<p>And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [1,2,3,4,5,6]\n&gt;&gt;&gt; x[::-1]\n[6,5,4,3,2,1]\n</code></pre>\n<p>Easy way to reverse sequences!</p>\n<p>And if you wanted, for some reason, every second item in the reversed sequence:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [1,2,3,4,5,6]\n&gt;&gt;&gt; x[::-2]\n[6,4,2]\n</code></pre>\n", "abstract": "And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax: Easy way to reverse sequences! And if you wanted, for some reason, every second item in the reversed sequence:"}, {"id": 13005464, "score": 110, "vote": 0, "content": "<p>In Python 2.7</p>\n<p>Slicing in Python</p>\n<pre><code class=\"python\">[a:b:c]\n\nlen = length of string, tuple or list\n\nc -- default is +1. The sign of c indicates forward or backward, absolute value of c indicates steps. Default is forward with step size 1. Positive means forward, negative means backward.\n\na --  When c is positive or blank, default is 0. When c is negative, default is -1.\n\nb --  When c is positive or blank, default is len. When c is negative, default is -(len+1).\n</code></pre>\n<p>Understanding index assignment is very important.</p>\n<pre><code class=\"python\">In forward direction, starts at 0 and ends at len-1\n\nIn backward direction, starts at -1 and ends at -len\n</code></pre>\n<p>When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range:</p>\n<pre><code class=\"python\">-len, -len+1, -len+2, ..., 0, 1, 2,3,4 , len -1\n</code></pre>\n<p>But this range continues in both directions infinitely:</p>\n<pre><code class=\"python\">...,-len -2 ,-len-1,-len, -len+1, -len+2, ..., 0, 1, 2,3,4 , len -1, len, len +1, len+2 , ....\n</code></pre>\n<p>For example:</p>\n<pre><code class=\"python\">             0    1    2   3    4   5   6   7   8   9   10   11\n             a    s    t   r    i   n   g\n    -9  -8  -7   -6   -5  -4   -3  -2  -1\n</code></pre>\n<p>If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list.</p>\n<p>One last thing: if a and b are equal, then also you get an empty list:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; l1\n[2, 3, 4]\n\n&gt;&gt;&gt; l1[:]\n[2, 3, 4]\n\n&gt;&gt;&gt; l1[::-1] # a default is -1 , b default is -(len+1)\n[4, 3, 2]\n\n&gt;&gt;&gt; l1[:-4:-1] # a default is -1\n[4, 3, 2]\n\n&gt;&gt;&gt; l1[:-3:-1] # a default is -1\n[4, 3]\n\n&gt;&gt;&gt; l1[::] # c default is +1, so a default is 0, b default is len\n[2, 3, 4]\n\n&gt;&gt;&gt; l1[::-1] # c is -1 , so a default is -1 and b default is -(len+1)\n[4, 3, 2]\n\n\n&gt;&gt;&gt; l1[-100:-200:-1] # Interesting\n[]\n\n&gt;&gt;&gt; l1[-1:-200:-1] # Interesting\n[4, 3, 2]\n\n\n&gt;&gt;&gt; l1[-1:-1:1]\n[]\n\n\n&gt;&gt;&gt; l1[-1:5:1] # Interesting\n[4]\n\n\n&gt;&gt;&gt; l1[1:-7:1]\n[]\n\n&gt;&gt;&gt; l1[1:-7:-1] # Interesting\n[3, 2]\n\n&gt;&gt;&gt; l1[:-2:-2] # a default is -1, stop(b) at -2 , step(c) by 2 in reverse direction\n[4]\n</code></pre>\n", "abstract": "In Python 2.7 Slicing in Python Understanding index assignment is very important. When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range: But this range continues in both directions infinitely: For example: If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list. One last thing: if a and b are equal, then also you get an empty list:"}, {"id": 7315935, "score": 101, "vote": 0, "content": "<p>Found this great table at <a href=\"http://wiki.python.org/moin/MovingToPythonFromOtherLanguages\" rel=\"noreferrer\">http://wiki.python.org/moin/MovingToPythonFromOtherLanguages</a></p>\n<pre><code class=\"python\">Python indexes and slices for a six-element list.\nIndexes enumerate the elements, slices enumerate the spaces between the elements.\n\nIndex from rear:    -6  -5  -4  -3  -2  -1      a=[0,1,2,3,4,5]    a[1:]==[1,2,3,4,5]\nIndex from front:    0   1   2   3   4   5      len(a)==6          a[:5]==[0,1,2,3,4]\n                   +---+---+---+---+---+---+    a[0]==0            a[:-2]==[0,1,2,3]\n                   | a | b | c | d | e | f |    a[5]==5            a[1:2]==[1]\n                   +---+---+---+---+---+---+    a[-1]==5           a[1:-1]==[1,2,3,4]\nSlice from front:  :   1   2   3   4   5   :    a[-2]==4\nSlice from rear:   :  -5  -4  -3  -2  -1   :\n                                                b=a[:]\n                                                b==[0,1,2,3,4,5] (shallow copy of a)</code></pre>\n", "abstract": "Found this great table at http://wiki.python.org/moin/MovingToPythonFromOtherLanguages"}, {"id": 567094, "score": 70, "vote": 0, "content": "<p>After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a <code>for</code> loop...</p>\n<pre><code class=\"python\">(from:to:step)\n</code></pre>\n<p>Any of them are optional:</p>\n<pre><code class=\"python\">(:to:step)\n(from::step)\n(from:to)\n</code></pre>\n<p>Then the negative indexing just needs you to add the length of the string to the negative indices to understand it.</p>\n<p>This works for me anyway...</p>\n", "abstract": "After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a for loop... Any of them are optional: Then the negative indexing just needs you to add the length of the string to the negative indices to understand it. This works for me anyway..."}, {"id": 9923354, "score": 54, "vote": 0, "content": "<p>I find it easier to remember how it works, and then I can figure out any specific start/stop/step combination.</p>\n<p>It's instructive to understand <code>range()</code> first:</p>\n<pre><code class=\"python\">def range(start=0, stop, step=1):  # Illegal syntax, but that's the effect\n    i = start\n    while (i &lt; stop if step &gt; 0 else i &gt; stop):\n        yield i\n        i += step\n</code></pre>\n<p>Begin from <code>start</code>, increment by <code>step</code>, do not reach <code>stop</code>.  Very simple.</p>\n<p>The thing to remember about negative step is that <code>stop</code> is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. <code>'abcde'[1:-2][::-1]</code> slices off one char from left, two from right, then reverses. (See also <a href=\"http://www.python.org/dev/peps/pep-0322/\" rel=\"noreferrer\"><code>reversed()</code></a>.)</p>\n<p>Sequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence:</p>\n<p><strong>TODO</strong>: The code below had a bug with \"never go outside the sequence\" when abs(step)&gt;1; I <em>think</em> I patched it to be correct, but it's hard to understand.</p>\n<pre><code class=\"python\">def this_is_how_slicing_works(seq, start=None, stop=None, step=1):\n    if start is None:\n        start = (0 if step &gt; 0 else len(seq)-1)\n    elif start &lt; 0:\n        start += len(seq)\n    if not 0 &lt;= start &lt; len(seq):  # clip if still outside bounds\n        start = (0 if step &gt; 0 else len(seq)-1)\n    if stop is None:\n        stop = (len(seq) if step &gt; 0 else -1)  # really -1, not last element\n    elif stop &lt; 0:\n        stop += len(seq)\n    for i in range(start, stop, step):\n        if 0 &lt;= i &lt; len(seq):\n            yield seq[i]\n</code></pre>\n<p>Don't worry about the <code>is None</code> details - just remember that omitting <code>start</code> and/or <code>stop</code> always does the right thing to give you the whole sequence.</p>\n<p>Normalizing negative indexes first allows start and/or stop to be counted from the end independently: <code>'abcde'[1:-2] == 'abcde'[1:3] == 'bc'</code> despite <code>range(1,-2) == []</code>.\nThe normalization is sometimes thought of as \"modulo the length\", but note it adds the length just once: e.g. <code>'abcde'[-53:42]</code> is just the whole string.</p>\n", "abstract": "I find it easier to remember how it works, and then I can figure out any specific start/stop/step combination. It's instructive to understand range() first: Begin from start, increment by step, do not reach stop.  Very simple. The thing to remember about negative step is that stop is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. 'abcde'[1:-2][::-1] slices off one char from left, two from right, then reverses. (See also reversed().) Sequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence: TODO: The code below had a bug with \"never go outside the sequence\" when abs(step)>1; I think I patched it to be correct, but it's hard to understand. Don't worry about the is None details - just remember that omitting start and/or stop always does the right thing to give you the whole sequence. Normalizing negative indexes first allows start and/or stop to be counted from the end independently: 'abcde'[1:-2] == 'abcde'[1:3] == 'bc' despite range(1,-2) == [].\nThe normalization is sometimes thought of as \"modulo the length\", but note it adds the length just once: e.g. 'abcde'[-53:42] is just the whole string."}, {"id": 522212, "score": 43, "vote": 0, "content": "<p>I use the \"an index points between elements\" method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:</p>\n<pre><code class=\"python\">mylist[X:Y]\n</code></pre>\n<p>X is the index of the first element you want.<br/>\nY is the index of the first element you <em>don't</em> want.</p>\n", "abstract": "I use the \"an index points between elements\" method of thinking about it myself, but one way of describing it which sometimes helps others get it is this: X is the index of the first element you want.\nY is the index of the first element you don't want."}, {"id": 14682039, "score": 43, "vote": 0, "content": "<pre><code class=\"python\">Index:\n      ------------&gt;\n  0   1   2   3   4\n+---+---+---+---+---+\n| a | b | c | d | e |\n+---+---+---+---+---+\n  0  -4  -3  -2  -1\n      &lt;------------\n\nSlice:\n    &lt;---------------|\n|---------------&gt;\n:   1   2   3   4   :\n+---+---+---+---+---+\n| a | b | c | d | e |\n+---+---+---+---+---+\n:  -4  -3  -2  -1   :\n|---------------&gt;\n    &lt;---------------|\n</code></pre>\n<p>I hope this will help you to model the list in Python.</p>\n<p>Reference: <a href=\"http://wiki.python.org/moin/MovingToPythonFromOtherLanguages\" rel=\"noreferrer\">http://wiki.python.org/moin/MovingToPythonFromOtherLanguages</a></p>\n", "abstract": "I hope this will help you to model the list in Python. Reference: http://wiki.python.org/moin/MovingToPythonFromOtherLanguages"}, {"id": 29237560, "score": 39, "vote": 0, "content": "<p>This is how I teach slices to newbies:</p>\n<p><strong>Understanding the difference between indexing and slicing:</strong></p>\n<p>Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.</p>\n<p><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/o99aU.png\"/></p>\n<p>It is a list with six elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it.</p>\n<p>Indexing is like dealing with the contents of box. You can check contents of any box. But you can't check the contents of multiple boxes at once. You can even replace the contents of the box. But you can't place two balls in one box or replace two balls at a time.</p>\n<pre><code class=\"python\">In [122]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [123]: alpha\nOut[123]: ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [124]: alpha[0]\nOut[124]: 'a'\n\nIn [127]: alpha[0] = 'A'\n\nIn [128]: alpha\nOut[128]: ['A', 'b', 'c', 'd', 'e', 'f']\n\nIn [129]: alpha[0,1]\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-129-c7eb16585371&gt; in &lt;module&gt;()\n----&gt; 1 alpha[0,1]\n\nTypeError: list indices must be integers, not tuple\n</code></pre>\n<p>Slicing is like dealing with boxes themselves. You can pick up the first box and place it on another table. To pick up the box, all you need to know is the position of beginning and ending of the box.</p>\n<p>You can even pick up the first three boxes or the last two boxes or all boxes between 1 and 4. So, you can pick any set of boxes if you know the beginning and ending. These positions are called start and stop positions.</p>\n<p>The interesting thing is that you can replace multiple boxes at once. Also you can place multiple boxes wherever you like.</p>\n<pre><code class=\"python\">In [130]: alpha[0:1]\nOut[130]: ['A']\n\nIn [131]: alpha[0:1] = 'a'\n\nIn [132]: alpha\nOut[132]: ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [133]: alpha[0:2] = ['A', 'B']\n\nIn [134]: alpha\nOut[134]: ['A', 'B', 'c', 'd', 'e', 'f']\n\nIn [135]: alpha[2:2] = ['x', 'xx']\n\nIn [136]: alpha\nOut[136]: ['A', 'B', 'x', 'xx', 'c', 'd', 'e', 'f']\n</code></pre>\n<p><strong>Slicing With Step:</strong></p>\n<p>Till now you have picked boxes continuously. But sometimes you need to pick up discretely. For example, you can pick up every second box. You can even pick up every third box from the end. This value is called step size. This represents the gap between your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa.</p>\n<pre><code class=\"python\">In [137]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [142]: alpha[1:5:2]\nOut[142]: ['b', 'd']\n\nIn [143]: alpha[-1:-5:-2]\nOut[143]: ['f', 'd']\n\nIn [144]: alpha[1:5:-2]\nOut[144]: []\n\nIn [145]: alpha[-1:-5:2]\nOut[145]: []\n</code></pre>\n<p><strong>How Python Figures Out Missing Parameters:</strong></p>\n<p>When slicing, if you leave out any parameter, Python tries to figure it out automatically.</p>\n<p>If you check the source code of <a href=\"http://en.wikipedia.org/wiki/CPython\" rel=\"noreferrer\">CPython</a>, you will find a function called PySlice_GetIndicesEx() which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python.</p>\n<p>This function takes a Python object and optional parameters for slicing and returns the start, stop, step, and slice length for the requested slice.</p>\n<pre><code class=\"python\">def py_slice_get_indices_ex(obj, start=None, stop=None, step=None):\n\n    length = len(obj)\n\n    if step is None:\n        step = 1\n    if step == 0:\n        raise Exception(\"Step cannot be zero.\")\n\n    if start is None:\n        start = 0 if step &gt; 0 else length - 1\n    else:\n        if start &lt; 0:\n            start += length\n        if start &lt; 0:\n            start = 0 if step &gt; 0 else -1\n        if start &gt;= length:\n            start = length if step &gt; 0 else length - 1\n\n    if stop is None:\n        stop = length if step &gt; 0 else -1\n    else:\n        if stop &lt; 0:\n            stop += length\n        if stop &lt; 0:\n            stop = 0 if step &gt; 0 else -1\n        if stop &gt;= length:\n            stop = length if step &gt; 0 else length - 1\n\n    if (step &lt; 0 and stop &gt;= start) or (step &gt; 0 and start &gt;= stop):\n        slice_length = 0\n    elif step &lt; 0:\n        slice_length = (stop - start + 1)/(step) + 1\n    else:\n        slice_length = (stop - start - 1)/(step) + 1\n\n    return (start, stop, step, slice_length)\n</code></pre>\n<p>This is the intelligence that is present behind slices. Since Python has an built-in function called slice, you can pass some parameters and check how smartly it calculates missing parameters.</p>\n<pre><code class=\"python\">In [21]: alpha = ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [22]: s = slice(None, None, None)\n\nIn [23]: s\nOut[23]: slice(None, None, None)\n\nIn [24]: s.indices(len(alpha))\nOut[24]: (0, 6, 1)\n\nIn [25]: range(*s.indices(len(alpha)))\nOut[25]: [0, 1, 2, 3, 4, 5]\n\nIn [26]: s = slice(None, None, -1)\n\nIn [27]: range(*s.indices(len(alpha)))\nOut[27]: [5, 4, 3, 2, 1, 0]\n\nIn [28]: s = slice(None, 3, -1)\n\nIn [29]: range(*s.indices(len(alpha)))\nOut[29]: [5, 4]\n</code></pre>\n<p><strong>Note:</strong> This post was originally written in my blog, <em><a href=\"https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html\" rel=\"noreferrer\">The Intelligence Behind Python Slices</a></em>.</p>\n", "abstract": "This is how I teach slices to newbies: Understanding the difference between indexing and slicing: Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.  It is a list with six elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it. Indexing is like dealing with the contents of box. You can check contents of any box. But you can't check the contents of multiple boxes at once. You can even replace the contents of the box. But you can't place two balls in one box or replace two balls at a time. Slicing is like dealing with boxes themselves. You can pick up the first box and place it on another table. To pick up the box, all you need to know is the position of beginning and ending of the box. You can even pick up the first three boxes or the last two boxes or all boxes between 1 and 4. So, you can pick any set of boxes if you know the beginning and ending. These positions are called start and stop positions. The interesting thing is that you can replace multiple boxes at once. Also you can place multiple boxes wherever you like. Slicing With Step: Till now you have picked boxes continuously. But sometimes you need to pick up discretely. For example, you can pick up every second box. You can even pick up every third box from the end. This value is called step size. This represents the gap between your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa. How Python Figures Out Missing Parameters: When slicing, if you leave out any parameter, Python tries to figure it out automatically. If you check the source code of CPython, you will find a function called PySlice_GetIndicesEx() which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python. This function takes a Python object and optional parameters for slicing and returns the start, stop, step, and slice length for the requested slice. This is the intelligence that is present behind slices. Since Python has an built-in function called slice, you can pass some parameters and check how smartly it calculates missing parameters. Note: This post was originally written in my blog, The Intelligence Behind Python Slices."}, {"id": 16267103, "score": 38, "vote": 0, "content": "<p>Python slicing notation:</p>\n<pre><code class=\"python\">a[start:end:step]\n</code></pre>\n<ul>\n<li>For <code>start</code> and <code>end</code>, negative values are interpreted as being relative to the end of the sequence.</li>\n<li>Positive indices for <code>end</code> indicate the position <em>after</em> the last element to be included.</li>\n<li>Blank values are defaulted as follows: <code>[+0:-0:1]</code>.</li>\n<li>Using a negative step reverses the interpretation of <code>start</code> and <code>end</code></li>\n</ul>\n<p>The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use:</p>\n<pre><code class=\"python\">m[::,0:2:] ## slice the first two columns\n</code></pre>\n<p>Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use <a href=\"https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python\"><code>deepcopy()</code></a>.</p>\n", "abstract": "Python slicing notation: The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use: Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use deepcopy()."}, {"id": 15824717, "score": 34, "vote": 0, "content": "<p>You can also use slice assignment to remove one or more elements from a list:</p>\n<pre><code class=\"python\">r = [1, 'blah', 9, 8, 2, 3, 4]\n&gt;&gt;&gt; r[1:4] = []\n&gt;&gt;&gt; r\n[1, 2, 3, 4]\n</code></pre>\n", "abstract": "You can also use slice assignment to remove one or more elements from a list:"}, {"id": 9827284, "score": 33, "vote": 0, "content": "<p>This is just for some extra info...\nConsider the list below </p>\n<pre><code class=\"python\">&gt;&gt;&gt; l=[12,23,345,456,67,7,945,467]\n</code></pre>\n<p>Few other tricks for reversing the list:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; l[len(l):-len(l)-1:-1]\n[467, 945, 7, 67, 456, 345, 23, 12]\n\n&gt;&gt;&gt; l[:-len(l)-1:-1]\n[467, 945, 7, 67, 456, 345, 23, 12]\n\n&gt;&gt;&gt; l[len(l)::-1]\n[467, 945, 7, 67, 456, 345, 23, 12]\n\n&gt;&gt;&gt; l[::-1]\n[467, 945, 7, 67, 456, 345, 23, 12]\n\n&gt;&gt;&gt; l[-1:-len(l)-1:-1]\n[467, 945, 7, 67, 456, 345, 23, 12]\n</code></pre>\n", "abstract": "This is just for some extra info...\nConsider the list below  Few other tricks for reversing the list:"}, {"id": 41548529, "score": 30, "vote": 0, "content": "<h2>1. Slice Notation</h2>\n<p>To make it simple, remember <strong>slice has only one form\uff1a</strong></p>\n<pre><code class=\"python\">s[start:end:step]\n</code></pre>\n<p>and here is how it works:</p>\n<ul>\n<li><code>s</code>: an object that can be sliced</li>\n<li><code>start</code>: first index to start iteration</li>\n<li><code>end</code>: last index, <strong>NOTE that <code>end</code> index will not be included in the resulted slice</strong></li>\n<li><code>step</code>: pick element every <code>step</code> index</li>\n</ul>\n<p>Another import thing: <strong>all <code>start</code>,<code>end</code>, <code>step</code> can be omitted!</strong> And if they are omitted, their default value will be used: <code>0</code>,<code>len(s)</code>,<code>1</code> accordingly.</p>\n<p>So possible variations are:</p>\n<pre><code class=\"python\"># Mostly used variations\ns[start:end]\ns[start:]\ns[:end]\n\n# Step-related variations\ns[:end:step]\ns[start::step]\ns[::step]\n\n# Make a copy\ns[:]\n</code></pre>\n<p>NOTE: If <code>start &gt;= end</code> (considering only when <code>step&gt;0</code>), Python will return a empty slice <code>[]</code>.</p>\n<h2>2. Pitfalls</h2>\n<p>The above part explains the core features on how slice works, and it will work on most occasions. However, there can be pitfalls you should watch out, and this part explains them.</p>\n<h3>Negative indexes</h3>\n<p>The very first thing that confuses Python learners is that <strong>an index can be negative!</strong>\nDon't panic: <strong>a negative index means count backwards.</strong></p>\n<p>For example:</p>\n<pre><code class=\"python\">s[-5:]    # Start at the 5th index from the end of array,\n          # thus returning the last 5 elements.\ns[:-5]    # Start at index 0, and end until the 5th index from end of array,\n          # thus returning s[0:len(s)-5].\n</code></pre>\n<h3>Negative step</h3>\n<p>Making things more confusing is that <strong><code>step</code> can be negative too!</strong></p>\n<p><strong>A negative step means iterate the array backwards: from the end to start, with the end index included, and the start index excluded from the result.</strong></p>\n<p><strong>NOTE</strong>: when step is negative, the default value for <code>start</code> is <code>len(s)</code> (while <code>end</code> does not equal to <code>0</code>, because <code>s[::-1]</code> contains <code>s[0]</code>). For example:</p>\n<pre><code class=\"python\">s[::-1]            # Reversed slice\ns[len(s)::-1]      # The same as above, reversed slice\ns[0:len(s):-1]     # Empty list\n</code></pre>\n<h3>Out of range error?</h3>\n<p>Be surprised: <strong>slice does not raise an IndexError when the index is out of range!</strong></p>\n<p>If the index is out of range, Python will try its best to set the index to <code>0</code> or <code>len(s)</code> according to the situation. For example:</p>\n<pre><code class=\"python\">s[:len(s)+5]      # The same as s[:len(s)]\ns[-len(s)-5::]    # The same as s[0:]\ns[len(s)+5::-1]   # The same as s[len(s)::-1], and the same as s[::-1]\n</code></pre>\n<h2>3. Examples</h2>\n<p>Let's finish this answer with examples, explaining everything we have discussed:</p>\n<pre><code class=\"python\"># Create our array for demonstration\nIn [1]: s = [i for i in range(10)]\n\nIn [2]: s\nOut[2]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nIn [3]: s[2:]   # From index 2 to last index\nOut[3]: [2, 3, 4, 5, 6, 7, 8, 9]\n\nIn [4]: s[:8]   # From index 0 up to index 8\nOut[4]: [0, 1, 2, 3, 4, 5, 6, 7]\n\nIn [5]: s[4:7]  # From index 4 (included) up to index 7(excluded)\nOut[5]: [4, 5, 6]\n\nIn [6]: s[:-2]  # Up to second last index (negative index)\nOut[6]: [0, 1, 2, 3, 4, 5, 6, 7]\n\nIn [7]: s[-2:]  # From second last index (negative index)\nOut[7]: [8, 9]\n\nIn [8]: s[::-1] # From last to first in reverse order (negative step)\nOut[8]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\nIn [9]: s[::-2] # All odd numbers in reversed order\nOut[9]: [9, 7, 5, 3, 1]\n\nIn [11]: s[-2::-2] # All even numbers in reversed order\nOut[11]: [8, 6, 4, 2, 0]\n\nIn [12]: s[3:15]   # End is out of range, and Python will set it to len(s).\nOut[12]: [3, 4, 5, 6, 7, 8, 9]\n\nIn [14]: s[5:1]    # Start &gt; end; return empty list\nOut[14]: []\n\nIn [15]: s[11]     # Access index 11 (greater than len(s)) will raise an IndexError\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\n&lt;ipython-input-15-79ffc22473a3&gt; in &lt;module&gt;()\n----&gt; 1 s[11]\n\nIndexError: list index out of range\n</code></pre>\n", "abstract": "To make it simple, remember slice has only one form\uff1a and here is how it works: Another import thing: all start,end, step can be omitted! And if they are omitted, their default value will be used: 0,len(s),1 accordingly. So possible variations are: NOTE: If start >= end (considering only when step>0), Python will return a empty slice []. The above part explains the core features on how slice works, and it will work on most occasions. However, there can be pitfalls you should watch out, and this part explains them. The very first thing that confuses Python learners is that an index can be negative!\nDon't panic: a negative index means count backwards. For example: Making things more confusing is that step can be negative too! A negative step means iterate the array backwards: from the end to start, with the end index included, and the start index excluded from the result. NOTE: when step is negative, the default value for start is len(s) (while end does not equal to 0, because s[::-1] contains s[0]). For example: Be surprised: slice does not raise an IndexError when the index is out of range! If the index is out of range, Python will try its best to set the index to 0 or len(s) according to the situation. For example: Let's finish this answer with examples, explaining everything we have discussed:"}, {"id": 20443928, "score": 29, "vote": 0, "content": "<p>As a general rule, writing code with a lot of hardcoded index values leads to a readability\nand maintenance mess. For example, if you come back to the code a year later, you\u2019ll\nlook at it and wonder what you were thinking when you wrote it. The solution shown\nis simply a way of more clearly stating what your code is actually doing.\nIn general, the built-in slice() creates a slice object that can be used anywhere a slice\nis allowed. For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; items = [0, 1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; a = slice(2, 4)\n&gt;&gt;&gt; items[2:4]\n[2, 3]\n&gt;&gt;&gt; items[a]\n[2, 3]\n&gt;&gt;&gt; items[a] = [10,11]\n&gt;&gt;&gt; items\n[0, 1, 10, 11, 4, 5, 6]\n&gt;&gt;&gt; del items[a]\n&gt;&gt;&gt; items\n[0, 1, 4, 5, 6]\n</code></pre>\n<p>If you have a slice instance s, you can get more information about it by looking at its\ns.start, s.stop, and s.step attributes, respectively. For example:</p>\n<blockquote>\n<pre><code class=\"python\">&gt;&gt;&gt; a = slice(10, 50, 2)\n&gt;&gt;&gt; a.start\n10\n&gt;&gt;&gt; a.stop\n50\n&gt;&gt;&gt; a.step\n2\n&gt;&gt;&gt;\n</code></pre>\n</blockquote>\n", "abstract": "As a general rule, writing code with a lot of hardcoded index values leads to a readability\nand maintenance mess. For example, if you come back to the code a year later, you\u2019ll\nlook at it and wonder what you were thinking when you wrote it. The solution shown\nis simply a way of more clearly stating what your code is actually doing.\nIn general, the built-in slice() creates a slice object that can be used anywhere a slice\nis allowed. For example: If you have a slice instance s, you can get more information about it by looking at its\ns.start, s.stop, and s.step attributes, respectively. For example:"}, {"id": 42522149, "score": 29, "vote": 0, "content": "<p>The previous answers don't discuss multi-dimensional array slicing which is possible using the famous <a href=\"http://en.wikipedia.org/wiki/NumPy\" rel=\"noreferrer\">NumPy</a> package:</p>\n<p><strong>Slicing can also be applied to multi-dimensional arrays.</strong></p>\n<pre><code class=\"python\"># Here, a is a NumPy array\n\n&gt;&gt;&gt; a\narray([[ 1,  2,  3,  4],\n       [ 5,  6,  7,  8],\n       [ 9, 10, 11, 12]])\n&gt;&gt;&gt; a[:2, 0:3:2]\narray([[1, 3],\n       [5, 7]])\n</code></pre>\n<p>The \"<code>:2</code>\" before the comma operates on the first dimension and the \"<code>0:3:2</code>\" after the comma operates on the second dimension.</p>\n", "abstract": "The previous answers don't discuss multi-dimensional array slicing which is possible using the famous NumPy package: Slicing can also be applied to multi-dimensional arrays. The \":2\" before the comma operates on the first dimension and the \"0:3:2\" after the comma operates on the second dimension."}, {"id": 63047385, "score": 20, "vote": 0, "content": "<h3>The rules of slicing are as follows:</h3>\n<pre><code class=\"python\">[lower bound : upper bound : step size]\n</code></pre>\n<p><strong>I-</strong> Convert <code>upper bound</code>  and <code>lower bound</code> into common signs.</p>\n<p><strong>II-</strong> Then check if the <code>step size</code> is a <em>positive</em> or a <em>negative</em> value.</p>\n<p><strong>(i)</strong> If the <code>step size</code> is a <strong>positive value</strong>, <code>upper bound</code> should be <strong>greater than</strong> <code>lower bound</code>, otherwise <code>empty string</code> is printed. <em>For example</em>:</p>\n<pre><code class=\"python\">s=\"Welcome\"\ns1=s[0:3:1]\nprint(s1)\n</code></pre>\n<p>The output:</p>\n<pre><code class=\"python\">Wel\n</code></pre>\n<p>However if we run the following code:</p>\n<pre><code class=\"python\">s=\"Welcome\"\ns1=s[3:0:1]\nprint(s1)\n</code></pre>\n<p>It will return an <strong>empty string</strong>.</p>\n<p><strong>(ii)</strong> If the <code>step size</code> if a <strong>negative value</strong>, <code>upper bound</code> should be <strong>lesser than</strong> <code>lower bound</code>, otherwise <code>empty string</code> will be printed. For example:</p>\n<pre><code class=\"python\">s=\"Welcome\"\ns1=s[3:0:-1]\nprint(s1)\n</code></pre>\n<p>The output:</p>\n<pre><code class=\"python\">cle\n</code></pre>\n<p>But if we run the following code:</p>\n<pre><code class=\"python\">s=\"Welcome\"\ns1=s[0:5:-1]\nprint(s1)\n</code></pre>\n<p>The output will be an <strong>empty string</strong>.</p>\n<p>Thus in the code:</p>\n<pre><code class=\"python\">str = 'abcd'\nl = len(str)\nstr2 = str[l-1:0:-1]    #str[3:0:-1] \nprint(str2)\nstr2 = str[l-1:-1:-1]    #str[3:-1:-1]\nprint(str2)\n</code></pre>\n<p>In the first <code>str2=str[l-1:0:-1]</code>, the <code>upper bound</code> is <strong>lesser than</strong> the <code>lower bound</code>, thus <code>dcb</code> is printed.</p>\n<p>However in <code>str2=str[l-1:-1:-1]</code>, the <code>upper bound</code> is <strong>not less than</strong> the <code>lower bound</code> (upon converting <code>lower bound</code> into <strong>negative value</strong> which is <code>-1</code>: since <code>index</code> of last element is -1 as well as 3).</p>\n", "abstract": "I- Convert upper bound  and lower bound into common signs. II- Then check if the step size is a positive or a negative value. (i) If the step size is a positive value, upper bound should be greater than lower bound, otherwise empty string is printed. For example: The output: However if we run the following code: It will return an empty string. (ii) If the step size if a negative value, upper bound should be lesser than lower bound, otherwise empty string will be printed. For example: The output: But if we run the following code: The output will be an empty string. Thus in the code: In the first str2=str[l-1:0:-1], the upper bound is lesser than the lower bound, thus dcb is printed. However in str2=str[l-1:-1:-1], the upper bound is not less than the lower bound (upon converting lower bound into negative value which is -1: since index of last element is -1 as well as 3)."}, {"id": 47765245, "score": 18, "vote": 0, "content": "<p>In my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on).</p>\n<p>Let's work with the following string ...</p>\n<pre><code class=\"python\">azString = \"abcdefghijklmnopqrstuvwxyz\"\n</code></pre>\n<p>For those who don't know, you can create any substring from <code>azString</code> using the notation <code>azString[x:y]</code></p>\n<p>Coming from other programming languages, that's when the common sense gets compromised. What are x and y?</p>\n<p>I had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt.</p>\n<p>My conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as <code>azString[index1, index2]</code> or even more clearer as <code>azString[index_of_first_character, index_after_the_last_character]</code>.</p>\n<p>Here is an example visualization of that ...</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">Letters   a b c d e f g h i j ...\n         \u2191 \u2191 \u2191 \u2191 \u2191 \u2191 \u2191 \u2191 \u2191 \u2191\n             \u250a           \u250a\nIndexes  0 1 2 3 4 5 6 7 8 9 ...\n             \u250a           \u250a\ncdefgh    index1       index2\n</code></pre>\n<p>So all you have to do is setting index1 and index2 to the values that will surround the desired substring. For instance, to get the substring \"cdefgh\", you can use <code>azString[2:8]</code>, because the index on the left side of \"c\" is 2 and the one on the right size of \"h\" is 8.</p>\n<p>Remember that we are setting the boundaries. And those boundaries are the positions where you could place some brackets that will be wrapped around the substring like this ...</p>\n<p>a b <strong>[</strong> c d e f g h <strong>]</strong> i j</p>\n<p>That trick works all the time and is easy to memorize.</p>\n", "abstract": "In my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on). Let's work with the following string ... For those who don't know, you can create any substring from azString using the notation azString[x:y] Coming from other programming languages, that's when the common sense gets compromised. What are x and y? I had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt. My conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as azString[index1, index2] or even more clearer as azString[index_of_first_character, index_after_the_last_character]. Here is an example visualization of that ... So all you have to do is setting index1 and index2 to the values that will surround the desired substring. For instance, to get the substring \"cdefgh\", you can use azString[2:8], because the index on the left side of \"c\" is 2 and the one on the right size of \"h\" is 8. Remember that we are setting the boundaries. And those boundaries are the positions where you could place some brackets that will be wrapped around the substring like this ... a b [ c d e f g h ] i j That trick works all the time and is easy to memorize."}, {"id": 57628026, "score": 18, "vote": 0, "content": "<p>I personally think about it like a <code>for</code> loop:</p>\n<pre><code class=\"python\">a[start:end:step]\n# for(i = start; i &lt; end; i += step)\n</code></pre>\n<p>Also, note that negative values for <code>start</code> and <code>end</code> are relative to the end of the list and computed in the example above by <code>given_index + a.shape[0]</code>.</p>\n", "abstract": "I personally think about it like a for loop: Also, note that negative values for start and end are relative to the end of the list and computed in the example above by given_index + a.shape[0]."}, {"id": 26442691, "score": 17, "vote": 0, "content": "<pre><code class=\"python\">#!/usr/bin/env python\n\ndef slicegraphical(s, lista):\n\n    if len(s) &gt; 9:\n        print \"\"\"Enter a string of maximum 9 characters,\n    so the printig would looki nice\"\"\"\n        return 0;\n    # print \" \",\n    print '  '+'+---' * len(s) +'+'\n    print ' ',\n    for letter in s:\n        print '| {}'.format(letter),\n    print '|'\n    print \" \",; print '+---' * len(s) +'+'\n\n    print \" \",\n    for letter in range(len(s) +1):\n        print '{}  '.format(letter),\n    print \"\"\n    for letter in range(-1*(len(s)), 0):\n        print ' {}'.format(letter),\n    print ''\n    print ''\n\n\n    for triada in lista:\n        if len(triada) == 3:\n            if triada[0]==None and triada[1] == None and triada[2] == None:\n                # 000\n                print s+'[   :   :   ]' +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] == None and triada[1] == None and triada[2] != None:\n                # 001\n                print s+'[   :   :{0:2d} ]'.format(triada[2], '','') +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] == None and triada[1] != None and triada[2] == None:\n                # 010\n                print s+'[   :{0:2d} :   ]'.format(triada[1]) +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] == None and triada[1] != None and triada[2] != None:\n                # 011\n                print s+'[   :{0:2d} :{1:2d} ]'.format(triada[1], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] != None and triada[1] == None and triada[2] == None:\n                # 100\n                print s+'[{0:2d} :   :   ]'.format(triada[0]) +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] != None and triada[1] == None and triada[2] != None:\n                # 101\n                print s+'[{0:2d} :   :{1:2d} ]'.format(triada[0], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] != None and triada[1] != None and triada[2] == None:\n                # 110\n                print s+'[{0:2d} :{1:2d} :   ]'.format(triada[0], triada[1]) +' = ', s[triada[0]:triada[1]:triada[2]]\n            elif triada[0] != None and triada[1] != None and triada[2] != None:\n                # 111\n                print s+'[{0:2d} :{1:2d} :{2:2d} ]'.format(triada[0], triada[1], triada[2]) +' = ', s[triada[0]:triada[1]:triada[2]]\n\n        elif len(triada) == 2:\n            if triada[0] == None and triada[1] == None:\n                # 00\n                print s+'[   :   ]    ' + ' = ', s[triada[0]:triada[1]]\n            elif triada[0] == None and triada[1] != None:\n                # 01\n                print s+'[   :{0:2d} ]    '.format(triada[1]) + ' = ', s[triada[0]:triada[1]]\n            elif triada[0] != None and triada[1] == None:\n                # 10\n                print s+'[{0:2d} :   ]    '.format(triada[0]) + ' = ', s[triada[0]:triada[1]]\n            elif triada[0] != None and triada[1] != None:\n                # 11\n                print s+'[{0:2d} :{1:2d} ]    '.format(triada[0],triada[1]) + ' = ', s[triada[0]:triada[1]]\n\n        elif len(triada) == 1:\n            print s+'[{0:2d} ]        '.format(triada[0]) + ' = ', s[triada[0]]\n\n\nif __name__ == '__main__':\n    # Change \"s\" to what ever string you like, make it 9 characters for\n    # better representation.\n    s = 'COMPUTERS'\n\n    # add to this list different lists to experement with indexes\n    # to represent ex. s[::], use s[None, None,None], otherwise you get an error\n    # for s[2:] use s[2:None]\n\n    lista = [[4,7],[2,5,2],[-5,1,-1],[4],[-4,-6,-1], [2,-3,1],[2,-3,-1], [None,None,-1],[-5,None],[-5,0,-1],[-5,None,-1],[-1,1,-2]]\n\n    slicegraphical(s, lista)\n</code></pre>\n<p>You can run this script and experiment with it, below is some samples that I got from the script.</p>\n<pre><code class=\"python\">  +---+---+---+---+---+---+---+---+---+\n  | C | O | M | P | U | T | E | R | S |\n  +---+---+---+---+---+---+---+---+---+\n  0   1   2   3   4   5   6   7   8   9   \n -9  -8  -7  -6  -5  -4  -3  -2  -1 \n\nCOMPUTERS[ 4 : 7 ]     =  UTE\nCOMPUTERS[ 2 : 5 : 2 ] =  MU\nCOMPUTERS[-5 : 1 :-1 ] =  UPM\nCOMPUTERS[ 4 ]         =  U\nCOMPUTERS[-4 :-6 :-1 ] =  TU\nCOMPUTERS[ 2 :-3 : 1 ] =  MPUT\nCOMPUTERS[ 2 :-3 :-1 ] =  \nCOMPUTERS[   :   :-1 ] =  SRETUPMOC\nCOMPUTERS[-5 :   ]     =  UTERS\nCOMPUTERS[-5 : 0 :-1 ] =  UPMO\nCOMPUTERS[-5 :   :-1 ] =  UPMOC\nCOMPUTERS[-1 : 1 :-2 ] =  SEUM\n[Finished in 0.9s]\n</code></pre>\n<p>When using a negative step, notice that the answer is shifted to the right by 1.</p>\n", "abstract": "You can run this script and experiment with it, below is some samples that I got from the script. When using a negative step, notice that the answer is shifted to the right by 1."}, {"id": 37455246, "score": 14, "vote": 0, "content": "<p>My brain seems happy to accept that <code>lst[start:end]</code> contains the <code>start</code>-th item. I might even say that it is a 'natural assumption'.</p>\n<p>But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the <code>end</code>-th element.</p>\n<p>In these moments I rely on this simple theorem:</p>\n<pre><code class=\"python\">for any n,    lst = lst[:n] + lst[n:]\n</code></pre>\n<p>This pretty property tells me that <code>lst[start:end]</code> does not contain the <code>end</code>-th item because it is in <code>lst[end:]</code>.</p>\n<p>Note that this theorem is true for any <code>n</code> at all. For example, you can check that</p>\n<pre><code class=\"python\">lst = range(10)\nlst[:-42] + lst[-42:] == lst\n</code></pre>\n<p>returns <code>True</code>.</p>\n", "abstract": "My brain seems happy to accept that lst[start:end] contains the start-th item. I might even say that it is a 'natural assumption'. But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the end-th element. In these moments I rely on this simple theorem: This pretty property tells me that lst[start:end] does not contain the end-th item because it is in lst[end:]. Note that this theorem is true for any n at all. For example, you can check that returns True."}, {"id": 49647978, "score": 12, "vote": 0, "content": "<p>I want to add one <em>Hello, World!</em> example that explains the basics of slices for the very beginners. It helped me a lot.</p>\n<p>Let's have a list with six values <code>['P', 'Y', 'T', 'H', 'O', 'N']</code>:</p>\n<pre><code class=\"python\">+---+---+---+---+---+---+\n| P | Y | T | H | O | N |\n+---+---+---+---+---+---+\n  0   1   2   3   4   5\n</code></pre>\n<p>Now the simplest slices of that list are its sublists. The notation is <code>[&lt;index&gt;:&lt;index&gt;]</code> and the key is to read it like this:</p>\n<pre><code class=\"python\">[ start cutting before this index : end cutting before this index ]\n</code></pre>\n<p>Now if you make a slice <code>[2:5]</code> of the list above, this will happen:</p>\n<pre><code class=\"python\">        |           |\n+---+---|---+---+---|---+\n| P | Y | T | H | O | N |\n+---+---|---+---+---|---+\n  0   1 | 2   3   4 | 5\n</code></pre>\n<p>You made a cut <strong>before</strong> the element with index <code>2</code> and another cut <strong>before</strong> the element with index <code>5</code>. So the result will be a slice between those two cuts, a list <code>['T', 'H', 'O']</code>.</p>\n", "abstract": "I want to add one Hello, World! example that explains the basics of slices for the very beginners. It helped me a lot. Let's have a list with six values ['P', 'Y', 'T', 'H', 'O', 'N']: Now the simplest slices of that list are its sublists. The notation is [<index>:<index>] and the key is to read it like this: Now if you make a slice [2:5] of the list above, this will happen: You made a cut before the element with index 2 and another cut before the element with index 5. So the result will be a slice between those two cuts, a list ['T', 'H', 'O']."}, {"id": 46040689, "score": 11, "vote": 0, "content": "<p>In Python, the most basic form for slicing is the following:</p>\n<pre><code class=\"python\">l[start:end]\n</code></pre>\n<p>where <code>l</code> is some collection, <code>start</code> is an inclusive index, and <code>end</code> is an exclusive index.</p>\n<pre><code class=\"python\">In [1]: l = list(range(10))\n\nIn [2]: l[:5] # First five elements\nOut[2]: [0, 1, 2, 3, 4]\n\nIn [3]: l[-5:] # Last five elements\nOut[3]: [5, 6, 7, 8, 9]\n</code></pre>\n<p>When slicing from the start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose:</p>\n<pre><code class=\"python\">In [5]: l[:3] == l[0:3]\nOut[5]: True\n\nIn [6]: l[7:] == l[7:len(l)]\nOut[6]: True\n</code></pre>\n<p>Negative integers are useful when doing offsets relative to the end of a collection:</p>\n<pre><code class=\"python\">In [7]: l[:-1] # Include all elements but the last one\nOut[7]: [0, 1, 2, 3, 4, 5, 6, 7, 8]\n\nIn [8]: l[-3:] # Take the last three elements\nOut[8]: [7, 8, 9]\n</code></pre>\n<p>It is possible to provide indices that are out of bounds when slicing such as:</p>\n<pre><code class=\"python\">In [9]: l[:20] # 20 is out of index bounds, and l[20] will raise an IndexError exception\nOut[9]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nIn [11]: l[-20:] # -20 is out of index bounds, and l[-20] will raise an IndexError exception\nOut[11]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<p>Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignments do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values:</p>\n<pre><code class=\"python\">In [16]: l[2:6] = list('abc') # Assigning fewer elements than the ones contained in the sliced collection l[2:6]\n\nIn [17]: l\nOut[17]: [0, 1, 'a', 'b', 'c', 6, 7, 8, 9]\n\nIn [18]: l[2:5] = list('hello') # Assigning more elements than the ones contained in the sliced collection l [2:5]\n\nIn [19]: l\nOut[19]: [0, 1, 'h', 'e', 'l', 'l', 'o', 6, 7, 8, 9]\n</code></pre>\n<p>If you omit the start and end index, you will make a copy of the collection:</p>\n<pre><code class=\"python\">In [14]: l_copy = l[:]\n\nIn [15]: l == l_copy and l is not l_copy\nOut[15]: True\n</code></pre>\n<p>If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced:</p>\n<pre><code class=\"python\">In [20]: l[:] = list('hello...')\n\nIn [21]: l\nOut[21]: ['h', 'e', 'l', 'l', 'o', '.', '.', '.']\n</code></pre>\n<p>Besides basic slicing, it is also possible to apply the following notation:</p>\n<pre><code class=\"python\">l[start:end:step]\n</code></pre>\n<p>where <code>l</code> is a collection, <code>start</code> is an inclusive index, <code>end</code> is an exclusive index, and <code>step</code> is a stride that can be used to take every <em>nth</em> item in <code>l</code>.</p>\n<pre><code class=\"python\">In [22]: l = list(range(10))\n\nIn [23]: l[::2] # Take the elements which indexes are even\nOut[23]: [0, 2, 4, 6, 8]\n\nIn [24]: l[1::2] # Take the elements which indexes are odd\nOut[24]: [1, 3, 5, 7, 9]\n</code></pre>\n<p>Using <code>step</code> provides a useful trick to reverse a collection in Python:</p>\n<pre><code class=\"python\">In [25]: l[::-1]\nOut[25]: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n</code></pre>\n<p>It is also possible to use negative integers for <code>step</code> as the following example:</p>\n<pre><code class=\"python\">In[28]:  l[::-2]\nOut[28]: [9, 7, 5, 3, 1]\n</code></pre>\n<p>However, using a negative value for <code>step</code> could become very confusing. Moreover, in order to be <a href=\"https://en.wiktionary.org/wiki/Pythonic#Adjective\" rel=\"nofollow noreferrer\">Pythonic</a>, you should avoid using <code>start</code>, <code>end</code>, and <code>step</code> in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).</p>\n<pre><code class=\"python\">In [29]: l = l[::2] # This step is for striding\n\nIn [30]: l\nOut[30]: [0, 2, 4, 6, 8]\n\nIn [31]: l = l[1:-1] # This step is for slicing\n\nIn [32]: l\nOut[32]: [2, 4, 6]\n</code></pre>\n", "abstract": "In Python, the most basic form for slicing is the following: where l is some collection, start is an inclusive index, and end is an exclusive index. When slicing from the start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose: Negative integers are useful when doing offsets relative to the end of a collection: It is possible to provide indices that are out of bounds when slicing such as: Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignments do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values: If you omit the start and end index, you will make a copy of the collection: If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced: Besides basic slicing, it is also possible to apply the following notation: where l is a collection, start is an inclusive index, end is an exclusive index, and step is a stride that can be used to take every nth item in l. Using step provides a useful trick to reverse a collection in Python: It is also possible to use negative integers for step as the following example: However, using a negative value for step could become very confusing. Moreover, in order to be Pythonic, you should avoid using start, end, and step in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride)."}, {"id": 46614773, "score": 11, "vote": 0, "content": "<p>Most of the previous answers clears up questions about slice notation.</p>\n<p>The extended indexing syntax used for slicing is <code>aList[start:stop:step]</code>, and basic examples are:</p>\n<p><a href=\"https://i.stack.imgur.com/IVkET.jpg\" rel=\"nofollow noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/IVkET.jpg\"/></a>:</p>\n<p>More slicing examples: <a href=\"https://docs.python.org/2.3/whatsnew/section-slices.html\" rel=\"nofollow noreferrer\">15 Extended Slices</a></p>\n", "abstract": "Most of the previous answers clears up questions about slice notation. The extended indexing syntax used for slicing is aList[start:stop:step], and basic examples are: : More slicing examples: 15 Extended Slices"}, {"id": 45370737, "score": 9, "vote": 0, "content": "<p>The below is the example of an index of a string:</p>\n<pre><code class=\"python\"> +---+---+---+---+---+\n | H | e | l | p | A |\n +---+---+---+---+---+\n 0   1   2   3   4   5\n-5  -4  -3  -2  -1\n\nstr=\"Name string\"\n</code></pre>\n<p>Slicing example: [start:end:step]</p>\n<pre><code class=\"python\">str[start:end] # Items start through end-1\nstr[start:]    # Items start through the rest of the array\nstr[:end]      # Items from the beginning through end-1\nstr[:]         # A copy of the whole array\n</code></pre>\n<p>Below is the example usage:</p>\n<pre><code class=\"python\">print str[0] = N\nprint str[0:2] = Na\nprint str[0:7] = Name st\nprint str[0:7:2] = Nm t\nprint str[0:-1:2] = Nm ti\n</code></pre>\n", "abstract": "The below is the example of an index of a string: Slicing example: [start:end:step] Below is the example usage:"}, {"id": 47880987, "score": 8, "vote": 0, "content": "<p>If you feel negative indices in slicing is confusing, here's a very easy way to think about it: just replace the negative index with <code>len - index</code>. So for example, replace -3 with <code>len(list) - 3</code>.</p>\n<p>The best way to illustrate what slicing does internally is just show it in code that implements this operation:</p>\n<pre><code class=\"python\">def slice(list, start = None, end = None, step = 1):\n  # Take care of missing start/end parameters\n  start = 0 if start is None else start\n  end = len(list) if end is None else end\n\n  # Take care of negative start/end parameters\n  start = len(list) + start if start &lt; 0 else start\n  end = len(list) + end if end &lt; 0 else end\n\n  # Now just execute a for-loop with start, end and step\n  return [list[i] for i in range(start, end, step)]\n</code></pre>\n", "abstract": "If you feel negative indices in slicing is confusing, here's a very easy way to think about it: just replace the negative index with len - index. So for example, replace -3 with len(list) - 3. The best way to illustrate what slicing does internally is just show it in code that implements this operation:"}, {"id": 51479594, "score": 7, "vote": 0, "content": "<p>The basic slicing technique is to define the starting point, the stopping point, and the step size\u2014also known as stride.</p>\n<p>First, we will create a list of values to use in our slicing.</p>\n<p>Create two lists to slice. The first is a numeric list from 1 to 9 (List A). The second is also a numeric list, from 0 to 9 (List B):</p>\n<pre><code class=\"python\">A = list(range(1, 10, 1)) # Start, stop, and step\nB = list(range(9))\n\nprint(\"This is List A:\", A)\nprint(\"This is List B:\", B)\n</code></pre>\n<p>Index the number 3 from A and the number 6 from B.</p>\n<pre><code class=\"python\">print(A[2])\nprint(B[6])\n</code></pre>\n<h3>Basic Slicing</h3>\n<p>Extended indexing syntax used for slicing is <code>aList[start:stop:step]</code>. The start argument and the step argument both default to <code>None</code>\u2014the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by <code>range(start, stop, step)</code>.</p>\n<p>As you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element.</p>\n<p>It is important to note, the first element is index 0, <em>not</em> index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc.) while List B's elements are the numbers that would be used to index them (<code>[0]</code> for the first element, 0, etc.).</p>\n<p>With extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon.</p>\n<pre><code class=\"python\">A[:]\n</code></pre>\n<p>To retrieve a subset of elements, the start and stop positions need to be defined.</p>\n<p>Given the pattern <code>aList[start:stop]</code>, retrieve the first two elements from List A.</p>\n", "abstract": "The basic slicing technique is to define the starting point, the stopping point, and the step size\u2014also known as stride. First, we will create a list of values to use in our slicing. Create two lists to slice. The first is a numeric list from 1 to 9 (List A). The second is also a numeric list, from 0 to 9 (List B): Index the number 3 from A and the number 6 from B. Extended indexing syntax used for slicing is aList[start:stop:step]. The start argument and the step argument both default to None\u2014the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by range(start, stop, step). As you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element. It is important to note, the first element is index 0, not index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc.) while List B's elements are the numbers that would be used to index them ([0] for the first element, 0, etc.). With extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon. To retrieve a subset of elements, the start and stop positions need to be defined. Given the pattern aList[start:stop], retrieve the first two elements from List A."}, {"id": 56332104, "score": 7, "vote": 0, "content": "<p>I don't think that the <a href=\"https://docs.python.org/3/tutorial/introduction.html#strings\" rel=\"noreferrer\">Python tutorial</a> diagram (cited in various other answers) is good as this suggestion works for positive stride, but does not for a negative stride.</p>\n<p>This is the diagram:</p>\n<pre><code class=\"python\"> +---+---+---+---+---+---+\n | P | y | t | h | o | n |\n +---+---+---+---+---+---+\n 0   1   2   3   4   5   6\n-6  -5  -4  -3  -2  -1\n\n</code></pre>\n<p>From the diagram, I expect <code>a[-4,-6,-1]</code> to be <code>yP</code> but it is <code>ty</code>.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; a = \"Python\"\n&gt;&gt;&gt; a[2:4:1] # as expected\n'th'\n&gt;&gt;&gt; a[-4:-6:-1] # off by 1\n'ty'\n</code></pre>\n<p>What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride.</p>\n<p>This way, I can think of <code>a[-4:-6:-1]</code> as <code>a(-6,-4]</code> in interval terminology.</p>\n<pre><code class=\"python\"> +---+---+---+---+---+---+\n | P | y | t | h | o | n |\n +---+---+---+---+---+---+\n   0   1   2   3   4   5  \n  -6  -5  -4  -3  -2  -1\n\n +---+---+---+---+---+---+---+---+---+---+---+---+\n | P | y | t | h | o | n | P | y | t | h | o | n |\n +---+---+---+---+---+---+---+---+---+---+---+---+\n  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5  \n</code></pre>\n", "abstract": "I don't think that the Python tutorial diagram (cited in various other answers) is good as this suggestion works for positive stride, but does not for a negative stride. This is the diagram: From the diagram, I expect a[-4,-6,-1] to be yP but it is ty. What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride. This way, I can think of a[-4:-6:-1] as a(-6,-4] in interval terminology."}, {"id": 56591541, "score": 3, "vote": 0, "content": "<p>I got a little frustrated in not finding an online source, or Python documentation that describes precisely what slicing does.</p>\n<p>I took Aaron Hall's suggestion, read the relevant parts of the CPython source code, and wrote some Python code that performs slicing similarly to how it's done in CPython. I've tested my code in Python 3 on millions of random tests on integer lists.</p>\n<p>You may find the references in my code to the relevant functions in CPython helpful.</p>\n<pre><code class=\"python\">def slicer(x, start=None, stop=None, step=None):\n    \"\"\" Return the result of slicing list x.  \n\n    See the part of list_subscript() in listobject.c that pertains \n    to when the indexing item is a PySliceObject.\n    \"\"\"\n\n    # Handle slicing index values of None, and a step value of 0.\n    # See PySlice_Unpack() in sliceobject.c, which\n    # extracts start, stop, step from a PySliceObject.\n    maxint = 10000000       # A hack to simulate PY_SSIZE_T_MAX\n    if step is None:\n        step = 1\n    elif step == 0:\n        raise ValueError('slice step cannot be zero')\n\n    if start is None:\n        start = maxint if step &lt; 0 else 0\n    if stop is None:\n        stop = -maxint if step &lt; 0 else maxint\n\n    # Handle negative slice indexes and bad slice indexes.\n    # Compute number of elements in the slice as slice_length.\n    # See PySlice_AdjustIndices() in sliceobject.c\n    length = len(x)\n    slice_length = 0\n\n    if start &lt; 0:\n        start += length\n        if start &lt; 0:\n            start = -1 if step &lt; 0 else 0\n    elif start &gt;= length:\n        start = length - 1 if step &lt; 0 else length\n\n    if stop &lt; 0:\n        stop += length\n        if stop &lt; 0:\n            stop = -1 if step &lt; 0 else 0\n    elif stop &gt; length:\n        stop = length - 1 if step &lt; 0 else length\n\n    if step &lt; 0:\n        if stop &lt; start:\n            slice_length = (start - stop - 1) // (-step) + 1\n    else:\n        if start &lt; stop:\n            slice_length = (stop - start - 1) // step + 1\n\n    # Cases of step = 1 and step != 1 are treated separately\n    if slice_length &lt;= 0:\n        return []\n    elif step == 1:\n        # See list_slice() in listobject.c\n        result = []\n        for i in range(stop - start):\n            result.append(x[i+start])\n        return result\n    else:\n        result = []\n        cur = start\n        for i in range(slice_length):\n            result.append(x[cur])\n            cur += step\n        return result\n</code></pre>\n", "abstract": "I got a little frustrated in not finding an online source, or Python documentation that describes precisely what slicing does. I took Aaron Hall's suggestion, read the relevant parts of the CPython source code, and wrote some Python code that performs slicing similarly to how it's done in CPython. I've tested my code in Python 3 on millions of random tests on integer lists. You may find the references in my code to the relevant functions in CPython helpful."}, {"id": 53953716, "score": 2, "vote": 0, "content": "<p>It is easy to understand if we could relate slicing to <code>range</code>, which gives the indexes. We can categorize slicing into the following two categories:</p>\n<hr/>\n<h2>1. No step or step &gt; 0. For example, <code>[i:j]</code> or <code>[i:j:k]</code> (k&gt;0)</h2>\n<p>Suppose the sequence is <code>s=[1,2,3,4,5]</code>.</p>\n<ul>\n<li>if <code>0&lt;i&lt;len(s)</code> and <code>0&lt;j&lt;len(s)</code>, then <code>[i:j:k] -&gt; range(i,j,k)</code></li>\n</ul>\n<p>For example, <code>[0:3:2] -&gt; range(0,3,2) -&gt; 0, 2</code></p>\n<ul>\n<li>if <code>i&gt;len(s)</code> or <code>j&gt;len(s)</code>, then <code>i=len(s)</code> or <code>j=len(s)</code></li>\n</ul>\n<p>For example, <code>[0:100:2] -&gt; range(0,len(s),2) -&gt; range(0,5,2) -&gt; 0, 2, 4</code></p>\n<ul>\n<li>if <code>i&lt;0</code> or <code>j&lt;0</code>, then <code>i=max(0,len(s)+i)</code> or <code>j=max(0,len(s)+j)</code></li>\n</ul>\n<p>For example, <code>[0:-3:2] -&gt; range(0,len(s)-3,2) -&gt; range(0,2,2) -&gt; 0</code></p>\n<p>For another example, <code>[0:-1:2] -&gt; range(0,len(s)-1,2) -&gt; range(0,4,2) -&gt; 0, 2</code></p>\n<ul>\n<li>if <code>i</code> is not specified, then <code>i=0</code></li>\n</ul>\n<p>For example, <code>[:4:2] -&gt; range(0,4,2) -&gt; range(0,4,2) -&gt; 0, 2</code></p>\n<ul>\n<li>if <code>j</code> is not specified, then <code>j=len(s)</code></li>\n</ul>\n<p>For example, <code>[0::2] -&gt; range(0,len(s),2) -&gt; range(0,5,2) -&gt; 0, 2, 4</code></p>\n<hr/>\n<h2>2. Step &lt; 0. For example, <code>[i:j:k]</code> (k&lt;0)</h2>\n<p>Suppose the sequence is <code>s=[1,2,3,4,5]</code>.</p>\n<ul>\n<li>if <code>0&lt;i&lt;len(s)</code> and <code>0&lt;j&lt;len(s)</code>, then <code>[i:j:k] -&gt; range(i,j,k)</code></li>\n</ul>\n<p>For example, <code>[5:0:-2] -&gt; range(5,0,-2) -&gt; 5, 3, 1</code></p>\n<ul>\n<li>if <code>i&gt;len(s)</code> or <code>j&gt;len(s)</code>, then <code>i=len(s)-1</code> or <code>j=len(s)-1</code></li>\n</ul>\n<p>For example, <code>[100:0:-2] -&gt; range(len(s)-1,0,-2) -&gt; range(4,0,-2) -&gt; 4, 2</code></p>\n<ul>\n<li>if <code>i&lt;0</code> or <code>j&lt;0</code>, then <code>i=max(-1,len(s)+i)</code> or <code>j=max(-1,len(s)+j)</code></li>\n</ul>\n<p>For example, <code>[-2:-10:-2] -&gt; range(len(s)-2,-1,-2) -&gt; range(3,-1,-2) -&gt; 3, 1</code></p>\n<ul>\n<li>if <code>i</code> is not specified, then <code>i=len(s)-1</code></li>\n</ul>\n<p>For example, <code>[:0:-2] -&gt; range(len(s)-1,0,-2) -&gt; range(4,0,-2) -&gt; 4, 2</code></p>\n<ul>\n<li>if <code>j</code> is not specified, then <code>j=-1</code></li>\n</ul>\n<p>For example, <code>[2::-2] -&gt; range(2,-1,-2) -&gt; 2, 0</code></p>\n<p>For another example, <code>[::-1] -&gt; range(len(s)-1,-1,-1) -&gt; range(4,-1,-1) -&gt; 4, 3, 2, 1, 0</code></p>\n<hr/>\n<h2>In summary</h2>\n<p><a href=\"https://i.stack.imgur.com/4DLrK.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/4DLrK.png\"/></a></p>\n", "abstract": "It is easy to understand if we could relate slicing to range, which gives the indexes. We can categorize slicing into the following two categories: Suppose the sequence is s=[1,2,3,4,5]. For example, [0:3:2] -> range(0,3,2) -> 0, 2 For example, [0:100:2] -> range(0,len(s),2) -> range(0,5,2) -> 0, 2, 4 For example, [0:-3:2] -> range(0,len(s)-3,2) -> range(0,2,2) -> 0 For another example, [0:-1:2] -> range(0,len(s)-1,2) -> range(0,4,2) -> 0, 2 For example, [:4:2] -> range(0,4,2) -> range(0,4,2) -> 0, 2 For example, [0::2] -> range(0,len(s),2) -> range(0,5,2) -> 0, 2, 4 Suppose the sequence is s=[1,2,3,4,5]. For example, [5:0:-2] -> range(5,0,-2) -> 5, 3, 1 For example, [100:0:-2] -> range(len(s)-1,0,-2) -> range(4,0,-2) -> 4, 2 For example, [-2:-10:-2] -> range(len(s)-2,-1,-2) -> range(3,-1,-2) -> 3, 1 For example, [:0:-2] -> range(len(s)-1,0,-2) -> range(4,0,-2) -> 4, 2 For example, [2::-2] -> range(2,-1,-2) -> 2, 0 For another example, [::-1] -> range(len(s)-1,-1,-1) -> range(4,-1,-1) -> 4, 3, 2, 1, 0 "}, {"id": 71640042, "score": 1, "vote": 0, "content": "<p>The important idea to remember about indices of a sequence is that</p>\n<ul>\n<li><em>nonnegative</em> indices begin at the <em>first</em> item in the sequence;</li>\n<li><em>negative</em> indices begin at the <em>last</em> item in the sequence (so only apply to finite sequences).</li>\n</ul>\n<p>In other words, negative indices are shifted right by the length of the sequence:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">              0   1   2   3   4   5   6   7   ...\n            -------------------------\n            | a | b | c | d | e | f |\n            -------------------------\n...  -8  -7  -6  -5  -4  -3  -2  -1\n</code></pre>\n<p>With that in mind, <a href=\"https://docs.python.org/3/reference/expressions.html#subscriptions\" rel=\"nofollow noreferrer\">subscription</a> and <a href=\"https://docs.python.org/3/reference/expressions.html#slicings\" rel=\"nofollow noreferrer\">slicing</a> are straightforward.</p>\n<h1>Subscription</h1>\n<p>Subscription uses the following syntax:*</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">sequence[index]\n</code></pre>\n<p>Subscription selects a single item in the <code>sequence</code> at <code>index</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; 'abcdef'[0]\n'a'\n&gt;&gt;&gt; 'abcdef'[-6]\n'a'\n</code></pre>\n<p>Subscription raises an <code>IndexError</code> for an <code>index</code> that is out of range:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; 'abcdef'[100]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nIndexError: string index out of range\n</code></pre>\n<h1>Slicing</h1>\n<p>Slicing uses the following syntax:**</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">sequence[start:stop:step]\n</code></pre>\n<p>Slicing selects a range of items in the <code>sequence</code>, beginning at <code>start</code> <em>inclusive</em> and ending at <code>stop</code> <em>exclusive</em>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; 'abcdef'[0:2:1]\n'ab'\n&gt;&gt;&gt; 'abcdef'[0:-4:1]\n'ab'\n&gt;&gt;&gt; 'abcdef'[-6:-4:1]\n'ab'\n&gt;&gt;&gt; 'abcdef'[-6:2:1]\n'ab'\n&gt;&gt;&gt; 'abcdef'[1:-7:-1]\n'ba'\n&gt;&gt;&gt; 'abcdef'[-5:-7:-1]\n'ba'\n</code></pre>\n<p>Slicing defaults to the <em>fullest</em> range of items in the <code>sequence</code>, so it uses the following default values for any <code>start</code>, <code>stop</code>, or <code>step</code> that is omitted or equal to <code>None</code>:***</p>\n<ul>\n<li><code>step</code> defaults to <code>1</code>;</li>\n<li>if <code>step</code> is positive\n<ul>\n<li><code>start</code> defaults to <code>0</code> (first item index),</li>\n<li><code>stop</code> defaults to <code>start + len(sequence)</code> (last item index plus one);</li>\n</ul>\n</li>\n<li>if <code>step</code> is negative\n<ul>\n<li><code>start</code> defaults to <code>-1</code> (last item index),</li>\n<li><code>stop</code> defaults to <code>start - len(sequence)</code> (first item index minus one).</li>\n</ul>\n</li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; 'abcdef'[0:6:1]\n'abcdef'\n&gt;&gt;&gt; 'abcdef'[::]\n'abcdef'\n&gt;&gt;&gt; 'abcdef'[-1:-7:-1]\n'fedcba'\n&gt;&gt;&gt; 'abcdef'[::-1]\n'fedcba'\n</code></pre>\n<p>Slicing raises a <code>ValueError</code> for a <code>step</code> that is equal to zero:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; 'abcdef'[::0]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: slice step cannot be zero\n</code></pre>\n<p>Slicing does not raise an <code>IndexError</code> for a <code>start</code> or <code>stop</code> that is out of range (contrary to subscription):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; 'abcdef'[-100:100]\n'abcdef'\n</code></pre>\n<hr/>\n<p>* The expressions <code>sequence[index]</code> and <code>sequence.__getitem__(index)</code> are equivalent.</p>\n<p>** The expressions <code>sequence[start:stop:step]</code>, <code>sequence[slice(start, stop, step)]</code>, and <code>sequence.__getitem__(slice(start, stop, step))</code> are equivalent, where the <a href=\"https://docs.python.org/3/library/functions.html#slice\" rel=\"nofollow noreferrer\">built-in class <code>slice</code></a> instance packs <code>start</code>, <code>stop</code>, and <code>step</code>.</p>\n<p>*** The expressions <code>sequence[:]</code>, <code>sequence[::]</code>, and <code>sequence[None:None:None]</code> use default values for <code>start</code>, <code>stop</code>, and <code>step</code>.</p>\n", "abstract": "The important idea to remember about indices of a sequence is that In other words, negative indices are shifted right by the length of the sequence: With that in mind, subscription and slicing are straightforward. Subscription uses the following syntax:* Subscription selects a single item in the sequence at index: Subscription raises an IndexError for an index that is out of range: Slicing uses the following syntax:** Slicing selects a range of items in the sequence, beginning at start inclusive and ending at stop exclusive: Slicing defaults to the fullest range of items in the sequence, so it uses the following default values for any start, stop, or step that is omitted or equal to None:*** Slicing raises a ValueError for a step that is equal to zero: Slicing does not raise an IndexError for a start or stop that is out of range (contrary to subscription): * The expressions sequence[index] and sequence.__getitem__(index) are equivalent. ** The expressions sequence[start:stop:step], sequence[slice(start, stop, step)], and sequence.__getitem__(slice(start, stop, step)) are equivalent, where the built-in class slice instance packs start, stop, and step. *** The expressions sequence[:], sequence[::], and sequence[None:None:None] use default values for start, stop, and step."}, {"id": 72372369, "score": 0, "vote": 0, "content": "<p>Lots of answers already, but I wanted to add a performance comparison</p>\n<pre><code class=\"python\">~$ python3.8 -m timeit -s 'fun = \"this is fun;slicer = slice(0, 3)\"' \"fun_slice = fun[slicer]\" \n10000000 loops, best of 5: 29.8 nsec per loop\n~$ python3.8 -m timeit -s 'fun = \"this is fun\"' \"fun_slice = fun[0:3]\" \n10000000 loops, best of 5: 37.9 nsec per loop\n~$ python3.8 -m timeit -s 'fun = \"this is fun\"' \"fun_slice = fun[slice(0, 3)]\" \n5000000 loops, best of 5: 68.7 nsec per loop\n~$ python3.8 -m timeit -s 'fun = \"this is fun\"' \"slicer = slice(0, 3)\" \n5000000 loops, best of 5: 42.8 nsec per loop\n</code></pre>\n<p>So, if you are using the same slice repeatedly, it would be beneficial and improve readability to use a slice object. However, if you are slicing only a handful of times, [:] notation should be preferred.</p>\n", "abstract": "Lots of answers already, but I wanted to add a performance comparison So, if you are using the same slice repeatedly, it would be beneficial and improve readability to use a slice object. However, if you are slicing only a handful of times, [:] notation should be preferred."}, {"id": 73011643, "score": -3, "vote": 0, "content": "<p>Here's a simple mnemonic for remembering how it works:</p>\n<ul>\n<li><code>S L *I* C *E*</code></li>\n<li>the 'i' of slice comes first and stands for <em>inclusive</em>,</li>\n<li>the 'e' comes last and stands for <em>exclusive</em>.</li>\n</ul>\n<p>So <code>array[j:k]</code> will <em>include</em> the <code>j</code>th element and <em>exclude</em> the <code>k</code>th element.</p>\n", "abstract": "Here's a simple mnemonic for remembering how it works: So array[j:k] will include the jth element and exclude the kth element."}]}, {"link": "https://stackoverflow.com/questions/176918/finding-the-index-of-an-item-in-a-list", "question": {"id": "176918", "title": "Finding the index of an item in a list", "content": "<p>Given a list <code>[\"foo\", \"bar\", \"baz\"]</code> and an item in the list <code>\"bar\"</code>, how do I get its index <code>1</code>?</p>\n", "abstract": "Given a list [\"foo\", \"bar\", \"baz\"] and an item in the list \"bar\", how do I get its index 1?"}, "answers": [{"id": 176921, "score": 5684, "vote": 0, "content": "<pre><code class=\"python\">&gt;&gt;&gt; [\"foo\", \"bar\", \"baz\"].index(\"bar\")\n1\n</code></pre>\n<p>Reference: <a href=\"https://docs.python.org/tutorial/datastructures.html#more-on-lists\" rel=\"noreferrer\">Data Structures &gt; More on Lists</a></p>\n<h1>Caveats follow</h1>\n<p>Note that while this is perhaps the cleanest way to answer the question <em>as asked</em>, <code>index</code> is a rather weak component of the <code>list</code> API, and I can't remember the last time I used it in anger. It's been pointed out to me in the comments that because this answer is heavily referenced, it should be made more complete. Some caveats about <code>list.index</code> follow. It is probably worth initially taking a look at the documentation for it:</p>\n<blockquote>\n<pre><code class=\"python\">list.index(x[, start[, end]])\n</code></pre>\n<p>Return zero-based index in the list of the first item whose value is equal to <em>x</em>. Raises a <a href=\"https://docs.python.org/library/exceptions.html#ValueError\" rel=\"noreferrer\"><code>ValueError</code></a> if there is no such item.</p>\n<p>The optional arguments <em>start</em> and <em>end</em> are interpreted as in the <a href=\"https://docs.python.org/tutorial/introduction.html#lists\" rel=\"noreferrer\">slice notation</a> and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument.</p>\n</blockquote>\n<h2>Linear time-complexity in list length</h2>\n<p>An <code>index</code> call checks every element of the list in order, until it finds a match. If your list is long, and you don't know roughly where in the list it occurs, this search could become a bottleneck. In that case, you should consider a different data structure. Note that if you know roughly where to find the match, you can give <code>index</code> a hint. For instance, in this snippet, <code>l.index(999_999, 999_990, 1_000_000)</code> is roughly five orders of magnitude faster than straight <code>l.index(999_999)</code>, because the former only has to search 10 entries, while the latter searches a million:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; timeit.timeit('l.index(999_999)', setup='l = list(range(0, 1_000_000))', number=1000)\n9.356267921015387\n&gt;&gt;&gt; timeit.timeit('l.index(999_999, 999_990, 1_000_000)', setup='l = list(range(0, 1_000_000))', number=1000)\n0.0004404920036904514\n \n</code></pre>\n<h2>Only returns the index of the <em>first match</em> to its argument</h2>\n<p>A call to <code>index</code> searches through the list in order until it finds a match, and <em>stops there.</em> If you expect to need indices of more matches, you should use a list comprehension, or generator expression.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; [1, 1].index(1)\n0\n&gt;&gt;&gt; [i for i, e in enumerate([1, 2, 1]) if e == 1]\n[0, 2]\n&gt;&gt;&gt; g = (i for i, e in enumerate([1, 2, 1]) if e == 1)\n&gt;&gt;&gt; next(g)\n0\n&gt;&gt;&gt; next(g)\n2\n</code></pre>\n<p>Most places where I once would have used <code>index</code>, I now use a list comprehension or generator expression because they're more generalizable. So if you're considering reaching for <code>index</code>, take a look at these excellent Python features.</p>\n<h2>Throws if element not present in list</h2>\n<p>A call to <code>index</code> results in a <a href=\"https://docs.python.org/library/exceptions.html#ValueError\" rel=\"noreferrer\"><code>ValueError</code></a> if the item's not present.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; [1, 1].index(2)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: 2 is not in list\n</code></pre>\n<p>If the item might not be present in the list, you should either</p>\n<ol>\n<li>Check for it first with <code>item in my_list</code> (clean, readable approach), or</li>\n<li>Wrap the <code>index</code> call in a <code>try/except</code> block which catches <code>ValueError</code> (probably faster, at least when the list to search is long, and the item is usually present.)</li>\n</ol>\n", "abstract": "Reference: Data Structures > More on Lists Note that while this is perhaps the cleanest way to answer the question as asked, index is a rather weak component of the list API, and I can't remember the last time I used it in anger. It's been pointed out to me in the comments that because this answer is heavily referenced, it should be made more complete. Some caveats about list.index follow. It is probably worth initially taking a look at the documentation for it: Return zero-based index in the list of the first item whose value is equal to x. Raises a ValueError if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. An index call checks every element of the list in order, until it finds a match. If your list is long, and you don't know roughly where in the list it occurs, this search could become a bottleneck. In that case, you should consider a different data structure. Note that if you know roughly where to find the match, you can give index a hint. For instance, in this snippet, l.index(999_999, 999_990, 1_000_000) is roughly five orders of magnitude faster than straight l.index(999_999), because the former only has to search 10 entries, while the latter searches a million: A call to index searches through the list in order until it finds a match, and stops there. If you expect to need indices of more matches, you should use a list comprehension, or generator expression. Most places where I once would have used index, I now use a list comprehension or generator expression because they're more generalizable. So if you're considering reaching for index, take a look at these excellent Python features. A call to index results in a ValueError if the item's not present. If the item might not be present in the list, you should either"}, {"id": 178399, "score": 990, "vote": 0, "content": "<p>One thing that is really helpful in learning Python is to use the interactive help function:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; help([\"foo\", \"bar\", \"baz\"])\nHelp on list object:\n\nclass list(object)\n ...\n\n |\n |  index(...)\n |      L.index(value, [start, [stop]]) -&gt; integer -- return first index of value\n |\n</code></pre>\n<p>which will often lead you to the method you are looking for.</p>\n", "abstract": "One thing that is really helpful in learning Python is to use the interactive help function: which will often lead you to the method you are looking for."}, {"id": 17202481, "score": 677, "vote": 0, "content": "<p>The majority of answers explain how to find <strong>a single index</strong>, but their methods do not return multiple indexes if the item is in the list multiple times. Use <a href=\"https://docs.python.org/library/functions.html#enumerate\" rel=\"noreferrer\"><code>enumerate()</code></a>:</p>\n<pre><code class=\"python\">for i, j in enumerate(['foo', 'bar', 'baz']):\n    if j == 'bar':\n        print(i)\n</code></pre>\n<p>The <code>index()</code> function only returns the first occurrence, while <code>enumerate()</code> returns all occurrences.</p>\n<p>As a list comprehension:</p>\n<pre><code class=\"python\">[i for i, j in enumerate(['foo', 'bar', 'baz']) if j == 'bar']\n</code></pre>\n<hr/>\n<p>Here's also another small solution with <a href=\"http://docs.python.org/library/itertools.html#itertools.count\" rel=\"noreferrer\"><code>itertools.count()</code></a> (which is pretty much the same approach as enumerate):</p>\n<pre><code class=\"python\">from itertools import izip as zip, count # izip for maximum efficiency\n[i for i, j in zip(count(), ['foo', 'bar', 'baz']) if j == 'bar']\n</code></pre>\n<p>This is more efficient for larger lists than using <code>enumerate()</code>:</p>\n<pre><code class=\"python\">$ python -m timeit -s \"from itertools import izip as zip, count\" \"[i for i, j in zip(count(), ['foo', 'bar', 'baz']*500) if j == 'bar']\"\n10000 loops, best of 3: 174 usec per loop\n$ python -m timeit \"[i for i, j in enumerate(['foo', 'bar', 'baz']*500) if j == 'bar']\"\n10000 loops, best of 3: 196 usec per loop\n</code></pre>\n", "abstract": "The majority of answers explain how to find a single index, but their methods do not return multiple indexes if the item is in the list multiple times. Use enumerate(): The index() function only returns the first occurrence, while enumerate() returns all occurrences. As a list comprehension: Here's also another small solution with itertools.count() (which is pretty much the same approach as enumerate): This is more efficient for larger lists than using enumerate():"}, {"id": 17300987, "score": 222, "vote": 0, "content": "<p>To get all indexes:</p>\n<pre><code class=\"python\">indexes = [i for i,x in enumerate(xs) if x == 'foo']\n</code></pre>\n", "abstract": "To get all indexes:"}, {"id": 7241298, "score": 151, "vote": 0, "content": "<p><code>index()</code> returns the <strong>first</strong> index of value!</p>\n<blockquote>\n<p>|  index(...)<br/>\n   |      L.index(value, [start, [stop]]) -&gt; integer -- return first index of value</p>\n</blockquote>\n<pre><code class=\"python\">def all_indices(value, qlist):\n    indices = []\n    idx = -1\n    while True:\n        try:\n            idx = qlist.index(value, idx+1)\n            indices.append(idx)\n        except ValueError:\n            break\n    return indices\n\nall_indices(\"foo\", [\"foo\",\"bar\",\"baz\",\"foo\"])\n</code></pre>\n", "abstract": "index() returns the first index of value! |  index(...)\n   |      L.index(value, [start, [stop]]) -> integer -- return first index of value"}, {"id": 16034499, "score": 103, "vote": 0, "content": "<p>A problem will arise if the element is not in the list. This function handles the issue:</p>\n<pre><code class=\"python\"># if element is found it returns index of element else returns None\n\ndef find_element_in_list(element, list_element):\n    try:\n        index_element = list_element.index(element)\n        return index_element\n    except ValueError:\n        return None\n</code></pre>\n", "abstract": "A problem will arise if the element is not in the list. This function handles the issue:"}, {"id": 12054409, "score": 101, "vote": 0, "content": "<pre><code class=\"python\">a = [\"foo\",\"bar\",\"baz\",'bar','any','much']\n\nindexes = [index for index in range(len(a)) if a[index] == 'bar']\n</code></pre>\n", "abstract": ""}, {"id": 23862698, "score": 72, "vote": 0, "content": "<p>You have to set a condition to check if the element you're searching is in the list</p>\n<pre><code class=\"python\">if 'your_element' in mylist:\n    print mylist.index('your_element')\nelse:\n    print None\n</code></pre>\n", "abstract": "You have to set a condition to check if the element you're searching is in the list"}, {"id": 33765024, "score": 60, "vote": 0, "content": "<p>If you want all indexes, then you can use <a href=\"http://en.wikipedia.org/wiki/NumPy\" rel=\"noreferrer\">NumPy</a>:</p>\n<pre><code class=\"python\">import numpy as np\n\narray = [1, 2, 1, 3, 4, 5, 1]\nitem = 1\nnp_array = np.array(array)\nitem_index = np.where(np_array==item)\nprint item_index\n# Out: (array([0, 2, 6], dtype=int64),)\n</code></pre>\n<p>It is clear, readable solution.</p>\n", "abstract": "If you want all indexes, then you can use NumPy: It is clear, readable solution."}, {"id": 16593099, "score": 53, "vote": 0, "content": "<p>All of the proposed functions here reproduce inherent language behavior but obscure what's going on.</p>\n<pre><code class=\"python\">[i for i in range(len(mylist)) if mylist[i]==myterm]  # get the indices\n\n[each for each in mylist if each==myterm]             # get the items\n\nmylist.index(myterm) if myterm in mylist else None    # get the first index and fail quietly\n</code></pre>\n<p>Why write a function with exception handling if the language provides the methods to do what you want itself?</p>\n", "abstract": "All of the proposed functions here reproduce inherent language behavior but obscure what's going on. Why write a function with exception handling if the language provides the methods to do what you want itself?"}, {"id": 45808300, "score": 50, "vote": 0, "content": "<blockquote>\n<h2>Finding the index of an item given a list containing it in Python</h2>\n<p>For a list <code>[\"foo\", \"bar\", \"baz\"]</code> and an item in the list <code>\"bar\"</code>, what's the cleanest way to get its index (1) in Python?</p>\n</blockquote>\n<p>Well, sure, there's the index method, which returns the index of the first occurrence:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; l = [\"foo\", \"bar\", \"baz\"]\n&gt;&gt;&gt; l.index('bar')\n1\n</code></pre>\n<p>There are a couple of issues with this method:</p>\n<ul>\n<li>if the value isn't in the list, you'll get a <code>ValueError</code></li>\n<li>if more than one of the value is in the list, you only get the index for the first one</li>\n</ul>\n<h3>No values</h3>\n<p>If the value could be missing, you need to catch the <code>ValueError</code>.</p>\n<p>You can do so with a reusable definition like this:</p>\n<pre><code class=\"python\">def index(a_list, value):\n    try:\n        return a_list.index(value)\n    except ValueError:\n        return None\n</code></pre>\n<p>And use it like this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print(index(l, 'quux'))\nNone\n&gt;&gt;&gt; print(index(l, 'bar'))\n1\n</code></pre>\n<p>And the downside of this is that you will probably have a check for if the returned value <code>is</code> or <code>is not</code> None:</p>\n<pre><code class=\"python\">result = index(a_list, value)\nif result is not None:\n    do_something(result)\n</code></pre>\n<h3>More than one value in the list</h3>\n<p>If you could have more occurrences, you'll <strong>not</strong> get complete information with <code>list.index</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; l.append('bar')\n&gt;&gt;&gt; l\n['foo', 'bar', 'baz', 'bar']\n&gt;&gt;&gt; l.index('bar')              # nothing at index 3?\n1\n</code></pre>\n<p>You might enumerate into a list comprehension the indexes:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; [index for index, v in enumerate(l) if v == 'bar']\n[1, 3]\n&gt;&gt;&gt; [index for index, v in enumerate(l) if v == 'boink']\n[]\n</code></pre>\n<p>If you have no occurrences, you can check for that with boolean check of the result, or just do nothing if you loop over the results:</p>\n<pre><code class=\"python\">indexes = [index for index, v in enumerate(l) if v == 'boink']\nfor index in indexes:\n    do_something(index)\n</code></pre>\n<h3>Better data munging with pandas</h3>\n<p>If you have pandas, you can easily get this information with a Series object:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; series = pd.Series(l)\n&gt;&gt;&gt; series\n0    foo\n1    bar\n2    baz\n3    bar\ndtype: object\n</code></pre>\n<p>A comparison check will return a series of booleans:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; series == 'bar'\n0    False\n1     True\n2    False\n3     True\ndtype: bool\n</code></pre>\n<p>Pass that series of booleans to the series via subscript notation, and you get just the matching members:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; series[series == 'bar']\n1    bar\n3    bar\ndtype: object\n</code></pre>\n<p>If you want just the indexes, the index attribute returns a series of integers:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; series[series == 'bar'].index\nInt64Index([1, 3], dtype='int64')\n</code></pre>\n<p>And if you want them in a list or tuple, just pass them to the constructor:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(series[series == 'bar'].index)\n[1, 3]\n</code></pre>\n<p>Yes, you could use a list comprehension with enumerate too, but that's just not as elegant, in my opinion - you're doing tests for equality in Python, instead of letting builtin code written in C handle it:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; [i for i, value in enumerate(l) if value == 'bar']\n[1, 3]\n</code></pre>\n<h2>Is this an <a href=\"https://meta.stackexchange.com/a/66378/239121\">XY problem</a>?</h2>\n<blockquote>\n<p>The XY problem is asking about your attempted solution rather than your actual problem.</p>\n</blockquote>\n<p>Why do you think you need the index given an element in a list?</p>\n<p>If you already know the value, why do you care where it is in a list?</p>\n<p>If the value isn't there, catching the <code>ValueError</code> is rather verbose - and I prefer to avoid that.</p>\n<p>I'm usually iterating over the list anyways, so I'll usually keep a pointer to any interesting information, getting the <a href=\"https://stackoverflow.com/q/522563/541136\">index with enumerate.</a></p>\n<p>If you're munging data, you should probably be using pandas - which has far more elegant tools than the pure Python workarounds I've shown.</p>\n<p>I do not recall needing <code>list.index</code>, myself. However, I have looked through the Python standard library, and I see some excellent uses for it.</p>\n<p>There are many, many uses for it in <code>idlelib</code>, for GUI and text parsing.</p>\n<p>The <code>keyword</code> module uses it to find comment markers in the module to automatically regenerate the list of keywords in it via metaprogramming.</p>\n<p>In Lib/mailbox.py it seems to be using it like an ordered mapping:</p>\n<pre><code class=\"python\">key_list[key_list.index(old)] = new\n</code></pre>\n<p>and</p>\n<pre><code class=\"python\">del key_list[key_list.index(key)]\n</code></pre>\n<p>In Lib/http/cookiejar.py, seems to be used to get the next month:</p>\n<pre><code class=\"python\">mon = MONTHS_LOWER.index(mon.lower())+1\n</code></pre>\n<p>In Lib/tarfile.py similar to distutils to get a slice up to an item:</p>\n<pre><code class=\"python\">members = members[:members.index(tarinfo)]\n</code></pre>\n<p>In Lib/pickletools.py:</p>\n<pre><code class=\"python\">numtopop = before.index(markobject)\n</code></pre>\n<p>What these usages seem to have in common is that they seem to operate on lists of constrained sizes (important because of O(n) lookup time for <code>list.index</code>), and they're mostly used in parsing (and UI in the case of Idle).</p>\n<p>While there are use-cases for it, they are fairly uncommon. If you find yourself looking for this answer, ask yourself if what you're doing is the most direct usage of the tools provided by the language for your use-case.</p>\n", "abstract": "For a list [\"foo\", \"bar\", \"baz\"] and an item in the list \"bar\", what's the cleanest way to get its index (1) in Python? Well, sure, there's the index method, which returns the index of the first occurrence: There are a couple of issues with this method: If the value could be missing, you need to catch the ValueError. You can do so with a reusable definition like this: And use it like this: And the downside of this is that you will probably have a check for if the returned value is or is not None: If you could have more occurrences, you'll not get complete information with list.index: You might enumerate into a list comprehension the indexes: If you have no occurrences, you can check for that with boolean check of the result, or just do nothing if you loop over the results: If you have pandas, you can easily get this information with a Series object: A comparison check will return a series of booleans: Pass that series of booleans to the series via subscript notation, and you get just the matching members: If you want just the indexes, the index attribute returns a series of integers: And if you want them in a list or tuple, just pass them to the constructor: Yes, you could use a list comprehension with enumerate too, but that's just not as elegant, in my opinion - you're doing tests for equality in Python, instead of letting builtin code written in C handle it: The XY problem is asking about your attempted solution rather than your actual problem. Why do you think you need the index given an element in a list? If you already know the value, why do you care where it is in a list? If the value isn't there, catching the ValueError is rather verbose - and I prefer to avoid that. I'm usually iterating over the list anyways, so I'll usually keep a pointer to any interesting information, getting the index with enumerate. If you're munging data, you should probably be using pandas - which has far more elegant tools than the pure Python workarounds I've shown. I do not recall needing list.index, myself. However, I have looked through the Python standard library, and I see some excellent uses for it. There are many, many uses for it in idlelib, for GUI and text parsing. The keyword module uses it to find comment markers in the module to automatically regenerate the list of keywords in it via metaprogramming. In Lib/mailbox.py it seems to be using it like an ordered mapping: and In Lib/http/cookiejar.py, seems to be used to get the next month: In Lib/tarfile.py similar to distutils to get a slice up to an item: In Lib/pickletools.py: What these usages seem to have in common is that they seem to operate on lists of constrained sizes (important because of O(n) lookup time for list.index), and they're mostly used in parsing (and UI in the case of Idle). While there are use-cases for it, they are fairly uncommon. If you find yourself looking for this answer, ask yourself if what you're doing is the most direct usage of the tools provided by the language for your use-case."}, {"id": 45559614, "score": 32, "vote": 0, "content": "<h3>Getting all the occurrences and the position of one or more (identical) items in a list</h3>\n<p>With enumerate(alist) you can store the first element (n) that is the index of the list when the element x is equal to what you look for.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; alist = ['foo', 'spam', 'egg', 'foo']\n&gt;&gt;&gt; foo_indexes = [n for n,x in enumerate(alist) if x=='foo']\n&gt;&gt;&gt; foo_indexes\n[0, 3]\n&gt;&gt;&gt;\n</code></pre>\n<h3>Let's make our function findindex</h3>\n<p>This function takes the item and the list as arguments and return the position of the item in the list, like we saw before.</p>\n<pre><code class=\"python\">def indexlist(item2find, list_or_string):\n  \"Returns all indexes of an item in a list or a string\"\n  return [n for n,item in enumerate(list_or_string) if item==item2find]\n\nprint(indexlist(\"1\", \"010101010\"))\n</code></pre>\n<hr/>\n<p><strong>Output</strong></p>\n<hr/>\n<pre><code class=\"python\">[1, 3, 5, 7]\n</code></pre>\n<h2>Simple</h2>\n<pre><code class=\"python\">for n, i in enumerate([1, 2, 3, 4, 1]):\n    if i == 1:\n        print(n)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">0\n4\n</code></pre>\n", "abstract": "With enumerate(alist) you can store the first element (n) that is the index of the list when the element x is equal to what you look for. This function takes the item and the list as arguments and return the position of the item in the list, like we saw before. Output Output:"}, {"id": 71900535, "score": 31, "vote": 0, "content": "<pre><code class=\"python\">me = [\"foo\", \"bar\", \"baz\"]\nme.index(\"bar\") \n</code></pre>\n<p>You can apply this for any member of the list to get their index</p>\n", "abstract": "You can apply this for any member of the list to get their index"}, {"id": 33644671, "score": 25, "vote": 0, "content": "<p>All indexes with the <a href=\"https://docs.python.org/2/library/functions.html#zip\" rel=\"noreferrer\"><code>zip</code></a> function:</p>\n<pre><code class=\"python\">get_indexes = lambda x, xs: [i for (y, i) in zip(xs, range(len(xs))) if x == y]\n\nprint get_indexes(2, [1, 2, 3, 4, 5, 6, 3, 2, 3, 2])\nprint get_indexes('f', 'xsfhhttytffsafweef')\n</code></pre>\n", "abstract": "All indexes with the zip function:"}, {"id": 16807733, "score": 23, "vote": 0, "content": "<p>Simply you can go with</p>\n<pre><code class=\"python\">a = [['hand', 'head'], ['phone', 'wallet'], ['lost', 'stock']]\nb = ['phone', 'lost']\n\nres = [[x[0] for x in a].index(y) for y in b]\n</code></pre>\n", "abstract": "Simply you can go with"}, {"id": 16822116, "score": 20, "vote": 0, "content": "<p>Another option</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = ['red', 'blue', 'green', 'red']\n&gt;&gt;&gt; b = 'red'\n&gt;&gt;&gt; offset = 0;\n&gt;&gt;&gt; indices = list()\n&gt;&gt;&gt; for i in range(a.count(b)):\n...     indices.append(a.index(b,offset))\n...     offset = indices[-1]+1\n... \n&gt;&gt;&gt; indices\n[0, 3]\n&gt;&gt;&gt; \n</code></pre>\n", "abstract": "Another option"}, {"id": 27712517, "score": 18, "vote": 0, "content": "<h1>And now, for something completely different...  </h1>\n<p>... like confirming the existence of the item before getting the index.  The nice thing about this approach is the function always returns a list of indices -- even if it is an empty list.  It works with strings as well.</p>\n<pre><code class=\"python\">def indices(l, val):\n    \"\"\"Always returns a list containing the indices of val in the_list\"\"\"\n    retval = []\n    last = 0\n    while val in l[last:]:\n            i = l[last:].index(val)\n            retval.append(last + i)\n            last += i + 1   \n    return retval\n\nl = ['bar','foo','bar','baz','bar','bar']\nq = 'bar'\nprint indices(l,q)\nprint indices(l,'bat')\nprint indices('abcdaababb','a')\n</code></pre>\n<p>When pasted into an interactive python window:</p>\n<pre><code class=\"python\">Python 2.7.6 (v2.7.6:3a1db0d2747e, Nov 10 2013, 00:42:54) \n[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; def indices(the_list, val):\n...     \"\"\"Always returns a list containing the indices of val in the_list\"\"\"\n...     retval = []\n...     last = 0\n...     while val in the_list[last:]:\n...             i = the_list[last:].index(val)\n...             retval.append(last + i)\n...             last += i + 1   \n...     return retval\n... \n&gt;&gt;&gt; l = ['bar','foo','bar','baz','bar','bar']\n&gt;&gt;&gt; q = 'bar'\n&gt;&gt;&gt; print indices(l,q)\n[0, 2, 4, 5]\n&gt;&gt;&gt; print indices(l,'bat')\n[]\n&gt;&gt;&gt; print indices('abcdaababb','a')\n[0, 4, 5, 7]\n&gt;&gt;&gt; \n</code></pre>\n<h1>Update</h1>\n<p>After another year of heads-down python development, I'm a bit embarrassed by my original answer, so to set the record straight, one can certainly use the above code; however, the <em>much</em> more idiomatic way to get the same behavior would be to use list comprehension, along with the enumerate() function.  </p>\n<p>Something like this:  </p>\n<pre><code class=\"python\">def indices(l, val):\n    \"\"\"Always returns a list containing the indices of val in the_list\"\"\"\n    return [index for index, value in enumerate(l) if value == val]\n\nl = ['bar','foo','bar','baz','bar','bar']\nq = 'bar'\nprint indices(l,q)\nprint indices(l,'bat')\nprint indices('abcdaababb','a')\n</code></pre>\n<p>Which, when pasted into an interactive python window yields:</p>\n<pre><code class=\"python\">Python 2.7.14 |Anaconda, Inc.| (default, Dec  7 2017, 11:07:58) \n[GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; def indices(l, val):\n...     \"\"\"Always returns a list containing the indices of val in the_list\"\"\"\n...     return [index for index, value in enumerate(l) if value == val]\n... \n&gt;&gt;&gt; l = ['bar','foo','bar','baz','bar','bar']\n&gt;&gt;&gt; q = 'bar'\n&gt;&gt;&gt; print indices(l,q)\n[0, 2, 4, 5]\n&gt;&gt;&gt; print indices(l,'bat')\n[]\n&gt;&gt;&gt; print indices('abcdaababb','a')\n[0, 4, 5, 7]\n&gt;&gt;&gt; \n</code></pre>\n<p>And now, after reviewing this question and all the answers, I realize that this is exactly what <a href=\"https://stackoverflow.com/users/55857/fmc\">FMc</a> suggested in his <a href=\"https://stackoverflow.com/questions/176918/finding-the-index-of-an-item-given-a-list-containing-it-in-python/17300987#17300987\">earlier answer</a>.  At the time I originally answered this question, I didn't even <em>see</em> that answer, because I didn't understand it.  I hope that my somewhat more verbose example will aid understanding.  </p>\n<p>If the single line of code above still <em>doesn't</em> make sense to you, I highly recommend you Google 'python list comprehension' and take a few minutes to familiarize yourself.  It's just one of the many powerful features that make it a joy to use Python to develop code.</p>\n", "abstract": "... like confirming the existence of the item before getting the index.  The nice thing about this approach is the function always returns a list of indices -- even if it is an empty list.  It works with strings as well. When pasted into an interactive python window: After another year of heads-down python development, I'm a bit embarrassed by my original answer, so to set the record straight, one can certainly use the above code; however, the much more idiomatic way to get the same behavior would be to use list comprehension, along with the enumerate() function.   Something like this:   Which, when pasted into an interactive python window yields: And now, after reviewing this question and all the answers, I realize that this is exactly what FMc suggested in his earlier answer.  At the time I originally answered this question, I didn't even see that answer, because I didn't understand it.  I hope that my somewhat more verbose example will aid understanding.   If the single line of code above still doesn't make sense to you, I highly recommend you Google 'python list comprehension' and take a few minutes to familiarize yourself.  It's just one of the many powerful features that make it a joy to use Python to develop code."}, {"id": 70702309, "score": 16, "vote": 0, "content": "<p>My friend, I have made the easiest code to solve your question. While you were receiving gigantic lines of codes, I am here to cater you a two line code which is all due to the help of <code>index()</code> function in python.</p>\n<pre><code class=\"python\">LIST = ['foo' ,'boo', 'shoo']\nprint(LIST.index('boo'))\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">1\n</code></pre>\n<p>I Hope I have given you the best and the simplest answer which might help you greatly.</p>\n", "abstract": "My friend, I have made the easiest code to solve your question. While you were receiving gigantic lines of codes, I am here to cater you a two line code which is all due to the help of index() function in python. Output: I Hope I have given you the best and the simplest answer which might help you greatly."}, {"id": 22708420, "score": 15, "vote": 0, "content": "<p>A variant on the answer from FMc and user7177 will give a dict that can return all indices for any entry:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = ['foo','bar','baz','bar','any', 'foo', 'much']\n&gt;&gt;&gt; l = dict(zip(set(a), map(lambda y: [i for i,z in enumerate(a) if z is y ], set(a))))\n&gt;&gt;&gt; l['foo']\n[0, 5]\n&gt;&gt;&gt; l ['much']\n[6]\n&gt;&gt;&gt; l\n{'baz': [2], 'foo': [0, 5], 'bar': [1, 3], 'any': [4], 'much': [6]}\n&gt;&gt;&gt; \n</code></pre>\n<p>You could also use this as a one liner to get all indices for a single entry. There are no guarantees for efficiency, though I did use set(a) to reduce the number of times the lambda is called.</p>\n", "abstract": "A variant on the answer from FMc and user7177 will give a dict that can return all indices for any entry: You could also use this as a one liner to get all indices for a single entry. There are no guarantees for efficiency, though I did use set(a) to reduce the number of times the lambda is called."}, {"id": 50537324, "score": 14, "vote": 0, "content": "<p>Finding index of item x in list L:</p>\n<pre><code class=\"python\">idx = L.index(x) if (x in L) else -1\n</code></pre>\n", "abstract": "Finding index of item x in list L:"}, {"id": 30283031, "score": 12, "vote": 0, "content": "<p>This solution is not as powerful as others, but if you're a beginner and only know about <code>for</code>loops it's still possible to find the first index of an item while avoiding the ValueError:</p>\n<pre><code class=\"python\">def find_element(p,t):\n    i = 0\n    for e in p:\n        if e == t:\n            return i\n        else:\n            i +=1\n    return -1\n</code></pre>\n", "abstract": "This solution is not as powerful as others, but if you're a beginner and only know about forloops it's still possible to find the first index of an item while avoiding the ValueError:"}, {"id": 63631183, "score": 10, "vote": 0, "content": "<p>There is a chance that that value may not be present so to avoid this ValueError, we can check if that actually exists in the list .</p>\n<pre><code class=\"python\">list =  [\"foo\", \"bar\", \"baz\"]\n\nitem_to_find = \"foo\"\n\nif item_to_find in list:\n      index = list.index(item_to_find)\n      print(\"Index of the item is \" + str(index))\nelse:\n    print(\"That word does not exist\") \n</code></pre>\n", "abstract": "There is a chance that that value may not be present so to avoid this ValueError, we can check if that actually exists in the list ."}, {"id": 67031974, "score": 7, "vote": 0, "content": "<p>It just uses the python function <code>array.index()</code> and with a simple Try / Except it returns the position of the record if it is found in the list and return -1 if it is not found in the list (like on JavaScript with the function <code>indexOf()</code>).</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">fruits = ['apple', 'banana', 'cherry']\n\ntry:\n  pos = fruits.index(\"mango\")\nexcept:\n  pos = -1\n</code></pre>\n<p>In this case \"mango\" is not present in the list <code>fruits</code> so the <code>pos</code> variable is -1, if I had searched for \"cherry\" the <code>pos</code> variable would be 2.</p>\n", "abstract": "It just uses the python function array.index() and with a simple Try / Except it returns the position of the record if it is found in the list and return -1 if it is not found in the list (like on JavaScript with the function indexOf()). In this case \"mango\" is not present in the list fruits so the pos variable is -1, if I had searched for \"cherry\" the pos variable would be 2."}, {"id": 71017253, "score": 7, "vote": 0, "content": "<p>List comprehension would be the best option to acquire a compact implementation in finding the index of an item in a list.</p>\n<pre><code class=\"python\">a_list = [\"a\", \"b\", \"a\"]\nprint([index for (index , item) in enumerate(a_list) if item == \"a\"])\n</code></pre>\n", "abstract": "List comprehension would be the best option to acquire a compact implementation in finding the index of an item in a list."}, {"id": 31230699, "score": 6, "vote": 0, "content": "<pre><code class=\"python\">name =\"bar\"\nlist = [[\"foo\", 1], [\"bar\", 2], [\"baz\", 3]]\nnew_list=[]\nfor item in list:\n    new_list.append(item[0])\nprint(new_list)\ntry:\n    location= new_list.index(name)\nexcept:\n    location=-1\nprint (location)\n</code></pre>\n<p>This accounts for if the string is not in the list too, if it isn't in the list then <code>location = -1</code></p>\n", "abstract": "This accounts for if the string is not in the list too, if it isn't in the list then location = -1"}, {"id": 49093542, "score": 6, "vote": 0, "content": "<p>Python <code>index()</code> method throws an error if the item was not found. So instead you can make it similar to the <code>indexOf()</code> function of JavaScript which returns <code>-1</code> if the item was not found:</p>\n<pre><code class=\"python\">try:\n    index = array.index('search_keyword')\nexcept ValueError:\n    index = -1\n</code></pre>\n", "abstract": "Python index() method throws an error if the item was not found. So instead you can make it similar to the indexOf() function of JavaScript which returns -1 if the item was not found:"}, {"id": 49159543, "score": 6, "vote": 0, "content": "<p>There is a more functional answer to this.</p>\n<pre><code class=\"python\">list(filter(lambda x: x[1]==\"bar\",enumerate([\"foo\", \"bar\", \"baz\", \"bar\", \"baz\", \"bar\", \"a\", \"b\", \"c\"])))\n</code></pre>\n<p>More generic form:</p>\n<pre><code class=\"python\">def get_index_of(lst, element):\n    return list(map(lambda x: x[0],\\\n       (list(filter(lambda x: x[1]==element, enumerate(lst))))))\n</code></pre>\n", "abstract": "There is a more functional answer to this. More generic form:"}, {"id": 62518645, "score": 6, "vote": 0, "content": "<h3>For one comparable</h3>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># Throws ValueError if nothing is found\nsome_list = ['foo', 'bar', 'baz'].index('baz')\n# some_list == 2\n</code></pre>\n<h3>Custom predicate</h3>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">some_list = [item1, item2, item3]\n\n# Throws StopIteration if nothing is found\n# *unless* you provide a second parameter to `next`\nindex_of_value_you_like = next(\n    i for i, item in enumerate(some_list)\n    if item.matches_your_criteria())\n</code></pre>\n<h3>Finding index of all items by predicate</h3>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">index_of_staff_members = [\n    i for i, user in enumerate(users)\n    if user.is_staff()]\n</code></pre>\n", "abstract": ""}, {"id": 45654421, "score": 4, "vote": 0, "content": "<p>Since Python lists are zero-based, we can use the zip built-in function as follows:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; [i for i,j in zip(range(len(haystack)), haystack) if j == 'needle' ]\n</code></pre>\n<p>where \"haystack\" is the list in question and \"needle\" is the item to look for.</p>\n<p>(Note: Here we are iterating using i to get the indexes, but if we need rather to focus on the items we can switch to j.)</p>\n", "abstract": "Since Python lists are zero-based, we can use the zip built-in function as follows: where \"haystack\" is the list in question and \"needle\" is the item to look for. (Note: Here we are iterating using i to get the indexes, but if we need rather to focus on the items we can switch to j.)"}, {"id": 52263806, "score": 3, "vote": 0, "content": "<h1>If performance is of concern:</h1>\n<p>It is mentioned in numerous answers that the built-in method of <code>list.index(item)</code> method is an O(n) algorithm. It is fine if you need to perform this once. But if you need to access the indices of elements a number of times, it makes more sense to first create a dictionary (O(n)) of item-index pairs, and then access the index at O(1) every time you need it.</p>\n<p>If you are sure that the items in your list are never repeated, you can easily:</p>\n<pre><code class=\"python\">myList = [\"foo\", \"bar\", \"baz\"]\n\n# Create the dictionary\nmyDict = dict((e,i) for i,e in enumerate(myList))\n\n# Lookup\nmyDict[\"bar\"] # Returns 1\n# myDict.get(\"blah\") if you don't want an error to be raised if element not found.\n</code></pre>\n<p>If you may have duplicate elements, and need to return all of their indices:</p>\n<pre><code class=\"python\">from collections import defaultdict as dd\nmyList = [\"foo\", \"bar\", \"bar\", \"baz\", \"foo\"]\n\n# Create the dictionary\nmyDict = dd(list)\nfor i,e in enumerate(myList):\n    myDict[e].append(i)\n\n# Lookup\nmyDict[\"foo\"] # Returns [0, 4]\n</code></pre>\n", "abstract": "It is mentioned in numerous answers that the built-in method of list.index(item) method is an O(n) algorithm. It is fine if you need to perform this once. But if you need to access the indices of elements a number of times, it makes more sense to first create a dictionary (O(n)) of item-index pairs, and then access the index at O(1) every time you need it. If you are sure that the items in your list are never repeated, you can easily: If you may have duplicate elements, and need to return all of their indices:"}, {"id": 61016685, "score": 3, "vote": 0, "content": "<p>If you are going to find an index once then using \"index\" method is fine. However, if you are going to search your data more than once then I recommend using <a href=\"https://docs.python.org/3/library/bisect.html\" rel=\"nofollow noreferrer\">bisect</a> module. Keep in mind that using bisect module data must be sorted. So you sort data once and then you can use bisect.\nUsing <a href=\"https://docs.python.org/3/library/bisect.html\" rel=\"nofollow noreferrer\">bisect</a> module on my machine is about 20 times faster than using index method.</p>\n<p>Here is an example of code using Python 3.8 and above syntax:</p>\n<pre><code class=\"python\">import bisect\nfrom timeit import timeit\n\ndef bisect_search(container, value):\n    return (\n      index \n      if (index := bisect.bisect_left(container, value)) &lt; len(container) \n      and container[index] == value else -1\n    )\n\ndata = list(range(1000))\n# value to search\nvalue = 666\n\n# times to test\nttt = 1000\n\nt1 = timeit(lambda: data.index(value), number=ttt)\nt2 = timeit(lambda: bisect_search(data, value), number=ttt)\n\nprint(f\"{t1=:.4f}, {t2=:.4f}, diffs {t1/t2=:.2f}\")\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">t1=0.0400, t2=0.0020, diffs t1/t2=19.60\n</code></pre>\n", "abstract": "If you are going to find an index once then using \"index\" method is fine. However, if you are going to search your data more than once then I recommend using bisect module. Keep in mind that using bisect module data must be sorted. So you sort data once and then you can use bisect.\nUsing bisect module on my machine is about 20 times faster than using index method. Here is an example of code using Python 3.8 and above syntax: Output:"}, {"id": 69425614, "score": 3, "vote": 0, "content": "<p>I find this two solution is better and I tried it by myself</p>\n<pre><code class=\"python\">&gt;&gt;&gt; expences = [2200, 2350, 2600, 2130, 2190]\n&gt;&gt;&gt; 2000 in expences\nFalse\n&gt;&gt;&gt; expences.index(2200)\n0\n&gt;&gt;&gt; expences.index(2350)\n1\n&gt;&gt;&gt; index = expences.index(2350)\n&gt;&gt;&gt; expences[index]\n2350\n\n&gt;&gt;&gt; try:\n...     print(expences.index(2100))\n... except ValueError as e:\n...     print(e)\n... \n2100 is not in list\n&gt;&gt;&gt; \n\n\n</code></pre>\n", "abstract": "I find this two solution is better and I tried it by myself"}, {"id": 70615103, "score": 3, "vote": 0, "content": "<pre><code class=\"python\">text = [\"foo\", \"bar\", \"baz\"]\ntarget = \"bar\"\n\n[index for index, value in enumerate(text) if value == target]\n</code></pre>\n<blockquote>\n<p>For a small list of elements, this would work fine. However, if the\nlist contains a large number of elements, better to <strong>apply binary\nsearch with O(log n) runtime complexity</strong>\n.</p>\n</blockquote>\n", "abstract": "For a small list of elements, this would work fine. However, if the\nlist contains a large number of elements, better to apply binary\nsearch with O(log n) runtime complexity\n."}, {"id": 48530557, "score": 2, "vote": 0, "content": "<p>For those coming from another language like me, maybe with a simple loop it's easier to understand and use it:</p>\n<pre><code class=\"python\">mylist = [\"foo\", \"bar\", \"baz\", \"bar\"]\nnewlist = enumerate(mylist)\nfor index, item in newlist:\n  if item == \"bar\":\n    print(index, item)\n</code></pre>\n<p>I am thankful for <em><a href=\"https://www.codecademy.com/en/forum_questions/5087f2d786a27b02000041a9\" rel=\"nofollow noreferrer\">So what exactly does enumerate do?</a></em>. That helped me to understand.</p>\n", "abstract": "For those coming from another language like me, maybe with a simple loop it's easier to understand and use it: I am thankful for So what exactly does enumerate do?. That helped me to understand."}, {"id": 52502151, "score": 2, "vote": 0, "content": "<p>As indicated by @TerryA, many answers discuss how to find <em>one</em> index.</p>\n<p><a href=\"https://github.com/erikrose/more-itertools\" rel=\"nofollow noreferrer\"><code>more_itertools</code></a> is a third-party library with tools to locate <em>multiple</em> indices within an iterable. </p>\n<p><strong>Given</strong></p>\n<pre><code class=\"python\">import more_itertools as mit\n\n\niterable = [\"foo\", \"bar\", \"baz\", \"ham\", \"foo\", \"bar\", \"baz\"]\n</code></pre>\n<p><strong>Code</strong></p>\n<p>Find indices of multiple observations:</p>\n<pre><code class=\"python\">list(mit.locate(iterable, lambda x: x == \"bar\"))\n# [1, 5]\n</code></pre>\n<p>Test multiple items:</p>\n<pre><code class=\"python\">list(mit.locate(iterable, lambda x: x in {\"bar\", \"ham\"}))\n# [1, 3, 5]\n</code></pre>\n<p>See also more options with <a href=\"https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.locate\" rel=\"nofollow noreferrer\"><code>more_itertools.locate</code></a>.  Install via <a href=\"https://github.com/erikrose/more-itertools\" rel=\"nofollow noreferrer\"><code>&gt; pip install more_itertools</code></a>.</p>\n", "abstract": "As indicated by @TerryA, many answers discuss how to find one index. more_itertools is a third-party library with tools to locate multiple indices within an iterable.  Given Code Find indices of multiple observations: Test multiple items: See also more options with more_itertools.locate.  Install via > pip install more_itertools."}, {"id": 53306924, "score": 2, "vote": 0, "content": "<p>Let\u2019s give the name <code>lst</code> to the list that you have. One can convert the list <code>lst</code> to a <code>numpy array</code>. And, then use <a href=\"https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.where.html\" rel=\"nofollow noreferrer\">numpy.where</a> to get the index of the chosen item in the list. Following is the way in which you will implement it.</p>\n<pre><code class=\"python\">import numpy as np\n\nlst = [\"foo\", \"bar\", \"baz\"]  #lst: : 'list' data type\nprint np.where( np.array(lst) == 'bar')[0][0]\n\n&gt;&gt;&gt; 1\n</code></pre>\n", "abstract": "Let\u2019s give the name lst to the list that you have. One can convert the list lst to a numpy array. And, then use numpy.where to get the index of the chosen item in the list. Following is the way in which you will implement it."}, {"id": 70523709, "score": 2, "vote": 0, "content": "<p>Certain structures in python contains a index method that works beautifully to solve this question.</p>\n<pre><code class=\"python\">'oi tchau'.index('oi')     # 0\n['oi','tchau'].index('oi') # 0\n('oi','tchau').index('oi') # 0\n</code></pre>\n<p>References:</p>\n<p><a href=\"https://www.programiz.com/python-programming/methods/list/index\" rel=\"nofollow noreferrer\">In lists</a></p>\n<p><a href=\"https://www.programiz.com/python-programming/methods/list/index\" rel=\"nofollow noreferrer\">In tuples</a></p>\n<p><a href=\"https://www.programiz.com/python-programming/methods/list/index\" rel=\"nofollow noreferrer\">In string</a></p>\n", "abstract": "Certain structures in python contains a index method that works beautifully to solve this question. References: In lists In tuples In string"}, {"id": 55218236, "score": 1, "vote": 0, "content": "<p>using dictionary , where process the list first and then add the index to it </p>\n<pre><code class=\"python\">from collections import defaultdict\n\nindex_dict = defaultdict(list)    \nword_list =  ['foo','bar','baz','bar','any', 'foo', 'much']\n\nfor word_index in range(len(word_list)) :\n    index_dict[word_list[word_index]].append(word_index)\n\nword_index_to_find = 'foo'       \nprint(index_dict[word_index_to_find])\n\n# output :  [0, 5]\n</code></pre>\n", "abstract": "using dictionary , where process the list first and then add the index to it "}, {"id": 70143454, "score": 1, "vote": 0, "content": "<p>Pythonic way would to use <code>enumerate</code> but you can also use <a href=\"https://docs.python.org/3/library/operator.html#operator.indexOf\" rel=\"nofollow noreferrer\"><code>indexOf</code></a> from <code>operator</code> module. Please note that this will raise <a href=\"https://github.com/python/cpython/blob/3.10/Lib/operator.py#L179\" rel=\"nofollow noreferrer\"><code>ValueError</code> if <code>b</code> not in <code>a</code>.</a></p>\n<pre><code class=\"python\">&gt;&gt;&gt; from operator import indexOf\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; help(indexOf)\nHelp on built-in function indexOf in module _operator:\n\nindexOf(a, b, /)\n    Return the first index of b in a.\n\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; indexOf((\"foo\", \"bar\", \"baz\"), \"bar\") # with tuple\n1\n&gt;&gt;&gt; indexOf([\"foo\", \"bar\", \"baz\"], \"bar\") # with list\n1\n</code></pre>\n", "abstract": "Pythonic way would to use enumerate but you can also use indexOf from operator module. Please note that this will raise ValueError if b not in a."}, {"id": 72121787, "score": 0, "vote": 0, "content": "<p>One can use zip() function to get the index of the value in the list. The code could be;</p>\n<pre><code class=\"python\">list1 = [\"foo\",\"bar\",\"baz\"]\nfor index,value in zip(range(0,len(list1)),list1):\n    if value == \"bar\":\n        print(index)\n</code></pre>\n", "abstract": "One can use zip() function to get the index of the value in the list. The code could be;"}, {"id": 73924789, "score": 0, "vote": 0, "content": "<p>Try the following code:</p>\n<pre><code class=\"python\">[\"foo\", \"bar\", \"baz\"].index(\"bar\")\n</code></pre>\n<p>Refer to: <a href=\"https://www.programiz.com/python-programming/methods/list/index\" rel=\"nofollow noreferrer\">https://www.programiz.com/python-programming/methods/list/index</a></p>\n", "abstract": "Try the following code: Refer to: https://www.programiz.com/python-programming/methods/list/index"}, {"id": 67384774, "score": -1, "vote": 0, "content": "<p>Simple option:</p>\n<pre><code class=\"python\">a = [\"foo\", \"bar\", \"baz\"]\n[i for i in range(len(a)) if a[i].find(\"bar\") != -1]\n</code></pre>\n", "abstract": "Simple option:"}]}, {"link": "https://stackoverflow.com/questions/3294889/iterating-over-dictionaries-using-for-loops", "question": {"id": "3294889", "title": "Iterating over dictionaries using &#39;for&#39; loops", "content": "<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3}\n\nfor key in d:\n    print(key, 'corresponds to', d[key])\n</code></pre>\n<p>How does Python recognize that it needs only to read the <code>key</code> from the dictionary? Is <code>key</code> a special keyword, or is it simply a variable?</p>\n", "abstract": "How does Python recognize that it needs only to read the key from the dictionary? Is key a special keyword, or is it simply a variable?"}, "answers": [{"id": 3294899, "score": 6502, "vote": 0, "content": "<p><code>key</code> is just a variable name.  </p>\n<pre><code class=\"python\">for key in d:\n</code></pre>\n<p>will simply loop over the keys in the dictionary, rather than the keys and values.  To loop over both key and value you can use the following:</p>\n<p>For Python 3.x:</p>\n<pre><code class=\"python\">for key, value in d.items():\n</code></pre>\n<p>For Python 2.x:</p>\n<pre><code class=\"python\">for key, value in d.iteritems():\n</code></pre>\n<p>To test for yourself, change the word <code>key</code> to <code>poop</code>.</p>\n<p>In Python 3.x, <code>iteritems()</code> was replaced with simply <code>items()</code>, which returns a set-like view backed by the dict, like <code>iteritems()</code> but even better. \nThis is also available in 2.7 as <code>viewitems()</code>. </p>\n<p>The operation <code>items()</code> will work for both 2 and 3, but in 2 it will return a list of the dictionary's <code>(key, value)</code> pairs, which will not reflect changes to the dict that happen after the <code>items()</code> call. If you want the 2.x behavior in 3.x, you can call <code>list(d.items())</code>.</p>\n", "abstract": "key is just a variable name.   will simply loop over the keys in the dictionary, rather than the keys and values.  To loop over both key and value you can use the following: For Python 3.x: For Python 2.x: To test for yourself, change the word key to poop. In Python 3.x, iteritems() was replaced with simply items(), which returns a set-like view backed by the dict, like iteritems() but even better. \nThis is also available in 2.7 as viewitems().  The operation items() will work for both 2 and 3, but in 2 it will return a list of the dictionary's (key, value) pairs, which will not reflect changes to the dict that happen after the items() call. If you want the 2.x behavior in 3.x, you can call list(d.items())."}, {"id": 3295295, "score": 531, "vote": 0, "content": "<p>It's not that key is a special word, but that dictionaries implement the iterator protocol.  You could do this in your class, e.g. see <a href=\"https://stackoverflow.com/questions/19151/build-a-basic-python-iterator/24377#24377\">this question</a> for how to build class iterators.</p>\n<p>In the case of dictionaries, it's implemented at the C level.  The details are available in <a href=\"http://www.python.org/dev/peps/pep-0234/\" rel=\"noreferrer\">PEP 234</a>.  In particular, the section titled \"Dictionary Iterators\":</p>\n<blockquote>\n<ul>\n<li><p>Dictionaries implement a tp_iter slot that returns an efficient\n  iterator that iterates over the keys of the dictionary. [...] This \n  means that we can write</p>\n<pre><code class=\"python\">for k in dict: ...\n</code></pre>\n<p>which is equivalent to, but much faster than</p>\n<pre><code class=\"python\">for k in dict.keys(): ...\n</code></pre>\n<p>as long as the restriction on modifications to the dictionary\n  (either by the loop or by another thread) are not violated.</p></li>\n<li><p>Add methods to dictionaries that return different kinds of\n  iterators explicitly:</p>\n<pre><code class=\"python\">for key in dict.iterkeys(): ...\n\nfor value in dict.itervalues(): ...\n\nfor key, value in dict.iteritems(): ...\n</code></pre>\n<p>This means that <code>for x in dict</code> is shorthand for <code>for x in\n   dict.iterkeys()</code>.</p></li>\n</ul>\n</blockquote>\n<p>In Python 3, <code>dict.iterkeys()</code>, <code>dict.itervalues()</code> and <code>dict.iteritems()</code> are no longer supported. Use <code>dict.keys()</code>, <code>dict.values()</code> and <code>dict.items()</code> instead.</p>\n", "abstract": "It's not that key is a special word, but that dictionaries implement the iterator protocol.  You could do this in your class, e.g. see this question for how to build class iterators. In the case of dictionaries, it's implemented at the C level.  The details are available in PEP 234.  In particular, the section titled \"Dictionary Iterators\": Dictionaries implement a tp_iter slot that returns an efficient\n  iterator that iterates over the keys of the dictionary. [...] This \n  means that we can write which is equivalent to, but much faster than as long as the restriction on modifications to the dictionary\n  (either by the loop or by another thread) are not violated. Add methods to dictionaries that return different kinds of\n  iterators explicitly: This means that for x in dict is shorthand for for x in\n   dict.iterkeys(). In Python 3, dict.iterkeys(), dict.itervalues() and dict.iteritems() are no longer supported. Use dict.keys(), dict.values() and dict.items() instead."}, {"id": 3295662, "score": 261, "vote": 0, "content": "<p>Iterating over a <code>dict</code> iterates through its keys in no particular order, as you can see here:</p>\n<p>(This is <strong><a href=\"https://stackoverflow.com/questions/39980323/dictionaries-are-ordered-in-python-3-6\">no longer the case in Python 3.6</a></strong>, but note that it's <strong>not guaranteed</strong> behaviour yet.)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d = {'x': 1, 'y': 2, 'z': 3}\n&gt;&gt;&gt; list(d)\n['y', 'x', 'z']\n&gt;&gt;&gt; d.keys()\n['y', 'x', 'z']\n</code></pre>\n<p>For your example, it is a better idea to use <code>dict.items()</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d.items()\n[('y', 2), ('x', 1), ('z', 3)]\n</code></pre>\n<p>This gives you a list of tuples. When you loop over them like this, each tuple is unpacked into <code>k</code> and <code>v</code> automatically:</p>\n<pre><code class=\"python\">for k,v in d.items():\n    print(k, 'corresponds to', v)\n</code></pre>\n<p>Using <code>k</code> and <code>v</code> as variable names when looping over a <code>dict</code> is quite common if the body of the loop is only a few lines. For more complicated loops it may be a good idea to use more descriptive names:</p>\n<pre><code class=\"python\">for letter, number in d.items():\n    print(letter, 'corresponds to', number)\n</code></pre>\n<p>It's a good idea to get into the habit of using format strings:</p>\n<pre><code class=\"python\">for letter, number in d.items():\n    print('{0} corresponds to {1}'.format(letter, number))\n</code></pre>\n", "abstract": "Iterating over a dict iterates through its keys in no particular order, as you can see here: (This is no longer the case in Python 3.6, but note that it's not guaranteed behaviour yet.) For your example, it is a better idea to use dict.items(): This gives you a list of tuples. When you loop over them like this, each tuple is unpacked into k and v automatically: Using k and v as variable names when looping over a dict is quite common if the body of the loop is only a few lines. For more complicated loops it may be a good idea to use more descriptive names: It's a good idea to get into the habit of using format strings:"}, {"id": 3295279, "score": 132, "vote": 0, "content": "<p><code>key</code> is simply a variable.</p>\n<p>For <strong>Python2.X</strong>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d = {'x': 1, 'y': 2, 'z': 3} \n&gt;&gt;&gt; for my_var in d:\n&gt;&gt;&gt;     print my_var, 'corresponds to', d[my_var]\n\nx corresponds to 1\ny corresponds to 2\nz corresponds to 3\n</code></pre>\n<p>... or better,</p>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3} \n\nfor the_key, the_value in d.iteritems():\n    print the_key, 'corresponds to', the_value\n</code></pre>\n<p>For <strong>Python3.X</strong>:</p>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3} \n\nfor the_key, the_value in d.items():\n    print(the_key, 'corresponds to', the_value)\n</code></pre>\n", "abstract": "key is simply a variable. For Python2.X: ... or better, For Python3.X:"}, {"id": 3294897, "score": 108, "vote": 0, "content": "<p>When you iterate through dictionaries using the <code>for .. in ..</code>-syntax, it always iterates over the keys (the values are accessible using <code>dictionary[key]</code>).</p>\n<p>To iterate over key-value pairs, use the following:</p>\n<ul>\n<li><code>for k,v in dict.iteritems()</code> in Python 2</li>\n<li><code>for k,v in dict.items()</code> in Python 3</li>\n</ul>\n", "abstract": "When you iterate through dictionaries using the for .. in ..-syntax, it always iterates over the keys (the values are accessible using dictionary[key]). To iterate over key-value pairs, use the following:"}, {"id": 3294969, "score": 40, "vote": 0, "content": "<p>This is a very common looping idiom. <code>in</code> is an operator. For when to use <code>for key in dict</code> and when it must be <code>for key in dict.keys()</code> see <a href=\"https://web.archive.org/web/20180411011411/http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html\" rel=\"noreferrer\">David Goodger's Idiomatic Python article (archived copy)</a>.</p>\n", "abstract": "This is a very common looping idiom. in is an operator. For when to use for key in dict and when it must be for key in dict.keys() see David Goodger's Idiomatic Python article (archived copy)."}, {"id": 44182134, "score": 34, "vote": 0, "content": "<p>I have a use case where I have to iterate through the dict to get the key, value pair, also the index indicating where I am. This is how I do it:</p>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3} \nfor i, (key, value) in enumerate(d.items()):\n   print(i, key, value)\n</code></pre>\n<p>Note that the parentheses around the key, value are important, without them, you'd get an <code>ValueError</code> \"not enough values to unpack\".</p>\n", "abstract": "I have a use case where I have to iterate through the dict to get the key, value pair, also the index indicating where I am. This is how I do it: Note that the parentheses around the key, value are important, without them, you'd get an ValueError \"not enough values to unpack\"."}, {"id": 44666083, "score": 30, "vote": 0, "content": "<blockquote>\n<h2>Iterating over dictionaries using 'for' loops</h2>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3} \nfor key in d:\n    ...\n</code></pre>\n<p>How does Python recognize that it needs only to read the key from the\n  dictionary? Is key a special word in Python? Or is it simply a\n  variable?</p>\n</blockquote>\n<p>It's not just <code>for</code> loops. The important word here is \"iterating\".</p>\n<p>A dictionary is a mapping of keys to values:</p>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3} \n</code></pre>\n<p>Any time we iterate over it, we iterate over the keys. The variable name <code>key</code> is only intended to be descriptive - and it is quite apt for the purpose.</p>\n<p>This happens in a list comprehension:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; [k for k in d]\n['x', 'y', 'z']\n</code></pre>\n<p>It happens when we pass the dictionary to list (or any other collection type object):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(d)\n['x', 'y', 'z']\n</code></pre>\n<p>The way Python iterates is, in a context where it needs to, it calls the <code>__iter__</code> method of the object (in this case the dictionary) which returns an iterator (in this case, a keyiterator object):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d.__iter__()\n&lt;dict_keyiterator object at 0x7fb1747bee08&gt;\n</code></pre>\n<p>We shouldn't use these special methods ourselves, instead, use the respective builtin function to call it, <code>iter</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; key_iterator = iter(d)\n&gt;&gt;&gt; key_iterator\n&lt;dict_keyiterator object at 0x7fb172fa9188&gt;\n</code></pre>\n<p>Iterators have a <code>__next__</code> method - but we call it with the builtin function, <code>next</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; next(key_iterator)\n'x'\n&gt;&gt;&gt; next(key_iterator)\n'y'\n&gt;&gt;&gt; next(key_iterator)\n'z'\n&gt;&gt;&gt; next(key_iterator)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nStopIteration\n</code></pre>\n<p>When an iterator is exhausted, it raises <code>StopIteration</code>. This is how Python knows to exit a <code>for</code> loop, or a list comprehension, or a generator expression, or any other iterative context. Once an iterator raises <code>StopIteration</code> it will always raise it - if you want to iterate again, you need a new one.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(key_iterator)\n[]\n&gt;&gt;&gt; new_key_iterator = iter(d)\n&gt;&gt;&gt; list(new_key_iterator)\n['x', 'y', 'z']\n</code></pre>\n<h2>Returning to dicts</h2>\n<p>We've seen dicts iterating in many contexts. What we've seen is that any time we iterate over a dict, we get the keys. Back to the original example:</p>\n<blockquote>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3} \nfor key in d:\n</code></pre>\n</blockquote>\n<p>If we change the variable name, we still get the keys. Let's try it:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; for each_key in d:\n...     print(each_key, '=&gt;', d[each_key])\n... \nx =&gt; 1\ny =&gt; 2\nz =&gt; 3\n</code></pre>\n<p>If we want to iterate over the values, we need to use the <code>.values</code> method of dicts, or for both together, <code>.items</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(d.values())\n[1, 2, 3]\n&gt;&gt;&gt; list(d.items())\n[('x', 1), ('y', 2), ('z', 3)]\n</code></pre>\n<p>In the example given, it would be more efficient to iterate over the items like this:</p>\n<pre><code class=\"python\">for a_key, corresponding_value in d.items():\n    print(a_key, corresponding_value)\n</code></pre>\n<p>But for academic purposes, the question's example is just fine.</p>\n", "abstract": "How does Python recognize that it needs only to read the key from the\n  dictionary? Is key a special word in Python? Or is it simply a\n  variable? It's not just for loops. The important word here is \"iterating\". A dictionary is a mapping of keys to values: Any time we iterate over it, we iterate over the keys. The variable name key is only intended to be descriptive - and it is quite apt for the purpose. This happens in a list comprehension: It happens when we pass the dictionary to list (or any other collection type object): The way Python iterates is, in a context where it needs to, it calls the __iter__ method of the object (in this case the dictionary) which returns an iterator (in this case, a keyiterator object): We shouldn't use these special methods ourselves, instead, use the respective builtin function to call it, iter: Iterators have a __next__ method - but we call it with the builtin function, next: When an iterator is exhausted, it raises StopIteration. This is how Python knows to exit a for loop, or a list comprehension, or a generator expression, or any other iterative context. Once an iterator raises StopIteration it will always raise it - if you want to iterate again, you need a new one. We've seen dicts iterating in many contexts. What we've seen is that any time we iterate over a dict, we get the keys. Back to the original example: If we change the variable name, we still get the keys. Let's try it: If we want to iterate over the values, we need to use the .values method of dicts, or for both together, .items: In the example given, it would be more efficient to iterate over the items like this: But for academic purposes, the question's example is just fine."}, {"id": 70724260, "score": 21, "vote": 0, "content": "<p>For Iterating through dictionaries, The below code can be used.</p>\n<pre><code class=\"python\">dictionary= {1:\"a\", 2:\"b\", 3:\"c\"}\n\n#To iterate over the keys\nfor key in dictionary.keys():\n    print(key)\n\n#To Iterate over the values\nfor value in dictionary.values():\n    print(value)\n\n#To Iterate both the keys and values\nfor key, value in dictionary.items():\n    print(key,'\\t', value)\n</code></pre>\n", "abstract": "For Iterating through dictionaries, The below code can be used."}, {"id": 47088919, "score": 13, "vote": 0, "content": "<p>You can check the implementation of CPython's <code>dicttype</code> on GitHub. This is the signature of method that implements the dict iterator:</p>\n<pre><code class=\"python\">_PyDict_Next(PyObject *op, Py_ssize_t *ppos, PyObject **pkey,\n             PyObject **pvalue, Py_hash_t *phash)\n</code></pre>\n<p><a href=\"https://github.com/python/cpython/blob/b2e5794870eb4728ddfaafc0f79a40299576434f/Objects/dictobject.c\" rel=\"noreferrer\">CPython dictobject.c</a></p>\n", "abstract": "You can check the implementation of CPython's dicttype on GitHub. This is the signature of method that implements the dict iterator: CPython dictobject.c"}, {"id": 34550429, "score": 8, "vote": 0, "content": "<p>To iterate over keys, it is slower but better to use <code>my_dict.keys()</code>. If you tried to do something like this:</p>\n<pre><code class=\"python\">for key in my_dict:\n    my_dict[key+\"-1\"] = my_dict[key]-1\n</code></pre>\n<p>it would create a runtime error because you are changing the keys while the program is running. If you are absolutely set on reducing time, use the <code>for key in my_dict</code> way, but you have been warned.</p>\n", "abstract": "To iterate over keys, it is slower but better to use my_dict.keys(). If you tried to do something like this: it would create a runtime error because you are changing the keys while the program is running. If you are absolutely set on reducing time, use the for key in my_dict way, but you have been warned."}, {"id": 63814044, "score": 7, "vote": 0, "content": "<p>If you are looking for a clear and visual example:</p>\n<pre><code class=\"python\">cat  = {'name': 'Snowy', 'color': 'White' ,'age': 14}\nfor key , value in cat.items():\n   print(key, ': ', value)\n</code></pre>\n<p>Result:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">name:  Snowy\ncolor:  White\nage:  14\n</code></pre>\n", "abstract": "If you are looking for a clear and visual example: Result:"}, {"id": 61296126, "score": 6, "vote": 0, "content": "<p>This will print the output in <em>sorted</em> order by <em>values</em> in ascending order.</p>\n<pre><code class=\"python\">d = {'x': 3, 'y': 1, 'z': 2}\n\ndef by_value(item):\n    return item[1]\n\nfor key, value in sorted(d.items(), key=by_value):\n    print(key, '-&gt;', value)\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<pre><code class=\"python\">y -&gt; 1\nz -&gt; 2\nx -&gt; 3\n</code></pre>\n</blockquote>\n", "abstract": "This will print the output in sorted order by values in ascending order. Output:"}, {"id": 67599090, "score": 0, "vote": 0, "content": "<p>Let's get straight to the point. If the word key is just a variable, as you have mentioned then the main thing to note is that when you run a <strong>'FOR LOOP'</strong> over a dictionary it runs through only the <em>'keys'</em> and ignores the <em>'values'</em>.</p>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3} \nfor key in d:\n    print (key, 'corresponds to', d[key])\n</code></pre>\n<p>rather try this:</p>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3} \nfor i in d:\n    print (i, 'corresponds to', d[i])\n</code></pre>\n<p>but if you use a function like:</p>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3}\nprint(d.keys())\n</code></pre>\n<p>in the above case <strong>'keys'</strong> is just not a variable, its a function.</p>\n", "abstract": "Let's get straight to the point. If the word key is just a variable, as you have mentioned then the main thing to note is that when you run a 'FOR LOOP' over a dictionary it runs through only the 'keys' and ignores the 'values'. rather try this: but if you use a function like: in the above case 'keys' is just not a variable, its a function."}, {"id": 70747846, "score": 0, "vote": 0, "content": "<p>A dictionary in Python is a collection of key-value pairs. Each key is connected to a value, and you can use a key to access the value associated with that key. A key's value can be a number, a string, a list, or even another dictionary. In this case, threat each \"key-value pair\" as a separate row in the table: d is your table with two columns. the key is the first column, key[value] is your second column. Your for loop is a standard way to iterate over a table.</p>\n", "abstract": "A dictionary in Python is a collection of key-value pairs. Each key is connected to a value, and you can use a key to access the value associated with that key. A key's value can be a number, a string, a list, or even another dictionary. In this case, threat each \"key-value pair\" as a separate row in the table: d is your table with two columns. the key is the first column, key[value] is your second column. Your for loop is a standard way to iterate over a table."}, {"id": 73890429, "score": 0, "vote": 0, "content": "<h1>Use enumerate keyword with for loop</h1>\n<p>Key is simple a variable you can use any other name as show in below example</p>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3}\nfor names in d:\n    print(names , 'corresponds to ', d[names])\n</code></pre>\n<p>using <strong>enumerate</strong>,  you can get both value and key in same for loop</p>\n<pre><code class=\"python\">d = {'x': 1, 'y': 2, 'z': 3}\nfor values, names in enumerate(d):\n    print(names , 'corresponds to ', values)\n</code></pre>\n", "abstract": "Key is simple a variable you can use any other name as show in below example using enumerate,  you can get both value and key in same for loop"}]}, {"link": "https://stackoverflow.com/questions/423379/using-global-variables-in-a-function", "question": {"id": "423379", "title": "Using global variables in a function", "content": "<p>How do I create or use a global variable inside a function?</p>\n<p>How do I use a global variable that was defined in one function inside other functions?</p>\n<hr/>\n<p><sub>Failing to use the <code>global</code> keyword where appropriate often causes <code>UnboundLocalError</code>. The precise rules for this are explained at <a href=\"https://stackoverflow.com/questions/370357\">UnboundLocalError on local variable when reassigned after first use</a>. Generally, please close other questions as a duplicate of <em>that</em> question when an explanation is sought, and <em>this</em> question when someone simply needs to know the <code>global</code> keyword.</sub></p>\n", "abstract": "How do I create or use a global variable inside a function? How do I use a global variable that was defined in one function inside other functions? Failing to use the global keyword where appropriate often causes UnboundLocalError. The precise rules for this are explained at UnboundLocalError on local variable when reassigned after first use. Generally, please close other questions as a duplicate of that question when an explanation is sought, and this question when someone simply needs to know the global keyword."}, "answers": [{"id": 423596, "score": 4958, "vote": 0, "content": "<p>You can use a global variable within other functions by declaring it as <code>global</code> within each function that assigns a value to it:</p>\n<pre><code class=\"python\">globvar = 0\n\ndef set_globvar_to_one():\n    global globvar    # Needed to modify global copy of globvar\n    globvar = 1\n\ndef print_globvar():\n    print(globvar)     # No need for global declaration to read value of globvar\n\nset_globvar_to_one()\nprint_globvar()       # Prints 1\n</code></pre>\n<p>Since it's unclear whether <code>globvar = 1</code> is creating a local variable or changing a global variable, Python defaults to creating a local variable, and makes you explicitly choose the other behavior with the <code>global</code> keyword.</p>\n<p>See other answers if you want to share a global variable across modules.</p>\n", "abstract": "You can use a global variable within other functions by declaring it as global within each function that assigns a value to it: Since it's unclear whether globvar = 1 is creating a local variable or changing a global variable, Python defaults to creating a local variable, and makes you explicitly choose the other behavior with the global keyword. See other answers if you want to share a global variable across modules."}, {"id": 423668, "score": 867, "vote": 0, "content": "<p>If I'm understanding your situation correctly, what you're seeing is the result of how Python handles local (function) and global (module) namespaces.</p>\n<p>Say you've got a module like this:</p>\n<pre><code class=\"python\"># sample.py\n_my_global = 5\n\ndef func1():\n    _my_global = 42\n\ndef func2():\n    print _my_global\n\nfunc1()\nfunc2()\n</code></pre>\n<p>You might expecting this to print 42, but instead it prints 5.  As has already been mentioned, if you add a '<code>global</code>' declaration to <code>func1()</code>, then <code>func2()</code> will print 42.</p>\n<pre><code class=\"python\">def func1():\n    global _my_global \n    _my_global = 42\n</code></pre>\n<p>What's going on here is that Python assumes that any name that is <em>assigned to</em>, anywhere within a function, is local to that function unless explicitly told otherwise.  If it is only <em>reading</em> from a name, and the name doesn't exist locally, it will try to look up the name in any containing scopes (e.g. the module's global scope).</p>\n<p>When you assign 42 to the name <code>_my_global</code>, therefore, Python creates a local variable that shadows the global variable of the same name.  That local goes out of scope and is <a href=\"http://www.digi.com/wiki/developer/index.php/Python_Garbage_Collection\" rel=\"noreferrer\">garbage-collected</a> when <code>func1()</code> returns; meanwhile, <code>func2()</code> can never see anything other than the (unmodified) global name.  Note that this namespace decision happens at compile time, not at runtime -- if you were to read the value of <code>_my_global</code> inside <code>func1()</code> before you assign to it, you'd get an <code>UnboundLocalError</code>, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.  But by using the '<code>global</code>' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally.</p>\n<p>(I believe that this behavior originated largely through an optimization of local namespaces -- without this behavior,  Python's VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn't already exist at module/builtin level), which would significantly slow down a very common operation.)</p>\n", "abstract": "If I'm understanding your situation correctly, what you're seeing is the result of how Python handles local (function) and global (module) namespaces. Say you've got a module like this: You might expecting this to print 42, but instead it prints 5.  As has already been mentioned, if you add a 'global' declaration to func1(), then func2() will print 42. What's going on here is that Python assumes that any name that is assigned to, anywhere within a function, is local to that function unless explicitly told otherwise.  If it is only reading from a name, and the name doesn't exist locally, it will try to look up the name in any containing scopes (e.g. the module's global scope). When you assign 42 to the name _my_global, therefore, Python creates a local variable that shadows the global variable of the same name.  That local goes out of scope and is garbage-collected when func1() returns; meanwhile, func2() can never see anything other than the (unmodified) global name.  Note that this namespace decision happens at compile time, not at runtime -- if you were to read the value of _my_global inside func1() before you assign to it, you'd get an UnboundLocalError, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.  But by using the 'global' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally. (I believe that this behavior originated largely through an optimization of local namespaces -- without this behavior,  Python's VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn't already exist at module/builtin level), which would significantly slow down a very common operation.)"}, {"id": 423401, "score": 265, "vote": 0, "content": "<p>You may want to explore the notion of <a href=\"http://docs.python.org/reference/datamodel.html\" rel=\"noreferrer\">namespaces</a>. In Python, the <a href=\"http://docs.python.org/tutorial/modules.html\" rel=\"noreferrer\">module</a> is the natural place for <em>global</em> data:</p>\n<blockquote>\n<p>Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user\u2019s global variables. On the other hand, if you know what you are doing you can touch a module\u2019s global variables with the same notation used to refer to its functions, <code>modname.itemname</code>.</p>\n</blockquote>\n<p>A specific use of global-in-a-module is described here - <a href=\"https://docs.python.org/3/faq/programming.html#how-do-i-share-global-variables-across-modules\" rel=\"noreferrer\">How do I share global variables across modules?</a>, and for completeness the contents are shared here:</p>\n<blockquote>\n<p>The canonical way to share information across modules within a single program is to create a special configuration module (often called <strong>config</strong> or <strong>cfg</strong>). Just import the configuration module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:</p>\n</blockquote>\n<blockquote>\n<p>File: config.py</p>\n</blockquote>\n<blockquote>\n<pre><code class=\"python\">x = 0   # Default value of the 'x' configuration setting\n</code></pre>\n</blockquote>\n<blockquote>\n<p>File: mod.py</p>\n</blockquote>\n<pre><code class=\"python\">import config\nconfig.x = 1\n</code></pre>\n<blockquote>\n<p>File: main.py</p>\n</blockquote>\n<pre><code class=\"python\">import config\nimport mod\nprint config.x\n</code></pre>\n", "abstract": "You may want to explore the notion of namespaces. In Python, the module is the natural place for global data: Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user\u2019s global variables. On the other hand, if you know what you are doing you can touch a module\u2019s global variables with the same notation used to refer to its functions, modname.itemname. A specific use of global-in-a-module is described here - How do I share global variables across modules?, and for completeness the contents are shared here: The canonical way to share information across modules within a single program is to create a special configuration module (often called config or cfg). Just import the configuration module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example: File: config.py File: mod.py File: main.py"}, {"id": 6664227, "score": 111, "vote": 0, "content": "<p>Python uses a simple heuristic to decide which scope it should load a variable from, between local and global.  If a variable name appears on the left hand side of an assignment, but is not declared global, it is assumed to be local.  If it does not appear on the left hand side of an assignment, it is assumed to be global.  </p>\n<pre><code class=\"python\">&gt;&gt;&gt; import dis\n&gt;&gt;&gt; def foo():\n...     global bar\n...     baz = 5\n...     print bar\n...     print baz\n...     print quux\n... \n&gt;&gt;&gt; dis.disassemble(foo.func_code)\n  3           0 LOAD_CONST               1 (5)\n              3 STORE_FAST               0 (baz)\n\n  4           6 LOAD_GLOBAL              0 (bar)\n              9 PRINT_ITEM          \n             10 PRINT_NEWLINE       \n\n  5          11 LOAD_FAST                0 (baz)\n             14 PRINT_ITEM          \n             15 PRINT_NEWLINE       \n\n  6          16 LOAD_GLOBAL              1 (quux)\n             19 PRINT_ITEM          \n             20 PRINT_NEWLINE       \n             21 LOAD_CONST               0 (None)\n             24 RETURN_VALUE        \n&gt;&gt;&gt; \n</code></pre>\n<p>See how baz, which appears on the left side of an assignment in <code>foo()</code>, is the only <code>LOAD_FAST</code> variable.</p>\n", "abstract": "Python uses a simple heuristic to decide which scope it should load a variable from, between local and global.  If a variable name appears on the left hand side of an assignment, but is not declared global, it is assumed to be local.  If it does not appear on the left hand side of an assignment, it is assumed to be global.   See how baz, which appears on the left side of an assignment in foo(), is the only LOAD_FAST variable."}, {"id": 423641, "score": 74, "vote": 0, "content": "<p>If you want to refer to a global variable in a function, you can use the <strong>global</strong> keyword to declare which variables are global. You don't have to use it in all cases (as someone here incorrectly claims) - if the name referenced in an expression cannot be found in local scope or scopes in the functions in which this function is defined, it is looked up among global variables.</p>\n<p>However, if you assign to a new variable not declared as global in the function, it is implicitly declared as local, and it can overshadow any existing global variable with the same name.</p>\n<p>Also, global variables are useful, contrary to some OOP zealots who claim otherwise - especially for smaller scripts, where OOP is overkill.</p>\n", "abstract": "If you want to refer to a global variable in a function, you can use the global keyword to declare which variables are global. You don't have to use it in all cases (as someone here incorrectly claims) - if the name referenced in an expression cannot be found in local scope or scopes in the functions in which this function is defined, it is looked up among global variables. However, if you assign to a new variable not declared as global in the function, it is implicitly declared as local, and it can overshadow any existing global variable with the same name. Also, global variables are useful, contrary to some OOP zealots who claim otherwise - especially for smaller scripts, where OOP is overkill."}, {"id": 34559513, "score": 67, "vote": 0, "content": "<blockquote>\n<h1>If I create a global variable in one function, how can I use that variable in another function?</h1>\n</blockquote>\n<p>We can create a global with the following function:</p>\n<pre><code class=\"python\">def create_global_variable():\n    global global_variable # must declare it to be a global first\n    # modifications are thus reflected on the module's global scope\n    global_variable = 'Foo' \n</code></pre>\n<p>Writing a function does not actually run its code. So we call the <code>create_global_variable</code> function:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; create_global_variable()\n</code></pre>\n<h2>Using globals without modification</h2>\n<p>You can just use it, so long as you don't expect to change which object it points to: </p>\n<p>For example, </p>\n<pre><code class=\"python\">def use_global_variable():\n    return global_variable + '!!!'\n</code></pre>\n<p>and now we can use the global variable:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; use_global_variable()\n'Foo!!!'\n</code></pre>\n<h2>Modification of the global variable from inside a function</h2>\n<p>To point the global variable at a different object, you are required to use the global keyword again:</p>\n<pre><code class=\"python\">def change_global_variable():\n    global global_variable\n    global_variable = 'Bar'\n</code></pre>\n<p>Note that after writing this function, the code actually changing it has still not run:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; use_global_variable()\n'Foo!!!'\n</code></pre>\n<p>So after calling the function:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; change_global_variable()\n</code></pre>\n<p>we can see that the global variable has been changed. The <code>global_variable</code> name now points to <code>'Bar'</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; use_global_variable()\n'Bar!!!'\n</code></pre>\n<p>Note that \"global\" in Python is not truly global - it's only global to the module level. So it is only available to functions written in the modules in which it is global. Functions remember the module in which they are written, so when they are exported into other modules, they still look in the module in which they were created to find global variables.</p>\n<h1>Local variables with the same name</h1>\n<p>If you create a local variable with the same name, it will overshadow a global variable:</p>\n<pre><code class=\"python\">def use_local_with_same_name_as_global():\n    # bad name for a local variable, though.\n    global_variable = 'Baz' \n    return global_variable + '!!!'\n\n&gt;&gt;&gt; use_local_with_same_name_as_global()\n'Baz!!!'\n</code></pre>\n<p>But using that misnamed local variable does not change the global variable:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; use_global_variable()\n'Bar!!!'\n</code></pre>\n<p>Note that you should avoid using the local variables with the same names as globals unless you know precisely what you are doing and have a very good reason to do so. I have not yet encountered such a reason.</p>\n<h2>We get the same behavior in classes</h2>\n<p>A follow on comment asks:</p>\n<blockquote>\n<p>what to do if I want to create a global variable inside a function inside a class and want to use that variable inside another function inside another class?</p>\n</blockquote>\n<p>Here I demonstrate we get the same behavior in methods as we do in regular functions:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class Foo:\n    def foo(self):\n        global global_variable\n        global_variable = 'Foo'\n\nclass Bar:\n    def bar(self):\n        return global_variable + '!!!'\n\nFoo().foo()\n</code></pre>\n<p>And now:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; Bar().bar()\n'Foo!!!'\n</code></pre>\n<p>But I would suggest instead of using global variables you use class attributes, to avoid cluttering the module namespace. Also note we don't use <code>self</code> arguments here - these could be class methods (handy if mutating the class attribute from the usual <code>cls</code> argument) or static methods (no <code>self</code> or <code>cls</code>).</p>\n", "abstract": "We can create a global with the following function: Writing a function does not actually run its code. So we call the create_global_variable function: You can just use it, so long as you don't expect to change which object it points to:  For example,  and now we can use the global variable: To point the global variable at a different object, you are required to use the global keyword again: Note that after writing this function, the code actually changing it has still not run: So after calling the function: we can see that the global variable has been changed. The global_variable name now points to 'Bar': Note that \"global\" in Python is not truly global - it's only global to the module level. So it is only available to functions written in the modules in which it is global. Functions remember the module in which they are written, so when they are exported into other modules, they still look in the module in which they were created to find global variables. If you create a local variable with the same name, it will overshadow a global variable: But using that misnamed local variable does not change the global variable: Note that you should avoid using the local variables with the same names as globals unless you know precisely what you are doing and have a very good reason to do so. I have not yet encountered such a reason. A follow on comment asks: what to do if I want to create a global variable inside a function inside a class and want to use that variable inside another function inside another class? Here I demonstrate we get the same behavior in methods as we do in regular functions: And now: But I would suggest instead of using global variables you use class attributes, to avoid cluttering the module namespace. Also note we don't use self arguments here - these could be class methods (handy if mutating the class attribute from the usual cls argument) or static methods (no self or cls)."}, {"id": 24572187, "score": 56, "vote": 0, "content": "<p>In addition to already existing answers and to make this more confusing:</p>\n<blockquote>\n<p>In Python, variables that are only referenced inside a function are\n  <strong>implicitly global</strong>. If a variable is assigned a new value anywhere\n  within the function\u2019s body, it\u2019s assumed to be a <strong>local</strong>. If a variable\n  is ever assigned a new value inside the function, the variable is\n  implicitly local, and you need to explicitly declare it as \u2018global\u2019.</p>\n<p>Though a bit surprising at first, a moment\u2019s consideration explains\n  this. On one hand, requiring global for assigned variables provides a\n  bar against unintended side-effects. On the other hand, if global was\n  required for all global references, you\u2019d be using global all the\n  time. You\u2019d have to declare as global every reference to a built-in\n  function or to a component of an imported module. This clutter would\n  defeat the usefulness of the global declaration for identifying\n  side-effects.</p>\n</blockquote>\n<p>Source: <em><a href=\"https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python\">What are the rules for local and global variables in Python?</a></em>.</p>\n", "abstract": "In addition to already existing answers and to make this more confusing: In Python, variables that are only referenced inside a function are\n  implicitly global. If a variable is assigned a new value anywhere\n  within the function\u2019s body, it\u2019s assumed to be a local. If a variable\n  is ever assigned a new value inside the function, the variable is\n  implicitly local, and you need to explicitly declare it as \u2018global\u2019. Though a bit surprising at first, a moment\u2019s consideration explains\n  this. On one hand, requiring global for assigned variables provides a\n  bar against unintended side-effects. On the other hand, if global was\n  required for all global references, you\u2019d be using global all the\n  time. You\u2019d have to declare as global every reference to a built-in\n  function or to a component of an imported module. This clutter would\n  defeat the usefulness of the global declaration for identifying\n  side-effects. Source: What are the rules for local and global variables in Python?."}, {"id": 19151605, "score": 41, "vote": 0, "content": "<p>With parallel execution, global variables can cause unexpected results if you don't understand what is happening. Here is an example of using a global variable within multiprocessing. We can clearly see that each process works with its own copy of the variable:</p>\n<pre><code class=\"python\">import multiprocessing\nimport os\nimport random\nimport sys\nimport time\n\ndef worker(new_value):\n    old_value = get_value()\n    set_value(random.randint(1, 99))\n    print('pid=[{pid}] '\n          'old_value=[{old_value:2}] '\n          'new_value=[{new_value:2}] '\n          'get_value=[{get_value:2}]'.format(\n          pid=str(os.getpid()),\n          old_value=old_value,\n          new_value=new_value,\n          get_value=get_value()))\n\ndef get_value():\n    global global_variable\n    return global_variable\n\ndef set_value(new_value):\n    global global_variable\n    global_variable = new_value\n\nglobal_variable = -1\n\nprint('before set_value(), get_value() = [%s]' % get_value())\nset_value(new_value=-2)\nprint('after  set_value(), get_value() = [%s]' % get_value())\n\nprocessPool = multiprocessing.Pool(processes=5)\nprocessPool.map(func=worker, iterable=range(15))\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"python\">before set_value(), get_value() = [-1]\nafter  set_value(), get_value() = [-2]\npid=[53970] old_value=[-2] new_value=[ 0] get_value=[23]\npid=[53971] old_value=[-2] new_value=[ 1] get_value=[42]\npid=[53970] old_value=[23] new_value=[ 4] get_value=[50]\npid=[53970] old_value=[50] new_value=[ 6] get_value=[14]\npid=[53971] old_value=[42] new_value=[ 5] get_value=[31]\npid=[53972] old_value=[-2] new_value=[ 2] get_value=[44]\npid=[53973] old_value=[-2] new_value=[ 3] get_value=[94]\npid=[53970] old_value=[14] new_value=[ 7] get_value=[21]\npid=[53971] old_value=[31] new_value=[ 8] get_value=[34]\npid=[53972] old_value=[44] new_value=[ 9] get_value=[59]\npid=[53973] old_value=[94] new_value=[10] get_value=[87]\npid=[53970] old_value=[21] new_value=[11] get_value=[21]\npid=[53971] old_value=[34] new_value=[12] get_value=[82]\npid=[53972] old_value=[59] new_value=[13] get_value=[ 4]\npid=[53973] old_value=[87] new_value=[14] get_value=[70]\n</code></pre>\n", "abstract": "With parallel execution, global variables can cause unexpected results if you don't understand what is happening. Here is an example of using a global variable within multiprocessing. We can clearly see that each process works with its own copy of the variable: Output:"}, {"id": 19347254, "score": 34, "vote": 0, "content": "<p>As it turns out the answer is always simple.</p>\n<p>Here is a small sample module with a simple way to show it in a <code>main</code> definition:</p>\n<pre><code class=\"python\">def five(enterAnumber,sumation):\n    global helper\n    helper  = enterAnumber + sumation\n\ndef isTheNumber():\n    return helper\n</code></pre>\n<p>Here is how to show it in a <code>main</code> definition:</p>\n<pre><code class=\"python\">import TestPy\n\ndef main():\n    atest  = TestPy\n    atest.five(5,8)\n    print(atest.isTheNumber())\n\nif __name__ == '__main__':\n    main()\n</code></pre>\n<p>This simple code works just like that, and it will execute. I hope it helps.</p>\n", "abstract": "As it turns out the answer is always simple. Here is a small sample module with a simple way to show it in a main definition: Here is how to show it in a main definition: This simple code works just like that, and it will execute. I hope it helps."}, {"id": 27287648, "score": 33, "vote": 0, "content": "<p>What you are saying is to use the method like this:</p>\n<pre><code class=\"python\">globvar = 5\n\ndef f():\n    var = globvar\n    print(var)\n\nf()  # Prints 5\n</code></pre>\n<p>But the better way is to use the global variable like this:</p>\n<pre><code class=\"python\">globvar = 5\ndef f():\n    global globvar\n    print(globvar)\nf()   #prints 5\n</code></pre>\n<p>Both give the same output.</p>\n", "abstract": "What you are saying is to use the method like this: But the better way is to use the global variable like this: Both give the same output."}, {"id": 27580376, "score": 30, "vote": 0, "content": "<p>You need to reference the global variable in every function you want to use.</p>\n<p>As follows:</p>\n<pre><code class=\"python\">var = \"test\"\n\ndef printGlobalText():\n    global var #wWe are telling to explicitly use the global version\n    var = \"global from printGlobalText fun.\"\n    print \"var from printGlobalText: \" + var\n\ndef printLocalText():\n    #We are NOT telling to explicitly use the global version, so we are creating a local variable\n    var = \"local version from printLocalText fun\"\n    print \"var from printLocalText: \" + var\n\nprintGlobalText()\nprintLocalText()\n\"\"\"\nOutput Result:\nvar from printGlobalText: global from printGlobalText fun.\nvar from printLocalText: local version from printLocalText\n[Finished in 0.1s]\n\"\"\"\n</code></pre>\n", "abstract": "You need to reference the global variable in every function you want to use. As follows:"}, {"id": 28329600, "score": 30, "vote": 0, "content": "<p>Try this:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def x1():\n    global x\n    x += 1\n    print('x1: ', x)\n\ndef x2():\n    global x\n    x = x+1\n    print('x2: ', x)\n\nx = 5\nprint('x:  ', x)\nx1()\nx2()\n\n# Output:\n# x:   5\n# x1:  6\n# x2:  7\n</code></pre>\n", "abstract": "Try this:"}, {"id": 427818, "score": 27, "vote": 0, "content": "<p>You're not actually storing the global in a local variable, just creating a local reference to the same object that your original global reference refers to. Remember that pretty much everything in Python is a name referring to an object, and nothing gets copied in usual operation.</p>\n<p>If you didn't have to explicitly specify when an identifier was to refer to a predefined global, then you'd presumably have to explicitly specify when an identifier is a new local variable instead (for example, with something like the 'var' command seen in JavaScript). Since local variables are more common than global variables in any serious and non-trivial system, Python's system makes more sense in most cases.</p>\n<p>You <em>could</em> have a language which attempted to guess, using a global variable if it existed or creating a local variable if it didn't. However, that would be very error-prone. For example, importing another module could inadvertently introduce a global variable by that name, changing the behaviour of your program.</p>\n", "abstract": "You're not actually storing the global in a local variable, just creating a local reference to the same object that your original global reference refers to. Remember that pretty much everything in Python is a name referring to an object, and nothing gets copied in usual operation. If you didn't have to explicitly specify when an identifier was to refer to a predefined global, then you'd presumably have to explicitly specify when an identifier is a new local variable instead (for example, with something like the 'var' command seen in JavaScript). Since local variables are more common than global variables in any serious and non-trivial system, Python's system makes more sense in most cases. You could have a language which attempted to guess, using a global variable if it existed or creating a local variable if it didn't. However, that would be very error-prone. For example, importing another module could inadvertently introduce a global variable by that name, changing the behaviour of your program."}, {"id": 43285234, "score": 23, "vote": 0, "content": "<p>In case you have a local variable with the same name, you might want to use the <a href=\"https://docs.python.org/3/library/functions.html#globals\" rel=\"noreferrer\"><code>globals()</code> function</a>.</p>\n<pre><code class=\"python\">globals()['your_global_var'] = 42\n</code></pre>\n", "abstract": "In case you have a local variable with the same name, you might want to use the globals() function."}, {"id": 33320055, "score": 20, "vote": 0, "content": "<p>Following on and as an add on, use a file to contain all global variables all declared locally and then <code>import as</code>:</p>\n<p>File <em>initval.py</em>:</p>\n<pre><code class=\"python\">Stocksin = 300\nPrices = []\n</code></pre>\n<p>File <em>getstocks.py</em>:</p>\n<pre><code class=\"python\">import initval as iv\n\ndef getmystocks(): \n    iv.Stocksin = getstockcount()\n\n\ndef getmycharts():\n    for ic in range(iv.Stocksin):\n</code></pre>\n", "abstract": "Following on and as an add on, use a file to contain all global variables all declared locally and then import as: File initval.py: File getstocks.py:"}, {"id": 34664752, "score": 17, "vote": 0, "content": "<p>Writing to explicit elements of a global array does not apparently need the global declaration, though writing to it \"wholesale\" does have that requirement:</p>\n<pre><code class=\"python\">import numpy as np\n\nhostValue = 3.14159\nhostArray = np.array([2., 3.])\nhostMatrix = np.array([[1.0, 0.0],[ 0.0, 1.0]])\n\ndef func1():\n    global hostValue    # mandatory, else local.\n    hostValue = 2.0\n\ndef func2():\n    global hostValue    # mandatory, else UnboundLocalError.\n    hostValue += 1.0\n\ndef func3():\n    global hostArray    # mandatory, else local.\n    hostArray = np.array([14., 15.])\n\ndef func4():            # no need for globals\n    hostArray[0] = 123.4\n\ndef func5():            # no need for globals\n    hostArray[1] += 1.0\n\ndef func6():            # no need for globals\n    hostMatrix[1][1] = 12.\n\ndef func7():            # no need for globals\n    hostMatrix[0][0] += 0.33\n\nfunc1()\nprint \"After func1(), hostValue = \", hostValue\nfunc2()\nprint \"After func2(), hostValue = \", hostValue\nfunc3()\nprint \"After func3(), hostArray = \", hostArray\nfunc4()\nprint \"After func4(), hostArray = \", hostArray\nfunc5()\nprint \"After func5(), hostArray = \", hostArray\nfunc6()\nprint \"After func6(), hostMatrix = \\n\", hostMatrix\nfunc7()\nprint \"After func7(), hostMatrix = \\n\", hostMatrix\n</code></pre>\n", "abstract": "Writing to explicit elements of a global array does not apparently need the global declaration, though writing to it \"wholesale\" does have that requirement:"}, {"id": 46058078, "score": 9, "vote": 0, "content": "<p>I'm adding this as I haven't seen it in any of the other answers and it might be useful for someone struggling with something similar. The <a href=\"https://docs.python.org/library/functions.html#globals\" rel=\"nofollow noreferrer\"><code>globals()</code></a> function returns a mutable global symbol dictionary where you can \"magically\" make data available for the rest of your code. \nFor example:</p>\n<pre><code class=\"python\">from pickle import load\ndef loaditem(name):\n    with open(r\"C:\\pickle\\file\\location\"+\"\\{}.dat\".format(name), \"rb\") as openfile:\n        globals()[name] = load(openfile)\n    return True\n</code></pre>\n<p>and </p>\n<pre><code class=\"python\">from pickle import dump\ndef dumpfile(name):\n    with open(name+\".dat\", \"wb\") as outfile:\n        dump(globals()[name], outfile)\n    return True\n</code></pre>\n<p>Will just let you dump/load variables out of and into the global namespace. Super convenient, no muss, no fuss. Pretty sure it's Python 3 only.</p>\n", "abstract": "I'm adding this as I haven't seen it in any of the other answers and it might be useful for someone struggling with something similar. The globals() function returns a mutable global symbol dictionary where you can \"magically\" make data available for the rest of your code. \nFor example: and  Will just let you dump/load variables out of and into the global namespace. Super convenient, no muss, no fuss. Pretty sure it's Python 3 only."}, {"id": 45769568, "score": 8, "vote": 0, "content": "<p>Reference the class namespace where you want the change to show up.  </p>\n<p>In this example, runner is using <strong>max</strong> from the file config. I want my test to change the value of <strong>max</strong> when runner is using it.</p>\n<p><strong>main/config.py</strong></p>\n<pre><code class=\"python\">max = 15000\n</code></pre>\n<p><strong>main/runner.py</strong></p>\n<pre><code class=\"python\">from main import config\ndef check_threads():\n    return max &lt; thread_count \n</code></pre>\n<p><strong>tests/runner_test.py</strong></p>\n<pre><code class=\"python\">from main import runner                # &lt;----- 1. add file\nfrom main.runner import check_threads\nclass RunnerTest(unittest):\n   def test_threads(self):\n       runner.max = 0                  # &lt;----- 2. set global \n       check_threads()\n</code></pre>\n", "abstract": "Reference the class namespace where you want the change to show up.   In this example, runner is using max from the file config. I want my test to change the value of max when runner is using it. main/config.py main/runner.py tests/runner_test.py"}, {"id": 61992762, "score": 6, "vote": 0, "content": "<h2>Globals are fine - Except with Multiprocessing</h2>\n<p>Globals in connection with multiprocessing on different platforms/envrionments \nas Windows/Mac OS on the one side and Linux on the other are troublesome.</p>\n<p>I will show you this with a simple example pointing out a problem which I run into some time ago. </p>\n<p>If you want to understand, why things are different on Windows/MacOs and Linux you \nneed to know that, the default mechanism to start a new process on ...</p>\n<ul>\n<li>Windows/MacOs is 'spawn'</li>\n<li>Linux is 'fork'</li>\n</ul>\n<p>They are different in Memory allocation an initialisation ... (but I don't go into this\nhere). </p>\n<p>Let's have a look at the problem/example ...</p>\n<pre><code class=\"python\">import multiprocessing\n\ncounter = 0\n\ndef do(task_id):\n    global counter\n    counter +=1\n    print(f'task {task_id}: counter = {counter}')\n\nif __name__ == '__main__':\n\n    pool = multiprocessing.Pool(processes=4)\n    task_ids = list(range(4))\n    pool.map(do, task_ids)\n</code></pre>\n<h3>Windows</h3>\n<p>If you run this on Windows (And I suppose on MacOS too), you get the following output ...</p>\n<pre><code class=\"python\">task 0: counter = 1\ntask 1: counter = 2\ntask 2: counter = 3\ntask 3: counter = 4\n</code></pre>\n<h3>Linux</h3>\n<p>If you run this on Linux, you get the following instead. </p>\n<pre><code class=\"python\">task 0: counter = 1\ntask 1: counter = 1\ntask 2: counter = 1\ntask 3: counter = 1\n</code></pre>\n", "abstract": "Globals in connection with multiprocessing on different platforms/envrionments \nas Windows/Mac OS on the one side and Linux on the other are troublesome. I will show you this with a simple example pointing out a problem which I run into some time ago.  If you want to understand, why things are different on Windows/MacOs and Linux you \nneed to know that, the default mechanism to start a new process on ... They are different in Memory allocation an initialisation ... (but I don't go into this\nhere).  Let's have a look at the problem/example ... If you run this on Windows (And I suppose on MacOS too), you get the following output ... If you run this on Linux, you get the following instead. "}, {"id": 63629668, "score": 6, "vote": 0, "content": "<p>There are 2 ways to declare a variable as global:</p>\n<p><strong>1. assign variable inside functions and use global line</strong></p>\n<pre><code class=\"python\">def declare_a_global_variable():\n    global global_variable_1\n    global_variable_1 = 1\n\n# Note to use the function to global variables\ndeclare_a_global_variable() \n</code></pre>\n<p><strong>2. assign variable outside functions:</strong></p>\n<pre><code class=\"python\">global_variable_2 = 2\n</code></pre>\n<p>Now we can use these declared global variables in the other functions:</p>\n<pre><code class=\"python\">def declare_a_global_variable():\n    global global_variable_1\n    global_variable_1 = 1\n\n# Note to use the function to global variables\ndeclare_a_global_variable() \nglobal_variable_2 = 2\n\ndef print_variables():\n    print(global_variable_1)\n    print(global_variable_2)\nprint_variables() # prints 1 &amp; 2\n</code></pre>\n<p><strong>Note 1:</strong></p>\n<p>If you want to change a global variable inside another function like <code>update_variables()</code> you should use global line in that function before assigning the variable:</p>\n<pre><code class=\"python\">global_variable_1 = 1\nglobal_variable_2 = 2\n\ndef update_variables():\n    global global_variable_1\n    global_variable_1 = 11\n    global_variable_2 = 12 # will update just locally for this function\n\nupdate_variables()\nprint(global_variable_1) # prints 11\nprint(global_variable_2) # prints 2\n</code></pre>\n<p><strong>Note 2:</strong></p>\n<p>There is a exception for note 1 for list and dictionary variables while not using global line inside a function:</p>\n<pre><code class=\"python\"># declaring some global variables\nvariable = 'peter'\nlist_variable_1 = ['a','b']\nlist_variable_2 = ['c','d']\n\ndef update_global_variables():\n    \"\"\"without using global line\"\"\"\n    variable = 'PETER' # won't update in global scope\n    list_variable_1 = ['A','B'] # won't update in global scope\n    list_variable_2[0] = 'C' # updated in global scope surprisingly this way\n    list_variable_2[1] = 'D' # updated in global scope surprisingly this way\n\nupdate_global_variables()\n\nprint('variable is: %s'%variable) # prints peter\nprint('list_variable_1 is: %s'%list_variable_1) # prints ['a', 'b']\nprint('list_variable_2 is: %s'%list_variable_2) # prints ['C', 'D']\n</code></pre>\n", "abstract": "There are 2 ways to declare a variable as global: 1. assign variable inside functions and use global line 2. assign variable outside functions: Now we can use these declared global variables in the other functions: Note 1: If you want to change a global variable inside another function like update_variables() you should use global line in that function before assigning the variable: Note 2: There is a exception for note 1 for list and dictionary variables while not using global line inside a function:"}, {"id": 71663780, "score": 6, "vote": 0, "content": "<pre><code class=\"python\">global_var = 10  # will be considered as a global variable\n\n\ndef func_1():\n    global global_var  # access variable using variable keyword\n    global_var += 1\n\n\ndef func_2():\n    global global_var\n    global_var *= 2\n    print(f\"func_2: {global_var}\")\n\n\nfunc_1()\nfunc_2()\nprint(\"Global scope:\", global_var) # will print 22\n</code></pre>\n<p>Explanation:</p>\n<p><code>global_var</code> is a global variable and all functions and classes can access that variable.</p>\n<p>The <code>func_1()</code> accessed that global variable using the keyword <code>global</code> which points to the variable which is written in the global scope. If I didn't write the global keyword the variable <code>global_var</code> inside <code>func_1</code> is considered a local variable that is only usable inside the function. Then inside <code>func_1</code>, I have incremented that global variable by 1.</p>\n<p>The same happened in <code>func_2()</code>.</p>\n<p>After calling <code>func_1</code> and <code>func_2</code>, you'll see the <code>global_var</code> is changed</p>\n", "abstract": "Explanation: global_var is a global variable and all functions and classes can access that variable. The func_1() accessed that global variable using the keyword global which points to the variable which is written in the global scope. If I didn't write the global keyword the variable global_var inside func_1 is considered a local variable that is only usable inside the function. Then inside func_1, I have incremented that global variable by 1. The same happened in func_2(). After calling func_1 and func_2, you'll see the global_var is changed"}, {"id": 67339244, "score": 5, "vote": 0, "content": "<p>Though this has been answered, I am giving solution again as I prefer single line\nThis is if you wish to create global variable within function</p>\n<pre><code class=\"python\">def someFunc():\n    x=20\n    globals()['y']=50\nsomeFunc() # invoking function so that variable Y is created globally \nprint(y) # output 50\nprint(x) #NameError: name 'x' is not defined as x was defined locally within function\n</code></pre>\n", "abstract": "Though this has been answered, I am giving solution again as I prefer single line\nThis is if you wish to create global variable within function"}, {"id": 71074895, "score": 1, "vote": 0, "content": "<p>Like this code:</p>\n<pre><code class=\"python\">myVar = 12\n\ndef myFunc():\n  myVar += 12\n</code></pre>\n<p><strong>Key:</strong></p>\n<p>If you declare a variable outside the strings, it become global.</p>\n<p>If you declare a variable inside the strings, it become local.</p>\n<p>If you want to declare a global variable inside the strings, use the keyword <code>global</code> before the variable you want to declare:</p>\n<pre><code class=\"python\">myVar = 124\ndef myFunc():\n  global myVar2\n  myVar2 = 100\nmyFunc()\nprint(myVar2)\n</code></pre>\n<p>and then you have 100 in the document.</p>\n", "abstract": "Like this code: Key: If you declare a variable outside the strings, it become global. If you declare a variable inside the strings, it become local. If you want to declare a global variable inside the strings, use the keyword global before the variable you want to declare: and then you have 100 in the document."}, {"id": 71883300, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">Initialized = 0  #Here This Initialized is global variable  \n\ndef Initialize():\n     print(\"Initialized!\")\n     Initialized = 1  #This is local variable and assigning 1 to local variable\nwhile Initialized == 0:  \n</code></pre>\n<p>Here we are comparing global variable Initialized that 0, so while loop condition got true</p>\n<pre><code class=\"python\">     Initialize()\n</code></pre>\n<p>Function will get called.Loop will be infinite</p>\n<pre><code class=\"python\">#if we do Initialized=1 then loop will terminate  \n\nelse:\n    print(\"Lets do something else now!\")\n</code></pre>\n", "abstract": "Here we are comparing global variable Initialized that 0, so while loop condition got true Function will get called.Loop will be infinite"}]}, {"link": "https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas", "question": {"id": "16476924", "title": "How to iterate over rows in a DataFrame in Pandas", "content": "<p>I have a pandas dataframe, <code>df</code>:</p>\n<pre><code class=\"python\">   c1   c2\n0  10  100\n1  11  110\n2  12  120\n</code></pre>\n<p>How do I iterate over the rows of this dataframe? For every row, I want to be able to access its elements (values in cells) by the name of the columns. For example:</p>\n<pre><code class=\"python\">for row in df.rows:\n   print(row['c1'], row['c2'])\n</code></pre>\n<hr/>\n<p>I found a <a href=\"https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas\">similar question</a> which suggests using either of these:</p>\n<pre><code class=\"python\">for date, row in df.T.iteritems():\n</code></pre>\n<pre><code class=\"python\">for row in df.iterrows():\n</code></pre>\n<p>But I do not understand what the <code>row</code> object is and how I can work with it.</p>\n", "abstract": "I have a pandas dataframe, df: How do I iterate over the rows of this dataframe? For every row, I want to be able to access its elements (values in cells) by the name of the columns. For example: I found a similar question which suggests using either of these: But I do not understand what the row object is and how I can work with it."}, "answers": [{"id": 16476974, "score": 4738, "vote": 0, "content": "<p><a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows\" rel=\"noreferrer\"><code>DataFrame.iterrows</code></a> is a generator which yields both the index and row (as a Series):</p>\n<pre><code class=\"python\">import pandas as pd\n\ndf = pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]})\ndf = df.reset_index()  # make sure indexes pair with number of rows\n\nfor index, row in df.iterrows():\n    print(row['c1'], row['c2'])\n</code></pre>\n<pre><code class=\"python\">10 100\n11 110\n12 120\n</code></pre>\n", "abstract": "DataFrame.iterrows is a generator which yields both the index and row (as a Series):"}, {"id": 55557758, "score": 2023, "vote": 0, "content": "<blockquote>\n<h2>How to iterate over rows in a DataFrame in Pandas</h2>\n</blockquote>\n<h1>Answer: DON'T<sup>*</sup>!</h1>\n<p>Iteration in Pandas is an anti-pattern and is something you should only do when you have exhausted every other option. You should not use any function with \"<code>iter</code>\" in its name for more than a few thousand rows or you will have to get used to a <strong>lot</strong> of waiting.</p>\n<p>Do you want to print a DataFrame? Use <a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_string.html\" rel=\"noreferrer\"><strong><code>DataFrame.to_string()</code></strong></a>.</p>\n<p>Do you want to compute something? In that case, search for methods in this order (list modified from <a href=\"https://stackoverflow.com/questions/24870953/does-iterrows-have-performance-issues\">here</a>):</p>\n<ol>\n<li>Vectorization</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Cython\" rel=\"noreferrer\">Cython</a> routines</li>\n<li>List Comprehensions (vanilla <code>for</code> loop)</li>\n<li><a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html\" rel=\"noreferrer\"><strong><code>DataFrame.apply()</code></strong></a>: i) \u00a0Reductions that can be performed in Cython, ii) Iteration in Python space</li>\n<li><a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.itertuples.html\" rel=\"noreferrer\"><strong><code>DataFrame.itertuples()</code></strong></a> and <a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iteritems.html#pandas.DataFrame.iteritems\" rel=\"noreferrer\"><strong><code>iteritems()</code></strong></a></li>\n<li><a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows\" rel=\"noreferrer\"><strong><code>DataFrame.iterrows()</code></strong></a></li>\n</ol>\n<p><code>iterrows</code> and <code>itertuples</code> (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects/nametuples for sequential processing, which is really the only thing these functions are useful for.</p>\n<p><strong>Appeal to Authority</strong></p>\n<p><a href=\"https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#iteration\" rel=\"noreferrer\">The documentation page</a> on iteration has a huge red warning box that says:</p>\n<blockquote>\n<p>Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].</p>\n</blockquote>\n<p><sub>* It's actually a little more complicated than \"don't\". <code>df.iterrows()</code> is the correct answer to this question, but \"vectorize your ops\" is the better one. I will concede that there are circumstances where iteration cannot be avoided (for example, some operations where the result depends on the value computed for the previous row). However, it takes some familiarity with the library to know when. If you're not sure whether you need an iterative solution, you probably don't. PS: To know more about my rationale for writing this answer, skip to the very bottom.</sub></p>\n<hr/>\n<h2>Faster than Looping: <a href=\"https://stackoverflow.com/questions/1422149/what-is-vectorization\">Vectorization</a>, <a href=\"https://cython.org\" rel=\"noreferrer\">Cython</a></h2>\n<p>A good number of basic operations and computations are \"vectorised\" by pandas (either through NumPy, or through Cythonized functions). This includes arithmetic, comparisons, (most) reductions, reshaping (such as pivoting), joins, and groupby operations. Look through the documentation on <a href=\"https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html#essential-basic-functionality\" rel=\"noreferrer\">Essential Basic Functionality</a> to find a suitable vectorised method for your problem.</p>\n<p>If none exists, feel free to write your own using custom <a href=\"https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html#cython-writing-c-extensions-for-pandas\" rel=\"noreferrer\">Cython extensions</a>.</p>\n<hr/>\n<h2>Next Best Thing: <a href=\"https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions\" rel=\"noreferrer\">List Comprehensions</a><sup>*</sup></h2>\n<p>List comprehensions should be your next port of call if 1) there is no vectorized solution available, 2) performance is important, but not important enough to go through the hassle of cythonizing your code, and 3) you're trying to perform elementwise transformation on your code. There is a <a href=\"https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care\">good amount of evidence</a> to suggest that list comprehensions are sufficiently fast (and even sometimes faster) for many common Pandas tasks.</p>\n<p>The formula is simple,</p>\n<pre><code class=\"python\"># Iterating over one column - `f` is some function that processes your data\nresult = [f(x) for x in df['col']]\n# Iterating over two columns, use `zip`\nresult = [f(x, y) for x, y in zip(df['col1'], df['col2'])]\n# Iterating over multiple columns - same data type\nresult = [f(row[0], ..., row[n]) for row in df[['col1', ...,'coln']].to_numpy()]\n# Iterating over multiple columns - differing data type\nresult = [f(row[0], ..., row[n]) for row in zip(df['col1'], ..., df['coln'])]\n</code></pre>\n<p>If you can encapsulate your business logic into a function, you can use a list comprehension that calls it. You can make arbitrarily complex things work through the simplicity and speed of raw Python code.</p>\n<p><strong>Caveats</strong></p>\n<p>List comprehensions assume that your data is easy to work with - what that means is your data types are consistent and you don't have NaNs, but this cannot always be guaranteed.</p>\n<ol>\n<li>The first one is more obvious, but when dealing with NaNs, prefer in-built pandas methods if they exist (because they have much better corner-case handling logic), or ensure your business logic includes appropriate NaN handling logic.</li>\n<li>When dealing with mixed data types you should iterate over <code>zip(df['A'], df['B'], ...)</code> instead of <code>df[['A', 'B']].to_numpy()</code> as the latter implicitly upcasts data to the most common type. As an example if A is numeric and B is string, <code>to_numpy()</code> will cast the entire array to string, which may not be what you want. Fortunately <code>zip</code>ping your columns together is the most straightforward workaround to this.</li>\n</ol>\n<p><sub>*Your mileage may vary for the reasons outlined in the <strong>Caveats</strong> section above.</sub></p>\n<hr/>\n<h2>An Obvious Example</h2>\n<p>Let's demonstrate the difference with a simple example of adding two pandas columns <code>A + B</code>. This is a vectorizable operation, so it will be easy to contrast the performance of the methods discussed above.</p>\n<img src=\"https://i.stack.imgur.com/y44RJ.png\" width=\"600\"/>\n<p><a href=\"https://gist.github.com/Coldsp33d/948f96b384ca5bdf6e8ce203ac97c9a0\" rel=\"noreferrer\">Benchmarking code, for your reference</a>. The line at the bottom measures a function written in numpandas, a style of Pandas that mixes heavily with NumPy to squeeze out maximum performance. Writing numpandas code should be avoided unless you know what you're doing. Stick to the API where you can (i.e., prefer <code>vec</code> over <code>vec_numpy</code>).</p>\n<p>I should mention, however, that it isn't always this cut and dry. Sometimes the answer to \"what is the best method for an operation\" is \"it depends on your data\". My advice is to test out different approaches on your data before settling on one.</p>\n<hr/>\n<h2>My Personal Opinion <sup>*</sup></h2>\n<p>Most of the analyses performed on the various alternatives to the iter family has been through the lens of performance. However, in most situations you will typically be working on a reasonably sized dataset (nothing beyond a few thousand or 100K rows) and performance will come second to simplicity/readability of the solution.</p>\n<p>Here is my personal preference when selecting a method to use for a problem.</p>\n<p>For the novice:</p>\n<blockquote>\n<p><em>Vectorization</em> (when possible)<em>; <code>apply()</code>; List Comprehensions; <code>itertuples()</code>/<code>iteritems()</code>; <code>iterrows()</code>; Cython</em></p>\n</blockquote>\n<p>For the more experienced:</p>\n<blockquote>\n<p><em>Vectorization</em> (when possible)<em>; <code>apply()</code>; List Comprehensions; Cython; <code>itertuples()</code>/<code>iteritems()</code>; <code>iterrows()</code></em></p>\n</blockquote>\n<p>Vectorization prevails as the most idiomatic method for any problem that can be vectorized. Always seek to vectorize! When in doubt, consult the docs, or look on Stack Overflow for an existing question on your particular task.</p>\n<p>I do tend to go on about how bad <code>apply</code> is in a lot of my posts, but I do concede it is easier for a beginner to wrap their head around what it's doing. Additionally, there are quite a few use cases for <code>apply</code> has explained in <a href=\"https://stackoverflow.com/questions/54432583/when-should-i-not-want-to-use-pandas-apply-in-my-code\">this post of mine</a>.</p>\n<p>Cython ranks lower down on the list because it takes more time and effort to pull off correctly. You will usually never need to write code with pandas that demands this level of performance that even a list comprehension cannot satisfy.</p>\n<p><sub>* As with any personal opinion, please take with heaps of salt!</sub></p>\n<hr/>\n<h2>Further Reading</h2>\n<ul>\n<li><p><a href=\"https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html\" rel=\"noreferrer\">10 Minutes to pandas</a>, and <a href=\"https://pandas.pydata.org/pandas-docs/stable/user_guide/basics.html\" rel=\"noreferrer\">Essential Basic Functionality</a> - Useful links that introduce you to Pandas and its library of vectorized*/cythonized functions.</p>\n</li>\n<li><p><a href=\"https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html\" rel=\"noreferrer\">Enhancing Performance</a> - A primer from the documentation on enhancing standard Pandas operations</p>\n</li>\n<li><p><em><a href=\"https://stackoverflow.com/questions/54028199/for-loops-with-pandas-when-should-i-care\">Are for-loops in pandas really bad? When should I care?</a></em> - a detailed write-up by me on list comprehensions and their suitability for various operations (mainly ones involving non-numeric data)</p>\n</li>\n<li><p><em><a href=\"https://stackoverflow.com/questions/54432583/when-should-i-ever-want-to-use-pandas-apply-in-my-code\">When should I (not) want to use pandas apply() in my code?</a></em> - <code>apply</code> is slow (but not as slow as the <code>iter*</code> family. There are, however, situations where one can (or should) consider <code>apply</code> as a serious alternative, especially in some <code>GroupBy</code> operations).</p>\n</li>\n</ul>\n<p><sub>* Pandas string methods are \"vectorized\" in the sense that they are specified on the series but operate on each element. The underlying mechanisms are still iterative, because string operations are inherently hard to vectorize.</sub></p>\n<hr/>\n<h2>Why I Wrote this Answer</h2>\n<p>A common trend I notice from new users is to ask questions of the form \"How can I iterate over my df to do X?\". Showing code that calls <code>iterrows()</code> while doing something inside a <code>for</code> loop. Here is why. A new user to the library who has not been introduced to the concept of vectorization will likely envision the code that solves their problem as iterating over their data to do something. Not knowing how to iterate over a DataFrame, the first thing they do is Google it and end up here, at this question. They then see the accepted answer telling them how to, and they close their eyes and run this code without ever first questioning if iteration is the right thing to do.</p>\n<p>The aim of this answer is to help new users understand that iteration is not necessarily the solution to every problem, and that better, faster and more idiomatic solutions could exist, and that it is worth investing time in exploring them. I'm not trying to start a war of iteration vs. vectorization, but I want new users to be informed when developing solutions to their problems with this library.</p>\n", "abstract": "Iteration in Pandas is an anti-pattern and is something you should only do when you have exhausted every other option. You should not use any function with \"iter\" in its name for more than a few thousand rows or you will have to get used to a lot of waiting. Do you want to print a DataFrame? Use DataFrame.to_string(). Do you want to compute something? In that case, search for methods in this order (list modified from here): iterrows and itertuples (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects/nametuples for sequential processing, which is really the only thing these functions are useful for. Appeal to Authority The documentation page on iteration has a huge red warning box that says: Iterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...]. * It's actually a little more complicated than \"don't\". df.iterrows() is the correct answer to this question, but \"vectorize your ops\" is the better one. I will concede that there are circumstances where iteration cannot be avoided (for example, some operations where the result depends on the value computed for the previous row). However, it takes some familiarity with the library to know when. If you're not sure whether you need an iterative solution, you probably don't. PS: To know more about my rationale for writing this answer, skip to the very bottom. A good number of basic operations and computations are \"vectorised\" by pandas (either through NumPy, or through Cythonized functions). This includes arithmetic, comparisons, (most) reductions, reshaping (such as pivoting), joins, and groupby operations. Look through the documentation on Essential Basic Functionality to find a suitable vectorised method for your problem. If none exists, feel free to write your own using custom Cython extensions. List comprehensions should be your next port of call if 1) there is no vectorized solution available, 2) performance is important, but not important enough to go through the hassle of cythonizing your code, and 3) you're trying to perform elementwise transformation on your code. There is a good amount of evidence to suggest that list comprehensions are sufficiently fast (and even sometimes faster) for many common Pandas tasks. The formula is simple, If you can encapsulate your business logic into a function, you can use a list comprehension that calls it. You can make arbitrarily complex things work through the simplicity and speed of raw Python code. Caveats List comprehensions assume that your data is easy to work with - what that means is your data types are consistent and you don't have NaNs, but this cannot always be guaranteed. *Your mileage may vary for the reasons outlined in the Caveats section above. Let's demonstrate the difference with a simple example of adding two pandas columns A + B. This is a vectorizable operation, so it will be easy to contrast the performance of the methods discussed above. Benchmarking code, for your reference. The line at the bottom measures a function written in numpandas, a style of Pandas that mixes heavily with NumPy to squeeze out maximum performance. Writing numpandas code should be avoided unless you know what you're doing. Stick to the API where you can (i.e., prefer vec over vec_numpy). I should mention, however, that it isn't always this cut and dry. Sometimes the answer to \"what is the best method for an operation\" is \"it depends on your data\". My advice is to test out different approaches on your data before settling on one. Most of the analyses performed on the various alternatives to the iter family has been through the lens of performance. However, in most situations you will typically be working on a reasonably sized dataset (nothing beyond a few thousand or 100K rows) and performance will come second to simplicity/readability of the solution. Here is my personal preference when selecting a method to use for a problem. For the novice: Vectorization (when possible); apply(); List Comprehensions; itertuples()/iteritems(); iterrows(); Cython For the more experienced: Vectorization (when possible); apply(); List Comprehensions; Cython; itertuples()/iteritems(); iterrows() Vectorization prevails as the most idiomatic method for any problem that can be vectorized. Always seek to vectorize! When in doubt, consult the docs, or look on Stack Overflow for an existing question on your particular task. I do tend to go on about how bad apply is in a lot of my posts, but I do concede it is easier for a beginner to wrap their head around what it's doing. Additionally, there are quite a few use cases for apply has explained in this post of mine. Cython ranks lower down on the list because it takes more time and effort to pull off correctly. You will usually never need to write code with pandas that demands this level of performance that even a list comprehension cannot satisfy. * As with any personal opinion, please take with heaps of salt! 10 Minutes to pandas, and Essential Basic Functionality - Useful links that introduce you to Pandas and its library of vectorized*/cythonized functions. Enhancing Performance - A primer from the documentation on enhancing standard Pandas operations Are for-loops in pandas really bad? When should I care? - a detailed write-up by me on list comprehensions and their suitability for various operations (mainly ones involving non-numeric data) When should I (not) want to use pandas apply() in my code? - apply is slow (but not as slow as the iter* family. There are, however, situations where one can (or should) consider apply as a serious alternative, especially in some GroupBy operations). * Pandas string methods are \"vectorized\" in the sense that they are specified on the series but operate on each element. The underlying mechanisms are still iterative, because string operations are inherently hard to vectorize. A common trend I notice from new users is to ask questions of the form \"How can I iterate over my df to do X?\". Showing code that calls iterrows() while doing something inside a for loop. Here is why. A new user to the library who has not been introduced to the concept of vectorization will likely envision the code that solves their problem as iterating over their data to do something. Not knowing how to iterate over a DataFrame, the first thing they do is Google it and end up here, at this question. They then see the accepted answer telling them how to, and they close their eyes and run this code without ever first questioning if iteration is the right thing to do. The aim of this answer is to help new users understand that iteration is not necessarily the solution to every problem, and that better, faster and more idiomatic solutions could exist, and that it is worth investing time in exploring them. I'm not trying to start a war of iteration vs. vectorization, but I want new users to be informed when developing solutions to their problems with this library."}, {"id": 41022840, "score": 543, "vote": 0, "content": "<p>First consider if you really need to <em>iterate</em> over rows in a DataFrame. See <a href=\"https://stackoverflow.com/a/55557758/3844376\">this answer</a> for alternatives.</p>\n<p>If you still need to iterate over rows, you can use methods below. Note some  <strong>important caveats</strong> which are not mentioned in any of the other answers.</p>\n<ul>\n<li><p><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html\" rel=\"noreferrer\">DataFrame.iterrows()</a></p>\n<pre><code class=\"python\">  for index, row in df.iterrows():\n      print(row[\"c1\"], row[\"c2\"])\n</code></pre>\n</li>\n<li><p><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html\" rel=\"noreferrer\">DataFrame.itertuples()</a></p>\n<pre><code class=\"python\">  for row in df.itertuples(index=True, name='Pandas'):\n      print(row.c1, row.c2)\n</code></pre>\n</li>\n</ul>\n<p><code>itertuples()</code> is supposed to be faster than <code>iterrows()</code></p>\n<p>But be aware, according to the docs (pandas 0.24.2 at the moment):</p>\n<ul>\n<li>iterrows: <code>dtype</code> might not match from row to row</li>\n</ul>\n<blockquote>\n<p>Because iterrows returns a Series for each row, it <strong>does not preserve</strong> dtypes across the rows (dtypes are preserved across columns for DataFrames). To preserve dtypes while iterating over the rows, it is better to use itertuples() which returns namedtuples of the values and which is generally much faster than iterrows()</p>\n</blockquote>\n<ul>\n<li>iterrows: Do not modify rows</li>\n</ul>\n<blockquote>\n<p>You should <strong>never modify</strong> something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect.</p>\n</blockquote>\n<p>Use <a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html\" rel=\"noreferrer\">DataFrame.apply()</a> instead:</p>\n<pre><code class=\"python\">    new_df = df.apply(lambda x: x * 2, axis = 1)\n</code></pre>\n<ul>\n<li>itertuples:</li>\n</ul>\n<blockquote>\n<p>The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (&gt;255), regular tuples are returned.</p>\n</blockquote>\n<p>See <a href=\"https://pandas.pydata.org/docs/user_guide/basics.html#iteration\" rel=\"noreferrer\">pandas docs on iteration</a> for more details.</p>\n", "abstract": "First consider if you really need to iterate over rows in a DataFrame. See this answer for alternatives. If you still need to iterate over rows, you can use methods below. Note some  important caveats which are not mentioned in any of the other answers. DataFrame.iterrows() DataFrame.itertuples() itertuples() is supposed to be faster than iterrows() But be aware, according to the docs (pandas 0.24.2 at the moment): Because iterrows returns a Series for each row, it does not preserve dtypes across the rows (dtypes are preserved across columns for DataFrames). To preserve dtypes while iterating over the rows, it is better to use itertuples() which returns namedtuples of the values and which is generally much faster than iterrows() You should never modify something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect. Use DataFrame.apply() instead: The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (>255), regular tuples are returned. See pandas docs on iteration for more details."}, {"id": 10739432, "score": 242, "vote": 0, "content": "<p>You should use <a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html\" rel=\"noreferrer\"><code>df.iterrows()</code></a>. Though iterating row-by-row is not especially efficient since <code>Series</code> objects have to be created.</p>\n", "abstract": "You should use df.iterrows(). Though iterating row-by-row is not especially efficient since Series objects have to be created."}, {"id": 32680162, "score": 180, "vote": 0, "content": "<p>While <code>iterrows()</code> is a good option, sometimes <code>itertuples()</code> can be much faster:</p>\n<pre><code class=\"python\">df = pd.DataFrame({'a': randn(1000), 'b': randn(1000),'N': randint(100, 1000, (1000)), 'x': 'x'})\n\n%timeit [row.a * 2 for idx, row in df.iterrows()]\n# =&gt; 10 loops, best of 3: 50.3 ms per loop\n\n%timeit [row[1] * 2 for row in df.itertuples()]\n# =&gt; 1000 loops, best of 3: 541 \u00b5s per loop\n</code></pre>\n", "abstract": "While iterrows() is a good option, sometimes itertuples() can be much faster:"}, {"id": 39370553, "score": 130, "vote": 0, "content": "<p>You can use the <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iloc.html\" rel=\"noreferrer\"><code>df.iloc</code></a> function as follows:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">for i in range(0, len(df)):\n    print(df.iloc[i]['c1'], df.iloc[i]['c2'])\n</code></pre>\n", "abstract": "You can use the df.iloc function as follows:"}, {"id": 30566899, "score": 122, "vote": 0, "content": "<p>You can also use <code>df.apply()</code> to iterate over rows and access multiple columns for a function.</p>\n<p><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html\">docs: DataFrame.apply()</a></p>\n<pre><code class=\"python\">def valuation_formula(x, y):\n    return x * y * 0.5\n\ndf['price'] = df.apply(lambda row: valuation_formula(row['x'], row['y']), axis=1)\n</code></pre>\n", "abstract": "You can also use df.apply() to iterate over rows and access multiple columns for a function. docs: DataFrame.apply()"}, {"id": 59413206, "score": 62, "vote": 0, "content": "<h1>How to iterate efficiently</h1>\n<p>If you really have to iterate a Pandas dataframe, you will probably want to <strong>avoid using iterrows()</strong>. There are different methods and the usual <code>iterrows()</code> is far from being the best. <strong>itertuples() can be 100 times faster.</strong></p>\n<p><strong>In short:</strong></p>\n<ul>\n<li>As a general rule, use <code>df.itertuples(name=None)</code>. In particular, when you have a fixed number columns and less than 255 columns. <em>See point (3)</em></li>\n<li>Otherwise, use <code>df.itertuples()</code> except if your columns have special characters such as spaces or '-'. <em>See point (2)</em></li>\n<li>It is possible to use <code>itertuples()</code> even if your dataframe has strange columns by using the last example. <em>See point (4)</em></li>\n<li>Only use <code>iterrows()</code> if you cannot the previous solutions. <em>See point (1)</em></li>\n</ul>\n<h1>Different methods to iterate over rows in a Pandas dataframe:</h1>\n<p>Generate a random dataframe with a million rows and 4 columns:</p>\n<pre><code class=\"python\">    df = pd.DataFrame(np.random.randint(0, 100, size=(1000000, 4)), columns=list('ABCD'))\n    print(df)\n</code></pre>\n<p>1) The usual <code>iterrows()</code> is convenient, but damn slow:</p>\n<pre><code class=\"python\">start_time = time.clock()\nresult = 0\nfor _, row in df.iterrows():\n    result += max(row['B'], row['C'])\n\ntotal_elapsed_time = round(time.clock() - start_time, 2)\nprint(\"1. Iterrows done in {} seconds, result = {}\".format(total_elapsed_time, result))\n</code></pre>\n<p>2) The default <code>itertuples()</code> is already much faster, but it doesn't work with column names such as <code>My Col-Name is very Strange</code> (you should avoid this method if your columns are repeated or if a column name cannot be simply converted to a Python variable name).:</p>\n<pre><code class=\"python\">start_time = time.clock()\nresult = 0\nfor row in df.itertuples(index=False):\n    result += max(row.B, row.C)\n\ntotal_elapsed_time = round(time.clock() - start_time, 2)\nprint(\"2. Named Itertuples done in {} seconds, result = {}\".format(total_elapsed_time, result))\n</code></pre>\n<p>3) The default <code>itertuples()</code> using name=None is even faster but not really convenient as you have to define a variable per column.</p>\n<pre><code class=\"python\">start_time = time.clock()\nresult = 0\nfor(_, col1, col2, col3, col4) in df.itertuples(name=None):\n    result += max(col2, col3)\n\ntotal_elapsed_time = round(time.clock() - start_time, 2)\nprint(\"3. Itertuples done in {} seconds, result = {}\".format(total_elapsed_time, result))\n</code></pre>\n<p>4) Finally, the named <code>itertuples()</code> is slower than the previous point, but you do not have to define a variable per column and it works with column names such as <code>My Col-Name is very Strange</code>.</p>\n<pre><code class=\"python\">start_time = time.clock()\nresult = 0\nfor row in df.itertuples(index=False):\n    result += max(row[df.columns.get_loc('B')], row[df.columns.get_loc('C')])\n\ntotal_elapsed_time = round(time.clock() - start_time, 2)\nprint(\"4. Polyvalent Itertuples working even with special characters in the column name done in {} seconds, result = {}\".format(total_elapsed_time, result))\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">         A   B   C   D\n0       41  63  42  23\n1       54   9  24  65\n2       15  34  10   9\n3       39  94  82  97\n4        4  88  79  54\n...     ..  ..  ..  ..\n999995  48  27   4  25\n999996  16  51  34  28\n999997   1  39  61  14\n999998  66  51  27  70\n999999  51  53  47  99\n\n[1000000 rows x 4 columns]\n\n1. Iterrows done in 104.96 seconds, result = 66151519\n2. Named Itertuples done in 1.26 seconds, result = 66151519\n3. Itertuples done in 0.94 seconds, result = 66151519\n4. Polyvalent Itertuples working even with special characters in the column name done in 2.94 seconds, result = 66151519\n</code></pre>\n<p><a href=\"https://medium.com/swlh/why-pandas-itertuples-is-faster-than-iterrows-and-how-to-make-it-even-faster-bc50c0edd30d\" rel=\"noreferrer\">This article is a very interesting comparison between iterrows and itertuples</a></p>\n", "abstract": "If you really have to iterate a Pandas dataframe, you will probably want to avoid using iterrows(). There are different methods and the usual iterrows() is far from being the best. itertuples() can be 100 times faster. In short: Generate a random dataframe with a million rows and 4 columns: 1) The usual iterrows() is convenient, but damn slow: 2) The default itertuples() is already much faster, but it doesn't work with column names such as My Col-Name is very Strange (you should avoid this method if your columns are repeated or if a column name cannot be simply converted to a Python variable name).: 3) The default itertuples() using name=None is even faster but not really convenient as you have to define a variable per column. 4) Finally, the named itertuples() is slower than the previous point, but you do not have to define a variable per column and it works with column names such as My Col-Name is very Strange. Output: This article is a very interesting comparison between iterrows and itertuples"}, {"id": 48297889, "score": 49, "vote": 0, "content": "<p>I was looking for <strong>How to iterate on rows</strong> <strong><em>and</em></strong> <strong>columns</strong> and ended here so:</p>\n<pre><code class=\"python\">for i, row in df.iterrows():\n    for j, column in row.iteritems():\n        print(column)\n</code></pre>\n", "abstract": "I was looking for How to iterate on rows and columns and ended here so:"}, {"id": 70096237, "score": 26, "vote": 0, "content": "<p>We have multiple options to do the same, and lots of folks have shared their answers.</p>\n<p>I found the below two methods easy and efficient to do:</p>\n<ol>\n<li><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iterrows.html\" rel=\"noreferrer\">DataFrame.iterrows()</a></li>\n<li><a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.itertuples.html\" rel=\"noreferrer\">DataFrame.itertuples()</a></li>\n</ol>\n<p>Example:</p>\n<pre><code class=\"python\"> import pandas as pd\n inp = [{'c1':10, 'c2':100}, {'c1':11,'c2':110}, {'c1':12,'c2':120}]\n df = pd.DataFrame(inp)\n print (df)\n\n # With the iterrows method\n\n for index, row in df.iterrows():\n     print(row[\"c1\"], row[\"c2\"])\n\n # With the itertuples method\n\n for row in df.itertuples(index=True, name='Pandas'):\n     print(row.c1, row.c2)\n</code></pre>\n<p>Note: itertuples() is supposed to be faster than iterrows()</p>\n", "abstract": "We have multiple options to do the same, and lots of folks have shared their answers. I found the below two methods easy and efficient to do: Example: Note: itertuples() is supposed to be faster than iterrows()"}, {"id": 47149876, "score": 25, "vote": 0, "content": "<p>You can write your own iterator that implements <code>namedtuple</code></p>\n<pre><code class=\"python\">from collections import namedtuple\n\ndef myiter(d, cols=None):\n    if cols is None:\n        v = d.values.tolist()\n        cols = d.columns.values.tolist()\n    else:\n        j = [d.columns.get_loc(c) for c in cols]\n        v = d.values[:, j].tolist()\n\n    n = namedtuple('MyTuple', cols)\n\n    for line in iter(v):\n        yield n(*line)\n</code></pre>\n<p>This is directly comparable to <code>pd.DataFrame.itertuples</code>.  I'm aiming at performing the same task with more efficiency.</p>\n<hr/>\n<p>For the given dataframe with my function:</p>\n<pre><code class=\"python\">list(myiter(df))\n\n[MyTuple(c1=10, c2=100), MyTuple(c1=11, c2=110), MyTuple(c1=12, c2=120)]\n</code></pre>\n<p>Or with <code>pd.DataFrame.itertuples</code>:</p>\n<pre><code class=\"python\">list(df.itertuples(index=False))\n\n[Pandas(c1=10, c2=100), Pandas(c1=11, c2=110), Pandas(c1=12, c2=120)]\n</code></pre>\n<hr/>\n<p><strong>A comprehensive test</strong><br/>\nWe test making all columns available and subsetting the columns.  </p>\n<pre><code class=\"python\">def iterfullA(d):\n    return list(myiter(d))\n\ndef iterfullB(d):\n    return list(d.itertuples(index=False))\n\ndef itersubA(d):\n    return list(myiter(d, ['col3', 'col4', 'col5', 'col6', 'col7']))\n\ndef itersubB(d):\n    return list(d[['col3', 'col4', 'col5', 'col6', 'col7']].itertuples(index=False))\n\nres = pd.DataFrame(\n    index=[10, 30, 100, 300, 1000, 3000, 10000, 30000],\n    columns='iterfullA iterfullB itersubA itersubB'.split(),\n    dtype=float\n)\n\nfor i in res.index:\n    d = pd.DataFrame(np.random.randint(10, size=(i, 10))).add_prefix('col')\n    for j in res.columns:\n        stmt = '{}(d)'.format(j)\n        setp = 'from __main__ import d, {}'.format(j)\n        res.at[i, j] = timeit(stmt, setp, number=100)\n\nres.groupby(res.columns.str[4:-1], axis=1).plot(loglog=True);\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/rt88e.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/rt88e.png\"/></a></p>\n<p><a href=\"https://i.stack.imgur.com/azbOF.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/azbOF.png\"/></a></p>\n", "abstract": "You can write your own iterator that implements namedtuple This is directly comparable to pd.DataFrame.itertuples.  I'm aiming at performing the same task with more efficiency. For the given dataframe with my function: Or with pd.DataFrame.itertuples: A comprehensive test\nWe test making all columns available and subsetting the columns.    "}, {"id": 42741552, "score": 21, "vote": 0, "content": "<p>To loop all rows in a <code>dataframe</code> you can use:</p>\n<pre><code class=\"python\">for x in range(len(date_example.index)):\n    print date_example['Date'].iloc[x]\n</code></pre>\n", "abstract": "To loop all rows in a dataframe you can use:"}, {"id": 47073107, "score": 21, "vote": 0, "content": "<pre><code class=\"python\"> for ind in df.index:\n     print df['c1'][ind], df['c2'][ind]\n</code></pre>\n", "abstract": ""}, {"id": 60836700, "score": 15, "vote": 0, "content": "<p><strong>Update</strong>: cs95 has updated <a href=\"https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#55557758\">his answer</a> to include plain numpy vectorization. You can simply refer to his answer.</p>\n<hr/>\n<p><a href=\"https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/55557758#55557758\">cs95 shows</a> that Pandas vectorization far outperforms other Pandas methods for computing stuff with dataframes.</p>\n<p>I wanted to add that if you first convert the dataframe to a NumPy array and then use vectorization, it's even faster than Pandas dataframe vectorization, (and that includes the time to turn it back into a dataframe series).</p>\n<p>If you add the following functions to cs95's benchmark code, this becomes pretty evident:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def np_vectorization(df):\n    np_arr = df.to_numpy()\n    return pd.Series(np_arr[:,0] + np_arr[:,1], index=df.index)\n\ndef just_np_vectorization(df):\n    np_arr = df.to_numpy()\n    return np_arr[:,0] + np_arr[:,1]\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/L0u4A.png\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/L0u4A.png\"/></a></p>\n", "abstract": "Update: cs95 has updated his answer to include plain numpy vectorization. You can simply refer to his answer. cs95 shows that Pandas vectorization far outperforms other Pandas methods for computing stuff with dataframes. I wanted to add that if you first convert the dataframe to a NumPy array and then use vectorization, it's even faster than Pandas dataframe vectorization, (and that includes the time to turn it back into a dataframe series). If you add the following functions to cs95's benchmark code, this becomes pretty evident: "}, {"id": 51069586, "score": 14, "vote": 0, "content": "<p>Sometimes a useful pattern is:</p>\n<pre><code class=\"python\"># Borrowing @KutalmisB df example\ndf = pd.DataFrame({'col1': [1, 2], 'col2': [0.1, 0.2]}, index=['a', 'b'])\n# The to_dict call results in a list of dicts\n# where each row_dict is a dictionary with k:v pairs of columns:value for that row\nfor row_dict in df.to_dict(orient='records'):\n    print(row_dict)\n</code></pre>\n<p>Which results in:</p>\n<pre><code class=\"python\">{'col1':1.0, 'col2':0.1}\n{'col1':2.0, 'col2':0.2}\n</code></pre>\n", "abstract": "Sometimes a useful pattern is: Which results in:"}, {"id": 62136475, "score": 13, "vote": 0, "content": "<p>In short</p>\n<ul>\n<li>Use vectorization if possible</li>\n<li>If an operation can't be vectorized - use list comprehensions</li>\n<li>If you need a single object representing the entire row - use itertuples</li>\n<li>If the above is too slow - try <em>swifter.apply</em></li>\n<li>If it's still too slow - try a <a href=\"https://en.wikipedia.org/wiki/Cython\" rel=\"noreferrer\">Cython</a> routine</li>\n</ul>\n<h3>Benchmark</h3>\n<p><a href=\"https://i.stack.imgur.com/ytaWK.png\" rel=\"noreferrer\"><img alt=\"Benchmark of iteration over rows in a Pandas DataFrame\" src=\"https://i.stack.imgur.com/ytaWK.png\"/></a></p>\n", "abstract": "In short "}, {"id": 49984074, "score": 12, "vote": 0, "content": "<p>To loop all rows in a <code>dataframe</code> and <strong>use</strong> values of each row <strong>conveniently</strong>, <code>namedtuples</code> can be converted to <code>ndarray</code>s. For example:</p>\n<pre><code class=\"python\">df = pd.DataFrame({'col1': [1, 2], 'col2': [0.1, 0.2]}, index=['a', 'b'])\n</code></pre>\n<p>Iterating over the rows:</p>\n<pre><code class=\"python\">for row in df.itertuples(index=False, name='Pandas'):\n    print np.asarray(row)\n</code></pre>\n<p>results in:</p>\n<pre><code class=\"python\">[ 1.   0.1]\n[ 2.   0.2]\n</code></pre>\n<p>Please note that if <code>index=True</code>, <strong>the index is added as the first element of the tuple</strong>, which may be undesirable for some applications.</p>\n", "abstract": "To loop all rows in a dataframe and use values of each row conveniently, namedtuples can be converted to ndarrays. For example: Iterating over the rows: results in: Please note that if index=True, the index is added as the first element of the tuple, which may be undesirable for some applications."}, {"id": 58436037, "score": 12, "vote": 0, "content": "<p>There is a way to iterate throw rows while getting a DataFrame in return, and not a Series. I don't see anyone mentioning that you can pass index as a list for the row to be returned as a DataFrame:</p>\n<pre><code class=\"python\">for i in range(len(df)):\n    row = df.iloc[[i]]\n</code></pre>\n<p>Note the usage of double brackets. This returns a DataFrame with a single row.</p>\n", "abstract": "There is a way to iterate throw rows while getting a DataFrame in return, and not a Series. I don't see anyone mentioning that you can pass index as a list for the row to be returned as a DataFrame: Note the usage of double brackets. This returns a DataFrame with a single row."}, {"id": 54896256, "score": 11, "vote": 0, "content": "<p>For both viewing and modifying values, I would use <code>iterrows()</code>. In a for loop and by using tuple unpacking (see the example: <code>i, row</code>), I use the <code>row</code> for only viewing the value and use <code>i</code> with the <code>loc</code> method when I want to modify values. As stated in previous answers, here you should not modify something you are iterating over.</p>\n<pre><code class=\"python\">for i, row in df.iterrows():\n    df_column_A = df.loc[i, 'A']\n    if df_column_A == 'Old_Value':\n        df_column_A = 'New_value'  \n</code></pre>\n<p>Here the <code>row</code> in the loop is a copy of that row, and not a view of it. Therefore, you should NOT write something like <code>row['A'] = 'New_Value'</code>, it will not modify the DataFrame. However, you can use <code>i</code> and <code>loc</code> and specify the DataFrame to do the work.</p>\n", "abstract": "For both viewing and modifying values, I would use iterrows(). In a for loop and by using tuple unpacking (see the example: i, row), I use the row for only viewing the value and use i with the loc method when I want to modify values. As stated in previous answers, here you should not modify something you are iterating over. Here the row in the loop is a copy of that row, and not a view of it. Therefore, you should NOT write something like row['A'] = 'New_Value', it will not modify the DataFrame. However, you can use i and loc and specify the DataFrame to do the work."}, {"id": 54264778, "score": 8, "vote": 0, "content": "<p>There are so many ways to iterate over the rows in Pandas dataframe. One very simple and intuitive way is:</p>\n<pre><code class=\"python\">df = pd.DataFrame({'A':[1, 2, 3], 'B':[4, 5, 6], 'C':[7, 8, 9]})\nprint(df)\nfor i in range(df.shape[0]):\n    # For printing the second column\n    print(df.iloc[i, 1])\n\n    # For printing more than one columns\n    print(df.iloc[i, [0, 2]])\n</code></pre>\n", "abstract": "There are so many ways to iterate over the rows in Pandas dataframe. One very simple and intuitive way is:"}, {"id": 64653674, "score": 7, "vote": 0, "content": "<p>The easiest way, use the <code>apply</code> function</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def print_row(row):\n   print row['c1'], row['c2']\n\ndf.apply(lambda row: print_row(row), axis=1)\n</code></pre>\n", "abstract": "The easiest way, use the apply function"}, {"id": 65396738, "score": 5, "vote": 0, "content": "<p>As many answers here correctly and clearly point out, you should not generally attempt to loop in Pandas, but rather should write vectorized code.  But the question remains if you should <em>ever</em> write loops in Pandas, and if so the best way to loop in those situations.</p>\n<p><strong>I believe there is at least one general situation where loops are appropriate: when you need to calculate some function that depends on values in <em>other</em> rows in a somewhat complex manner.  In this case, the looping code is often simpler, more readable, and less error prone than vectorized code.</strong>  The looping code might even be faster, too.</p>\n<p>I will attempt to show this with an example.  Suppose you want to take a cumulative sum of a column, but reset it whenever some other column equals zero:</p>\n<pre><code class=\"python\">import pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame( { 'x':[1,2,3,4,5,6], 'y':[1,1,1,0,1,1]  } )\n\n#   x  y  desired_result\n#0  1  1               1\n#1  2  1               3\n#2  3  1               6\n#3  4  0               4\n#4  5  1               9\n#5  6  1              15\n</code></pre>\n<p>This is a good example where you could certainly write one line of Pandas to achieve this, although it's not especially readable, especially if you aren't fairly experienced with Pandas already:</p>\n<pre><code class=\"python\">df.groupby( (df.y==0).cumsum() )['x'].cumsum()\n</code></pre>\n<p>That's going to be fast enough for most situations, although you could also write faster code by avoiding the <code>groupby</code>, but it will likely be even less readable.</p>\n<p>Alternatively, what if we write this as a loop?  You could do something like the following with NumPy:</p>\n<pre><code class=\"python\">import numba as nb\n\n@nb.jit(nopython=True)  # Optional\ndef custom_sum(x,y):\n    x_sum = x.copy()\n    for i in range(1,len(df)):\n        if y[i] &gt; 0: x_sum[i] = x_sum[i-1] + x[i]\n    return x_sum\n\ndf['desired_result'] = custom_sum( df.x.to_numpy(), df.y.to_numpy() )\n</code></pre>\n<p>Admittedly, there's a bit of overhead there required to convert DataFrame columns to NumPy arrays, but the core piece of code is just one line of code that you could read even if you didn't know anything about Pandas or NumPy:</p>\n<pre><code class=\"python\">if y[i] &gt; 0: x_sum[i] = x_sum[i-1] + x[i]\n</code></pre>\n<p>And this code is actually <em>faster</em> than the vectorized code.  In some quick tests with 100,000 rows, the above is about 10x faster than the <em>groupby</em> approach.  Note that one key to the speed there is numba, which is optional.  Without the \"@nb.jit\" line, the looping code is actually about 10x slower than the <em>groupby</em> approach.</p>\n<p>Clearly this example is simple enough that you would likely prefer the one line of pandas to writing a loop with its associated overhead.  However, there are more complex versions of this problem for which the readability or speed of the NumPy/numba loop approach likely makes sense.</p>\n", "abstract": "As many answers here correctly and clearly point out, you should not generally attempt to loop in Pandas, but rather should write vectorized code.  But the question remains if you should ever write loops in Pandas, and if so the best way to loop in those situations. I believe there is at least one general situation where loops are appropriate: when you need to calculate some function that depends on values in other rows in a somewhat complex manner.  In this case, the looping code is often simpler, more readable, and less error prone than vectorized code.  The looping code might even be faster, too. I will attempt to show this with an example.  Suppose you want to take a cumulative sum of a column, but reset it whenever some other column equals zero: This is a good example where you could certainly write one line of Pandas to achieve this, although it's not especially readable, especially if you aren't fairly experienced with Pandas already: That's going to be fast enough for most situations, although you could also write faster code by avoiding the groupby, but it will likely be even less readable. Alternatively, what if we write this as a loop?  You could do something like the following with NumPy: Admittedly, there's a bit of overhead there required to convert DataFrame columns to NumPy arrays, but the core piece of code is just one line of code that you could read even if you didn't know anything about Pandas or NumPy: And this code is actually faster than the vectorized code.  In some quick tests with 100,000 rows, the above is about 10x faster than the groupby approach.  Note that one key to the speed there is numba, which is optional.  Without the \"@nb.jit\" line, the looping code is actually about 10x slower than the groupby approach. Clearly this example is simple enough that you would likely prefer the one line of pandas to writing a loop with its associated overhead.  However, there are more complex versions of this problem for which the readability or speed of the NumPy/numba loop approach likely makes sense."}, {"id": 47598852, "score": 4, "vote": 0, "content": "<p>You can also do NumPy indexing for even greater speed ups. It's not really iterating but works much better than iteration for certain applications.</p>\n<pre><code class=\"python\">subset = row['c1'][0:5]\nall = row['c1'][:]\n</code></pre>\n<p>You may also want to cast it to an array. These indexes/selections are supposed to act like NumPy arrays already, but I ran into issues and needed to cast</p>\n<pre><code class=\"python\">np.asarray(all)\nimgs[:] = cv2.resize(imgs[:], (224,224) ) # Resize every image in an hdf5 file\n</code></pre>\n", "abstract": "You can also do NumPy indexing for even greater speed ups. It's not really iterating but works much better than iteration for certain applications. You may also want to cast it to an array. These indexes/selections are supposed to act like NumPy arrays already, but I ran into issues and needed to cast"}, {"id": 68233908, "score": 4, "vote": 0, "content": "<p><code>df.iterrows()</code> returns <code>tuple(a, b)</code> where <code>a</code> is the <code>index</code> and <code>b</code> is the <code>row</code>.</p>\n", "abstract": "df.iterrows() returns tuple(a, b) where a is the index and b is the row."}, {"id": 55202153, "score": 3, "vote": 0, "content": "<p>This example uses iloc to isolate each digit in the data frame. </p>\n<pre><code class=\"python\">import pandas as pd\n\n a = [1, 2, 3, 4]\n b = [5, 6, 7, 8]\n\n mjr = pd.DataFrame({'a':a, 'b':b})\n\n size = mjr.shape\n\n for i in range(size[0]):\n     for j in range(size[1]):\n         print(mjr.iloc[i, j])\n</code></pre>\n", "abstract": "This example uses iloc to isolate each digit in the data frame. "}, {"id": 71234113, "score": 3, "vote": 0, "content": "<p><strong>Disclaimer:</strong> Although here are so many answers which recommend <strong>not</strong> using an iterative (loop) approach (and I mostly agree), I would still see it as a reasonable approach for the following situation:</p>\n<h2>Extend a dataframe with data from an API</h2>\n<p>Let's say you have a large dataframe which contains incomplete user data. Now you have to extend this data with additional columns, for example, the user's <code>age</code> and <code>gender</code>.</p>\n<p>Both values have to be fetched from a backend API. I'm assuming the API doesn't provide a \"batch\" endpoint (which would accept multiple user IDs at once). Otherwise, you should rather call the API only once.</p>\n<p>The costs (waiting time) for the network request surpass the iteration of the dataframe by far. We're talking about network round trip times of hundreds of milliseconds compared to the negligibly small gains in using alternative approaches to iterations.</p>\n<h2>One expensive network request for each row</h2>\n<p>So in this case, I would absolutely prefer using an iterative approach. Although the network request is expensive, it is guaranteed being triggered only once for each row in the dataframe. Here is an example using <a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iterrows.html#pandas-dataframe-iterrows\" rel=\"nofollow noreferrer\">DataFrame.iterrows</a>:</p>\n<h2>Example</h2>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">for index, row in users_df.iterrows():\n  user_id = row['user_id']\n\n  # Trigger expensive network request once for each row\n  response_dict = backend_api.get(f'/api/user-data/{user_id}')\n\n  # Extend dataframe with multiple data from response\n  users_df.at[index, 'age'] = response_dict.get('age')\n  users_df.at[index, 'gender'] = response_dict.get('gender')\n</code></pre>\n", "abstract": "Disclaimer: Although here are so many answers which recommend not using an iterative (loop) approach (and I mostly agree), I would still see it as a reasonable approach for the following situation: Let's say you have a large dataframe which contains incomplete user data. Now you have to extend this data with additional columns, for example, the user's age and gender. Both values have to be fetched from a backend API. I'm assuming the API doesn't provide a \"batch\" endpoint (which would accept multiple user IDs at once). Otherwise, you should rather call the API only once. The costs (waiting time) for the network request surpass the iteration of the dataframe by far. We're talking about network round trip times of hundreds of milliseconds compared to the negligibly small gains in using alternative approaches to iterations. So in this case, I would absolutely prefer using an iterative approach. Although the network request is expensive, it is guaranteed being triggered only once for each row in the dataframe. Here is an example using DataFrame.iterrows:"}, {"id": 59264161, "score": 2, "vote": 0, "content": "<p>Some libraries (e.g. a Java interop library that I use) require values to be passed in a row at a time, for example, if streaming data. To replicate the streaming nature, I 'stream' my dataframe values one by one, I wrote the below, which comes in handy from time to time.</p>\n<pre><code class=\"python\">class DataFrameReader:\n  def __init__(self, df):\n    self._df = df\n    self._row = None\n    self._columns = df.columns.tolist()\n    self.reset()\n    self.row_index = 0\n\n  def __getattr__(self, key):\n    return self.__getitem__(key)\n\n  def read(self) -&gt; bool:\n    self._row = next(self._iterator, None)\n    self.row_index += 1\n    return self._row is not None\n\n  def columns(self):\n    return self._columns\n\n  def reset(self) -&gt; None:\n    self._iterator = self._df.itertuples()\n\n  def get_index(self):\n    return self._row[0]\n\n  def index(self):\n    return self._row[0]\n\n  def to_dict(self, columns: List[str] = None):\n    return self.row(columns=columns)\n\n  def tolist(self, cols) -&gt; List[object]:\n    return [self.__getitem__(c) for c in cols]\n\n  def row(self, columns: List[str] = None) -&gt; Dict[str, object]:\n    cols = set(self._columns if columns is None else columns)\n    return {c : self.__getitem__(c) for c in self._columns if c in cols}\n\n  def __getitem__(self, key) -&gt; object:\n    # the df index of the row is at index 0\n    try:\n        if type(key) is list:\n            ix = [self._columns.index(key) + 1 for k in key]\n        else:\n            ix = self._columns.index(key) + 1\n        return self._row[ix]\n    except BaseException as e:\n        return None\n\n  def __next__(self) -&gt; 'DataFrameReader':\n    if self.read():\n        return self\n    else:\n        raise StopIteration\n\n  def __iter__(self) -&gt; 'DataFrameReader':\n    return self\n</code></pre>\n<p>Which can be used:</p>\n<pre><code class=\"python\">for row in DataFrameReader(df):\n  print(row.my_column_name)\n  print(row.to_dict())\n  print(row['my_column_name'])\n  print(row.tolist())\n</code></pre>\n<p>And preserves the values/ name mapping for the rows being iterated. Obviously, is a lot slower than using apply and Cython as indicated above, but is necessary in some circumstances.</p>\n", "abstract": "Some libraries (e.g. a Java interop library that I use) require values to be passed in a row at a time, for example, if streaming data. To replicate the streaming nature, I 'stream' my dataframe values one by one, I wrote the below, which comes in handy from time to time. Which can be used: And preserves the values/ name mapping for the rows being iterated. Obviously, is a lot slower than using apply and Cython as indicated above, but is necessary in some circumstances."}, {"id": 68562557, "score": 2, "vote": 0, "content": "<p>Probably the most elegant solution (but certainly not the most efficient):</p>\n<pre><code class=\"python\">for row in df.values:\n    c2 = row[1]\n    print(row)\n    # ...\n\nfor c1, c2 in df.values:\n    # ...\n</code></pre>\n<p>Note that:</p>\n<ul>\n<li><a href=\"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.values.html\" rel=\"nofollow noreferrer\">the documentation</a> explicitly recommends to use <code>.to_numpy()</code> instead</li>\n<li>the produced NumPy array will have a dtype that fits all columns, in the worst case <code>object</code></li>\n<li>there are <a href=\"https://stackoverflow.com/a/55557758/4248897\">good reasons</a> not to use a loop in the first place</li>\n</ul>\n<p>Still, I think this option should be included here, as a straightforward solution to a (one should think) trivial problem.</p>\n", "abstract": "Probably the most elegant solution (but certainly not the most efficient): Note that: Still, I think this option should be included here, as a straightforward solution to a (one should think) trivial problem."}, {"id": 64177887, "score": 1, "vote": 0, "content": "<p>Along with the great answers in this post I am going to propose <strong>Divide and Conquer</strong> approach, I am not writing this answer to abolish the other great answers but to fulfill them with another approach which was working efficiently for me. It has two steps of <code>splitting</code> and <code>merging</code> the pandas dataframe:</p>\n<p><strong>PROS of Divide and Conquer:</strong></p>\n<ul>\n<li>You don't need to use vectorization or any other methods to cast the type of your dataframe into another type</li>\n<li>You don't need to Cythonize your code which normally takes extra time from you</li>\n<li>Both <code>iterrows()</code> and <code>itertuples()</code> in my case were having the same performance over entire dataframe</li>\n<li>Depends on your choice of slicing <code>index</code>, you will be able to exponentially quicken the iteration. The higher <code>index</code>, the quicker your iteration process.</li>\n</ul>\n<p><strong>CONS of Divide and Conquer:</strong></p>\n<ul>\n<li>You shouldn't have dependency over the iteration process to the same dataframe and different <em>slice</em>. Meaning if you want to read or write from other <em>slice</em>, it maybe difficult to do that.</li>\n</ul>\n<p><strong>===================    Divide and Conquer Approach    =================</strong></p>\n<p><strong>Step 1: Splitting/Slicing</strong></p>\n<p>In this step, we are going to divide the iteration over the entire dataframe. Think that you are going to read a <a href=\"https://%3Chttps://en.wikipedia.org/wiki/Comma-separated_values%3E\" rel=\"nofollow noreferrer\">CSV</a> file into pandas df then iterate over it. In may case I have 5,000,000 records and I am going to split it into 100,000 records.</p>\n<p><strong>NOTE:</strong> I need to reiterate as other runtime analysis explained in the other solutions in this page, \"number of records\" has exponential proportion of \"runtime\" on search on the df. Based on the benchmark on my data here are the results:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">Number of records | Iteration rate [per second]\n========================================\n100,000           | 500\n500,000           | 200\n1,000,000         | 50\n5,000,000         | 20\n</code></pre>\n<p><strong>Step 2: Merging</strong></p>\n<p>This is going to be an easy step, just merge all the written CSV files into one dataframe and write it into a bigger CSV file.</p>\n<p>Here is the sample code:</p>\n<pre><code class=\"python\"># Step 1 (Splitting/Slicing)\nimport pandas as pd\ndf_all = pd.read_csv('C:/KtV.csv')\ndf_index = 100000\ndf_len = len(df)\nfor i in range(df_len // df_index + 1):\n    lower_bound = i * df_index\n    higher_bound = min(lower_bound + df_index, df_len)\n    # Splitting/slicing df (make sure to copy() otherwise it will be a view\n    df = df_all[lower_bound:higher_bound].copy()\n    '''\n    Write your iteration over the sliced df here\n    using iterrows() or intertuples() or ...\n    '''\n    # Writing into CSV files\n    df.to_csv('C:/KtV_prep_' + str(i) + '.csv')\n\n\n\n# Step 2 (Merging)\nfilename = 'C:/KtV_prep_'\ndf = (pd.read_csv(f) for f in [filename + str(i) + '.csv' for i in range(ktv_len // ktv_index + 1)])\ndf_prep_all = pd.concat(df)\ndf_prep_all.to_csv('C:/KtV_prep_all.csv')\n</code></pre>\n<p><strong>Reference:</strong></p>\n<p><a href=\"https://stackoverflow.com/questions/7837722/what-is-the-most-efficient-way-to-loop-through-dataframes-with-pandas\">Efficient way of iteration over datafreame</a></p>\n<p><a href=\"https://stackoverflow.com/questions/20906474/import-multiple-csv-files-into-pandas-and-concatenate-into-one-dataframe\">Concatenate CSV files into one Pandas Dataframe</a></p>\n", "abstract": "Along with the great answers in this post I am going to propose Divide and Conquer approach, I am not writing this answer to abolish the other great answers but to fulfill them with another approach which was working efficiently for me. It has two steps of splitting and merging the pandas dataframe: PROS of Divide and Conquer: CONS of Divide and Conquer: ===================    Divide and Conquer Approach    ================= Step 1: Splitting/Slicing In this step, we are going to divide the iteration over the entire dataframe. Think that you are going to read a CSV file into pandas df then iterate over it. In may case I have 5,000,000 records and I am going to split it into 100,000 records. NOTE: I need to reiterate as other runtime analysis explained in the other solutions in this page, \"number of records\" has exponential proportion of \"runtime\" on search on the df. Based on the benchmark on my data here are the results: Step 2: Merging This is going to be an easy step, just merge all the written CSV files into one dataframe and write it into a bigger CSV file. Here is the sample code: Reference: Efficient way of iteration over datafreame Concatenate CSV files into one Pandas Dataframe"}, {"id": 67701850, "score": 1, "vote": 0, "content": "<p>As <a href=\"https://stackoverflow.com/questions/16476924/how-to-iterate-over-rows-in-a-dataframe-in-pandas/16476974#16476974\">the accepted answer</a> states, the fastest way to apply a function over rows is to use a <strong>vectorized function</strong>, the so-called NumPy <code>ufuncs</code> (universal functions).</p>\n<p>But what should you do when the function you want to apply isn't already implemented in NumPy?</p>\n<p>Well, using the <code>vectorize</code> decorator from <code>numba</code>, you can easily create ufuncs directly in Python like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from numba import vectorize, float64\n\n@vectorize([float64(float64)])\ndef f(x):\n    #x is your line, do something with it, and return a float\n</code></pre>\n<p>The documentation for this function is here: <em><a href=\"https://numba.pydata.org/numba-doc/latest/user/vectorize.html\" rel=\"nofollow noreferrer\">Creating NumPy universal functions</a></em></p>\n", "abstract": "As the accepted answer states, the fastest way to apply a function over rows is to use a vectorized function, the so-called NumPy ufuncs (universal functions). But what should you do when the function you want to apply isn't already implemented in NumPy? Well, using the vectorize decorator from numba, you can easily create ufuncs directly in Python like this: The documentation for this function is here: Creating NumPy universal functions"}, {"id": 66481258, "score": 0, "vote": 0, "content": "<p>Use <code>df.iloc[]</code>. For example, using dataframe 'rows_df':</p>\n<p><a href=\"https://i.stack.imgur.com/eRESg.png\" rel=\"nofollow noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/eRESg.png\"/></a></p>\n<p><em>Or</em></p>\n<p>To get values from a specific row, you can convert the dataframe into ndarray.</p>\n<p>Then select the row and column values like this:</p>\n<p><a href=\"https://i.stack.imgur.com/7iMUn.png\" rel=\"nofollow noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/7iMUn.png\"/></a></p>\n", "abstract": "Use df.iloc[]. For example, using dataframe 'rows_df':  Or To get values from a specific row, you can convert the dataframe into ndarray. Then select the row and column values like this: "}]}, {"link": "https://stackoverflow.com/questions/415511/how-do-i-get-the-current-time", "question": {"id": "415511", "title": "How do I get the current time?", "content": "<p>How do I get the current time?</p>\n", "abstract": "How do I get the current time?"}, "answers": [{"id": 415519, "score": 3686, "vote": 0, "content": "<p>Use <a href=\"https://docs.python.org/3/library/datetime.html\" rel=\"noreferrer\"><code>datetime</code></a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; now = datetime.datetime.now()\n&gt;&gt;&gt; now\ndatetime.datetime(2009, 1, 6, 15, 8, 24, 78915)\n&gt;&gt;&gt; print(now)\n2009-01-06 15:08:24.789150\n</code></pre>\n<p>For just the clock time without the date:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; now.time()\ndatetime.time(15, 8, 24, 78915)\n&gt;&gt;&gt; print(now.time())\n15:08:24.789150\n</code></pre>\n<hr/>\n<p>To save typing, you can import the <code>datetime</code> object from the <a href=\"https://docs.python.org/3/library/datetime.html\" rel=\"noreferrer\"><code>datetime</code></a> module:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from datetime import datetime\n</code></pre>\n<p>Then remove the prefix <code>datetime.</code> from all of the above.</p>\n", "abstract": "Use datetime: For just the clock time without the date: To save typing, you can import the datetime object from the datetime module: Then remove the prefix datetime. from all of the above."}, {"id": 415525, "score": 1137, "vote": 0, "content": "<p>Use <a href=\"http://docs.python.org/3.3/library/time.html?highlight=time.strftime#time.strftime\" rel=\"noreferrer\"><code>time.strftime()</code></a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from time import gmtime, strftime\n&gt;&gt;&gt; strftime(\"%Y-%m-%d %H:%M:%S\", gmtime())\n'2009-01-05 22:14:39'\n</code></pre>\n", "abstract": "Use time.strftime():"}, {"id": 14229023, "score": 812, "vote": 0, "content": "<pre><code class=\"python\">from datetime import datetime\ndatetime.now().strftime('%Y-%m-%d %H:%M:%S')\n</code></pre>\n<p>Example output: <code>'2013-09-18 11:16:32'</code></p>\n<p>See list of <a href=\"https://docs.python.org/library/datetime.html#strftime-and-strptime-format-codes\" rel=\"noreferrer\"><code>strftime</code> directives</a>.</p>\n", "abstract": "Example output: '2013-09-18 11:16:32' See list of strftime directives."}, {"id": 5877368, "score": 515, "vote": 0, "content": "<p>Similar to <a href=\"https://stackoverflow.com/questions/415511/how-to-get-current-time-in-python/415519#415519\">Harley's answer</a>, but use the <code>str()</code> function for a quick-n-dirty, slightly more human readable format:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; str(datetime.now())\n'2011-05-03 17:45:35.177000'\n</code></pre>\n", "abstract": "Similar to Harley's answer, but use the str() function for a quick-n-dirty, slightly more human readable format:"}, {"id": 28576383, "score": 494, "vote": 0, "content": "<blockquote>\n<h1>How do I get the current time in Python?</h1>\n</blockquote>\n<h2>The <code>time</code> module</h2>\n<p>The <code>time</code> module provides functions that tell us the time in \"seconds since the epoch\" as well as other utilities.</p>\n<pre><code class=\"python\">import time\n</code></pre>\n<h3>Unix Epoch Time</h3>\n<p>This is the format you should get timestamps in for saving in databases. It is a simple floating-point number that can be converted to an integer. It is also good for arithmetic in seconds, as it represents the number of seconds since Jan 1, 1970, 00:00:00, and it is memory light relative to the other representations of time we'll be looking at next:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; time.time()\n1424233311.771502\n</code></pre>\n<p>This timestamp does not account for leap-seconds, so it's not linear - leap seconds are ignored. So while it is not equivalent to the international UTC standard, it is close, and therefore quite good for most cases of record-keeping.</p>\n<p>This is not ideal for human scheduling, however. If you have a future event you wish to take place at a certain point in time, you'll want to store that time with a string that can be parsed into a <code>datetime</code> object or a serialized <code>datetime</code> object (these will be described later).</p>\n<h3><code>time.ctime</code></h3>\n<p>You can also represent the current time in the way preferred by your operating system (which means it can change when you change your system preferences, so don't rely on this to be standard across all systems, as I've seen others expect). This is typically user friendly, but doesn't typically result in strings one can sort chronologically:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; time.ctime()\n'Tue Feb 17 23:21:56 2015'\n</code></pre>\n<p>You can hydrate timestamps into human readable form with <code>ctime</code> as well:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; time.ctime(1424233311.771502)\n'Tue Feb 17 23:21:51 2015'\n</code></pre>\n<p>This conversion is also not good for record-keeping (except in text that will only be parsed by humans - and with improved Optical Character Recognition and Artificial Intelligence, I think the number of these cases will diminish).</p>\n<h2><code>datetime</code> module</h2>\n<p>The <code>datetime</code> module is also quite useful here:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import datetime\n</code></pre>\n<h3><code>datetime.datetime.now</code></h3>\n<p>The <code>datetime.now</code> is a class method that returns the current time. It uses the <code>time.localtime</code> without the timezone info (if not given, otherwise see timezone aware below). It has a representation (which would allow you to recreate an equivalent object) echoed on the shell, but when printed (or coerced to a <code>str</code>), it is in human readable (and nearly ISO) format, and the lexicographic sort is equivalent to the chronological sort:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; datetime.datetime.now()\ndatetime.datetime(2015, 2, 17, 23, 43, 49, 94252)\n&gt;&gt;&gt; print(datetime.datetime.now())\n2015-02-17 23:43:51.782461\n</code></pre>\n<h3>datetime's <code>utcnow</code></h3>\n<p>You can get a datetime object in UTC time, a global standard, by doing this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; datetime.datetime.utcnow()\ndatetime.datetime(2015, 2, 18, 4, 53, 28, 394163)\n&gt;&gt;&gt; print(datetime.datetime.utcnow())\n2015-02-18 04:53:31.783988\n</code></pre>\n<p>UTC is a time standard that is nearly equivalent to the GMT timezone. (While GMT and UTC do not change for Daylight Savings Time, their users may switch to other timezones, like British Summer Time, during the Summer.)</p>\n<h3>datetime timezone aware</h3>\n<p>However, none of the datetime objects we've created so far can be easily converted to various timezones. We can solve that problem with the <code>pytz</code> module:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import pytz\n&gt;&gt;&gt; then = datetime.datetime.now(pytz.utc)\n&gt;&gt;&gt; then\ndatetime.datetime(2015, 2, 18, 4, 55, 58, 753949, tzinfo=&lt;UTC&gt;)\n</code></pre>\n<p>Equivalently, in Python 3 we have the <code>timezone</code> class with a utc <code>timezone</code> instance attached, which also makes the object timezone aware (but to convert to another timezone without the handy <code>pytz</code> module is left as an exercise to the reader):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; datetime.datetime.now(datetime.timezone.utc)\ndatetime.datetime(2015, 2, 18, 22, 31, 56, 564191, tzinfo=datetime.timezone.utc)\n</code></pre>\n<p>And we see we can easily convert to timezones from the original UTC object.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print(then)\n2015-02-18 04:55:58.753949+00:00\n&gt;&gt;&gt; print(then.astimezone(pytz.timezone('US/Eastern')))\n2015-02-17 23:55:58.753949-05:00\n</code></pre>\n<p>You can also make a naive datetime object aware with the <code>pytz</code> timezone <code>localize</code> method, or by replacing the tzinfo attribute (with <code>replace</code>, this is done blindly), but these are more last resorts than best practices:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; pytz.utc.localize(datetime.datetime.utcnow())\ndatetime.datetime(2015, 2, 18, 6, 6, 29, 32285, tzinfo=&lt;UTC&gt;)\n&gt;&gt;&gt; datetime.datetime.utcnow().replace(tzinfo=pytz.utc)\ndatetime.datetime(2015, 2, 18, 6, 9, 30, 728550, tzinfo=&lt;UTC&gt;)\n</code></pre>\n<p>The <code>pytz</code> module allows us to make our <code>datetime</code> objects timezone aware and convert the times to the hundreds of timezones available in the <code>pytz</code> module.</p>\n<p>One could ostensibly serialize this object for UTC time and store <em>that</em> in a database, but it would require far more memory and be more prone to error than simply storing the Unix Epoch time, which I demonstrated first.</p>\n<p>The other ways of viewing times are much more error-prone, especially when dealing with data that may come from different time zones. You want there to be no confusion as to which timezone a string or serialized datetime object was intended for.</p>\n<p>If you're displaying the time with Python for the user, <code>ctime</code> works nicely, not in a table (it doesn't typically sort well), but perhaps in a clock. However, I personally recommend, when dealing with time in Python, either using Unix time, or a timezone aware UTC <code>datetime</code> object.</p>\n", "abstract": "The time module provides functions that tell us the time in \"seconds since the epoch\" as well as other utilities. This is the format you should get timestamps in for saving in databases. It is a simple floating-point number that can be converted to an integer. It is also good for arithmetic in seconds, as it represents the number of seconds since Jan 1, 1970, 00:00:00, and it is memory light relative to the other representations of time we'll be looking at next: This timestamp does not account for leap-seconds, so it's not linear - leap seconds are ignored. So while it is not equivalent to the international UTC standard, it is close, and therefore quite good for most cases of record-keeping. This is not ideal for human scheduling, however. If you have a future event you wish to take place at a certain point in time, you'll want to store that time with a string that can be parsed into a datetime object or a serialized datetime object (these will be described later). You can also represent the current time in the way preferred by your operating system (which means it can change when you change your system preferences, so don't rely on this to be standard across all systems, as I've seen others expect). This is typically user friendly, but doesn't typically result in strings one can sort chronologically: You can hydrate timestamps into human readable form with ctime as well: This conversion is also not good for record-keeping (except in text that will only be parsed by humans - and with improved Optical Character Recognition and Artificial Intelligence, I think the number of these cases will diminish). The datetime module is also quite useful here: The datetime.now is a class method that returns the current time. It uses the time.localtime without the timezone info (if not given, otherwise see timezone aware below). It has a representation (which would allow you to recreate an equivalent object) echoed on the shell, but when printed (or coerced to a str), it is in human readable (and nearly ISO) format, and the lexicographic sort is equivalent to the chronological sort: You can get a datetime object in UTC time, a global standard, by doing this: UTC is a time standard that is nearly equivalent to the GMT timezone. (While GMT and UTC do not change for Daylight Savings Time, their users may switch to other timezones, like British Summer Time, during the Summer.) However, none of the datetime objects we've created so far can be easily converted to various timezones. We can solve that problem with the pytz module: Equivalently, in Python 3 we have the timezone class with a utc timezone instance attached, which also makes the object timezone aware (but to convert to another timezone without the handy pytz module is left as an exercise to the reader): And we see we can easily convert to timezones from the original UTC object. You can also make a naive datetime object aware with the pytz timezone localize method, or by replacing the tzinfo attribute (with replace, this is done blindly), but these are more last resorts than best practices: The pytz module allows us to make our datetime objects timezone aware and convert the times to the hundreds of timezones available in the pytz module. One could ostensibly serialize this object for UTC time and store that in a database, but it would require far more memory and be more prone to error than simply storing the Unix Epoch time, which I demonstrated first. The other ways of viewing times are much more error-prone, especially when dealing with data that may come from different time zones. You want there to be no confusion as to which timezone a string or serialized datetime object was intended for. If you're displaying the time with Python for the user, ctime works nicely, not in a table (it doesn't typically sort well), but perhaps in a clock. However, I personally recommend, when dealing with time in Python, either using Unix time, or a timezone aware UTC datetime object."}, {"id": 416605, "score": 152, "vote": 0, "content": "<p>Do</p>\n<pre><code class=\"python\">from time import time\n\nt = time()\n</code></pre>\n<ul>\n<li><code>t</code> - float number, good for time interval measurement.</li>\n</ul>\n<p>There is some difference for Unix and Windows platforms.</p>\n", "abstract": "Do There is some difference for Unix and Windows platforms."}, {"id": 415527, "score": 117, "vote": 0, "content": "<pre><code class=\"python\">&gt;&gt;&gt; from time import gmtime, strftime\n&gt;&gt;&gt; strftime(\"%a, %d %b %Y %X +0000\", gmtime())\n'Tue, 06 Jan 2009 04:54:56 +0000'\n</code></pre>\n<p>That outputs the current GMT in the specified format. There is also a <a href=\"https://docs.python.org/3/library/time.html#time.localtime\" rel=\"noreferrer\"><code>localtime()</code></a> method. </p>\n<p>This <a href=\"http://docs.python.org/library/time.html#module-time\" rel=\"noreferrer\">page</a> has more details.</p>\n", "abstract": "That outputs the current GMT in the specified format. There is also a localtime() method.  This page has more details."}, {"id": 19710846, "score": 84, "vote": 0, "content": "<p>The previous answers are all good suggestions, but I find it easiest to use <code>ctime()</code>:</p>\n<pre><code class=\"python\">In [2]: from time import ctime\nIn [3]: ctime()\nOut[3]: 'Thu Oct 31 11:40:53 2013'\n</code></pre>\n<p>This gives a nicely formatted string representation of the current local time. </p>\n", "abstract": "The previous answers are all good suggestions, but I find it easiest to use ctime(): This gives a nicely formatted string representation of the current local time. "}, {"id": 18980227, "score": 79, "vote": 0, "content": "<p>The quickest way is:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import time\n&gt;&gt;&gt; time.strftime(\"%Y%m%d\")\n'20130924'\n</code></pre>\n", "abstract": "The quickest way is:"}, {"id": 4538034, "score": 65, "vote": 0, "content": "<p>If you need current time as a <code>time</code> object:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; now = datetime.datetime.now()\n&gt;&gt;&gt; datetime.time(now.hour, now.minute, now.second)\ndatetime.time(11, 23, 44)\n</code></pre>\n", "abstract": "If you need current time as a time object:"}, {"id": 28371709, "score": 51, "vote": 0, "content": "<p>You can use the <code>time</code> module:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import time\n&gt;&gt;&gt; print(time.strftime(\"%d/%m/%Y\"))\n06/02/2015\n</code></pre>\n<p>The use of the capital <code>Y</code> gives the full year, and using <code>y</code> would give <code>06/02/15</code>.</p>\n<p>You could also use the following code to give a more lengthy time:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; time.strftime(\"%a, %d %b %Y %H:%M:%S\")\n'Fri, 06 Feb 2015 17:45:09'\n</code></pre>\n", "abstract": "You can use the time module: The use of the capital Y gives the full year, and using y would give 06/02/15. You could also use the following code to give a more lengthy time:"}, {"id": 17287377, "score": 48, "vote": 0, "content": "<p><code>.isoformat()</code> is in the documentation, but not yet here\n(this is mighty similar to @Ray Vega's answer):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; datetime.datetime.now().isoformat()\n'2013-06-24T20:35:55.982000'\n</code></pre>\n", "abstract": ".isoformat() is in the documentation, but not yet here\n(this is mighty similar to @Ray Vega's answer):"}, {"id": 39046637, "score": 44, "vote": 0, "content": "<p>Why not ask the <a href=\"http://tycho.usno.navy.mil/cgi-bin/timer.pl\">U.S. Naval Observatory</a>, the official timekeeper of the United States Navy?</p>\n<pre><code class=\"python\">import requests\nfrom lxml import html\n\npage = requests.get('http://tycho.usno.navy.mil/cgi-bin/timer.pl')\ntree = html.fromstring(page.content)\nprint(tree.xpath('//html//body//h3//pre/text()')[1])\n</code></pre>\n<p>If you live in the D.C. area (like me) the latency might not be too bad...</p>\n", "abstract": "Why not ask the U.S. Naval Observatory, the official timekeeper of the United States Navy? If you live in the D.C. area (like me) the latency might not be too bad..."}, {"id": 46365153, "score": 42, "vote": 0, "content": "<p>Using <a href=\"https://en.wikipedia.org/wiki/Pandas_%28software%29\" rel=\"noreferrer\">pandas</a> to get the current time, kind of overkilling the problem at hand:</p>\n<pre><code class=\"python\">import pandas as pd\nprint(pd.datetime.now())\nprint(pd.datetime.now().date())\nprint(pd.datetime.now().year)\nprint(pd.datetime.now().month)\nprint(pd.datetime.now().day)\nprint(pd.datetime.now().hour)\nprint(pd.datetime.now().minute)\nprint(pd.datetime.now().second)\nprint(pd.datetime.now().microsecond)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">2017-09-22 12:44:56.092642\n2017-09-22\n2017\n9\n22\n12\n44\n56\n92693\n</code></pre>\n", "abstract": "Using pandas to get the current time, kind of overkilling the problem at hand: Output:"}, {"id": 47151173, "score": 34, "vote": 0, "content": "<p>if you are using numpy already then directly you can use numpy.datetime64() \nfunction.</p>\n<pre><code class=\"python\">import numpy as np\nstr(np.datetime64('now'))\n</code></pre>\n<p>for only date:</p>\n<pre><code class=\"python\">str(np.datetime64('today'))\n</code></pre>\n<p>or, if you are using pandas already then you can use pandas.to_datetime() function</p>\n<pre><code class=\"python\">import pandas as pd\nstr(pd.to_datetime('now'))\n</code></pre>\n<p>or,</p>\n<pre><code class=\"python\">str(pd.to_datetime('today'))\n</code></pre>\n", "abstract": "if you are using numpy already then directly you can use numpy.datetime64() \nfunction. for only date: or, if you are using pandas already then you can use pandas.to_datetime() function or,"}, {"id": 27866830, "score": 33, "vote": 0, "content": "<p>This is what I ended up going with: </p>\n<pre><code class=\"python\">&gt;&gt;&gt;from time import strftime\n&gt;&gt;&gt;strftime(\"%m/%d/%Y %H:%M\")\n01/09/2015 13:11\n</code></pre>\n<p>Also, this table is a necessary reference for choosing the appropriate format codes to get the date formatted just the way you want it (from Python \"datetime\" documentation <a href=\"https://docs.python.org/2/library/datetime.html#strftime-strptime-behavior\" rel=\"noreferrer\">here</a>).</p>\n<p><img alt=\"strftime format code table\" src=\"https://i.stack.imgur.com/i6Hg7.jpg\"/></p>\n", "abstract": "This is what I ended up going with:  Also, this table is a necessary reference for choosing the appropriate format codes to get the date formatted just the way you want it (from Python \"datetime\" documentation here). "}, {"id": 27611645, "score": 31, "vote": 0, "content": "<p><code>datetime.now()</code> returns the current time as a naive datetime object that represents time in the local timezone. That value may be ambiguous e.g., during DST transitions (\"fall back\"). To avoid ambiguity either UTC timezone should be used:</p>\n<pre><code class=\"python\">from datetime import datetime\n\nutc_time = datetime.utcnow()\nprint(utc_time) # -&gt; 2014-12-22 22:48:59.916417\n</code></pre>\n<p>Or a timezone-aware object that has the corresponding timezone info attached (Python 3.2+):</p>\n<pre><code class=\"python\">from datetime import datetime, timezone\n\nnow = datetime.now(timezone.utc).astimezone()\nprint(now) # -&gt; 2014-12-23 01:49:25.837541+03:00\n</code></pre>\n", "abstract": "datetime.now() returns the current time as a naive datetime object that represents time in the local timezone. That value may be ambiguous e.g., during DST transitions (\"fall back\"). To avoid ambiguity either UTC timezone should be used: Or a timezone-aware object that has the corresponding timezone info attached (Python 3.2+):"}, {"id": 23753208, "score": 25, "vote": 0, "content": "<pre><code class=\"python\">&gt;&gt;&gt; import datetime, time\n&gt;&gt;&gt; time = time.strftime(\"%H:%M:%S:%MS\", time.localtime())\n&gt;&gt;&gt; print time\n'00:21:38:20S'\n</code></pre>\n", "abstract": ""}, {"id": 43302976, "score": 25, "vote": 0, "content": "<pre><code class=\"python\">import datetime\ndate_time = datetime.datetime.now()\n\ndate = date_time.date()  # Gives the date\ntime = date_time.time()  # Gives the time\n\nprint date.year, date.month, date.day\nprint time.hour, time.minute, time.second, time.microsecond\n</code></pre>\n<p>Do <code>dir(date)</code> or any variables including the package. You can get all the attributes and methods associated with the variable.</p>\n", "abstract": "Do dir(date) or any variables including the package. You can get all the attributes and methods associated with the variable."}, {"id": 51829852, "score": 25, "vote": 0, "content": "<p>This question doesn't need a new answer just for the sake of it ... a shiny new-ish toy/module, however, is enough justification.  That being the <a href=\"https://pendulum.eustace.io/docs/\" rel=\"noreferrer\">Pendulum library</a>, which appears to do the sort of things which arrow attempted, except without the inherent flaws and bugs which beset arrow.</p>\n<p>For instance, the answer to the original question:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import pendulum\n&gt;&gt;&gt; print(pendulum.now())\n2018-08-14T05:29:28.315802+10:00\n&gt;&gt;&gt; print(pendulum.now('utc'))\n2018-08-13T19:29:35.051023+00:00\n</code></pre>\n<p>There's a lot of standards which need addressing, including multiple RFCs and ISOs, to worry about.  Ever get them mixed up; not to worry, take a little look into <code>dir(pendulum.constants)</code> There's a bit more than RFC and ISO formats there, though.</p>\n<p>When we say local, though what do we mean?  Well I mean:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print(pendulum.now().timezone_name)\nAustralia/Melbourne\n&gt;&gt;&gt;\n</code></pre>\n<p>Presumably most of the rest of you mean somewhere else.</p>\n<p>And on it goes.  Long story short: Pendulum attempts to do for date and time what requests did for HTTP.  It's worth consideration, particularly for both its ease of use and extensive documentation.</p>\n", "abstract": "This question doesn't need a new answer just for the sake of it ... a shiny new-ish toy/module, however, is enough justification.  That being the Pendulum library, which appears to do the sort of things which arrow attempted, except without the inherent flaws and bugs which beset arrow. For instance, the answer to the original question: There's a lot of standards which need addressing, including multiple RFCs and ISOs, to worry about.  Ever get them mixed up; not to worry, take a little look into dir(pendulum.constants) There's a bit more than RFC and ISO formats there, though. When we say local, though what do we mean?  Well I mean: Presumably most of the rest of you mean somewhere else. And on it goes.  Long story short: Pendulum attempts to do for date and time what requests did for HTTP.  It's worth consideration, particularly for both its ease of use and extensive documentation."}, {"id": 49048869, "score": 22, "vote": 0, "content": "<p>By default, <code>now()</code> function returns output in the <code>YYYY-MM-DD HH:MM:SS:MS</code> format. Use the below sample script to get the current date and time in a Python script and print results on the screen. Create file <code>getDateTime1.py</code> with the below content.</p>\n<pre><code class=\"python\">import datetime\n\ncurrentDT = datetime.datetime.now()\nprint (str(currentDT))\n</code></pre>\n<p>The output looks like below:</p>\n<pre><code class=\"python\">2018-03-01 17:03:46.759624\n</code></pre>\n", "abstract": "By default, now() function returns output in the YYYY-MM-DD HH:MM:SS:MS format. Use the below sample script to get the current date and time in a Python script and print results on the screen. Create file getDateTime1.py with the below content. The output looks like below:"}, {"id": 33704374, "score": 21, "vote": 0, "content": "<p>Try the arrow module from <a href=\"http://crsmithdev.com/arrow/\" rel=\"noreferrer\">http://crsmithdev.com/arrow/</a>:</p>\n<pre><code class=\"python\">import arrow\narrow.now()\n</code></pre>\n<p>Or the UTC version:</p>\n<pre><code class=\"python\">arrow.utcnow()\n</code></pre>\n<p>To change its output, add .format():</p>\n<pre><code class=\"python\">arrow.utcnow().format('YYYY-MM-DD HH:mm:ss ZZ')\n</code></pre>\n<p>For a specific timezone:</p>\n<pre><code class=\"python\">arrow.now('US/Pacific')\n</code></pre>\n<p>An hour ago:</p>\n<pre><code class=\"python\">arrow.utcnow().replace(hours=-1)\n</code></pre>\n<p>Or if you want the gist.</p>\n<pre><code class=\"python\">arrow.get('2013-05-11T21:23:58.970460+00:00').humanize()\n&gt;&gt;&gt; '2 years ago'\n</code></pre>\n", "abstract": "Try the arrow module from http://crsmithdev.com/arrow/: Or the UTC version: To change its output, add .format(): For a specific timezone: An hour ago: Or if you want the gist."}, {"id": 38433505, "score": 19, "vote": 0, "content": "<p>To get exactly <strong>3</strong> <strong>decimal points</strong> for milliseconds <code>11:34:23.751</code> run this:</p>\n<pre><code class=\"python\">def get_time_str(decimal_points=3):\n        return time.strftime(\"%H:%M:%S\", time.localtime()) + '.%d' % (time.time() % 1 * 10**decimal_points)\n</code></pre>\n<p><strong>More context:</strong></p>\n<p>I want to get the time with milliseconds. A simple way to get them:</p>\n<pre><code class=\"python\">import time, datetime\n\nprint(datetime.datetime.now().time())                         # 11:20:08.272239\n\n# Or in a more complicated way\nprint(datetime.datetime.now().time().isoformat())             # 11:20:08.272239\nprint(datetime.datetime.now().time().strftime('%H:%M:%S.%f')) # 11:20:08.272239\n\n# But do not use this:\nprint(time.strftime(\"%H:%M:%S.%f\", time.localtime()), str)    # 11:20:08.%f\n</code></pre>\n<p>But I want <strong>only milliseconds</strong>, right? The shortest way to get them:</p>\n<pre><code class=\"python\">import time\n\ntime.strftime(\"%H:%M:%S\", time.localtime()) + '.%d' % (time.time() % 1 * 1000)\n# 11:34:23.751\n</code></pre>\n<p>Add or remove zeroes from the last multiplication to adjust number of decimal points, or just:</p>\n<pre><code class=\"python\">def get_time_str(decimal_points=3):\n    return time.strftime(\"%H:%M:%S\", time.localtime()) + '.%d' % (time.time() % 1 * 10**decimal_points)\n</code></pre>\n", "abstract": "To get exactly 3 decimal points for milliseconds 11:34:23.751 run this: More context: I want to get the time with milliseconds. A simple way to get them: But I want only milliseconds, right? The shortest way to get them: Add or remove zeroes from the last multiplication to adjust number of decimal points, or just:"}, {"id": 58451609, "score": 19, "vote": 0, "content": "<p><strong>Current time of a timezone</strong></p>\n<pre><code class=\"python\">from datetime import datetime\nimport pytz\n\ntz_NY = pytz.timezone('America/New_York') \ndatetime_NY = datetime.now(tz_NY)\nprint(\"NY time:\", datetime_NY.strftime(\"%H:%M:%S\"))\n\ntz_London = pytz.timezone('Europe/London')\ndatetime_London = datetime.now(tz_London)\nprint(\"London time:\", datetime_London.strftime(\"%H:%M:%S\"))\n\ntz_India = pytz.timezone('Asia/India')\ndatetime_India = datetime.now(tz_India)\nprint(\"India time:\", datetime_India.strftime(\"%H:%M:%S\"))\n\n#list timezones\npytz.all_timezones\n</code></pre>\n", "abstract": "Current time of a timezone"}, {"id": 47548082, "score": 18, "vote": 0, "content": "<p>You can use this function to get the time (unfortunately it doesn't say AM or PM):</p>\n<pre><code class=\"python\">def gettime():\n    from datetime import datetime\n    return ((str(datetime.now())).split(' ')[1]).split('.')[0]\n</code></pre>\n<p>To get the hours, minutes, seconds and milliseconds to merge later, you can use these functions:</p>\n<p><em>Hour:</em></p>\n<pre><code class=\"python\">def gethour():\n    from datetime import datetime\n    return (((str(datetime.now())).split(' ')[1]).split('.')[0]).split(':')[0]\n</code></pre>\n<p><em>Minute:</em></p>\n<pre><code class=\"python\">def getminute():\n    from datetime import datetime\n    return (((str(datetime.now())).split(' ')[1]).split('.')[0]).split(':')[1]\n</code></pre>\n<p><em>Second:</em></p>\n<pre><code class=\"python\">def getsecond():\n    from datetime import datetime\n    return (((str(datetime.now())).split(' ')[1]).split('.')[0]).split(':')[2]\n</code></pre>\n<p><em>Millisecond:</em></p>\n<pre><code class=\"python\">def getmillisecond():\n    from datetime import datetime\n    return (str(datetime.now())).split('.')[1]\n</code></pre>\n", "abstract": "You can use this function to get the time (unfortunately it doesn't say AM or PM): To get the hours, minutes, seconds and milliseconds to merge later, you can use these functions: Hour: Minute: Second: Millisecond:"}, {"id": 51395703, "score": 18, "vote": 0, "content": "<p>If you just want the current timestamp in ms (for example, to measure execution time), you can also use the \"timeit\" module:</p>\n<pre><code class=\"python\">import timeit\nstart_time = timeit.default_timer()\ndo_stuff_you_want_to_measure()\nend_time = timeit.default_timer()\nprint(\"Elapsed time: {}\".format(end_time - start_time))\n</code></pre>\n", "abstract": "If you just want the current timestamp in ms (for example, to measure execution time), you can also use the \"timeit\" module:"}, {"id": 62205205, "score": 18, "vote": 0, "content": "<p>You can  try the following</p>\n<pre><code class=\"python\">import datetime\n\nnow = datetime.datetime.now()\nprint(now)\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">import datetime\n\nnow = datetime.datetime.now()\nprint(now.strftime(\"%Y-%b-%d, %A %I:%M:%S\"))\n</code></pre>\n", "abstract": "You can  try the following or"}, {"id": 51206016, "score": 15, "vote": 0, "content": "<p>Because no one has mentioned it yet, and this is something I ran into recently... a pytz timezone's fromutc() method combined with datetime's utcnow() is the best way I've found to get a useful current time (and date) in any timezone.</p>\n<pre><code class=\"python\">from datetime import datetime\n\nimport pytz\n\n\nJST = pytz.timezone(\"Asia/Tokyo\")\n\n\nlocal_time = JST.fromutc(datetime.utcnow())\n</code></pre>\n<p>If all you want is the time, you can then get that with <code>local_time.time()</code>.</p>\n", "abstract": "Because no one has mentioned it yet, and this is something I ran into recently... a pytz timezone's fromutc() method combined with datetime's utcnow() is the best way I've found to get a useful current time (and date) in any timezone. If all you want is the time, you can then get that with local_time.time()."}, {"id": 58357045, "score": 14, "vote": 0, "content": "<pre><code class=\"python\">import datetime\n\ntodays_date = datetime.date.today()\nprint(todays_date)\n&gt;&gt;&gt; 2019-10-12\n\n# adding strftime will remove the seconds\ncurrent_time = datetime.datetime.now().strftime('%H:%M')\nprint(current_time)\n&gt;&gt;&gt; 23:38\n</code></pre>\n", "abstract": ""}, {"id": 61290837, "score": 13, "vote": 0, "content": "<p><strong>Method1: Getting Current Date and Time from system datetime</strong></p>\n<p>The <strong>datetime</strong> module supplies classes for manipulating dates and times.</p>\n<blockquote>\n<p>Code</p>\n</blockquote>\n<pre><code class=\"python\">from datetime import datetime,date\n\nprint(\"Date: \"+str(date.today().year)+\"-\"+str(date.today().month)+\"-\"+str(date.today().day))\nprint(\"Year: \"+str(date.today().year))\nprint(\"Month: \"+str(date.today().month))\nprint(\"Day: \"+str(date.today().day)+\"\\n\")\n\nprint(\"Time: \"+str(datetime.today().hour)+\":\"+str(datetime.today().minute)+\":\"+str(datetime.today().second))\nprint(\"Hour: \"+str(datetime.today().hour))\nprint(\"Minute: \"+str(datetime.today().minute))\nprint(\"Second: \"+str(datetime.today().second))\nprint(\"MilliSecond: \"+str(datetime.today().microsecond))\n</code></pre>\n<blockquote>\n<p>Output will be like</p>\n</blockquote>\n<pre><code class=\"python\">Date: 2020-4-18\nYear: 2020\nMonth: 4\nDay: 18\n\nTime: 19:30:5\nHour: 19\nMinute: 30\nSecond: 5\nMilliSecond: 836071\n</code></pre>\n<p><strong>Method2: Getting Current Date and Time if Network is available</strong></p>\n<p><strong>urllib</strong> package helps us to handle the url's that means webpages. Here we collects data from the webpage <a href=\"http://just-the-time.appspot.com/\" rel=\"noreferrer\">http://just-the-time.appspot.com/</a> and parses <strong>dateime</strong> from the webpage using the package <strong>dateparser</strong>.</p>\n<blockquote>\n<p>Code</p>\n</blockquote>\n<pre><code class=\"python\">from urllib.request import urlopen\nimport dateparser\n\ntime_url = urlopen(u'http://just-the-time.appspot.com/')\ndatetime = time_url.read().decode(\"utf-8\", errors=\"ignore\").split(' ')[:-1]\ndate = datetime[0]\ntime = datetime[1]\n\nprint(\"Date: \"+str(date))\nprint(\"Year: \"+str(date.split('-')[0]))\nprint(\"Month: \"+str(date.split('-')[1]))\nprint(\"Day: \"+str(date.split('-')[2])+'\\n')\n\nprint(\"Time: \"+str(time))\nprint(\"Hour: \"+str(time.split(':')[0]))\nprint(\"Minute: \"+str(time.split(':')[1]))\nprint(\"Second: \"+str(time.split(':')[2]))\n</code></pre>\n<blockquote>\n<p>Output will be like</p>\n</blockquote>\n<pre><code class=\"python\">Date: 2020-04-18\nYear: 2020\nMonth: 04\nDay: 18\n\nTime: 14:17:10\nHour: 14\nMinute: 17\nSecond: 10\n</code></pre>\n<p><strong>Method3: Getting Current Date and Time from Local Time of the Machine</strong></p>\n<p>Python's <strong>time</strong> module provides a function for getting local time from the number of seconds elapsed since the epoch called localtime(). <strong>ctime()</strong> function takes seconds passed since epoch as an argument and returns a string representing local time.</p>\n<blockquote>\n<p>Code</p>\n</blockquote>\n<pre><code class=\"python\">from time import time, ctime\ndatetime = ctime(time()).split(' ')\n\nprint(\"Date: \"+str(datetime[4])+\"-\"+str(datetime[1])+\"-\"+str(datetime[2]))\nprint(\"Year: \"+str(datetime[4]))\nprint(\"Month: \"+str(datetime[1]))\nprint(\"Day: \"+str(datetime[2]))\nprint(\"Week Day: \"+str(datetime[0])+'\\n')\n\nprint(\"Time: \"+str(datetime[3]))\nprint(\"Hour: \"+str(datetime[3]).split(':')[0])\nprint(\"Minute: \"+str(datetime[3]).split(':')[1])\nprint(\"Second: \"+str(datetime[3]).split(':')[2])\n</code></pre>\n<blockquote>\n<p>Output will be like</p>\n</blockquote>\n<pre><code class=\"python\">Date: 2020-Apr-18\nYear: 2020\nMonth: Apr\nDay: 18\nWeek Day: Sat\n\nTime: 19:30:20\nHour: 19\nMinute: 30\nSecond: 20\n</code></pre>\n", "abstract": "Method1: Getting Current Date and Time from system datetime The datetime module supplies classes for manipulating dates and times. Code Output will be like Method2: Getting Current Date and Time if Network is available urllib package helps us to handle the url's that means webpages. Here we collects data from the webpage http://just-the-time.appspot.com/ and parses dateime from the webpage using the package dateparser. Code Output will be like Method3: Getting Current Date and Time from Local Time of the Machine Python's time module provides a function for getting local time from the number of seconds elapsed since the epoch called localtime(). ctime() function takes seconds passed since epoch as an argument and returns a string representing local time. Code Output will be like"}, {"id": 57937132, "score": 11, "vote": 0, "content": "<p>You can do so using ctime():</p>\n<pre><code class=\"python\">from time import time, ctime\nt = time()\nctime(t)\n</code></pre>\n<p>output:</p>\n<p><code>Sat Sep 14 21:27:08 2019</code></p>\n<p>These outputs are different because the timestamp returned by <code>ctime()</code> depends on your geographical location.</p>\n", "abstract": "You can do so using ctime(): output: Sat Sep 14 21:27:08 2019 These outputs are different because the timestamp returned by ctime() depends on your geographical location."}, {"id": 69101777, "score": 11, "vote": 0, "content": "<p>try this one:-</p>\n<pre><code class=\"python\">from datetime import datetime\n\nnow = datetime.now()\n\ncurrent_time = now.strftime(\"%H:%M:%S\")\nprint(\"Current Time =\", current_time)\n</code></pre>\n", "abstract": "try this one:-"}, {"id": 29980465, "score": 9, "vote": 0, "content": "<p>The following is what I use to get the time without having to format. Some people don't like the split method, but it is useful here:</p>\n<pre><code class=\"python\">from time import ctime\nprint ctime().split()[3]\n</code></pre>\n<p>It will print in HH:MM:SS format.</p>\n", "abstract": "The following is what I use to get the time without having to format. Some people don't like the split method, but it is useful here: It will print in HH:MM:SS format."}, {"id": 38366394, "score": 9, "vote": 0, "content": "<pre><code class=\"python\">import datetime\ndate_time = str(datetime.datetime.now()).split()\ndate,time = date_time\n</code></pre>\n<p><strong>date</strong> will print date and <strong>time</strong> will print time.</p>\n", "abstract": "date will print date and time will print time."}, {"id": 56458580, "score": 9, "vote": 0, "content": "<p>This question is for Python but since Django is one of the most widely used frameworks for Python, its important to note that if you are using Django you can always use <code>timezone.now()</code> instead of <code>datetime.datetime.now()</code>. The former is timezone 'aware' while the latter is not. </p>\n<p>See <a href=\"https://stackoverflow.com/a/26950056/1526703\">this SO answer</a> and the <a href=\"https://docs.djangoproject.com/en/dev/topics/i18n/timezones/#naive-and-aware-datetime-objects\" rel=\"noreferrer\">Django doc</a> for details and rationale behind <code>timezone.now()</code>.</p>\n<pre><code class=\"python\">from django.utils import timezone\n\nnow = timezone.now()\n</code></pre>\n", "abstract": "This question is for Python but since Django is one of the most widely used frameworks for Python, its important to note that if you are using Django you can always use timezone.now() instead of datetime.datetime.now(). The former is timezone 'aware' while the latter is not.  See this SO answer and the Django doc for details and rationale behind timezone.now()."}, {"id": 54287129, "score": 8, "vote": 0, "content": "<p>This is so simple.\nTry:</p>\n<pre><code class=\"python\">import datetime\ndate_time = str(datetime.datetime.now())\ndate = date_time.split()[0]\ntime = date_time.split()[1]\n</code></pre>\n", "abstract": "This is so simple.\nTry:"}, {"id": 48283832, "score": 7, "vote": 0, "content": "<pre><code class=\"python\">from time import ctime\n\n// Day {Mon,Tue,..}\nprint ctime().split()[0]\n// Month {Jan, Feb,..}\nprint ctime().split()[1]\n// Date {1,2,..}\nprint ctime().split()[2]\n// HH:MM:SS\nprint ctime().split()[3]\n// Year {2018,..}\nprint ctime().split()[4]\n</code></pre>\n<p>When you call <code>ctime()</code> it will convert seconds to string in format <code>'Day Month Date HH:MM:SS Year'</code> (for example: <code>'Wed January 17 16:53:22 2018'</code>), then you call <code>split()</code> method that will make a list from your string <code>['Wed','Jan','17','16:56:45','2018']</code> (default delimeter is space).</p>\n<p>Brackets are used to 'select' wanted argument in list.</p>\n<p>One should call just one code line. One should not call them like I did, that was just an example, because in some cases you will get different values, rare but not impossible cases. </p>\n", "abstract": "When you call ctime() it will convert seconds to string in format 'Day Month Date HH:MM:SS Year' (for example: 'Wed January 17 16:53:22 2018'), then you call split() method that will make a list from your string ['Wed','Jan','17','16:56:45','2018'] (default delimeter is space). Brackets are used to 'select' wanted argument in list. One should call just one code line. One should not call them like I did, that was just an example, because in some cases you will get different values, rare but not impossible cases. "}, {"id": 54979470, "score": 7, "vote": 0, "content": "<p>Get current date time attributes:</p>\n<pre><code class=\"python\">import datetime\n\ncurrentDT = datetime.datetime.now()\n\nprint (\"Current Year is: %d\" % currentDT.year)\nprint (\"Current Month is: %d\" % currentDT.month)\nprint (\"Current Day is: %d\" % currentDT.day)\nprint (\"Current Hour is: %d\" % currentDT.hour)\nprint (\"Current Minute is: %d\" % currentDT.minute)\nprint (\"Current Second is: %d\" % currentDT.second)\nprint (\"Current Microsecond is: %d\" % currentDT.microsecond)\n\n\n#!/usr/bin/python\nimport time;\n\nticks = time.time()\nprint \"Number of ticks since \"12:00am, Jan 1, 1970\":\", ticks\n</code></pre>\n", "abstract": "Get current date time attributes:"}, {"id": 50517665, "score": 5, "vote": 0, "content": "<p>First import the datetime module from datetime</p>\n<pre><code class=\"python\">from datetime import datetime\n</code></pre>\n<p>Then print the current time as 'yyyy-mm-dd hh:mm:ss'</p>\n<pre><code class=\"python\">print(str(datetime.now())\n</code></pre>\n<p>To get only the time in the form 'hh:mm:ss' where ss stands for the full number of seconds plus the fraction of seconds elapsed, just do;</p>\n<pre><code class=\"python\">print(str(datetime.now()[11:])\n</code></pre>\n<p>Converting the datetime.now() to a string yields an answer that is in the format that feels like the regular DATES AND TIMES we are used to.</p>\n", "abstract": "First import the datetime module from datetime Then print the current time as 'yyyy-mm-dd hh:mm:ss' To get only the time in the form 'hh:mm:ss' where ss stands for the full number of seconds plus the fraction of seconds elapsed, just do; Converting the datetime.now() to a string yields an answer that is in the format that feels like the regular DATES AND TIMES we are used to."}, {"id": 70782771, "score": 5, "vote": 0, "content": "<p>If you using it for django datetime sometimes won't work on server so I recommend using timezone</p>\n<p>But for use django timezone you should set your country timezone code in your settings.py</p>\n<pre><code class=\"python\">TIME_ZONE = 'Asia/Tashkent'\n</code></pre>\n<p>Then you can use it</p>\n<pre><code class=\"python\">from django.utils import timezone\n\ntimezone.now() // for date time\n\ntimezone.now().year // for yaer\n\ntimezone.now().month // for month\n\ntimezone.now().day // for day \n\ntimezone.now().date // for date\n\ntimezone.now().hour // for hour\n\ntimezone.now().weekday // for minute\n\n</code></pre>\n<p>or if you want use on python</p>\n<pre><code class=\"python\">import time\n\ntime.strftime('%X') // '13:12:47'\n\ntime.strftime('%x') // '01/20/22'\n\ntime.strftime('%d') // '20' day\n\ntime.strftime('%m') // '01' month\n\ntime.strftime('%y') // '20' year\n\ntime.strftime('%H') // '01' hour\n\ntime.strftime('%M') // '01' minute\n\ntime.strftime('%m') // '01' second\n</code></pre>\n", "abstract": "If you using it for django datetime sometimes won't work on server so I recommend using timezone But for use django timezone you should set your country timezone code in your settings.py Then you can use it or if you want use on python"}, {"id": 61322999, "score": 4, "vote": 0, "content": "<p>The <code>time</code> module can import all sorts of time stuff, inculduing sleep and other types of stuff including - the current time type</p>\n<pre><code class=\"python\">import time\ntime.strftime(\"%T\", time.localtime())\n</code></pre>\n<p>The output should look like this</p>\n<pre><code class=\"python\">05:46:33\n11:22:56\n13:44:55\n22:33:44\n00:00:00\n</code></pre>\n", "abstract": "The time module can import all sorts of time stuff, inculduing sleep and other types of stuff including - the current time type The output should look like this"}, {"id": 62359990, "score": 4, "vote": 0, "content": "<p>we can accomplish that Using datetime module</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; now = datetime.now() #get a datetime object containing current date and time\n&gt;&gt;&gt; current_time = now.strftime(\"%H:%M:%S\") #created a string representing current time\n&gt;&gt;&gt; print(\"Current Time =\", current_time)\nCurrent Time = 17:56:54\n</code></pre>\n<p>In addition, we can get the current time of time zome using <a href=\"http://pytz.sourceforge.net/\" rel=\"nofollow noreferrer\">pytZ module</a>.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from pytz import timezone\n&gt;&gt;&gt; import pytz\n&gt;&gt;&gt; eastern = timezone('US/Eastern')\n&gt;&gt;&gt; eastern.zone\n'US/Eastern'\n&gt;&gt;&gt; amsterdam = timezone('Europe/Amsterdam')\n&gt;&gt;&gt; datetime_eu = datetime.now(amsterdam)\n&gt;&gt;&gt; print(\"Europe time::\", datetime_eu.strftime(\"%H:%M:%S\"))\nEurope time:: 14:45:31\n</code></pre>\n", "abstract": "we can accomplish that Using datetime module In addition, we can get the current time of time zome using pytZ module."}, {"id": 66849416, "score": 4, "vote": 0, "content": "<pre><code class=\"python\">import datetime\n\nprint('date='+datetime.datetime.now().__str__().split(' ')[0]+' '+'time='+datetime.datetime.now().__str__().split(' ')[1]\n\n</code></pre>\n<p>Since Qt is used extensively,</p>\n<pre><code class=\"python\">from PyQt5 import QDateTime\nprint(QDateTime.currentDateTime().__str__().split('(')[1].rstrip(')'))\n</code></pre>\n", "abstract": "Since Qt is used extensively,"}, {"id": 62608622, "score": 3, "vote": 0, "content": "<p>From Python 3.9, the <a href=\"https://docs.python.org/3.9/library/zoneinfo.html\" rel=\"nofollow noreferrer\"><code>zoneinfo</code></a> module can be used for getting timezones rather than using a third party library.</p>\n<p>To get the current time in a particular timezone:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from datetime import datetime\nfrom zoneinfo import ZoneInfo\n\ndatetime.now(tz=ZoneInfo(\"Europe/Amsterdam\"))\n</code></pre>\n", "abstract": "From Python 3.9, the zoneinfo module can be used for getting timezones rather than using a third party library. To get the current time in a particular timezone:"}, {"id": 71917138, "score": 3, "vote": 0, "content": "<p>If you use <em>pandas</em> a lot you can use <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html\" rel=\"nofollow noreferrer\"><code>Timestamp</code></a>, which is the equivalent of <em>Python</em>\u2019s <a href=\"https://docs.python.org/3/library/datetime.html\" rel=\"nofollow noreferrer\"><code>Datetime</code></a>:</p>\n<pre><code class=\"python\">In [1]: import pandas as pd\n\nIn [2]: pd.Timestamp.now()\nOut[2]: Timestamp('2022-06-21 21:52:50.568788')\n</code></pre>\n<p>And just the time:</p>\n<pre><code class=\"python\">In [3]: pd.Timestamp.now().strftime(\"%H:%M:%S\")\nOut[3]: '21:53:01'\n</code></pre>\n", "abstract": "If you use pandas a lot you can use Timestamp, which is the equivalent of Python\u2019s Datetime: And just the time:"}, {"id": 62425566, "score": 2, "vote": 0, "content": "<p>If you want the time for purpose of timing function calls, then you want time.perf_counter().</p>\n<pre><code class=\"python\">start_time = time.perf_counter()\nexpensive_function()\ntime_taken = time.perf_counter() - start_time\nprint(f'expensive_function() took {round(time_taken,2)}s')\n</code></pre>\n<blockquote>\n<p>time.perf_counter() \u2192 float</p>\n<p>Return the value (in fractional seconds) of a performance counter, i.e. a clock with the highest available resolution to measure a short duration. It does include time elapsed during sleep and is system-wide. The reference point of the returned value is undefined, so that only the difference between the results of consecutive calls is valid.</p>\n<p>New in version 3.3.</p>\n<hr/>\n<p>time.perf_counter_ns() \u2192 int</p>\n<p>Similar to perf_counter(), but return time as nanoseconds.</p>\n<p>New in version 3.7.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://docs.python.org/3/library/time.html#time.perf_counter\" rel=\"nofollow noreferrer\">https://docs.python.org/3/library/time.html#time.perf_counter</a></li>\n</ul>\n", "abstract": "If you want the time for purpose of timing function calls, then you want time.perf_counter(). time.perf_counter() \u2192 float Return the value (in fractional seconds) of a performance counter, i.e. a clock with the highest available resolution to measure a short duration. It does include time elapsed during sleep and is system-wide. The reference point of the returned value is undefined, so that only the difference between the results of consecutive calls is valid. New in version 3.3. time.perf_counter_ns() \u2192 int Similar to perf_counter(), but return time as nanoseconds. New in version 3.7."}, {"id": 71191706, "score": 2, "vote": 0, "content": "<p>Attributes of now() can be used to get the current time in python:</p>\n<pre><code class=\"python\"># importing datetime module for now()\nimport datetime\n    \n# using now() to get current time\ncurrent_time = datetime.datetime.now()\n    \n# Printing attributes of now().\nprint (\"The attributes of now() are : \")\n    \nprint (\"Year : \", end = \"\")\nprint (current_time.year)\n    \nprint (\"Month : \", end = \"\")\nprint (current_time.month)\n    \nprint (\"Day : \", end = \"\")\nprint (current_time.day)\n    \nprint (\"Hour : \", end = \"\")\nprint (current_time.hour)\n    \nprint (\"Minute : \", end = \"\")\nprint (current_time.minute)\n    \nprint (\"Second : \", end = \"\")\nprint (current_time.second)\n    \nprint (\"Microsecond : \", end = \"\")\nprint (current_time.microsecond)\n</code></pre>\n", "abstract": "Attributes of now() can be used to get the current time in python:"}, {"id": 71103877, "score": 1, "vote": 0, "content": "<p>Gets the current time and converts it to string:</p>\n<pre><code class=\"python\">from datetime import datetime\ndatetime.now().strftime('%Y-%m-%d %H:%M:%S')\n</code></pre>\n", "abstract": "Gets the current time and converts it to string:"}, {"id": 73575408, "score": 1, "vote": 0, "content": "<p>There are so many complex solutions here it could be confusing for a beginner. I find this is the most simple solution to the question - as it just returns the current time as asked (no frills):</p>\n<pre><code class=\"python\">import datetime\n\ntime = datetime.datetime.now()\n\ndisplay_time = time.strftime(\"%H:%M\")\nprint(display_time)\n</code></pre>\n<p>If you wanted more detail back than just the current time, you can do what some others have suggested here:</p>\n<pre><code class=\"python\">import datetime\n\ntime = datetime.datetime.now()\nprint(time)\n</code></pre>\n<p>Although this approach is shorter to write, it returns the current date and milliseconds as well, which may not be required when simply looking to return the current time.</p>\n", "abstract": "There are so many complex solutions here it could be confusing for a beginner. I find this is the most simple solution to the question - as it just returns the current time as asked (no frills): If you wanted more detail back than just the current time, you can do what some others have suggested here: Although this approach is shorter to write, it returns the current date and milliseconds as well, which may not be required when simply looking to return the current time."}, {"id": 68065961, "score": 0, "vote": 0, "content": "<p>Here's the code which will only show time according to your question:</p>\n<pre><code class=\"python\"> from datetime import datetime\n time= datetime.now()\n b = time.strftime(\"%H:%M:%S\")\n print(b)\n</code></pre>\n<ul>\n<li>Used <code>datetime.now()</code> to get the current date and time.</li>\n<li>Then used <code>.strftime</code> to get desired value i.e time only.</li>\n</ul>\n<p><a href=\"https://www.tutorialspoint.com/python/time_strftime.htm\" rel=\"nofollow noreferrer\"><code>strftime</code></a> is used to retrieve the desired output or to change the default format according to our need.</p>\n", "abstract": "Here's the code which will only show time according to your question: strftime is used to retrieve the desired output or to change the default format according to our need."}, {"id": 70742500, "score": 0, "vote": 0, "content": "<p><strong>Use this  method for UTC DateTime, local Date-Time, and convert am and pm</strong></p>\n<pre><code class=\"python\">import pytz\nfrom datetime import datetime\n\n#UTC Time\nprint(\"UTC Date and time\")\nepoch: datetime =datetime.now().replace(tzinfo=pytz.utc)\nprint(epoch)\n\n#local date and time\nprint(\"Local Date and time\")\ntoday = datetime.now()\nlocal_time = today.strftime(\"%Y-%M-%d:%H:%M:%S\")\nprint(local_time)\n\n#convert time to AM PM format\nprint(\"Date and time AM and PM\")\nnow = today.strftime(\"%Y-%M-%d:%I:%M %p\")\nprint(now)\n</code></pre>\n", "abstract": "Use this  method for UTC DateTime, local Date-Time, and convert am and pm"}, {"id": 71589047, "score": -2, "vote": 0, "content": "<p>This should work</p>\n<pre><code class=\"python\">import time\n\nnow = datetime.now()\ncurrent_time = now.strftime(\"%H:%M:%S\")\nprint(\"The current time is\", current_time)\n</code></pre>\n", "abstract": "This should work"}]}, {"link": "https://stackoverflow.com/questions/3437059/does-python-have-a-string-contains-substring-method", "question": {"id": "3437059", "title": "Does Python have a string &#39;contains&#39; substring method?", "content": "<p>I'm looking for a <code>string.contains</code> or <code>string.indexof</code> method in Python.</p>\n<p>I want to do:</p>\n<pre><code class=\"python\">if not somestring.contains(\"blah\"):\n   continue\n</code></pre>\n", "abstract": "I'm looking for a string.contains or string.indexof method in Python. I want to do:"}, "answers": [{"id": 3437070, "score": 7979, "vote": 0, "content": "<p>Use the <a href=\"https://docs.python.org/reference/expressions.html#membership-test-details\" rel=\"noreferrer\"><code>in</code> operator</a>:</p>\n<pre><code class=\"python\">if \"blah\" not in somestring: \n    continue\n</code></pre>\n", "abstract": "Use the in operator:"}, {"id": 3437068, "score": 865, "vote": 0, "content": "<p>If it's just a substring search you can use <code>string.find(\"substring\")</code>.</p>\n<p>You do have to be a little careful with <a href=\"https://docs.python.org/library/stdtypes.html#str.find\" rel=\"noreferrer\"><code>find</code></a>, <a href=\"https://docs.python.org/library/stdtypes.html#str.index\" rel=\"noreferrer\"><code>index</code></a>, and <a href=\"https://docs.python.org/reference/expressions.html#membership-test-operations\" rel=\"noreferrer\"><code>in</code></a> though, as they are substring searches. In other words, this:</p>\n<pre><code class=\"python\">s = \"This be a string\"\nif s.find(\"is\") == -1:\n    print(\"No 'is' here!\")\nelse:\n    print(\"Found 'is' in the string.\")\n</code></pre>\n<p>It would print <code>Found 'is' in the string.</code> Similarly, <code>if \"is\" in s:</code> would evaluate to <code>True</code>. This may or may not be what you want.</p>\n", "abstract": "If it's just a substring search you can use string.find(\"substring\"). You do have to be a little careful with find, index, and in though, as they are substring searches. In other words, this: It would print Found 'is' in the string. Similarly, if \"is\" in s: would evaluate to True. This may or may not be what you want."}, {"id": 27138045, "score": 467, "vote": 0, "content": "<blockquote>\n<h2>Does Python have a string contains substring method?</h2>\n</blockquote>\n<p><strong>99%</strong> of use cases will be covered using the keyword, <code>in</code>, which returns <code>True</code> or <code>False</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">'substring' in any_string\n</code></pre>\n<p>For the use case of getting the index, use <code>str.find</code> (which returns -1 on failure, and has optional positional arguments):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">start = 0\nstop = len(any_string)\nany_string.find('substring', start, stop)\n</code></pre>\n<p>or <code>str.index</code> (like <code>find</code> but raises ValueError on failure):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">start = 100 \nend = 1000\nany_string.index('substring', start, end)\n</code></pre>\n<h2>Explanation</h2>\n<p>Use the <code>in</code> comparison operator because</p>\n<ol>\n<li>the language intends its usage, and</li>\n<li>other Python programmers will expect you to use it.</li>\n</ol>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; 'foo' in '**foo**'\nTrue\n</code></pre>\n<p>The opposite (complement), which the original question asked for, is <code>not in</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; 'foo' not in '**foo**' # returns False\nFalse\n</code></pre>\n<p>This is semantically the same as <code>not 'foo' in '**foo**'</code> but it's much more readable and explicitly provided for in the language as a readability improvement.</p>\n<h2>Avoid using <code>__contains__</code></h2>\n<p>The \"contains\" method implements the behavior for <code>in</code>. This example,</p>\n<pre><code class=\"python\">str.__contains__('**foo**', 'foo')\n</code></pre>\n<p>returns <code>True</code>. You could also call this function from the instance of the superstring:</p>\n<pre><code class=\"python\">'**foo**'.__contains__('foo')\n</code></pre>\n<p>But don't. Methods that start with underscores are considered semantically non-public. The only reason to use this is when implementing or extending the <code>in</code> and <code>not in</code> functionality (e.g. if subclassing <code>str</code>):</p>\n<pre><code class=\"python\">class NoisyString(str):\n    def __contains__(self, other):\n        print(f'testing if \"{other}\" in \"{self}\"')\n        return super(NoisyString, self).__contains__(other)\n\nns = NoisyString('a string with a substring inside')\n</code></pre>\n<p>and now:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 'substring' in ns\ntesting if \"substring\" in \"a string with a substring inside\"\nTrue\n</code></pre>\n<h2>Don't use <code>find</code> and <code>index</code> to test for \"contains\"</h2>\n<p>Don't use the following string methods to test for \"contains\":</p>\n<pre><code class=\"python\">&gt;&gt;&gt; '**foo**'.index('foo')\n2\n&gt;&gt;&gt; '**foo**'.find('foo')\n2\n\n&gt;&gt;&gt; '**oo**'.find('foo')\n-1\n&gt;&gt;&gt; '**oo**'.index('foo')\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#40&gt;\", line 1, in &lt;module&gt;\n    '**oo**'.index('foo')\nValueError: substring not found\n</code></pre>\n<p>Other languages may have no methods to directly test for substrings, and so you would have to use these types of methods, but with Python, it is much more efficient to use the <code>in</code> comparison operator.</p>\n<p>Also, these are not drop-in replacements for <code>in</code>. You may have to handle the exception or <code>-1</code> cases, and if they return <code>0</code> (because they found the substring at the beginning) the boolean interpretation is <code>False</code> instead of <code>True</code>.</p>\n<p>If you really mean <code>not any_string.startswith(substring)</code> then say it.</p>\n<h2>Performance comparisons</h2>\n<p>We can compare various ways of accomplishing the same goal.</p>\n<pre><code class=\"python\">import timeit\n\ndef in_(s, other):\n    return other in s\n\ndef contains(s, other):\n    return s.__contains__(other)\n\ndef find(s, other):\n    return s.find(other) != -1\n\ndef index(s, other):\n    try:\n        s.index(other)\n    except ValueError:\n        return False\n    else:\n        return True\n\n\n\nperf_dict = {\n'in:True': min(timeit.repeat(lambda: in_('superstring', 'str'))),\n'in:False': min(timeit.repeat(lambda: in_('superstring', 'not'))),\n'__contains__:True': min(timeit.repeat(lambda: contains('superstring', 'str'))),\n'__contains__:False': min(timeit.repeat(lambda: contains('superstring', 'not'))),\n'find:True': min(timeit.repeat(lambda: find('superstring', 'str'))),\n'find:False': min(timeit.repeat(lambda: find('superstring', 'not'))),\n'index:True': min(timeit.repeat(lambda: index('superstring', 'str'))),\n'index:False': min(timeit.repeat(lambda: index('superstring', 'not'))),\n}\n</code></pre>\n<p>And now we see that using <code>in</code> is much faster than the others.\nLess time to do an equivalent operation is better:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; perf_dict\n{'in:True': 0.16450627865128808,\n 'in:False': 0.1609668098178645,\n '__contains__:True': 0.24355481654697542,\n '__contains__:False': 0.24382793854783813,\n 'find:True': 0.3067379407923454,\n 'find:False': 0.29860888058124146,\n 'index:True': 0.29647137792585454,\n 'index:False': 0.5502287584545229}\n</code></pre>\n<h3>How can <code>in</code> be faster than <code>__contains__</code> if <code>in</code> uses <code>__contains__</code>?</h3>\n<p>This is a fine follow-on question.</p>\n<p>Let's disassemble functions with the methods of interest:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from dis import dis\n&gt;&gt;&gt; dis(lambda: 'a' in 'b')\n  1           0 LOAD_CONST               1 ('a')\n              2 LOAD_CONST               2 ('b')\n              4 COMPARE_OP               6 (in)\n              6 RETURN_VALUE\n&gt;&gt;&gt; dis(lambda: 'b'.__contains__('a'))\n  1           0 LOAD_CONST               1 ('b')\n              2 LOAD_METHOD              0 (__contains__)\n              4 LOAD_CONST               2 ('a')\n              6 CALL_METHOD              1\n              8 RETURN_VALUE\n</code></pre>\n<p>so we see that the <code>.__contains__</code> method has to be separately looked up and then called from the Python virtual machine - this should adequately explain the difference.</p>\n", "abstract": "99% of use cases will be covered using the keyword, in, which returns True or False: For the use case of getting the index, use str.find (which returns -1 on failure, and has optional positional arguments): or str.index (like find but raises ValueError on failure): Use the in comparison operator because The opposite (complement), which the original question asked for, is not in: This is semantically the same as not 'foo' in '**foo**' but it's much more readable and explicitly provided for in the language as a readability improvement. The \"contains\" method implements the behavior for in. This example, returns True. You could also call this function from the instance of the superstring: But don't. Methods that start with underscores are considered semantically non-public. The only reason to use this is when implementing or extending the in and not in functionality (e.g. if subclassing str): and now: Don't use the following string methods to test for \"contains\": Other languages may have no methods to directly test for substrings, and so you would have to use these types of methods, but with Python, it is much more efficient to use the in comparison operator. Also, these are not drop-in replacements for in. You may have to handle the exception or -1 cases, and if they return 0 (because they found the substring at the beginning) the boolean interpretation is False instead of True. If you really mean not any_string.startswith(substring) then say it. We can compare various ways of accomplishing the same goal. And now we see that using in is much faster than the others.\nLess time to do an equivalent operation is better: This is a fine follow-on question. Let's disassemble functions with the methods of interest: so we see that the .__contains__ method has to be separately looked up and then called from the Python virtual machine - this should adequately explain the difference."}, {"id": 3437130, "score": 192, "vote": 0, "content": "<p><code>if needle in haystack:</code> is the normal use, as @Michael says -- it relies on the <a href=\"https://docs.python.org/reference/expressions.html#membership-test-details\" rel=\"noreferrer\"><code>in</code></a> operator, more readable and faster than a method call.</p>\n<p>If you truly need a method instead of an operator (e.g. to do some weird <code>key=</code> for a very peculiar sort...?), that would be <a href=\"https://docs.python.org/reference/datamodel.html#object.__contains__\" rel=\"noreferrer\"><code>'haystack'.__contains__</code></a>.  But since your example is for use in an <code>if</code>, I guess you don't really mean what you say;-).  It's not good form (nor readable, nor efficient) to use special methods directly -- they're meant to be used, instead, through the operators and builtins that delegate to them.</p>\n", "abstract": "if needle in haystack: is the normal use, as @Michael says -- it relies on the in operator, more readable and faster than a method call. If you truly need a method instead of an operator (e.g. to do some weird key= for a very peculiar sort...?), that would be 'haystack'.__contains__.  But since your example is for use in an if, I guess you don't really mean what you say;-).  It's not good form (nor readable, nor efficient) to use special methods directly -- they're meant to be used, instead, through the operators and builtins that delegate to them."}, {"id": 43687082, "score": 128, "vote": 0, "content": "<h1><code>in</code> Python strings and lists</h1>\n<p>Here are a few useful examples that speak for themselves concerning the <code>in</code> method:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; \"foo\" in \"foobar\"\nTrue\n&gt;&gt;&gt; \"foo\" in \"Foobar\"\nFalse\n&gt;&gt;&gt; \"foo\" in \"Foobar\".lower()\nTrue\n&gt;&gt;&gt; \"foo\".capitalize() in \"Foobar\"\nTrue\n&gt;&gt;&gt; \"foo\" in [\"bar\", \"foo\", \"foobar\"]\nTrue\n&gt;&gt;&gt; \"foo\" in [\"fo\", \"o\", \"foobar\"]\nFalse\n&gt;&gt;&gt; [\"foo\" in a for a in [\"fo\", \"o\", \"foobar\"]]\n[False, False, True]\n</code></pre>\n<p>Caveat. Lists are iterables, and the <code>in</code> method acts on iterables, not just strings.</p>\n<p>If you want to compare strings in a more fuzzy way to measure how \"alike\" they are, consider using the Levenshtein package</p>\n<p><a href=\"https://stackoverflow.com/a/69545740/3730397\">Here's an answer that shows how it works.</a></p>\n", "abstract": "Here are a few useful examples that speak for themselves concerning the in method: Caveat. Lists are iterables, and the in method acts on iterables, not just strings. If you want to compare strings in a more fuzzy way to measure how \"alike\" they are, consider using the Levenshtein package Here's an answer that shows how it works."}, {"id": 49531528, "score": 53, "vote": 0, "content": "<p>If you are happy with <code>\"blah\" in somestring</code> but want it to be a function/method call, you can probably do this</p>\n<pre><code class=\"python\">import operator\n\nif not operator.contains(somestring, \"blah\"):\n    continue\n</code></pre>\n<p>All operators in Python can be more or less found in the <a href=\"https://docs.python.org/3.5/library/operator.html#operator.contains\" rel=\"noreferrer\">operator module</a> including <code>in</code>.</p>\n", "abstract": "If you are happy with \"blah\" in somestring but want it to be a function/method call, you can probably do this All operators in Python can be more or less found in the operator module including in."}, {"id": 31476788, "score": 50, "vote": 0, "content": "<p>So apparently there is nothing similar for vector-wise comparison. An obvious Python way to do so would be:</p>\n<pre><code class=\"python\">names = ['bob', 'john', 'mike']\nany(st in 'bob and john' for st in names) \n&gt;&gt; True\n\nany(st in 'mary and jane' for st in names) \n&gt;&gt; False\n</code></pre>\n", "abstract": "So apparently there is nothing similar for vector-wise comparison. An obvious Python way to do so would be:"}, {"id": 54552127, "score": 32, "vote": 0, "content": "<p>You can use <code>y.count()</code>.</p>\n<p>It will return the integer value of the number of times a sub string appears in a string.</p>\n<p>For example:</p>\n<pre><code class=\"python\">string.count(\"bah\") &gt;&gt; 0\nstring.count(\"Hello\") &gt;&gt; 1\n</code></pre>\n", "abstract": "You can use y.count(). It will return the integer value of the number of times a sub string appears in a string. For example:"}, {"id": 30446999, "score": 26, "vote": 0, "content": "<p>Here is your answer:</p>\n<pre><code class=\"python\">if \"insert_char_or_string_here\" in \"insert_string_to_search_here\":\n    #DOSTUFF\n</code></pre>\n<p>For checking if it is false:</p>\n<pre><code class=\"python\">if not \"insert_char_or_string_here\" in \"insert_string_to_search_here\":\n    #DOSTUFF\n</code></pre>\n<p>OR:</p>\n<pre><code class=\"python\">if \"insert_char_or_string_here\" not in \"insert_string_to_search_here\":\n    #DOSTUFF\n</code></pre>\n", "abstract": "Here is your answer: For checking if it is false: OR:"}, {"id": 53442148, "score": 12, "vote": 0, "content": "<p>You can use regular expressions to get the occurrences:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import re\n&gt;&gt;&gt; print(re.findall(r'( |t)', to_search_in)) # searches for t or space\n['t', ' ', 't', ' ', ' ']\n</code></pre>\n", "abstract": "You can use regular expressions to get the occurrences:"}]}, {"link": "https://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block", "question": {"id": "6470428", "title": "Catch multiple exceptions in one line (except block)", "content": "<p>I know that I can do:</p>\n<pre><code class=\"python\">try:\n    # do something that may fail\nexcept:\n    # do this if ANYTHING goes wrong\n</code></pre>\n<p>I can also do this:</p>\n<pre><code class=\"python\">try:\n    # do something that may fail\nexcept IDontLikeYouException:\n    # say please\nexcept YouAreTooShortException:\n    # stand on a ladder\n</code></pre>\n<p>But if I want to do the same thing inside two different exceptions, the best I can think of right now is to do this:</p>\n<pre><code class=\"python\">try:\n    # do something that may fail\nexcept IDontLikeYouException:\n    # say please\nexcept YouAreBeingMeanException:\n    # say please\n</code></pre>\n<p>Is there any way that I can do something like this (since the action to take in both exceptions is to <code>say please</code>):</p>\n<pre><code class=\"python\">try:\n    # do something that may fail\nexcept IDontLikeYouException, YouAreBeingMeanException:\n    # say please\n</code></pre>\n<p>Now this really won't work, as it matches the syntax for:</p>\n<pre><code class=\"python\">try:\n    # do something that may fail\nexcept Exception, e:\n    # say please\n</code></pre>\n<p>So, my effort to catch the two distinct exceptions doesn't exactly come through.</p>\n<p>Is there a way to do this?</p>\n", "abstract": "I know that I can do: I can also do this: But if I want to do the same thing inside two different exceptions, the best I can think of right now is to do this: Is there any way that I can do something like this (since the action to take in both exceptions is to say please): Now this really won't work, as it matches the syntax for: So, my effort to catch the two distinct exceptions doesn't exactly come through. Is there a way to do this?"}, "answers": [{"id": 6470452, "score": 4783, "vote": 0, "content": "<p>From <a href=\"https://docs.python.org/3/tutorial/errors.html#handling-exceptions\" rel=\"noreferrer\">Python Documentation</a>:</p>\n<blockquote>\n<p>An except clause may name multiple exceptions as a parenthesized tuple, for example</p>\n</blockquote>\n<pre><code class=\"python\">except (IDontLikeYouException, YouAreBeingMeanException) as e:\n    pass\n</code></pre>\n<p>Or, for Python 2 only:</p>\n<pre><code class=\"python\">except (IDontLikeYouException, YouAreBeingMeanException), e:\n    pass\n</code></pre>\n<p>Separating the exception from the variable with a comma will still work in Python 2.6 and 2.7, but is now deprecated and does not work in Python 3; now you should be using <code>as</code>.</p>\n", "abstract": "From Python Documentation: An except clause may name multiple exceptions as a parenthesized tuple, for example Or, for Python 2 only: Separating the exception from the variable with a comma will still work in Python 2.6 and 2.7, but is now deprecated and does not work in Python 3; now you should be using as."}, {"id": 24338247, "score": 470, "vote": 0, "content": "<blockquote>\n<h2>How do I catch multiple exceptions in one line (except block)</h2>\n</blockquote>\n<p>Do this:</p>\n<pre><code class=\"python\">try:\n    may_raise_specific_errors():\nexcept (SpecificErrorOne, SpecificErrorTwo) as error:\n    handle(error) # might log or have some other default behavior...\n</code></pre>\n<p>The parentheses are required due to older syntax that used the commas to assign the error object to a name. The <code>as</code> keyword is used for the assignment. You can use any name for the error object, I prefer <code>error</code> personally.</p>\n<h2>Best Practice</h2>\n<p>To do this in a manner currently and forward compatible with Python, you need to separate the Exceptions with commas and wrap them with parentheses to differentiate from earlier syntax that assigned the exception instance to a variable name by following the Exception type to be caught with a comma. </p>\n<p>Here's an example of simple usage:</p>\n<pre><code class=\"python\">import sys\n\ntry:\n    mainstuff()\nexcept (KeyboardInterrupt, EOFError): # the parens are necessary\n    sys.exit(0)\n</code></pre>\n<p>I'm specifying only these exceptions to avoid hiding bugs, which if I encounter I expect the full stack trace from.</p>\n<p>This is documented here: <a href=\"https://docs.python.org/tutorial/errors.html\" rel=\"noreferrer\">https://docs.python.org/tutorial/errors.html</a></p>\n<p>You can assign the exception to a variable, (<code>e</code> is common, but you might prefer a more verbose variable if you have long exception handling or your IDE only highlights selections larger than that, as mine does.) The instance has an args attribute. Here is an example:</p>\n<pre><code class=\"python\">import sys\n\ntry:\n    mainstuff()\nexcept (KeyboardInterrupt, EOFError) as err: \n    print(err)\n    print(err.args)\n    sys.exit(0)\n</code></pre>\n<p>Note that in Python 3, the <code>err</code> object falls out of scope when the <code>except</code> block is concluded.</p>\n<h2>Deprecated</h2>\n<p>You may see code that assigns the error with a comma. This usage, the only form available in Python 2.5 and earlier, is deprecated, and if you wish your code to be forward compatible in Python 3, you should update the syntax to use the new form:</p>\n<pre><code class=\"python\">import sys\n\ntry:\n    mainstuff()\nexcept (KeyboardInterrupt, EOFError), err: # don't do this in Python 2.6+\n    print err\n    print err.args\n    sys.exit(0)\n</code></pre>\n<p>If you see the comma name assignment in your codebase, and you're using Python 2.5 or higher, switch to the new way of doing it so your code remains compatible when you upgrade.</p>\n<h2>The <code>suppress</code> context manager</h2>\n<p>The accepted answer is really 4 lines of code, minimum:</p>\n<pre><code class=\"python\">try:\n    do_something()\nexcept (IDontLikeYouException, YouAreBeingMeanException) as e:\n    pass\n</code></pre>\n<p>The <code>try</code>, <code>except</code>, <code>pass</code> lines can be handled in a single line with the <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.suppress\" rel=\"noreferrer\">suppress context manager, available in Python 3.4</a>:</p>\n<pre><code class=\"python\">from contextlib import suppress\n\nwith suppress(IDontLikeYouException, YouAreBeingMeanException):\n     do_something()\n</code></pre>\n<p>So when you want to <code>pass</code> on certain exceptions, use <code>suppress</code>.</p>\n", "abstract": "Do this: The parentheses are required due to older syntax that used the commas to assign the error object to a name. The as keyword is used for the assignment. You can use any name for the error object, I prefer error personally. To do this in a manner currently and forward compatible with Python, you need to separate the Exceptions with commas and wrap them with parentheses to differentiate from earlier syntax that assigned the exception instance to a variable name by following the Exception type to be caught with a comma.  Here's an example of simple usage: I'm specifying only these exceptions to avoid hiding bugs, which if I encounter I expect the full stack trace from. This is documented here: https://docs.python.org/tutorial/errors.html You can assign the exception to a variable, (e is common, but you might prefer a more verbose variable if you have long exception handling or your IDE only highlights selections larger than that, as mine does.) The instance has an args attribute. Here is an example: Note that in Python 3, the err object falls out of scope when the except block is concluded. You may see code that assigns the error with a comma. This usage, the only form available in Python 2.5 and earlier, is deprecated, and if you wish your code to be forward compatible in Python 3, you should update the syntax to use the new form: If you see the comma name assignment in your codebase, and you're using Python 2.5 or higher, switch to the new way of doing it so your code remains compatible when you upgrade. The accepted answer is really 4 lines of code, minimum: The try, except, pass lines can be handled in a single line with the suppress context manager, available in Python 3.4: So when you want to pass on certain exceptions, use suppress."}, {"id": 26650022, "score": 65, "vote": 0, "content": "<p>From <a href=\"https://docs.python.org/2/tutorial/errors.html#handling-exceptions\">Python documentation -&gt; 8.3 Handling Exceptions</a>:</p>\n<blockquote>\n<p>A <code>try</code> statement may have more than one except clause, to specify\n  handlers for different exceptions. At most one handler will be\n  executed. Handlers only handle exceptions that occur in the\n  corresponding try clause, not in other handlers of the same try\n  statement. An except clause may name multiple exceptions as a\n  parenthesized tuple, for example:</p>\n<pre><code class=\"python\">except (RuntimeError, TypeError, NameError):\n    pass\n</code></pre>\n<p>Note that the parentheses around this tuple are required, because\n  except <code>ValueError, e:</code> was the syntax used for what is normally\n  written as <code>except ValueError as e:</code> in modern Python (described\n  below). The old syntax is still supported for backwards compatibility.\n  This means <code>except RuntimeError, TypeError</code> is not equivalent to\n  <code>except (RuntimeError, TypeError):</code> but to <code>except RuntimeError as</code>\n<code>TypeError:</code> which is not what you want.</p>\n</blockquote>\n", "abstract": "From Python documentation -> 8.3 Handling Exceptions: A try statement may have more than one except clause, to specify\n  handlers for different exceptions. At most one handler will be\n  executed. Handlers only handle exceptions that occur in the\n  corresponding try clause, not in other handlers of the same try\n  statement. An except clause may name multiple exceptions as a\n  parenthesized tuple, for example: Note that the parentheses around this tuple are required, because\n  except ValueError, e: was the syntax used for what is normally\n  written as except ValueError as e: in modern Python (described\n  below). The old syntax is still supported for backwards compatibility.\n  This means except RuntimeError, TypeError is not equivalent to\n  except (RuntimeError, TypeError): but to except RuntimeError as\nTypeError: which is not what you want."}, {"id": 46270444, "score": 54, "vote": 0, "content": "<p>If you frequently use a large number of exceptions, you can pre-define a tuple, so you don't have to re-type them many times. </p>\n<pre><code class=\"python\">#This example code is a technique I use in a library that connects with websites to gather data\n\nConnectErrs  = (URLError, SSLError, SocketTimeoutError, BadStatusLine, ConnectionResetError)\n\ndef connect(url, data):\n    #do connection and return some data\n    return(received_data)\n\ndef some_function(var_a, var_b, ...):\n    try: o = connect(url, data)\n    except ConnectErrs as e:\n        #do the recovery stuff\n    blah #do normal stuff you would do if no exception occurred\n</code></pre>\n<p><strong>NOTES:</strong> </p>\n<ol>\n<li><p>If you, also, need to catch other exceptions than those in the\npre-defined tuple, you will need to define another except block.  </p></li>\n<li><p>If you just cannot tolerate a global variable, define it in main()\nand pass it around where needed...</p></li>\n</ol>\n", "abstract": "If you frequently use a large number of exceptions, you can pre-define a tuple, so you don't have to re-type them many times.  NOTES:  If you, also, need to catch other exceptions than those in the\npre-defined tuple, you will need to define another except block.   If you just cannot tolerate a global variable, define it in main()\nand pass it around where needed..."}, {"id": 45734488, "score": 29, "vote": 0, "content": "<p>One of the way to do this is..</p>\n<pre><code class=\"python\">try:\n   You do your operations here;\n   ......................\nexcept(Exception1[, Exception2[,...ExceptionN]]]):\n   If there is any exception from the given exception list, \n   then execute this block.\n   ......................\nelse:\n   If there is no exception then execute this block. \n</code></pre>\n<p>and another way is to create method which performs task executed by <code>except</code> block and call it through all of the <code>except</code> block that you write..</p>\n<pre><code class=\"python\">try:\n   You do your operations here;\n   ......................\nexcept Exception1:\n    functionname(parameterList)\nexcept Exception2:\n    functionname(parameterList)\nexcept Exception3:\n    functionname(parameterList)\nelse:\n   If there is no exception then execute this block. \n\ndef functionname( parameters ):\n   //your task..\n   return [expression]\n</code></pre>\n<p>I know that second one is not the best way to do this, but i'm just showing number of ways to do this thing.</p>\n", "abstract": "One of the way to do this is.. and another way is to create method which performs task executed by except block and call it through all of the except block that you write.. I know that second one is not the best way to do this, but i'm just showing number of ways to do this thing."}, {"id": 71713881, "score": 12, "vote": 0, "content": "<p>As of Python 3.11 you can take advantage of the <code>except*</code> clause that is used to handle multiple exceptions.</p>\n<p>PEP-654 introduced a new standard exception type called <code>ExceptionGroup</code> that corresponds to a group of exceptions that are being propagated together. The <code>ExceptionGroup</code> can be handled using a new <code>except*</code> syntax. The <code>*</code> symbol indicates that multiple exceptions can be handled by each <code>except*</code> clause.</p>\n<hr/>\n<p>For example, you can handle multiple exceptions</p>\n<pre><code class=\"python\">try:\n    raise ExceptionGroup('Example ExceptionGroup', (\n        TypeError('Example TypeError'),\n        ValueError('Example ValueError'),\n        KeyError('Example KeyError'),\n        AttributeError('Example AttributeError')\n    ))\nexcept* TypeError:\n    ...\nexcept* ValueError as e:\n    ...\nexcept* (KeyError, AttributeError) as e:\n    ...\n</code></pre>\n<hr/>\n<p>For more details see <a href=\"https://peps.python.org/pep-0654/\" rel=\"noreferrer\">PEP-654</a>.</p>\n", "abstract": "As of Python 3.11 you can take advantage of the except* clause that is used to handle multiple exceptions. PEP-654 introduced a new standard exception type called ExceptionGroup that corresponds to a group of exceptions that are being propagated together. The ExceptionGroup can be handled using a new except* syntax. The * symbol indicates that multiple exceptions can be handled by each except* clause. For example, you can handle multiple exceptions For more details see PEP-654."}]}, {"link": "https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr", "question": {"id": "1436703", "title": "What is the difference between __str__ and __repr__?", "content": "<p>What is the difference between <a href=\"https://docs.python.org/3/reference/datamodel.html#object.__str__\" rel=\"noreferrer\"><code>__str__</code></a> and <a href=\"https://docs.python.org/3/reference/datamodel.html#object.__repr__\" rel=\"noreferrer\"><code>__repr__</code></a> in Python?</p>\n", "abstract": "What is the difference between __str__ and __repr__ in Python?"}, "answers": [{"id": 2626364, "score": 3296, "vote": 0, "content": "<p><a href=\"https://stackoverflow.com/users/95810/alex-martelli\">Alex</a> summarized well but, surprisingly, was too succinct.</p>\n<p>First, let me reiterate the main points in <a href=\"https://stackoverflow.com/a/1436756/3798217\">Alex\u2019s post</a>:</p>\n<ul>\n<li>The default implementation is useless (it\u2019s hard to think of one which wouldn\u2019t be, but yeah)</li>\n<li><code>__repr__</code> goal is to be unambiguous</li>\n<li><code>__str__</code> goal is to be readable</li>\n<li>Container\u2019s <code>__str__</code> uses contained objects\u2019 <code>__repr__</code></li>\n</ul>\n<p><strong>Default implementation is useless</strong></p>\n<p>This is mostly a surprise because Python\u2019s defaults tend to be fairly useful. However, in this case, having a default for <code>__repr__</code> which would act like:</p>\n<pre><code class=\"python\">return \"%s(%r)\" % (self.__class__, self.__dict__)\n</code></pre>\n<p>would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if <code>__repr__</code> is defined, and <code>__str__</code> is not, the object will behave as though <code>__str__=__repr__</code>.</p>\n<p>This means, in simple terms: almost every object you implement should have a functional <code>__repr__</code> that\u2019s usable for understanding the object. Implementing <code>__str__</code> is optional: do that if you need a \u201cpretty print\u201d functionality (for example, used by a report generator).</p>\n<p><strong>The goal of <code>__repr__</code> is to be unambiguous</strong></p>\n<p>Let me come right out and say it \u2014 I do not believe in debuggers. I don\u2019t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature \u2014 most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a</p>\n<pre><code class=\"python\">log(INFO, \"I am in the weird function and a is\", a, \"and b is\", b, \"but I got a null C \u2014 using default\", default_c)\n</code></pre>\n<p>But you have to do the last step \u2014 make sure every object you implement has a useful repr, so code like that can just work. This is why the \u201ceval\u201d thing comes up: if you have enough information so <code>eval(repr(c))==c</code>, that means you know everything there is to know about <code>c</code>. If that\u2019s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about <code>c</code> anyway. I usually use an eval-like format: <code>\"MyClass(this=%r,that=%r)\" % (self.this,self.that)</code>. It does not mean that you can actually construct MyClass, or that those are the right constructor arguments \u2014 but it is a useful form to express \u201cthis is everything you need to know about this instance\u201d.</p>\n<p>Note: I used <code>%r</code> above, not <code>%s</code>. You always want to use <code>repr()</code> [or <code>%r</code> formatting character, equivalently] inside <code>__repr__</code> implementation, or you\u2019re defeating the goal of repr. You want to be able to differentiate <code>MyClass(3)</code> and <code>MyClass(\"3\")</code>.</p>\n<p><strong>The goal of <code>__str__</code> is to be readable</strong></p>\n<p>Specifically, it is not intended to be unambiguous \u2014 notice that <code>str(3)==str(\"3\")</code>. Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date/time abstraction, the str can be \"2010/4/12 15:35:22\", etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class \u2014 as long is it supports readability, it is an improvement.</p>\n<p><strong>Container\u2019s <code>__str__</code> uses contained objects\u2019 <code>__repr__</code></strong></p>\n<p>This seems surprising, doesn\u2019t it? It is a little, but how readable would it be if it used their <code>__str__</code>?</p>\n<pre><code class=\"python\">[moshe is, 3, hello\nworld, this is a list, oh I don't know, containing just 4 elements]\n</code></pre>\n<p>Not very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you\u2019re printing a list, just</p>\n<pre><code class=\"python\">print(\"[\" + \", \".join(l) + \"]\")\n</code></pre>\n<p>(you can probably also figure out what to do about dictionaries.</p>\n<p><strong>Summary</strong></p>\n<p>Implement <code>__repr__</code> for any class you implement. This should be second nature. Implement <code>__str__</code> if you think it would be useful to have a string version which errs on the side of readability.</p>\n", "abstract": "Alex summarized well but, surprisingly, was too succinct. First, let me reiterate the main points in Alex\u2019s post: Default implementation is useless This is mostly a surprise because Python\u2019s defaults tend to be fairly useful. However, in this case, having a default for __repr__ which would act like: would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if __repr__ is defined, and __str__ is not, the object will behave as though __str__=__repr__. This means, in simple terms: almost every object you implement should have a functional __repr__ that\u2019s usable for understanding the object. Implementing __str__ is optional: do that if you need a \u201cpretty print\u201d functionality (for example, used by a report generator). The goal of __repr__ is to be unambiguous Let me come right out and say it \u2014 I do not believe in debuggers. I don\u2019t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature \u2014 most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a But you have to do the last step \u2014 make sure every object you implement has a useful repr, so code like that can just work. This is why the \u201ceval\u201d thing comes up: if you have enough information so eval(repr(c))==c, that means you know everything there is to know about c. If that\u2019s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about c anyway. I usually use an eval-like format: \"MyClass(this=%r,that=%r)\" % (self.this,self.that). It does not mean that you can actually construct MyClass, or that those are the right constructor arguments \u2014 but it is a useful form to express \u201cthis is everything you need to know about this instance\u201d. Note: I used %r above, not %s. You always want to use repr() [or %r formatting character, equivalently] inside __repr__ implementation, or you\u2019re defeating the goal of repr. You want to be able to differentiate MyClass(3) and MyClass(\"3\"). The goal of __str__ is to be readable Specifically, it is not intended to be unambiguous \u2014 notice that str(3)==str(\"3\"). Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date/time abstraction, the str can be \"2010/4/12 15:35:22\", etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class \u2014 as long is it supports readability, it is an improvement. Container\u2019s __str__ uses contained objects\u2019 __repr__ This seems surprising, doesn\u2019t it? It is a little, but how readable would it be if it used their __str__? Not very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you\u2019re printing a list, just (you can probably also figure out what to do about dictionaries. Summary Implement __repr__ for any class you implement. This should be second nature. Implement __str__ if you think it would be useful to have a string version which errs on the side of readability."}, {"id": 1438297, "score": 734, "vote": 0, "content": "<p>My rule of thumb:  <code>__repr__</code> is for developers, <code>__str__</code> is for customers.</p>\n", "abstract": "My rule of thumb:  __repr__ is for developers, __str__ is for customers."}, {"id": 1436756, "score": 488, "vote": 0, "content": "<p>Unless you specifically act to ensure otherwise, most classes don't have helpful results for either:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class Sic(object): pass\n... \n&gt;&gt;&gt; print(str(Sic()))\n&lt;__main__.Sic object at 0x8b7d0&gt;\n&gt;&gt;&gt; print(repr(Sic()))\n&lt;__main__.Sic object at 0x8b7d0&gt;\n&gt;&gt;&gt; \n</code></pre>\n<p>As you see -- no difference, and no info beyond the class and object's <code>id</code>.  If you only override one of the two...:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class Sic(object): \n...   def __repr__(self): return 'foo'\n... \n&gt;&gt;&gt; print(str(Sic()))\nfoo\n&gt;&gt;&gt; print(repr(Sic()))\nfoo\n&gt;&gt;&gt; class Sic(object):\n...   def __str__(self): return 'foo'\n... \n&gt;&gt;&gt; print(str(Sic()))\nfoo\n&gt;&gt;&gt; print(repr(Sic()))\n&lt;__main__.Sic object at 0x2617f0&gt;\n&gt;&gt;&gt; \n</code></pre>\n<p>as you see, if you override <code>__repr__</code>, that's ALSO used for <code>__str__</code>, but not vice versa.</p>\n<p>Other crucial tidbits to know: <code>__str__</code> on a built-on container uses the <code>__repr__</code>, NOT the <code>__str__</code>, for the items it contains. And, despite the words on the subject found in typical docs, hardly anybody bothers making the <code>__repr__</code> of objects be a string that <code>eval</code> may use to build an equal object (it's just too hard, AND not knowing how the relevant module was actually imported makes it actually flat out impossible).</p>\n<p>So, my advice: focus on making <code>__str__</code> reasonably human-readable, and <code>__repr__</code> as unambiguous as you possibly can, even if that interferes with the fuzzy unattainable goal of making <code>__repr__</code>'s returned value acceptable as input to <code>__eval__</code>!</p>\n", "abstract": "Unless you specifically act to ensure otherwise, most classes don't have helpful results for either: As you see -- no difference, and no info beyond the class and object's id.  If you only override one of the two...: as you see, if you override __repr__, that's ALSO used for __str__, but not vice versa. Other crucial tidbits to know: __str__ on a built-on container uses the __repr__, NOT the __str__, for the items it contains. And, despite the words on the subject found in typical docs, hardly anybody bothers making the __repr__ of objects be a string that eval may use to build an equal object (it's just too hard, AND not knowing how the relevant module was actually imported makes it actually flat out impossible). So, my advice: focus on making __str__ reasonably human-readable, and __repr__ as unambiguous as you possibly can, even if that interferes with the fuzzy unattainable goal of making __repr__'s returned value acceptable as input to __eval__!"}, {"id": 1436721, "score": 203, "vote": 0, "content": "<p><strong><code>__repr__</code></strong>: representation of python object usually eval will convert it back to that object</p>\n<p><strong><code>__str__</code></strong>: is whatever you think is that object in text form</p>\n<p>e.g.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; s=\"\"\"w'o\"w\"\"\"\n&gt;&gt;&gt; repr(s)\n'\\'w\\\\\\'o\"w\\''\n&gt;&gt;&gt; str(s)\n'w\\'o\"w'\n&gt;&gt;&gt; eval(str(s))==s\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;string&gt;\", line 1\n    w'o\"w\n       ^\nSyntaxError: EOL while scanning single-quoted string\n&gt;&gt;&gt; eval(repr(s))==s\nTrue\n</code></pre>\n", "abstract": "__repr__: representation of python object usually eval will convert it back to that object __str__: is whatever you think is that object in text form e.g."}, {"id": 19597196, "score": 198, "vote": 0, "content": "<blockquote>\n<p>In short, the goal of <code>__repr__</code> is to be unambiguous and <code>__str__</code> is to be\n  readable.</p>\n</blockquote>\n<p>Here is a good example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; today = datetime.datetime.now()\n&gt;&gt;&gt; str(today)\n'2012-03-14 09:21:58.130922'\n&gt;&gt;&gt; repr(today)\n'datetime.datetime(2012, 3, 14, 9, 21, 58, 130922)'\n</code></pre>\n<p>Read this documentation for repr:</p>\n<blockquote>\n<p><code>repr(object)</code></p>\n<p>Return a string containing a printable representation of an object. This is the same value yielded by conversions (reverse\n  quotes). It is sometimes useful to be able to access this operation as\n  an ordinary function. For many types, this function makes an attempt\n  to return a string that would yield an object with the same value when\n  passed to <code>eval()</code>, otherwise the representation is a string enclosed in\n  angle brackets that contains the name of the type of the object\n  together with additional information often including the name and\n  address of the object. A class can control what this function returns\n  for its instances by defining a <code>__repr__()</code> method.</p>\n</blockquote>\n<p>Here is the documentation for str:</p>\n<blockquote>\n<p><code>str(object='')</code></p>\n<p>Return a string containing a nicely printable\n  representation of an object. For strings, this returns the string\n  itself. The difference with <code>repr(object)</code> is that <code>str(object)</code> does not\n  always attempt to return a string that is acceptable to <code>eval()</code>; its\n  goal is to return a printable string. If no argument is given, returns\n  the empty string, <code>''</code>.</p>\n</blockquote>\n", "abstract": "In short, the goal of __repr__ is to be unambiguous and __str__ is to be\n  readable. Here is a good example: Read this documentation for repr: repr(object) Return a string containing a printable representation of an object. This is the same value yielded by conversions (reverse\n  quotes). It is sometimes useful to be able to access this operation as\n  an ordinary function. For many types, this function makes an attempt\n  to return a string that would yield an object with the same value when\n  passed to eval(), otherwise the representation is a string enclosed in\n  angle brackets that contains the name of the type of the object\n  together with additional information often including the name and\n  address of the object. A class can control what this function returns\n  for its instances by defining a __repr__() method. Here is the documentation for str: str(object='') Return a string containing a nicely printable\n  representation of an object. For strings, this returns the string\n  itself. The difference with repr(object) is that str(object) does not\n  always attempt to return a string that is acceptable to eval(); its\n  goal is to return a printable string. If no argument is given, returns\n  the empty string, ''."}, {"id": 28132458, "score": 162, "vote": 0, "content": "<blockquote>\n<h1>What is the difference between <code>__str__</code> and <code>__repr__</code> in Python?</h1>\n</blockquote>\n<p><code>__str__</code> (read as \"dunder (double-underscore) string\") and <code>__repr__</code> (read as \"dunder-repper\" (for \"representation\")) are both special methods that return strings based on the state of the object.</p>\n<p><code>__repr__</code> provides backup behavior if <code>__str__</code> is missing.</p>\n<p>So one should first write a <code>__repr__</code> that allows you to reinstantiate an equivalent object from the string it returns e.g. using <code>eval</code> or by typing it in character-for-character in a Python shell.</p>\n<p>At any time later, one can write a <code>__str__</code> for a user-readable string representation of the instance, when one believes it to be necessary.</p>\n<h1><code>__str__</code></h1>\n<p>If you print an object, or pass it to <code>format</code>, <code>str.format</code>, or <code>str</code>, then if a <code>__str__</code> method is defined, that method will be called, otherwise, <code>__repr__</code> will be used.</p>\n<h1><code>__repr__</code></h1>\n<p>The <code>__repr__</code> method is called by the builtin function <code>repr</code> and is what is echoed on your python shell when it evaluates an expression that returns an object.</p>\n<p>Since it provides a backup for <code>__str__</code>, if you can only write one, start with <code>__repr__</code></p>\n<p>Here's the builtin help on <code>repr</code>:</p>\n<pre><code class=\"python\">repr(...)\n    repr(object) -&gt; string\n    \n    Return the canonical string representation of the object.\n    For most object types, eval(repr(object)) == object.\n</code></pre>\n<p>That is, for most objects, if you type in what is printed by <code>repr</code>, you should be able to create an equivalent object. <em>But this is not the default implementation.</em></p>\n<h1>Default Implementation of <code>__repr__</code></h1>\n<p>The default object <code>__repr__</code> is (<a href=\"https://github.com/python/cpython/blob/v3.7.3/Objects/object.c#L496\" rel=\"noreferrer\">C Python source</a>) something like:</p>\n<pre><code class=\"python\">def __repr__(self):\n    return '&lt;{0}.{1} object at {2}&gt;'.format(\n      type(self).__module__, type(self).__qualname__, hex(id(self)))\n</code></pre>\n<p>That means by default you'll print the module the object is from, the class name, and the hexadecimal representation of its location in memory - for example:</p>\n<pre><code class=\"python\">&lt;__main__.Foo object at 0x7f80665abdd0&gt;\n</code></pre>\n<p>This information isn't very useful, but there's no way to derive how one might accurately create a canonical representation of any given instance, and it's better than nothing, at least telling us how we might uniquely identify it in memory.</p>\n<h1>How can <code>__repr__</code> be useful?</h1>\n<p>Let's look at how useful it can be, using the Python shell and <code>datetime</code> objects. First we need to import the <code>datetime</code> module:</p>\n<pre><code class=\"python\">import datetime\n</code></pre>\n<p>If we call <code>datetime.now</code> in the shell, we'll see everything we need to recreate an equivalent datetime object. This is created by the datetime <code>__repr__</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; datetime.datetime.now()\ndatetime.datetime(2015, 1, 24, 20, 5, 36, 491180)\n</code></pre>\n<p>If we print a datetime object, we see a nice human readable (in fact, ISO) format. This is implemented by datetime's <code>__str__</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; print(datetime.datetime.now())\n2015-01-24 20:05:44.977951\n</code></pre>\n<p>It is a simple matter to recreate the object we lost because we didn't assign it to a variable by copying and pasting from the <code>__repr__</code> output, and then printing it, and we get it in the same human readable output as the other object:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; the_past = datetime.datetime(2015, 1, 24, 20, 5, 36, 491180)\n&gt;&gt;&gt; print(the_past)\n2015-01-24 20:05:36.491180\n</code></pre>\n<p>#How do I implement them?</p>\n<p>As you're developing, you'll want to be able to reproduce objects in the same state, if possible. This, for example, is how the datetime object defines <code>__repr__</code> (<a href=\"https://github.com/python/cpython/blob/v3.7.3/Lib/datetime.py#L1876\" rel=\"noreferrer\">Python source</a>). It is fairly complex, because of all of the attributes needed to reproduce such an object:</p>\n<pre><code class=\"python\">def __repr__(self):\n    \"\"\"Convert to formal string, for repr().\"\"\"\n    L = [self._year, self._month, self._day,  # These are never zero\n         self._hour, self._minute, self._second, self._microsecond]\n    if L[-1] == 0:\n        del L[-1]\n    if L[-1] == 0:\n        del L[-1]\n    s = \"%s.%s(%s)\" % (self.__class__.__module__,\n                       self.__class__.__qualname__,\n                       \", \".join(map(str, L)))\n    if self._tzinfo is not None:\n        assert s[-1:] == \")\"\n        s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n    if self._fold:\n        assert s[-1:] == \")\"\n        s = s[:-1] + \", fold=1)\"\n    return s\n</code></pre>\n<p>If you want your object to have a more human readable representation, you can implement <code>__str__</code> next. Here's how the datetime object (<a href=\"https://github.com/python/cpython/blob/v3.7.3/Lib/datetime.py#L1895\" rel=\"noreferrer\">Python source</a>) implements <code>__str__</code>, which it easily does because it already has a function to display it in ISO format:</p>\n<pre><code class=\"python\">def __str__(self):\n    \"Convert to string, for str().\"\n    return self.isoformat(sep=' ')\n</code></pre>\n<h2>Set <code>__repr__ = __str__</code>?</h2>\n<p>This is a critique of another answer here that suggests setting <code>__repr__ = __str__</code>.</p>\n<p>Setting <code>__repr__ = __str__</code> is silly - <code>__repr__</code> is a fallback for <code>__str__</code> and a <code>__repr__</code>, written for developers usage in debugging, should be written before you write a <code>__str__</code>.</p>\n<p>You need a <code>__str__</code> only when you need a textual representation of the object.</p>\n<h1>Conclusion</h1>\n<p>Define <code>__repr__</code> for objects you write so you and other developers have a reproducible example when using it as you develop. Define <code>__str__</code> when you need a human readable string representation of it.</p>\n", "abstract": "__str__ (read as \"dunder (double-underscore) string\") and __repr__ (read as \"dunder-repper\" (for \"representation\")) are both special methods that return strings based on the state of the object. __repr__ provides backup behavior if __str__ is missing. So one should first write a __repr__ that allows you to reinstantiate an equivalent object from the string it returns e.g. using eval or by typing it in character-for-character in a Python shell. At any time later, one can write a __str__ for a user-readable string representation of the instance, when one believes it to be necessary. If you print an object, or pass it to format, str.format, or str, then if a __str__ method is defined, that method will be called, otherwise, __repr__ will be used. The __repr__ method is called by the builtin function repr and is what is echoed on your python shell when it evaluates an expression that returns an object. Since it provides a backup for __str__, if you can only write one, start with __repr__ Here's the builtin help on repr: That is, for most objects, if you type in what is printed by repr, you should be able to create an equivalent object. But this is not the default implementation. The default object __repr__ is (C Python source) something like: That means by default you'll print the module the object is from, the class name, and the hexadecimal representation of its location in memory - for example: This information isn't very useful, but there's no way to derive how one might accurately create a canonical representation of any given instance, and it's better than nothing, at least telling us how we might uniquely identify it in memory. Let's look at how useful it can be, using the Python shell and datetime objects. First we need to import the datetime module: If we call datetime.now in the shell, we'll see everything we need to recreate an equivalent datetime object. This is created by the datetime __repr__: If we print a datetime object, we see a nice human readable (in fact, ISO) format. This is implemented by datetime's __str__: It is a simple matter to recreate the object we lost because we didn't assign it to a variable by copying and pasting from the __repr__ output, and then printing it, and we get it in the same human readable output as the other object: #How do I implement them? As you're developing, you'll want to be able to reproduce objects in the same state, if possible. This, for example, is how the datetime object defines __repr__ (Python source). It is fairly complex, because of all of the attributes needed to reproduce such an object: If you want your object to have a more human readable representation, you can implement __str__ next. Here's how the datetime object (Python source) implements __str__, which it easily does because it already has a function to display it in ISO format: This is a critique of another answer here that suggests setting __repr__ = __str__. Setting __repr__ = __str__ is silly - __repr__ is a fallback for __str__ and a __repr__, written for developers usage in debugging, should be written before you write a __str__. You need a __str__ only when you need a textual representation of the object. Define __repr__ for objects you write so you and other developers have a reproducible example when using it as you develop. Define __str__ when you need a human readable string representation of it."}, {"id": 44099267, "score": 47, "vote": 0, "content": "<p>On page 358 of the book <strong><em>Python scripting for computational science</em></strong> by Hans Petter Langtangen, it clearly states that </p>\n<ul>\n<li>The <code>__repr__</code> aims at a complete string representation of the object;</li>\n<li>The <code>__str__</code> is to return a nice string for printing.</li>\n</ul>\n<p>So, I prefer to understand them as</p>\n<ul>\n<li><strong>repr = reproduce</strong></li>\n<li><strong>str = string (representation)</strong></li>\n</ul>\n<p>from the user's point of view\nalthough this is a misunderstanding I made when learning python.</p>\n<p>A small but good example is also given on the same page as follows:</p>\n<h2>Example</h2>\n<pre><code class=\"python\">In [38]: str('s')\nOut[38]: 's'\n\nIn [39]: repr('s')\nOut[39]: \"'s'\"\n\nIn [40]: eval(str('s'))\nTraceback (most recent call last):\n\n  File \"&lt;ipython-input-40-abd46c0c43e7&gt;\", line 1, in &lt;module&gt;\n    eval(str('s'))\n\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\n\nNameError: name 's' is not defined\n\n\nIn [41]: eval(repr('s'))\nOut[41]: 's'\n</code></pre>\n", "abstract": "On page 358 of the book Python scripting for computational science by Hans Petter Langtangen, it clearly states that  So, I prefer to understand them as from the user's point of view\nalthough this is a misunderstanding I made when learning python. A small but good example is also given on the same page as follows:"}, {"id": 39382137, "score": 46, "vote": 0, "content": "<p>Apart from all the answers given, I would like to add few points :-</p>\n<p>1) <code>__repr__()</code> is invoked when you simply write object's name on interactive python console and press enter.</p>\n<p>2) <code>__str__()</code> is invoked when you use object with print statement.</p>\n<p>3) In case, if <code>__str__</code> is missing, then print and any function using <code>str()</code> invokes <code>__repr__()</code> of object.</p>\n<p>4) <code>__str__()</code> of containers, when invoked will execute <code>__repr__()</code> method of its contained elements.</p>\n<p>5) <code>str()</code> called within <code>__str__()</code> could potentially recurse without a base case, and error on maximum recursion depth.</p>\n<p>6) <code>__repr__()</code> can call <code>repr()</code> which will attempt to avoid infinite recursion automatically, replacing an already represented object with <code>...</code>.</p>\n", "abstract": "Apart from all the answers given, I would like to add few points :- 1) __repr__() is invoked when you simply write object's name on interactive python console and press enter. 2) __str__() is invoked when you use object with print statement. 3) In case, if __str__ is missing, then print and any function using str() invokes __repr__() of object. 4) __str__() of containers, when invoked will execute __repr__() method of its contained elements. 5) str() called within __str__() could potentially recurse without a base case, and error on maximum recursion depth. 6) __repr__() can call repr() which will attempt to avoid infinite recursion automatically, replacing an already represented object with ...."}, {"id": 63464185, "score": 36, "vote": 0, "content": "<p><strong>(2020 entry)</strong></p>\n<p><strong>Q:</strong> What's the difference between <code>__str__()</code> and <code>__repr__()</code>?</p>\n<p><strong>TL;DR:</strong>\n<a href=\"https://i.stack.imgur.com/cpqeK.png\" rel=\"noreferrer\"><img alt=\"Differences between str()/repr() and __str__()/__repr__()\" src=\"https://i.stack.imgur.com/cpqeK.png\"/></a></p>\n<p><strong>LONG</strong></p>\n<p>This question has been around a long time, and there are a variety of answers of which most are correct (not to mention from several Python community legends[!]). However when it comes down to the nitty-gritty, this question is analogous to asking the difference between the <code>str()</code> and <code>repr()</code> built-in functions. I'm going to describe the differences in my own words (which means I may be \"borrowing\" liberally from <a href=\"https://rads.stackoverflow.com/amzn/click/com/0132269937\" rel=\"nofollow noreferrer\"><em>Core Python Programming</em></a> so pls forgive me).</p>\n<p><strong>Both</strong> <code>str()</code> and <code>repr()</code> have the same basic job: their goal is to return a string representation of a Python object. What <em>kind</em> of string representation is what differentiates them.</p>\n<ul>\n<li><code>str()</code> &amp; <code>__str__()</code> return a <em>printable</em> string representation of\nan object... something human-readable/for human consumption</li>\n<li><code>repr()</code> &amp; <code>__repr__()</code> return a string representation of an object that is a <em>valid Python expression</em>, an object you can pass to <code>eval()</code> or type into the Python shell without getting an error.</li>\n</ul>\n<p>For example, let's assign a string to <code>x</code> and an <code>int</code> to <code>y</code>, and simply showing human-readable string versions of each:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x, y = 'foo', 123\n&gt;&gt;&gt; str(x), str(y)\n('foo', '123')\n</code></pre>\n<p>Can we take <strong>what is inside the quotes</strong> in both cases and enter them verbatim into the Python interpreter? Let's give it a try:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 123\n123\n&gt;&gt;&gt; foo\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'foo' is not defined\n</code></pre>\n<p>Clearly you can for an <code>int</code> but not necessarily for a <code>str</code>. Similarly, while I can pass <code>'123'</code> to <code>eval()</code>, that doesn't work for <code>'foo'</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; eval('123')\n123\n&gt;&gt;&gt; eval('foo')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\nNameError: name 'foo' is not defined\n</code></pre>\n<p>So this tells you the Python shell just <code>eval()</code>s what you give it. Got it? Now, let's <code>repr()</code> both expressions and see what we get. More specifically, take its output and dump <em>those</em> out in the interpreter (there's a point to this which we'll address afterwards):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; repr(x), repr(y)\n(\"'foo'\", '123')\n&gt;&gt;&gt; 123\n123\n&gt;&gt;&gt; 'foo'\n'foo'\n</code></pre>\n<p>Wow, they <em>both</em> work? That's because <code>'foo'</code>, while a printable string representation of that string, it's <strong>not</strong> evaluatable, but <code>\"'foo'\"</code> is. <code>123</code> is a valid Python <code>int</code> called by either <code>str()</code> or <code>repr()</code>. What happens when we call <code>eval()</code> with these?</p>\n<pre><code class=\"python\">&gt;&gt;&gt; eval('123')\n123\n&gt;&gt;&gt; eval(\"'foo'\")\n'foo'\n</code></pre>\n<p>It works because <code>123</code> and <code>'foo'</code> are valid Python objects. Another key takeaway is that while sometimes both return the same thing (the same string representation), that's not always the case. (And yes, yes, I can go create a variable <code>foo</code> where the <code>eval()</code> works, but that's not the point.)</p>\n<p><strong>More factoids about both pairs</strong></p>\n<ol>\n<li>Sometimes, <code>str()</code> and <code>repr()</code> are called <em>implicitly</em>, meaning they're called on behalf of users: when users execute <strong><code>print</code></strong> (Py1/Py2) or call <code>print()</code> (Py3+), even if users don't call <code>str()</code> explicitly, such a call is made on their behalf before the object is displayed.</li>\n<li>In the Python shell (interactive interpreter), if you enter a variable at the <code>&gt;&gt;&gt;</code> prompt and press RETURN, the interpreter displays the results of <code>repr()</code> implicitly called on that object.</li>\n<li>To connect <code>str()</code> and <code>repr()</code> to <code>__str__()</code> and <code>__repr__()</code>, realize that calls to the built-in functions, i.e., <code>str(x)</code> or <code>repr(y)</code> result in calling their object's corresponding special methods: <code>x.__str__()</code> or <code>y.__repr()__</code></li>\n<li>By implementing <code>__str__()</code> and <code>__repr__()</code> for <em>your</em> Python classes, you overload the built-in functions (<code>str()</code> and <code>repr()</code>), allowing instances of your classes to be passed in to <code>str()</code> and <code>repr()</code>. When such calls are made, they turn around and call the class' <code>__str__()</code> and <code>__repr__()</code> (per #3).</li>\n</ol>\n", "abstract": "(2020 entry) Q: What's the difference between __str__() and __repr__()? TL;DR:\n LONG This question has been around a long time, and there are a variety of answers of which most are correct (not to mention from several Python community legends[!]). However when it comes down to the nitty-gritty, this question is analogous to asking the difference between the str() and repr() built-in functions. I'm going to describe the differences in my own words (which means I may be \"borrowing\" liberally from Core Python Programming so pls forgive me). Both str() and repr() have the same basic job: their goal is to return a string representation of a Python object. What kind of string representation is what differentiates them. For example, let's assign a string to x and an int to y, and simply showing human-readable string versions of each: Can we take what is inside the quotes in both cases and enter them verbatim into the Python interpreter? Let's give it a try: Clearly you can for an int but not necessarily for a str. Similarly, while I can pass '123' to eval(), that doesn't work for 'foo': So this tells you the Python shell just eval()s what you give it. Got it? Now, let's repr() both expressions and see what we get. More specifically, take its output and dump those out in the interpreter (there's a point to this which we'll address afterwards): Wow, they both work? That's because 'foo', while a printable string representation of that string, it's not evaluatable, but \"'foo'\" is. 123 is a valid Python int called by either str() or repr(). What happens when we call eval() with these? It works because 123 and 'foo' are valid Python objects. Another key takeaway is that while sometimes both return the same thing (the same string representation), that's not always the case. (And yes, yes, I can go create a variable foo where the eval() works, but that's not the point.) More factoids about both pairs"}, {"id": 34734815, "score": 15, "vote": 0, "content": "<p>To put it simply:</p>\n<p><code>__str__</code> is used in to show a string representation of your object <strong>to be read easily</strong> by others.</p>\n<p><code>__repr__</code> is used to show a string representation of <strong>the</strong> object.</p>\n<p>Let's say I want to create a <code>Fraction</code> class where the string representation of a fraction is '(1/2)' and the object (Fraction class) is to be represented as 'Fraction (1,2)'</p>\n<p>So we can create a simple Fraction class:</p>\n<pre><code class=\"python\">class Fraction:\n    def __init__(self, num, den):\n        self.__num = num\n        self.__den = den\n\n    def __str__(self):\n        return '(' + str(self.__num) + '/' + str(self.__den) + ')'\n\n    def __repr__(self):\n        return 'Fraction (' + str(self.__num) + ',' + str(self.__den) + ')'\n\n\n\nf = Fraction(1,2)\nprint('I want to represent the Fraction STRING as ' + str(f)) # (1/2)\nprint('I want to represent the Fraction OBJECT as ', repr(f)) # Fraction (1,2)\n</code></pre>\n", "abstract": "To put it simply: __str__ is used in to show a string representation of your object to be read easily by others. __repr__ is used to show a string representation of the object. Let's say I want to create a Fraction class where the string representation of a fraction is '(1/2)' and the object (Fraction class) is to be represented as 'Fraction (1,2)' So we can create a simple Fraction class:"}, {"id": 1436706, "score": 14, "vote": 0, "content": "<p>From <a href=\"https://web.archive.org/web/20071127054034/http://pyref.infogami.com/__str__\" rel=\"nofollow noreferrer\">an (An Unofficial) Python Reference Wiki (archive copy)</a> by effbot:</p>\n<p><code>__str__</code> \"<em>computes the \"informal\" string representation of an object. This differs from <code>__repr__</code> in that it does not have to be a valid Python expression: a more convenient or concise representation may be used instead.</em>\"</p>\n", "abstract": "From an (An Unofficial) Python Reference Wiki (archive copy) by effbot: __str__ \"computes the \"informal\" string representation of an object. This differs from __repr__ in that it does not have to be a valid Python expression: a more convenient or concise representation may be used instead.\""}, {"id": 13395755, "score": 13, "vote": 0, "content": "<p>In all honesty, <code>eval(repr(obj))</code> is never used. If you find yourself using it, you should stop, because <code>eval</code> is dangerous, and strings are a very inefficient way to serialize your objects (use <code>pickle</code> instead).</p>\n<p>Therefore, I would recommend setting <code>__repr__ = __str__</code>. The reason is that <code>str(list)</code> calls <code>repr</code> on the elements (I consider this to be one of the biggest design flaws of Python that was not addressed by Python 3). An actual <code>repr</code> will probably not be very helpful as the output of <code>print([your, objects])</code>.</p>\n<p>To qualify this, in my experience, the most useful use case of the <code>repr</code> function is to put a string inside another string (using string formatting). This way, you don't have to worry about escaping quotes or anything. But note that there is no <code>eval</code> happening here.</p>\n", "abstract": "In all honesty, eval(repr(obj)) is never used. If you find yourself using it, you should stop, because eval is dangerous, and strings are a very inefficient way to serialize your objects (use pickle instead). Therefore, I would recommend setting __repr__ = __str__. The reason is that str(list) calls repr on the elements (I consider this to be one of the biggest design flaws of Python that was not addressed by Python 3). An actual repr will probably not be very helpful as the output of print([your, objects]). To qualify this, in my experience, the most useful use case of the repr function is to put a string inside another string (using string formatting). This way, you don't have to worry about escaping quotes or anything. But note that there is no eval happening here."}, {"id": 40960730, "score": 11, "vote": 0, "content": "<p><code>str</code> - Creates a new string object from the given object.</p>\n<p><code>repr</code> - Returns the canonical string representation of the object.</p>\n<p>The differences:</p>\n<p><strong>str():</strong></p>\n<ul>\n<li>makes object readable</li>\n<li>generates output for end-user</li>\n</ul>\n<p><strong>repr():</strong></p>\n<ul>\n<li>needs code that reproduces object</li>\n<li>generates output for developer</li>\n</ul>\n", "abstract": "str - Creates a new string object from the given object. repr - Returns the canonical string representation of the object. The differences: str(): repr():"}, {"id": 43207419, "score": 8, "vote": 0, "content": "<p>From the book <em>Fluent Python</em>:</p>\n<blockquote>\n<p>A basic requirement for a Python object is to provide usable \n       string   representations of itself, one used for debugging and\n       logging, another for presentation to end users. That is why the<br/>\n       special methods <code>__repr__</code> and <code>__str__</code> exist in the data model.</p>\n</blockquote>\n", "abstract": "From the book Fluent Python: A basic requirement for a Python object is to provide usable \n       string   representations of itself, one used for debugging and\n       logging, another for presentation to end users. That is why the\n       special methods __repr__ and __str__ exist in the data model."}, {"id": 44201752, "score": 8, "vote": 0, "content": "<p>One aspect that is missing in other answers. It's true that in general the pattern is:</p>\n<ul>\n<li>Goal of <code>__str__</code>: human-readable</li>\n<li>Goal of <code>__repr__</code>: unambiguous, possibly machine-readable via <code>eval</code></li>\n</ul>\n<p>Unfortunately, this differentiation is flawed, because the Python REPL and also IPython use <code>__repr__</code> for printing objects in a REPL console (see related questions for <a href=\"https://stackoverflow.com/questions/28304092/when-i-am-in-the-python-or-ipython-console-what-is-called-when-i-am-returned-an\">Python</a> and <a href=\"https://stackoverflow.com/questions/41453624/tell-ipython-to-use-an-objects-str-instead-of-repr-for-output\">IPython</a>). Thus, projects which are targeted for interactive console work (e.g., Numpy or Pandas) have started to ignore above rules and provide a human-readable <code>__repr__</code> implementation instead.</p>\n", "abstract": "One aspect that is missing in other answers. It's true that in general the pattern is: Unfortunately, this differentiation is flawed, because the Python REPL and also IPython use __repr__ for printing objects in a REPL console (see related questions for Python and IPython). Thus, projects which are targeted for interactive console work (e.g., Numpy or Pandas) have started to ignore above rules and provide a human-readable __repr__ implementation instead."}, {"id": 68665826, "score": 7, "vote": 0, "content": "<p>You can get some insight from this code:</p>\n<pre><code class=\"python\">class Foo():\n    def __repr__(self):\n        return(\"repr\")\n    def __str__(self):\n        return(\"str\")\n\nfoo = Foo()\nfoo #repr\nprint(foo) #str\n</code></pre>\n", "abstract": "You can get some insight from this code:"}, {"id": 56481986, "score": 6, "vote": 0, "content": "<p><code>__str__</code> can be invoked on an object by calling <code>str(obj)</code> and should return a human readable string. </p>\n<p><code>__repr__</code> can be invoked on an object by calling <code>repr(obj)</code> and should return internal object (object fields/attributes)</p>\n<p>This example may help:</p>\n<pre><code class=\"python\">class C1:pass\n\nclass C2:        \n    def __str__(self):\n        return str(f\"{self.__class__.__name__} class str \")\n\nclass C3:        \n    def __repr__(self):        \n         return str(f\"{self.__class__.__name__} class repr\")\n\nclass C4:        \n    def __str__(self):\n        return str(f\"{self.__class__.__name__} class str \")\n    def __repr__(self):        \n         return str(f\"{self.__class__.__name__} class repr\")\n\n\nci1 = C1()    \nci2 = C2()  \nci3 = C3()  \nci4 = C4()\n\nprint(ci1)       #&lt;__main__.C1 object at 0x0000024C44A80C18&gt;\nprint(str(ci1))  #&lt;__main__.C1 object at 0x0000024C44A80C18&gt;\nprint(repr(ci1)) #&lt;__main__.C1 object at 0x0000024C44A80C18&gt;\nprint(ci2)       #C2 class str\nprint(str(ci2))  #C2 class str\nprint(repr(ci2)) #&lt;__main__.C2 object at 0x0000024C44AE12E8&gt;\nprint(ci3)       #C3 class repr\nprint(str(ci3))  #C3 class repr\nprint(repr(ci3)) #C3 class repr\nprint(ci4)       #C4 class str \nprint(str(ci4))  #C4 class str \nprint(repr(ci4)) #C4 class repr\n</code></pre>\n", "abstract": "__str__ can be invoked on an object by calling str(obj) and should return a human readable string.  __repr__ can be invoked on an object by calling repr(obj) and should return internal object (object fields/attributes) This example may help:"}, {"id": 31427937, "score": 5, "vote": 0, "content": "<pre><code class=\"python\">&gt;&gt;&gt; print(decimal.Decimal(23) / decimal.Decimal(\"1.05\"))\n21.90476190476190476190476190\n&gt;&gt;&gt; decimal.Decimal(23) / decimal.Decimal(\"1.05\")\nDecimal('21.90476190476190476190476190')\n</code></pre>\n<p>When <code>print()</code> is called on the result of <code>decimal.Decimal(23) / decimal.Decimal(\"1.05\")</code> the raw number is printed; this output is in <strong>string form</strong> which can be achieved with <code>__str__()</code>. If we simply enter the expression we get a <code>decimal.Decimal</code> output \u2014 this output is in <strong>representational form</strong> which can be achieved with <code>__repr__()</code>. All Python objects have two output forms. String form is designed to be human-readable. The representational form is designed to produce output that if fed to a Python interpreter would (when possible) reproduce the represented object.</p>\n", "abstract": "When print() is called on the result of decimal.Decimal(23) / decimal.Decimal(\"1.05\") the raw number is printed; this output is in string form which can be achieved with __str__(). If we simply enter the expression we get a decimal.Decimal output \u2014 this output is in representational form which can be achieved with __repr__(). All Python objects have two output forms. String form is designed to be human-readable. The representational form is designed to produce output that if fed to a Python interpreter would (when possible) reproduce the represented object."}, {"id": 33421226, "score": 5, "vote": 0, "content": "<p>Excellent answers already cover the difference between <code>__str__</code> and <code>__repr__</code>, which for me boils down to the former being readable even by an end user, and the latter being as useful as possible to developers. Given that, I find that the default implementation of <code>__repr__</code> often fails to achieve this goal because it <em>omits</em> information useful to developers.</p>\n<p>For this reason, if I have a simple enough <code>__str__</code>, I generally just try to get the best of both worlds with something like:</p>\n<pre><code class=\"python\">def __repr__(self):\n    return '{0} ({1})'.format(object.__repr__(self), str(self))\n</code></pre>\n", "abstract": "Excellent answers already cover the difference between __str__ and __repr__, which for me boils down to the former being readable even by an end user, and the latter being as useful as possible to developers. Given that, I find that the default implementation of __repr__ often fails to achieve this goal because it omits information useful to developers. For this reason, if I have a simple enough __str__, I generally just try to get the best of both worlds with something like:"}, {"id": 33727876, "score": 4, "vote": 0, "content": "<blockquote>\n<p>One important thing to keep in mind is that container's <code>__str__</code> uses contained objects' <code>__repr__</code>.</p>\n</blockquote>\n<pre><code class=\"python\">&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; print (Decimal('52'), datetime.now())\n(Decimal('52'), datetime.datetime(2015, 11, 16, 10, 51, 26, 185000))\n&gt;&gt;&gt; str((Decimal('52'), datetime.now()))\n\"(Decimal('52'), datetime.datetime(2015, 11, 16, 10, 52, 22, 176000))\"\n</code></pre>\n<p><em>Python favors unambiguity over readability</em>, the <code>__str__</code> call of a <code>tuple</code> calls the contained objects' <code>__repr__</code>, the <em>\"formal\"</em> representation of an object. Although the formal representation is harder to read than an informal one, it is unambiguous and more robust against bugs.</p>\n", "abstract": "One important thing to keep in mind is that container's __str__ uses contained objects' __repr__. Python favors unambiguity over readability, the __str__ call of a tuple calls the contained objects' __repr__, the \"formal\" representation of an object. Although the formal representation is harder to read than an informal one, it is unambiguous and more robust against bugs."}, {"id": 49447574, "score": 4, "vote": 0, "content": "<p>In a nutshell:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class Demo:\n  def __repr__(self):\n    return 'repr'\n  def __str__(self):\n    return 'str'\n\ndemo = Demo()\nprint(demo) # use __str__, output 'str' to stdout\n\ns = str(demo) # __str__ is used, return 'str'\nr = repr(demo) # __repr__ is used, return 'repr'\n\nimport logging\nlogger = logging.getLogger(logging.INFO)\nlogger.info(demo) # use __str__, output 'str' to stdout\n\nfrom pprint import pprint, pformat\npprint(demo) # use __repr__, output 'repr' to stdout\nresult = pformat(demo) # use __repr__, result is string which value is 'str'\n</code></pre>\n", "abstract": "In a nutshell:"}, {"id": 47690304, "score": 3, "vote": 0, "content": "<p>Understand <code>__str__</code> and <code>__repr__</code> intuitively and permanently distinguish them at all.</p>\n<p><code>__str__</code> return the string disguised body of a given object for readable of eyes<br/>\n<code>__repr__</code> return the real flesh body of a given object (return itself) for unambiguity to identify.</p>\n<p>See it in an example</p>\n<pre><code class=\"python\">In [30]: str(datetime.datetime.now())\nOut[30]: '2017-12-07 15:41:14.002752'\nDisguised in string form\n</code></pre>\n<p>As to <code>__repr__</code></p>\n<pre><code class=\"python\">In [32]: datetime.datetime.now()\nOut[32]: datetime.datetime(2017, 12, 7, 15, 43, 27, 297769)\nPresence in real body which allows to be manipulated directly.\n</code></pre>\n<p>We can do arithmetic operation on <code>__repr__</code> results conveniently.</p>\n<pre><code class=\"python\">In [33]: datetime.datetime.now()\nOut[33]: datetime.datetime(2017, 12, 7, 15, 47, 9, 741521)\nIn [34]: datetime.datetime(2017, 12, 7, 15, 47, 9, 741521) - datetime.datetime(2\n    ...: 017, 12, 7, 15, 43, 27, 297769)\nOut[34]: datetime.timedelta(0, 222, 443752)\n</code></pre>\n<p>if apply the operation on <code>__str__</code></p>\n<pre><code class=\"python\">In [35]: '2017-12-07 15:43:14.002752' - '2017-12-07 15:41:14.002752'\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n</code></pre>\n<p>Returns nothing but error.</p>\n<p>Another example.</p>\n<pre><code class=\"python\">In [36]: str('string_body')\nOut[36]: 'string_body' # in string form\n\nIn [37]: repr('real_body')\nOut[37]: \"'real_body'\" #its real body hide inside\n</code></pre>\n<p>Hope this help you build concrete grounds to explore more answers.</p>\n", "abstract": "Understand __str__ and __repr__ intuitively and permanently distinguish them at all. __str__ return the string disguised body of a given object for readable of eyes\n__repr__ return the real flesh body of a given object (return itself) for unambiguity to identify. See it in an example As to __repr__ We can do arithmetic operation on __repr__ results conveniently. if apply the operation on __str__ Returns nothing but error. Another example. Hope this help you build concrete grounds to explore more answers."}, {"id": 55744921, "score": 3, "vote": 0, "content": "<ol>\n<li><code>__str__</code> must return string object whereas <code>__repr__</code> can return any python expression.</li>\n<li>If <code>__str__</code> implementation is missing then <code>__repr__</code> function is used as fallback. There is no fallback if <code>__repr__</code> function implementation is missing.</li>\n<li>If <code>__repr__</code> function is returning String representation of the object, we can skip implementation of <code>__str__</code> function.</li>\n</ol>\n<p>Source: <a href=\"https://www.journaldev.com/22460/python-str-repr-functions\" rel=\"nofollow noreferrer\">https://www.journaldev.com/22460/python-str-repr-functions</a></p>\n", "abstract": "Source: https://www.journaldev.com/22460/python-str-repr-functions"}, {"id": 50229578, "score": 2, "vote": 0, "content": "<p><code>__repr__</code> is used everywhere, except by <code>print</code> and <code>str</code> methods (when a <code>__str__</code>is defined !)</p>\n", "abstract": "__repr__ is used everywhere, except by print and str methods (when a __str__is defined !)"}, {"id": 65164408, "score": 1, "vote": 0, "content": "<p>Every object inherits <code>__repr__</code>  from the base class that all objects created.</p>\n<pre><code class=\"python\">class Person:\n     pass\n\np=Person()\n</code></pre>\n<p>if you call <code>repr(p)</code> you will get this as default:</p>\n<pre><code class=\"python\"> &lt;__main__.Person object at 0x7fb2604f03a0&gt;\n</code></pre>\n<p>But if you call <code>str(p)</code> you will get the same output. it is because when <code>__str__</code> does not exist, Python calls <code>__repr__</code></p>\n<p>Let's implement our own <code>__str__</code></p>\n<pre><code class=\"python\">class Person:\n    def __init__(self,name,age):\n        self.name=name\n        self.age=age\n    def __repr__(self):\n        print(\"__repr__ called\")\n        return f\"Person(name='{self.name}',age={self.age})\"\n\np=Person(\"ali\",20)\n</code></pre>\n<p><code>print(p)</code> and <code>str(p)</code>will return</p>\n<pre><code class=\"python\"> __repr__ called\n     Person(name='ali',age=20)\n</code></pre>\n<p>let's add <code>__str__()</code></p>\n<pre><code class=\"python\">class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n        \n    def __repr__(self):\n        print('__repr__ called')\n        return f\"Person(name='{self.name}, age=self.age')\"\n    \n    def __str__(self):\n        print('__str__ called')\n        return self.name\n\np=Person(\"ali\",20)\n</code></pre>\n<p>if we call <code>print(p)</code> and str(p), it will call <code>__str__()</code> so it will return</p>\n<pre><code class=\"python\">__str__ called\nali\n</code></pre>\n<p><code>repr(p)</code> will return</p>\n<p><strong>repr</strong> called\n\"Person(name='ali, age=self.age')\"</p>\n<p>Let's omit <code>__repr__</code> and just implement <code>__str__</code>.</p>\n<pre><code class=\"python\">class Person:\ndef __init__(self, name, age):\n    self.name = name\n    self.age = age\n\ndef __str__(self):\n    print('__str__ called')\n    return self.name\n\np=Person('ali',20)\n</code></pre>\n<p><code>print(p)</code> will look for the <code>__str__</code> and will return:</p>\n<pre><code class=\"python\">__str__ called\nali\n</code></pre>\n<p>NOTE= if we had <code>__repr__</code> and <code>__str__</code> defined, <code>f'name is {p}'</code> would call <code>__str__</code></p>\n", "abstract": "Every object inherits __repr__  from the base class that all objects created. if you call repr(p) you will get this as default: But if you call str(p) you will get the same output. it is because when __str__ does not exist, Python calls __repr__ Let's implement our own __str__ print(p) and str(p)will return let's add __str__() if we call print(p) and str(p), it will call __str__() so it will return repr(p) will return repr called\n\"Person(name='ali, age=self.age')\" Let's omit __repr__ and just implement __str__. print(p) will look for the __str__ and will return: NOTE= if we had __repr__ and __str__ defined, f'name is {p}' would call __str__"}, {"id": 72027825, "score": 1, "vote": 0, "content": "<blockquote>\n<p>Programmers with prior experience in languages with a <code>toString</code> method tend to implement <code>__str__</code> and not <code>__repr__</code>.\nIf you only implement one of these special methods in Python, choose <code>__repr__</code>.</p>\n</blockquote>\n<p>From <a href=\"https://rads.stackoverflow.com/amzn/click/com/B09WZJMMJP\" rel=\"nofollow noreferrer\">Fluent Python</a> book, by Ramalho, Luciano.</p>\n", "abstract": "Programmers with prior experience in languages with a toString method tend to implement __str__ and not __repr__.\nIf you only implement one of these special methods in Python, choose __repr__. From Fluent Python book, by Ramalho, Luciano."}, {"id": 72238659, "score": 0, "vote": 0, "content": "<p>Basically <code>__str__</code> or <strong>str()</strong> is used for creating output that is human-readable are must be for end-users.\nOn the other hand, <strong>repr()</strong> or <code>__repr__</code> mainly returns canonical string representation of objects which serve the purpose of debugging and development helps the programmers.</p>\n", "abstract": "Basically __str__ or str() is used for creating output that is human-readable are must be for end-users.\nOn the other hand, repr() or __repr__ mainly returns canonical string representation of objects which serve the purpose of debugging and development helps the programmers."}, {"id": 73923738, "score": 0, "vote": 0, "content": "<p>repr() used when we debug or log.It is used for developers to understand code.\none the other hand str() user for non developer like(QA) or user.<br/></p>\n<pre><code class=\"python\">class Customer:\n    def __init__(self,name):\n        self.name = name\n    def __repr__(self):\n        return \"Customer('{}')\".format(self.name)\n    def __str__(self):\n        return f\"cunstomer name is {self.name}\"\n\ncus_1 = Customer(\"Thusi\")\nprint(repr(cus_1)) #print(cus_1.__repr__()) \nprint(str(cus_1)) #print(cus_1.__str__())\n</code></pre>\n", "abstract": "repr() used when we debug or log.It is used for developers to understand code.\none the other hand str() user for non developer like(QA) or user."}]}, {"link": "https://stackoverflow.com/questions/3207219/how-do-i-list-all-files-of-a-directory", "question": {"id": "3207219", "title": "How do I list all files of a directory?", "content": "<p>How can I list all files of a directory in Python and add them to a <code>list</code>?</p>\n", "abstract": "How can I list all files of a directory in Python and add them to a list?"}, "answers": [{"id": 3207973, "score": 5955, "vote": 0, "content": "<p><strong><a href=\"https://docs.python.org/2/library/os.html#os.listdir\" rel=\"noreferrer\" title=\"os.listdir\"><code>os.listdir()</code></a></strong> returns everything inside a directory -- including both <strong>files</strong> and <strong>directories</strong>.</p>\n<p><a href=\"https://docs.python.org/2/library/os.path.html#module-os.path\" rel=\"noreferrer\"><strong><code>os.path</code></strong></a>'s <code>isfile()</code> can be used to only list files:</p>\n<pre><code class=\"python\">from os import listdir\nfrom os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]\n</code></pre>\n<p>Alternatively, <strong><a href=\"https://docs.python.org/2/library/os.html#os.walk\" rel=\"noreferrer\" title=\"os.walk\"><code>os.walk()</code></a></strong> <strong>yields two lists</strong> for each directory it visits -- one for <strong>files</strong> and one for <strong>dirs</strong>. If you only want the top directory you can break the first time it yields:</p>\n<pre><code class=\"python\">from os import walk\n\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\n    break\n</code></pre>\n<p>or, shorter:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from os import walk\n\nfilenames = next(walk(mypath), (None, None, []))[2]  # [] if no file\n</code></pre>\n", "abstract": "os.listdir() returns everything inside a directory -- including both files and directories. os.path's isfile() can be used to only list files: Alternatively, os.walk() yields two lists for each directory it visits -- one for files and one for dirs. If you only want the top directory you can break the first time it yields: or, shorter:"}, {"id": 3215392, "score": 2377, "vote": 0, "content": "<p>I prefer using the <a href=\"https://docs.python.org/library/glob.html\" rel=\"noreferrer\"><code>glob</code></a> module, as it does pattern matching and expansion.</p>\n<pre><code class=\"python\">import glob\nprint(glob.glob(\"/home/adam/*\"))\n</code></pre>\n<p>It does pattern matching intuitively</p>\n<pre><code class=\"python\">import glob\n# All files and directories ending with .txt and that don't begin with a dot:\nprint(glob.glob(\"/home/adam/*.txt\")) \n# All files and directories ending with .txt with depth of 2 folders, ignoring names beginning with a dot:\nprint(glob.glob(\"/home/adam/*/*.txt\")) \n</code></pre>\n<p>It will return a list with the queried files and directories:</p>\n<pre><code class=\"python\">['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]\n</code></pre>\n<p>Note that <code>glob</code> ignores files and directories that begin with a dot <code>.</code>, as those are considered hidden files and directories, unless the pattern is something like <code>.*</code>.</p>\n<p>Use <a href=\"https://docs.python.org/3/library/glob.html#glob.escape\" rel=\"noreferrer\"><code>glob.escape</code></a> to escape strings that are not meant to be patterns:</p>\n<pre><code class=\"python\">print(glob.glob(glob.escape(directory_name) + \"/*.txt\"))\n</code></pre>\n", "abstract": "I prefer using the glob module, as it does pattern matching and expansion. It does pattern matching intuitively It will return a list with the queried files and directories: Note that glob ignores files and directories that begin with a dot ., as those are considered hidden files and directories, unless the pattern is something like .*. Use glob.escape to escape strings that are not meant to be patterns:"}, {"id": 41447012, "score": 1477, "vote": 0, "content": "<p>list in the current directory</p>\n<p>With <code>listdir</code> in <code>os</code> module you get the files and the folders in the current dir</p>\n<pre><code class=\"python\">import os\n\narr = os.listdir()\n</code></pre>\n<p>Looking in a directory</p>\n<pre><code class=\"python\">arr = os.listdir('c:\\\\files')\n</code></pre>\n<p>with <code>glob</code> you can specify a type of file to list like this</p>\n<pre><code class=\"python\">import glob\n\ntxtfiles = []\nfor file in glob.glob(\"*.txt\"):\n    txtfiles.append(file)\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">mylist = [f for f in glob.glob(\"*.txt\")]\n</code></pre>\n<p>get the full path of only files in the current directory</p>\n<pre><code class=\"python\">import os\nfrom os import listdir\nfrom os.path import isfile, join\n\ncwd = os.getcwd()\nonlyfiles = [os.path.join(cwd, f) for f in os.listdir(cwd) if \nos.path.isfile(os.path.join(cwd, f))]\nprint(onlyfiles) \n\n['G:\\\\getfilesname\\\\getfilesname.py', 'G:\\\\getfilesname\\\\example.txt']\n</code></pre>\n<p>Getting the full path name with <code>os.path.abspath</code></p>\n<p>You get the full path in return</p>\n<pre><code class=\"python\"> import os\n files_path = [os.path.abspath(x) for x in os.listdir()]\n print(files_path)\n \n ['F:\\\\documenti\\applications.txt', 'F:\\\\documenti\\collections.txt']\n</code></pre>\n<p>Walk: going through sub directories</p>\n<p>os.walk returns the root, the directories list and the files list, that is why I unpacked them in r, d, f in the for loop; it, then, looks for other files and directories in the subfolders of the root and so on until there are no subfolders.</p>\n<pre><code class=\"python\">import os\n\n# Getting the current work directory (cwd)\nthisdir = os.getcwd()\n\n# r=root, d=directories, f = files\nfor r, d, f in os.walk(thisdir):\n    for file in f:\n        if file.endswith(\".docx\"):\n            print(os.path.join(r, file))\n</code></pre>\n<p>To go up in the directory tree</p>\n<pre><code class=\"python\"># Method 1\nx = os.listdir('..')\n\n# Method 2\nx= os.listdir('/')\n</code></pre>\n<p>Get files of a particular subdirectory with <code>os.listdir()</code></p>\n<pre><code class=\"python\">import os\n\nx = os.listdir(\"./content\")\n</code></pre>\n<p>os.walk('.') - current directory</p>\n<pre><code class=\"python\"> import os\n arr = next(os.walk('.'))[2]\n print(arr)\n \n &gt;&gt;&gt; ['5bs_Turismo1.pdf', '5bs_Turismo1.pptx', 'esperienza.txt']\n</code></pre>\n<p>next(os.walk('.')) and os.path.join('dir', 'file')</p>\n<pre><code class=\"python\"> import os\n arr = []\n for d,r,f in next(os.walk(\"F:\\\\_python\")):\n     for file in f:\n         arr.append(os.path.join(r,file))\n\n for f in arr:\n     print(files)\n\n&gt;&gt;&gt; F:\\\\_python\\\\dict_class.py\n&gt;&gt;&gt; F:\\\\_python\\\\programmi.txt\n</code></pre>\n<p>next... walk</p>\n<pre><code class=\"python\"> [os.path.join(r,file) for r,d,f in next(os.walk(\"F:\\\\_python\")) for file in f]\n \n &gt;&gt;&gt; ['F:\\\\_python\\\\dict_class.py', 'F:\\\\_python\\\\programmi.txt']\n</code></pre>\n<p>os.walk</p>\n<pre><code class=\"python\">x = [os.path.join(r,file) for r,d,f in os.walk(\"F:\\\\_python\") for file in f]\nprint(x)\n\n&gt;&gt;&gt; ['F:\\\\_python\\\\dict.py', 'F:\\\\_python\\\\progr.txt', 'F:\\\\_python\\\\readl.py']\n</code></pre>\n<p>os.listdir() - get only txt files</p>\n<pre><code class=\"python\"> arr_txt = [x for x in os.listdir() if x.endswith(\".txt\")]\n \n</code></pre>\n<p>Using <code>glob</code> to get the full path of the files</p>\n<pre><code class=\"python\">from path import path\nfrom glob import glob\n\nx = [path(f).abspath() for f in glob(\"F:\\\\*.txt\")]\n</code></pre>\n<p>Using <code>os.path.isfile</code> to avoid directories in the list</p>\n<pre><code class=\"python\">import os.path\nlistOfFiles = [f for f in os.listdir() if os.path.isfile(f)]\n</code></pre>\n<p>Using <code>pathlib</code> from Python 3.4</p>\n<pre><code class=\"python\">import pathlib\n\nflist = []\nfor p in pathlib.Path('.').iterdir():\n    if p.is_file():\n        print(p)\n        flist.append(p)\n</code></pre>\n<p>With <code>list comprehension</code>:</p>\n<pre><code class=\"python\">flist = [p for p in pathlib.Path('.').iterdir() if p.is_file()]\n</code></pre>\n<p>Use glob method in pathlib.Path()</p>\n<pre><code class=\"python\">import pathlib\n\npy = pathlib.Path().glob(\"*.py\")\n</code></pre>\n<p>Get all and only files with os.walk: checks only in the third element returned, i.e. the list of the files</p>\n<pre><code class=\"python\">import os\nx = [i[2] for i in os.walk('.')]\ny=[]\nfor t in x:\n    for f in t:\n        y.append(f)\n</code></pre>\n<p>Get only files with next in a directory: returns only the file in the root folder</p>\n<pre><code class=\"python\"> import os\n x = next(os.walk('F://python'))[2]\n</code></pre>\n<p>Get only directories with next and walk in a directory, because in the [1] element there are the folders only</p>\n<pre><code class=\"python\"> import os\n next(os.walk('F://python'))[1] # for the current dir use ('.')\n \n &gt;&gt;&gt; ['python3','others']\n</code></pre>\n<p>Get all the <code>subdir</code> names with <code>walk</code></p>\n<pre><code class=\"python\">for r,d,f in os.walk(\"F:\\\\_python\"):\n    for dirs in d:\n        print(dirs)\n</code></pre>\n<p><code>os.scandir()</code> from Python 3.5 and greater</p>\n<pre><code class=\"python\">import os\nx = [f.name for f in os.scandir() if f.is_file()]\n\n# Another example with `scandir` (a little variation from docs.python.org)\n# This one is more efficient than `os.listdir`.\n# In this case, it shows the files only in the current directory\n# where the script is executed.\n\nimport os\nwith os.scandir() as i:\n    for entry in i:\n        if entry.is_file():\n            print(entry.name)\n</code></pre>\n", "abstract": "list in the current directory With listdir in os module you get the files and the folders in the current dir Looking in a directory with glob you can specify a type of file to list like this or get the full path of only files in the current directory Getting the full path name with os.path.abspath You get the full path in return Walk: going through sub directories os.walk returns the root, the directories list and the files list, that is why I unpacked them in r, d, f in the for loop; it, then, looks for other files and directories in the subfolders of the root and so on until there are no subfolders. To go up in the directory tree Get files of a particular subdirectory with os.listdir() os.walk('.') - current directory next(os.walk('.')) and os.path.join('dir', 'file') next... walk os.walk os.listdir() - get only txt files Using glob to get the full path of the files Using os.path.isfile to avoid directories in the list Using pathlib from Python 3.4 With list comprehension: Use glob method in pathlib.Path() Get all and only files with os.walk: checks only in the third element returned, i.e. the list of the files Get only files with next in a directory: returns only the file in the root folder Get only directories with next and walk in a directory, because in the [1] element there are the folders only Get all the subdir names with walk os.scandir() from Python 3.5 and greater"}, {"id": 3207254, "score": 960, "vote": 0, "content": "<pre><code class=\"python\">import os\nos.listdir(\"somedirectory\")\n</code></pre>\n<p>will return a list of all files and directories in \"somedirectory\".</p>\n", "abstract": "will return a list of all files and directories in \"somedirectory\"."}, {"id": 21207590, "score": 185, "vote": 0, "content": "<p>A one-line solution to get <strong>only list of files</strong> (no subdirectories):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">filenames = next(os.walk(path))[2]\n</code></pre>\n<p>or absolute pathnames:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">paths = [os.path.join(path, fn) for fn in next(os.walk(path))[2]]\n</code></pre>\n", "abstract": "A one-line solution to get only list of files (no subdirectories): or absolute pathnames:"}, {"id": 19308592, "score": 155, "vote": 0, "content": "<p><strong>Getting Full File Paths From a Directory and All Its Subdirectories</strong></p>\n<pre><code class=\"python\">import os\n\ndef get_filepaths(directory):\n    \"\"\"\n    This function will generate the file names in a directory \n    tree by walking the tree either top-down or bottom-up. For each \n    directory in the tree rooted at directory top (including top itself), \n    it yields a 3-tuple (dirpath, dirnames, filenames).\n    \"\"\"\n    file_paths = []  # List which will store all of the full filepaths.\n\n    # Walk the tree.\n    for root, directories, files in os.walk(directory):\n        for filename in files:\n            # Join the two strings in order to form the full filepath.\n            filepath = os.path.join(root, filename)\n            file_paths.append(filepath)  # Add it to the list.\n\n    return file_paths  # Self-explanatory.\n\n# Run the above function and store its results in a variable.   \nfull_file_paths = get_filepaths(\"/Users/johnny/Desktop/TEST\")\n</code></pre>\n<hr/>\n<ul>\n<li>The path I provided in the above function contained 3 files\u2014 two of them in the root directory, and another in a subfolder called \"SUBFOLDER.\"  You can now do things like:</li>\n<li><p><code>print full_file_paths</code> which will print the list:</p>\n<ul>\n<li><code>['/Users/johnny/Desktop/TEST/file1.txt', '/Users/johnny/Desktop/TEST/file2.txt', '/Users/johnny/Desktop/TEST/SUBFOLDER/file3.dat']</code></li>\n</ul></li>\n</ul>\n<p>If you'd like, you can open and read the contents, or focus only on files with the extension \".dat\" like in the code below:</p>\n<pre><code class=\"python\">for f in full_file_paths:\n  if f.endswith(\".dat\"):\n    print f\n</code></pre>\n<p><code>/Users/johnny/Desktop/TEST/SUBFOLDER/file3.dat</code></p>\n", "abstract": "Getting Full File Paths From a Directory and All Its Subdirectories print full_file_paths which will print the list: If you'd like, you can open and read the contents, or focus only on files with the extension \".dat\" like in the code below: /Users/johnny/Desktop/TEST/SUBFOLDER/file3.dat"}, {"id": 30925692, "score": 100, "vote": 0, "content": "<p>Since version 3.4 there are builtin <em>iterators</em> for this which are a lot more efficient than <a href=\"http://docs.python.org/3/library/os.html#os.listdir\" rel=\"noreferrer\"><code>os.listdir()</code></a>:</p>\n<p><a href=\"http://docs.python.org/3/library/pathlib.html\" rel=\"noreferrer\"><code>pathlib</code></a>: <em>New in version 3.4.</em></p>\n<pre><code class=\"python\">&gt;&gt;&gt; import pathlib\n&gt;&gt;&gt; [p for p in pathlib.Path('.').iterdir() if p.is_file()]\n</code></pre>\n<p>According to <a href=\"http://www.python.org/dev/peps/pep-0428/\" rel=\"noreferrer\">PEP 428</a>, the aim of the <a href=\"http://docs.python.org/3/library/pathlib.html\" rel=\"noreferrer\"><code>pathlib</code></a> library is to provide a simple hierarchy of classes to handle filesystem paths and the common operations users do over them.</p>\n<p><a href=\"http://docs.python.org/3/library/os.html#os.scandir\" rel=\"noreferrer\"><code>os.scandir()</code></a>: <em>New in version 3.5.</em></p>\n<pre><code class=\"python\">&gt;&gt;&gt; import os\n&gt;&gt;&gt; [entry for entry in os.scandir('.') if entry.is_file()]\n</code></pre>\n<p>Note that <a href=\"http://docs.python.org/3/library/os.html#os.walk\" rel=\"noreferrer\"><code>os.walk()</code></a> uses <a href=\"http://docs.python.org/3/library/os.html#os.scandir\" rel=\"noreferrer\"><code>os.scandir()</code></a> instead of <a href=\"http://docs.python.org/3/library/os.html#os.listdir\" rel=\"noreferrer\"><code>os.listdir()</code></a> from version 3.5, and its speed got increased by 2-20 times according to <a href=\"http://www.python.org/dev/peps/pep-0471/\" rel=\"noreferrer\">PEP 471</a>.</p>\n<p>Let me also recommend reading ShadowRanger's comment below.</p>\n", "abstract": "Since version 3.4 there are builtin iterators for this which are a lot more efficient than os.listdir(): pathlib: New in version 3.4. According to PEP 428, the aim of the pathlib library is to provide a simple hierarchy of classes to handle filesystem paths and the common operations users do over them. os.scandir(): New in version 3.5. Note that os.walk() uses os.scandir() instead of os.listdir() from version 3.5, and its speed got increased by 2-20 times according to PEP 471. Let me also recommend reading ShadowRanger's comment below."}, {"id": 48393588, "score": 66, "vote": 0, "content": "<h2>Preliminary notes</h2>\n<ul>\n<li>Although there's a clear differentiation between <em>file</em> and <em>directory</em> terms in the question text, some may argue that directories are actually special files</li>\n<li>The statement: \"<em>all files of a directory</em>\" can be interpreted in two ways:\n\n<ol>\n<li>All <strong>direct</strong> (or level 1) descendants <strong>only</strong></li>\n<li>All descendants in the whole directory tree (including the ones in sub-directories)</li>\n</ol></li>\n<li><p>When the question was asked, I imagine that <em>Python <strong>2</strong></em>, was the <em>LTS</em> version, however the code samples will be run by <em>Python <strong>3</strong>(<strong>.5</strong>)</em> (I'll keep them as <em>Python 2</em> compliant as possible; also, any code belonging to <em>Python</em> that I'm going to post, is from <strong>v3.5.4</strong> - unless otherwise specified). That has consequences related to another keyword in the question: \"<em>add them into a <strong>list</strong></em>\":</p>\n<ul>\n<li>In pre <em>Python 2.2</em> versions, sequences (iterables) were mostly represented by lists (tuples, sets, ...)</li>\n<li>In <em>Python 2.2</em>, the concept of <strong>generator</strong> (<a href=\"https://wiki.python.org/moin/Generators\" rel=\"noreferrer\">[Python.Wiki]: Generators</a>) - courtesy of <a href=\"https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement\" rel=\"noreferrer\">[Python 3]: The yield statement</a>) - was introduced. As time passed, generator counterparts started to appear for functions that returned/worked with lists</li>\n<li>In <em>Python 3</em>, generator is the default behavior</li>\n<li>Not sure if returning a list is still mandatory (or a generator would do as well), but passing a generator to the <em>list</em> constructor, will create a list out of it (and also consume it). The example below illustrates the differences on <a href=\"https://docs.python.org/3/library/functions.html#map\" rel=\"noreferrer\">[Python 3]: <strong>map</strong>(<em>function, iterable, ...</em>)</a></li>\n</ul>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.version\n'2.7.10 (default, Mar  8 2016, 15:02:46) [MSC v.1600 64 bit (AMD64)]'\n&gt;&gt;&gt; m = map(lambda x: x, [1, 2, 3])  # Just a dummy lambda function\n&gt;&gt;&gt; m, type(m)\n([1, 2, 3], &lt;type 'list'&gt;)\n&gt;&gt;&gt; len(m)\n3\n</code></pre>\n</blockquote>\n<p><br/></p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.version\n'3.5.4 (v3.5.4:3f56838, Aug  8 2017, 02:17:05) [MSC v.1900 64 bit (AMD64)]'\n&gt;&gt;&gt; m = map(lambda x: x, [1, 2, 3])\n&gt;&gt;&gt; m, type(m)\n(&lt;map object at 0x000001B4257342B0&gt;, &lt;class 'map'&gt;)\n&gt;&gt;&gt; len(m)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: object of type 'map' has no len()\n&gt;&gt;&gt; lm0 = list(m)  # Build a list from the generator\n&gt;&gt;&gt; lm0, type(lm0)\n([1, 2, 3], &lt;class 'list'&gt;)\n&gt;&gt;&gt;\n&gt;&gt;&gt; lm1 = list(m)  # Build a list from the same generator\n&gt;&gt;&gt; lm1, type(lm1)  # Empty list now - generator already consumed\n([], &lt;class 'list'&gt;)\n</code></pre>\n</blockquote></li>\n<li><p>The examples will be based on a directory called <em>root_dir</em> with the following structure (this example is for <em>Win</em>, but I'm using the same tree on <em>Lnx</em> as well):</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">E:\\Work\\Dev\\StackOverflow\\q003207219&gt;tree /f \"root_dir\"\nFolder PATH listing for volume Work\nVolume serial number is 00000029 3655:6FED\nE:\\WORK\\DEV\\STACKOVERFLOW\\Q003207219\\ROOT_DIR\n\u00a6   file0\n\u00a6   file1\n\u00a6\n+---dir0\n\u00a6   +---dir00\n\u00a6   \u00a6   \u00a6   file000\n\u00a6   \u00a6   \u00a6\n\u00a6   \u00a6   +---dir000\n\u00a6   \u00a6           file0000\n\u00a6   \u00a6\n\u00a6   +---dir01\n\u00a6   \u00a6       file010\n\u00a6   \u00a6       file011\n\u00a6   \u00a6\n\u00a6   +---dir02\n\u00a6       +---dir020\n\u00a6           +---dir0200\n+---dir1\n\u00a6       file10\n\u00a6       file11\n\u00a6       file12\n\u00a6\n+---dir2\n\u00a6   \u00a6   file20\n\u00a6   \u00a6\n\u00a6   +---dir20\n\u00a6           file200\n\u00a6\n+---dir3\n</code></pre>\n</blockquote></li>\n</ul>\n<p><br/></p>\n<h2>Solutions</h2>\n<h3>Programmatic approaches:</h3>\n<ol>\n<li><p><a href=\"https://docs.python.org/3/library/os.html#os.listdir\" rel=\"noreferrer\">[Python 3]: os.<strong>listdir</strong>(<em>path='.'</em>)</a></p>\n<blockquote>\n<p>Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order, and does not include the special entries <code>'.'</code> and <code>'..'</code> ...</p>\n</blockquote>\n<p><br/></p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import os\n&gt;&gt;&gt; root_dir = \"root_dir\"  # Path relative to current dir (os.getcwd())\n&gt;&gt;&gt;\n&gt;&gt;&gt; os.listdir(root_dir)  # List all the items in root_dir\n['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1']\n&gt;&gt;&gt;\n&gt;&gt;&gt; [item for item in os.listdir(root_dir) if os.path.isfile(os.path.join(root_dir, item))]  # Filter items and only keep files (strip out directories)\n['file0', 'file1']\n</code></pre>\n</blockquote>\n<p>A more elaborate example (<em>code_os_listdir.py</em>):</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import os\nfrom pprint import pformat\n\n\ndef _get_dir_content(path, include_folders, recursive):\n    entries = os.listdir(path)\n    for entry in entries:\n        entry_with_path = os.path.join(path, entry)\n        if os.path.isdir(entry_with_path):\n            if include_folders:\n                yield entry_with_path\n            if recursive:\n                for sub_entry in _get_dir_content(entry_with_path, include_folders, recursive):\n                    yield sub_entry\n        else:\n            yield entry_with_path\n\n\ndef get_dir_content(path, include_folders=True, recursive=True, prepend_folder_name=True):\n    path_len = len(path) + len(os.path.sep)\n    for item in _get_dir_content(path, include_folders, recursive):\n        yield item if prepend_folder_name else item[path_len:]\n\n\ndef _get_dir_content_old(path, include_folders, recursive):\n    entries = os.listdir(path)\n    ret = list()\n    for entry in entries:\n        entry_with_path = os.path.join(path, entry)\n        if os.path.isdir(entry_with_path):\n            if include_folders:\n                ret.append(entry_with_path)\n            if recursive:\n                ret.extend(_get_dir_content_old(entry_with_path, include_folders, recursive))\n        else:\n            ret.append(entry_with_path)\n    return ret\n\n\ndef get_dir_content_old(path, include_folders=True, recursive=True, prepend_folder_name=True):\n    path_len = len(path) + len(os.path.sep)\n    return [item if prepend_folder_name else item[path_len:] for item in _get_dir_content_old(path, include_folders, recursive)]\n\n\ndef main():\n    root_dir = \"root_dir\"\n    ret0 = get_dir_content(root_dir, include_folders=True, recursive=True, prepend_folder_name=True)\n    lret0 = list(ret0)\n    print(ret0, len(lret0), pformat(lret0))\n    ret1 = get_dir_content_old(root_dir, include_folders=False, recursive=True, prepend_folder_name=False)\n    print(len(ret1), pformat(ret1))\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li>There are two implementations:\n\n<ul>\n<li>One that uses generators (of course here it seems useless, since I immediately convert the result to a list)</li>\n<li>The classic one (function names ending in <strong>_old</strong>)</li>\n</ul></li>\n<li>Recursion is used (to get into subdirectories)</li>\n<li>For each implementation there are two functions:\n\n<ul>\n<li>One that starts with an <em>underscore</em> (<strong>_</strong>): \"private\" (should not be called directly) - that does all the work</li>\n<li>The public one (wrapper over previous): it just strips off the initial path (if required) from the returned entries. It's an ugly implementation, but it's the only idea that I could come with at this point</li>\n</ul></li>\n<li>In terms of performance, generators are generally a little bit faster (considering both <em>creation</em> and  <em>iteration</em> times), but I didn't test them in recursive functions, and also I am iterating inside the function over inner generators - don't know how performance friendly is that</li>\n<li>Play with the arguments to get different results</li>\n</ul>\n<p><br/></p>\n<p><strong>Output</strong>:</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">(py35x64_test) E:\\Work\\Dev\\StackOverflow\\q003207219&gt;\"e:\\Work\\Dev\\VEnvs\\py35x64_test\\Scripts\\python.exe\" \"code_os_listdir.py\"\n&lt;generator object get_dir_content at 0x000001BDDBB3DF10&gt; 22 ['root_dir\\\\dir0',\n 'root_dir\\\\dir0\\\\dir00',\n 'root_dir\\\\dir0\\\\dir00\\\\dir000',\n 'root_dir\\\\dir0\\\\dir00\\\\dir000\\\\file0000',\n 'root_dir\\\\dir0\\\\dir00\\\\file000',\n 'root_dir\\\\dir0\\\\dir01',\n 'root_dir\\\\dir0\\\\dir01\\\\file010',\n 'root_dir\\\\dir0\\\\dir01\\\\file011',\n 'root_dir\\\\dir0\\\\dir02',\n 'root_dir\\\\dir0\\\\dir02\\\\dir020',\n 'root_dir\\\\dir0\\\\dir02\\\\dir020\\\\dir0200',\n 'root_dir\\\\dir1',\n 'root_dir\\\\dir1\\\\file10',\n 'root_dir\\\\dir1\\\\file11',\n 'root_dir\\\\dir1\\\\file12',\n 'root_dir\\\\dir2',\n 'root_dir\\\\dir2\\\\dir20',\n 'root_dir\\\\dir2\\\\dir20\\\\file200',\n 'root_dir\\\\dir2\\\\file20',\n 'root_dir\\\\dir3',\n 'root_dir\\\\file0',\n 'root_dir\\\\file1']\n11 ['dir0\\\\dir00\\\\dir000\\\\file0000',\n 'dir0\\\\dir00\\\\file000',\n 'dir0\\\\dir01\\\\file010',\n 'dir0\\\\dir01\\\\file011',\n 'dir1\\\\file10',\n 'dir1\\\\file11',\n 'dir1\\\\file12',\n 'dir2\\\\dir20\\\\file200',\n 'dir2\\\\file20',\n 'file0',\n 'file1']\n</code></pre>\n</blockquote></li>\n</ol>\n<p><br/></p>\n<ol start=\"2\">\n<li><p><a href=\"https://docs.python.org/3/library/os.html#os.scandir\" rel=\"noreferrer\">[Python 3]: os.<strong>scandir</strong>(<em>path='.'</em>)</a> (<em>Python <strong>3.5</strong></em>+, backport: <a href=\"https://pypi.org/project/scandir\" rel=\"noreferrer\">[PyPI]: scandir</a>)</p>\n<blockquote>\n<p>Return an iterator of <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry\" rel=\"noreferrer\">os.DirEntry</a> objects corresponding to the entries in the directory given by <em>path</em>. The entries are yielded in arbitrary order, and the special entries <code>'.'</code> and <code>'..'</code> are not included.</p>\n<p>Using <a href=\"https://docs.python.org/3/library/os.html#os.scandir\" rel=\"noreferrer\">scandir()</a> instead of <a href=\"https://docs.python.org/3/library/os.html#os.listdir\" rel=\"noreferrer\">listdir()</a> can significantly increase the performance of code that also needs file type or file attribute information, because <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry\" rel=\"noreferrer\">os.DirEntry</a> objects expose this information if the operating system provides it when scanning a directory. All <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry\" rel=\"noreferrer\">os.DirEntry</a> methods may perform a system call, but <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry.is_dir\" rel=\"noreferrer\">is_dir()</a> and <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry.is_file\" rel=\"noreferrer\">is_file()</a> usually only require a system call for symbolic links; <a href=\"https://docs.python.org/3/library/os.html#os.DirEntry.stat\" rel=\"noreferrer\">os.DirEntry.stat()</a> always requires a system call on Unix but only requires one for symbolic links on Windows.</p>\n</blockquote>\n<p><br/></p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import os\n&gt;&gt;&gt; root_dir = os.path.join(\".\", \"root_dir\")  # Explicitly prepending current directory\n&gt;&gt;&gt; root_dir\n'.\\\\root_dir'\n&gt;&gt;&gt;\n&gt;&gt;&gt; scandir_iterator = os.scandir(root_dir)\n&gt;&gt;&gt; scandir_iterator\n&lt;nt.ScandirIterator object at 0x00000268CF4BC140&gt;\n&gt;&gt;&gt; [item.path for item in scandir_iterator]\n['.\\\\root_dir\\\\dir0', '.\\\\root_dir\\\\dir1', '.\\\\root_dir\\\\dir2', '.\\\\root_dir\\\\dir3', '.\\\\root_dir\\\\file0', '.\\\\root_dir\\\\file1']\n&gt;&gt;&gt;\n&gt;&gt;&gt; [item.path for item in scandir_iterator]  # Will yield an empty list as it was consumed by previous iteration (automatically performed by the list comprehension)\n[]\n&gt;&gt;&gt;\n&gt;&gt;&gt; scandir_iterator = os.scandir(root_dir)  # Reinitialize the generator\n&gt;&gt;&gt; for item in scandir_iterator :\n...     if os.path.isfile(item.path):\n...             print(item.name)\n...\nfile0\nfile1\n</code></pre>\n</blockquote>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li>It's similar to <code>os.listdir</code></li>\n<li>But it's also more flexible (and offers more functionality), more <em>Python</em>ic (and in some cases, faster)</li>\n</ul></li>\n</ol>\n<p><br/></p>\n<ol start=\"3\">\n<li><p><a href=\"https://docs.python.org/3/library/os.html#os.walk\" rel=\"noreferrer\">[Python 3]: os.<strong>walk</strong>(<em>top, topdown=True, onerror=None, followlinks=False</em>)</a></p>\n<blockquote>\n<p>Generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory <em>top</em> (including <em>top</em> itself), it yields a 3-tuple (<code>dirpath</code>, <code>dirnames</code>, <code>filenames</code>).</p>\n</blockquote>\n<p><br/></p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import os\n&gt;&gt;&gt; root_dir = os.path.join(os.getcwd(), \"root_dir\")  # Specify the full path\n&gt;&gt;&gt; root_dir\n'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir'\n&gt;&gt;&gt;\n&gt;&gt;&gt; walk_generator = os.walk(root_dir)\n&gt;&gt;&gt; root_dir_entry = next(walk_generator)  # First entry corresponds to the root dir (passed as an argument)\n&gt;&gt;&gt; root_dir_entry\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir', ['dir0', 'dir1', 'dir2', 'dir3'], ['file0', 'file1'])\n&gt;&gt;&gt;\n&gt;&gt;&gt; root_dir_entry[1] + root_dir_entry[2]  # Display dirs and files (direct descendants) in a single list\n['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1']\n&gt;&gt;&gt;\n&gt;&gt;&gt; [os.path.join(root_dir_entry[0], item) for item in root_dir_entry[1] + root_dir_entry[2]]  # Display all the entries in the previous list by their full path\n['E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0', 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir1', 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir2', 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir3', 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\file0', 'E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\file1']\n&gt;&gt;&gt;\n&gt;&gt;&gt; for entry in walk_generator:  # Display the rest of the elements (corresponding to every subdir)\n...     print(entry)\n...\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0', ['dir00', 'dir01', 'dir02'], [])\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir00', ['dir000'], ['file000'])\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir00\\\\dir000', [], ['file0000'])\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir01', [], ['file010', 'file011'])\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir02', ['dir020'], [])\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir02\\\\dir020', ['dir0200'], [])\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir0\\\\dir02\\\\dir020\\\\dir0200', [], [])\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir1', [], ['file10', 'file11', 'file12'])\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir2', ['dir20'], ['file20'])\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir2\\\\dir20', [], ['file200'])\n('E:\\\\Work\\\\Dev\\\\StackOverflow\\\\q003207219\\\\root_dir\\\\dir3', [], [])\n</code></pre>\n</blockquote>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li>Under the scenes, it uses <code>os.scandir</code> (<code>os.listdir</code> on older versions)</li>\n<li>It does the heavy lifting by recurring in subfolders</li>\n</ul></li>\n</ol>\n<p><br/></p>\n<ol start=\"4\">\n<li><p><a href=\"https://docs.python.org/3/library/glob.html#glob.glob\" rel=\"noreferrer\">[Python 3]: glob.<strong>glob</strong>(<em>pathname, *, recursive=False</em>)</a> (<a href=\"https://docs.python.org/3/library/glob.html#glob.glob\" rel=\"noreferrer\">[Python 3]: glob.<strong>iglob</strong>(<em>pathname, *, recursive=False</em>)</a>)</p>\n<blockquote>\n<p>Return a possibly-empty list of path names that match <em>pathname</em>, which must be a string containing a path specification. <em>pathname</em> can be either absolute (like <code>/usr/src/Python-1.5/Makefile</code>) or relative (like <code>../../Tools/*/*.gif</code>), and can contain shell-style wildcards. Broken symlinks are included in the results (as in the shell).<br/>...<br/><strong><em>Changed in version 3.5</em></strong>: Support for recursive globs using \u201c<code>**</code>\u201d.</p>\n</blockquote>\n<p><br/></p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import glob, os\n&gt;&gt;&gt; wildcard_pattern = \"*\"\n&gt;&gt;&gt; root_dir = os.path.join(\"root_dir\", wildcard_pattern)  # Match every file/dir name\n&gt;&gt;&gt; root_dir\n'root_dir\\\\*'\n&gt;&gt;&gt;\n&gt;&gt;&gt; glob_list = glob.glob(root_dir)\n&gt;&gt;&gt; glob_list\n['root_dir\\\\dir0', 'root_dir\\\\dir1', 'root_dir\\\\dir2', 'root_dir\\\\dir3', 'root_dir\\\\file0', 'root_dir\\\\file1']\n&gt;&gt;&gt;\n&gt;&gt;&gt; [item.replace(\"root_dir\" + os.path.sep, \"\") for item in glob_list]  # Strip the dir name and the path separator from begining\n['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1']\n&gt;&gt;&gt;\n&gt;&gt;&gt; for entry in glob.iglob(root_dir + \"*\", recursive=True):\n...     print(entry)\n...\nroot_dir\\\nroot_dir\\dir0\nroot_dir\\dir0\\dir00\nroot_dir\\dir0\\dir00\\dir000\nroot_dir\\dir0\\dir00\\dir000\\file0000\nroot_dir\\dir0\\dir00\\file000\nroot_dir\\dir0\\dir01\nroot_dir\\dir0\\dir01\\file010\nroot_dir\\dir0\\dir01\\file011\nroot_dir\\dir0\\dir02\nroot_dir\\dir0\\dir02\\dir020\nroot_dir\\dir0\\dir02\\dir020\\dir0200\nroot_dir\\dir1\nroot_dir\\dir1\\file10\nroot_dir\\dir1\\file11\nroot_dir\\dir1\\file12\nroot_dir\\dir2\nroot_dir\\dir2\\dir20\nroot_dir\\dir2\\dir20\\file200\nroot_dir\\dir2\\file20\nroot_dir\\dir3\nroot_dir\\file0\nroot_dir\\file1\n</code></pre>\n</blockquote>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li>Uses <code>os.listdir</code></li>\n<li>For large trees (especially if <em>recursive</em> is on), <em>iglob</em> is preferred</li>\n<li>Allows advanced filtering based on name (due to the wildcard)</li>\n</ul></li>\n</ol>\n<p><br/></p>\n<ol start=\"5\">\n<li><p><a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path\" rel=\"noreferrer\">[Python 3]: class pathlib.<strong>Path</strong>(<em>*pathsegments</em>)</a> (<em>Python <strong>3.4</strong></em>+, backport: <a href=\"https://pypi.org/project/pathlib2\" rel=\"noreferrer\">[PyPI]: pathlib2</a>)</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import pathlib\n&gt;&gt;&gt; root_dir = \"root_dir\"\n&gt;&gt;&gt; root_dir_instance = pathlib.Path(root_dir)\n&gt;&gt;&gt; root_dir_instance\nWindowsPath('root_dir')\n&gt;&gt;&gt; root_dir_instance.name\n'root_dir'\n&gt;&gt;&gt; root_dir_instance.is_dir()\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; [item.name for item in root_dir_instance.glob(\"*\")]  # Wildcard searching for all direct descendants\n['dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1']\n&gt;&gt;&gt;\n&gt;&gt;&gt; [os.path.join(item.parent.name, item.name) for item in root_dir_instance.glob(\"*\") if not item.is_dir()]  # Display paths (including parent) for files only\n['root_dir\\\\file0', 'root_dir\\\\file1']\n</code></pre>\n</blockquote>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li>This is <em>one</em> way of achieving our goal</li>\n<li>It's the <em>OOP</em> style of handling paths</li>\n<li>Offers lots of functionalities</li>\n</ul></li>\n</ol>\n<p><br/></p>\n<ol start=\"6\">\n<li><p><a href=\"https://docs.python.org/2/library/dircache.html#dircache.listdir\" rel=\"noreferrer\">[Python 2]: dircache.listdir(path)</a> (<em>Python <strong>2</strong></em> only)</p>\n<ul>\n<li>But, according to <a href=\"https://github.com/python/cpython/blob/2.7/Lib/dircache.py\" rel=\"noreferrer\">[GitHub]: python/cpython - (2.7) cpython/Lib/dircache.py</a>, it's just a (thin) wrapper over <code>os.listdir</code> with caching</li>\n</ul>\n<p><br/></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def listdir(path):\n    \"\"\"List directory contents, using cache.\"\"\"\n    try:\n        cached_mtime, list = cache[path]\n        del cache[path]\n    except KeyError:\n        cached_mtime, list = -1, []\n    mtime = os.stat(path).st_mtime\n    if mtime != cached_mtime:\n        list = os.listdir(path)\n        list.sort()\n    cache[path] = mtime, list\n    return list\n</code></pre></li>\n</ol>\n<p><br/></p>\n<ol start=\"7\">\n<li><p><a href=\"http://man7.org/linux/man-pages/man3/opendir.3.html\" rel=\"noreferrer\">[man7]: OPENDIR(3)</a> / <a href=\"http://man7.org/linux/man-pages/man3/readdir.3.html\" rel=\"noreferrer\">[man7]: READDIR(3)</a> / <a href=\"http://man7.org/linux/man-pages/man3/closedir.3.html\" rel=\"noreferrer\">[man7]: CLOSEDIR(3)</a> via <a href=\"https://docs.python.org/3/library/ctypes.html#module-ctypes\" rel=\"noreferrer\">[Python 3]: ctypes - A foreign function library for Python</a> (<em>POSIX</em> specific)</p>\n<blockquote>\n<p><a href=\"https://docs.python.org/3/library/ctypes.html#module-ctypes\" rel=\"noreferrer\">ctypes</a> is a foreign function library for Python. It provides C compatible data types, and allows calling functions in DLLs or shared libraries. It can be used to wrap these libraries in pure Python.</p>\n</blockquote>\n<p><em>code_ctypes.py</em>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">#!/usr/bin/env python3\n\nimport sys\nfrom ctypes import Structure, \\\n    c_ulonglong, c_longlong, c_ushort, c_ubyte, c_char, c_int, \\\n    CDLL, POINTER, \\\n    create_string_buffer, get_errno, set_errno, cast\n\n\nDT_DIR = 4\nDT_REG = 8\n\nchar256 = c_char * 256\n\n\nclass LinuxDirent64(Structure):\n    _fields_ = [\n        (\"d_ino\", c_ulonglong),\n        (\"d_off\", c_longlong),\n        (\"d_reclen\", c_ushort),\n        (\"d_type\", c_ubyte),\n        (\"d_name\", char256),\n    ]\n\nLinuxDirent64Ptr = POINTER(LinuxDirent64)\n\nlibc_dll = this_process = CDLL(None, use_errno=True)\n# ALWAYS set argtypes and restype for functions, otherwise it's UB!!!\nopendir = libc_dll.opendir\nreaddir = libc_dll.readdir\nclosedir = libc_dll.closedir\n\n\ndef get_dir_content(path):\n    ret = [path, list(), list()]\n    dir_stream = opendir(create_string_buffer(path.encode()))\n    if (dir_stream == 0):\n        print(\"opendir returned NULL (errno: {:d})\".format(get_errno()))\n        return ret\n    set_errno(0)\n    dirent_addr = readdir(dir_stream)\n    while dirent_addr:\n        dirent_ptr = cast(dirent_addr, LinuxDirent64Ptr)\n        dirent = dirent_ptr.contents\n        name = dirent.d_name.decode()\n        if dirent.d_type &amp; DT_DIR:\n            if name not in (\".\", \"..\"):\n                ret[1].append(name)\n        elif dirent.d_type &amp; DT_REG:\n            ret[2].append(name)\n        dirent_addr = readdir(dir_stream)\n    if get_errno():\n        print(\"readdir returned NULL (errno: {:d})\".format(get_errno()))\n    closedir(dir_stream)\n    return ret\n\n\ndef main():\n    print(\"{:s} on {:s}\\n\".format(sys.version, sys.platform))\n    root_dir = \"root_dir\"\n    entries = get_dir_content(root_dir)\n    print(entries)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li>It loads the three functions from <em>libc</em> (loaded in the current process) and calls them (for more details check <a href=\"https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-using-python/44661513#44661513\">[SO]: How do I check whether a file exists without exceptions? (@CristiFati's answer)</a> - last notes from item <strong><em>#4.</em></strong>). That would place this approach very close to the <em>Python</em> / <em>C</em> edge</li>\n<li><em>LinuxDirent64</em> is the <em>ctypes</em> representation of <em>struct dirent64</em> from <a href=\"http://man7.org/linux/man-pages/man0/dirent.h.0p.html\" rel=\"noreferrer\">[man7]: dirent.h(0P)</a> (so are the <em>DT_</em> constants) from my machine: <em>Ubtu 16 x64</em> (<em>4.10.0-40-generic</em> and <em>libc6-dev:amd64</em>). On other flavors/versions, the struct definition might differ, and if so, the <em>ctypes</em> alias should be updated, otherwise it will yield <strong>Undefined Behavior</strong></li>\n<li>It returns data in the <code>os.walk</code>'s format. I didn't bother to make it recursive, but starting from the existing code, that would be a fairly trivial task</li>\n<li>Everything is doable on <em>Win</em> as well, the data (libraries, functions, structs, constants, ...) differ</li>\n</ul>\n<p><br/></p>\n<p><strong>Output</strong>:</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">[cfati@cfati-ubtu16x64-0:~/Work/Dev/StackOverflow/q003207219]&gt; ./code_ctypes.py\n3.5.2 (default, Nov 12 2018, 13:43:14)\n[GCC 5.4.0 20160609] on linux\n\n['root_dir', ['dir2', 'dir1', 'dir3', 'dir0'], ['file1', 'file0']]\n</code></pre>\n</blockquote></li>\n</ol>\n<p><br/></p>\n<ol start=\"8\">\n<li><p><a href=\"https://docs.activestate.com/activepython/3.1/pywin32/win32file__FindFilesW_meth.html\" rel=\"noreferrer\">[ActiveState.Docs]: win32file.FindFilesW</a> (<em>Win</em> specific)</p>\n<blockquote>\n<p>Retrieves a list of matching filenames, using the Windows Unicode API. An interface to the API FindFirstFileW/FindNextFileW/Find close functions.</p>\n</blockquote>\n<p><br/></p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import os, win32file, win32con\n&gt;&gt;&gt; root_dir = \"root_dir\"\n&gt;&gt;&gt; wildcard = \"*\"\n&gt;&gt;&gt; root_dir_wildcard = os.path.join(root_dir, wildcard)\n&gt;&gt;&gt; entry_list = win32file.FindFilesW(root_dir_wildcard)\n&gt;&gt;&gt; len(entry_list)  # Don't display the whole content as it's too long\n8\n&gt;&gt;&gt; [entry[-2] for entry in entry_list]  # Only display the entry names\n['.', '..', 'dir0', 'dir1', 'dir2', 'dir3', 'file0', 'file1']\n&gt;&gt;&gt;\n&gt;&gt;&gt; [entry[-2] for entry in entry_list if entry[0] &amp; win32con.FILE_ATTRIBUTE_DIRECTORY and entry[-2] not in (\".\", \"..\")]  # Filter entries and only display dir names (except self and parent)\n['dir0', 'dir1', 'dir2', 'dir3']\n&gt;&gt;&gt;\n&gt;&gt;&gt; [os.path.join(root_dir, entry[-2]) for entry in entry_list if entry[0] &amp; (win32con.FILE_ATTRIBUTE_NORMAL | win32con.FILE_ATTRIBUTE_ARCHIVE)]  # Only display file \"full\" names\n['root_dir\\\\file0', 'root_dir\\\\file1']\n</code></pre>\n</blockquote>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li><code>win32file.FindFilesW</code> is part of <a href=\"https://github.com/mhammond/pywin32\" rel=\"noreferrer\">[GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions</a>, which is a <em>Python</em> wrapper over <em>WINAPI</em>s</li>\n<li>The documentation link is from <a href=\"https://www.activestate.com\" rel=\"noreferrer\">ActiveState</a>, as I didn't find any <em>PyWin32</em> official documentation</li>\n</ul></li>\n</ol>\n<p><br/></p>\n<ol start=\"9\">\n<li>Install some (other) third-party package that does the trick\n\n<ul>\n<li>Most likely, will rely on one (or more) of the above (maybe with slight customizations)</li>\n</ul></li>\n</ol>\n<p><br/></p>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li><p>Code is meant to be portable (except places that target a specific area - which are marked) or cross:</p>\n<ul>\n<li>platform (<em>Nix</em>, <em>Win</em>, )</li>\n<li><em>Python</em> version (2, 3, )</li>\n</ul></li>\n<li><p>Multiple path styles (absolute, relatives) were used across the above variants, to illustrate the fact that the \"tools\" used are flexible in this direction</p></li>\n<li><p><code>os.listdir</code> and <code>os.scandir</code> use <em>opendir</em> / <em>readdir</em> / <em>closedir</em> (<a href=\"https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew\" rel=\"noreferrer\">[MS.Docs]: FindFirstFileW function</a> / <a href=\"https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew\" rel=\"noreferrer\">[MS.Docs]: FindNextFileW function</a> / <a href=\"https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose\" rel=\"noreferrer\">[MS.Docs]: FindClose function</a>) (via <a href=\"https://github.com/python/cpython/blob/master/Modules/posixmodule.c\" rel=\"noreferrer\">[GitHub]: python/cpython - (master) cpython/Modules/posixmodule.c</a>)</p></li>\n<li><p><code>win32file.FindFilesW</code> uses those (<em>Win</em> specific) functions as well (via <a href=\"https://github.com/mhammond/pywin32/blob/master/win32/src/win32file.i\" rel=\"noreferrer\">[GitHub]: mhammond/pywin32 - (master) pywin32/win32/src/win32file.i</a>)</p></li>\n<li><p><em>_get_dir_content</em> (from point <strong><em>#1.</em></strong>) can be implemented using any of these approaches (some will require more work and some less)</p>\n<ul>\n<li>Some advanced filtering (instead of just file <em>vs.</em> dir) could be done: e.g. the <em>include_folders</em> argument could be replaced by another one (e.g. <em>filter_func</em>) which would be a function that takes a path as an argument: <code>filter_func=lambda x: True</code> (this doesn't strip out anything) and inside <em>_get_dir_content</em> something like: <code>if not filter_func(entry_with_path): continue</code> (if the function fails for one entry, it will be skipped), but the more complex the code becomes, the longer it will take to execute</li>\n</ul></li>\n<li><p><strong>Nota bene!</strong> Since recursion is used, I must mention that I did some tests on my laptop (<em>Win 10 x64</em>), totally unrelated to this problem, and when the recursion level was reaching values somewhere in the <em>(990 .. 1000)</em> range (<em>recursionlimit</em> - 1000 (default)), I got <em>StackOverflow</em> :). If the directory tree exceeds that limit (I am not an <em>FS</em> expert, so I don't know if that is even possible), that could be a problem. <br/>\nI must also mention that I didn't try to increase <em>recursionlimit</em> because I have no experience in the area (how much can I increase it before having to also increase the stack at <em>OS</em> level), but in theory there will always be the possibility for failure, if the dir depth is larger than the highest possible <em>recursionlimit</em> (on that machine)</p></li>\n<li><p>The code samples are for demonstrative purposes only. That means that I didn't take into account error handling (I don't think there's any <strong><em>try</em></strong> / <strong><em>except</em></strong> / <strong><em>else</em></strong> / <strong><em>finally</em></strong> block), so the code is not robust (the reason is: to keep it as simple and short as possible). For <em>production</em>, error handling should be added as well</p></li>\n</ul>\n<h3>Other approaches:</h3>\n<ol>\n<li><p>Use <em>Python</em> only as a wrapper</p>\n<ul>\n<li>Everything is done using another technology</li>\n<li>That technology is invoked from <em>Python</em></li>\n<li><p>The most famous flavor that I know is what I call the <em>system administrator</em> approach:</p>\n<ul>\n<li>Use <em>Python</em> (or any programming language for that matter) in order to execute <em>shell</em> commands (and parse their outputs)</li>\n<li>Some consider this a neat hack</li>\n<li>I consider it more like a lame workaround (<em>gainarie</em>), as the action per se is performed from <em>shell</em> (<em>cmd</em> in this case), and thus doesn't have anything to do with <em>Python</em>.</li>\n<li>Filtering (<code>grep</code> / <code>findstr</code>) or output formatting could be done on both sides, but I'm not going to insist on it. Also, I deliberately used <code>os.system</code> instead of <code>subprocess.Popen</code>.</li>\n</ul>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">(py35x64_test) E:\\Work\\Dev\\StackOverflow\\q003207219&gt;\"e:\\Work\\Dev\\VEnvs\\py35x64_test\\Scripts\\python.exe\" -c \"import os;os.system(\\\"dir /b root_dir\\\")\"\ndir0\ndir1\ndir2\ndir3\nfile0\nfile1\n</code></pre>\n</blockquote></li>\n</ul>\n<p>In general this approach is to be avoided, since if some command output format slightly differs between <em>OS</em> versions/flavors, the parsing code should be adapted as well; not to mention differences between locales).</p></li>\n</ol>\n", "abstract": "When the question was asked, I imagine that Python 2, was the LTS version, however the code samples will be run by Python 3(.5) (I'll keep them as Python 2 compliant as possible; also, any code belonging to Python that I'm going to post, is from v3.5.4 - unless otherwise specified). That has consequences related to another keyword in the question: \"add them into a list\":  The examples will be based on a directory called root_dir with the following structure (this example is for Win, but I'm using the same tree on Lnx as well):  [Python 3]: os.listdir(path='.') Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order, and does not include the special entries '.' and '..' ...  A more elaborate example (code_os_listdir.py): Notes:  Output:  [Python 3]: os.scandir(path='.') (Python 3.5+, backport: [PyPI]: scandir) Return an iterator of os.DirEntry objects corresponding to the entries in the directory given by path. The entries are yielded in arbitrary order, and the special entries '.' and '..' are not included. Using scandir() instead of listdir() can significantly increase the performance of code that also needs file type or file attribute information, because os.DirEntry objects expose this information if the operating system provides it when scanning a directory. All os.DirEntry methods may perform a system call, but is_dir() and is_file() usually only require a system call for symbolic links; os.DirEntry.stat() always requires a system call on Unix but only requires one for symbolic links on Windows.  Notes:  [Python 3]: os.walk(top, topdown=True, onerror=None, followlinks=False) Generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory top (including top itself), it yields a 3-tuple (dirpath, dirnames, filenames).  Notes:  [Python 3]: glob.glob(pathname, *, recursive=False) ([Python 3]: glob.iglob(pathname, *, recursive=False)) Return a possibly-empty list of path names that match pathname, which must be a string containing a path specification. pathname can be either absolute (like /usr/src/Python-1.5/Makefile) or relative (like ../../Tools/*/*.gif), and can contain shell-style wildcards. Broken symlinks are included in the results (as in the shell)....Changed in version 3.5: Support for recursive globs using \u201c**\u201d.  Notes:  [Python 3]: class pathlib.Path(*pathsegments) (Python 3.4+, backport: [PyPI]: pathlib2) Notes:  [Python 2]: dircache.listdir(path) (Python 2 only)   [man7]: OPENDIR(3) / [man7]: READDIR(3) / [man7]: CLOSEDIR(3) via [Python 3]: ctypes - A foreign function library for Python (POSIX specific) ctypes is a foreign function library for Python. It provides C compatible data types, and allows calling functions in DLLs or shared libraries. It can be used to wrap these libraries in pure Python. code_ctypes.py: Notes:  Output:  [ActiveState.Docs]: win32file.FindFilesW (Win specific) Retrieves a list of matching filenames, using the Windows Unicode API. An interface to the API FindFirstFileW/FindNextFileW/Find close functions.  Notes:   Notes: Code is meant to be portable (except places that target a specific area - which are marked) or cross: Multiple path styles (absolute, relatives) were used across the above variants, to illustrate the fact that the \"tools\" used are flexible in this direction os.listdir and os.scandir use opendir / readdir / closedir ([MS.Docs]: FindFirstFileW function / [MS.Docs]: FindNextFileW function / [MS.Docs]: FindClose function) (via [GitHub]: python/cpython - (master) cpython/Modules/posixmodule.c) win32file.FindFilesW uses those (Win specific) functions as well (via [GitHub]: mhammond/pywin32 - (master) pywin32/win32/src/win32file.i) _get_dir_content (from point #1.) can be implemented using any of these approaches (some will require more work and some less) Nota bene! Since recursion is used, I must mention that I did some tests on my laptop (Win 10 x64), totally unrelated to this problem, and when the recursion level was reaching values somewhere in the (990 .. 1000) range (recursionlimit - 1000 (default)), I got StackOverflow :). If the directory tree exceeds that limit (I am not an FS expert, so I don't know if that is even possible), that could be a problem. \nI must also mention that I didn't try to increase recursionlimit because I have no experience in the area (how much can I increase it before having to also increase the stack at OS level), but in theory there will always be the possibility for failure, if the dir depth is larger than the highest possible recursionlimit (on that machine) The code samples are for demonstrative purposes only. That means that I didn't take into account error handling (I don't think there's any try / except / else / finally block), so the code is not robust (the reason is: to keep it as simple and short as possible). For production, error handling should be added as well Use Python only as a wrapper The most famous flavor that I know is what I call the system administrator approach: In general this approach is to be avoided, since if some command output format slightly differs between OS versions/flavors, the parsing code should be adapted as well; not to mention differences between locales)."}, {"id": 24652788, "score": 49, "vote": 0, "content": "<p>I really liked <a href=\"https://stackoverflow.com/a/3215392/901641\">adamk's answer</a>, suggesting that you use <code>glob()</code>, from the module of the same name. This allows you to have pattern matching with <code>*</code>s.</p>\n<p>But as other people pointed out in the comments, <code>glob()</code> can get tripped up over inconsistent slash directions. To help with that, I suggest you use the <code>join()</code> and <code>expanduser()</code> functions in the <code>os.path</code> module, and perhaps the <code>getcwd()</code> function in the <code>os</code> module, as well.</p>\n<p>As examples:</p>\n<pre><code class=\"python\">from glob import glob\n\n# Return everything under C:\\Users\\admin that contains a folder called wlp.\nglob('C:\\Users\\admin\\*\\wlp')\n</code></pre>\n<p>The above is terrible - the path has been hardcoded and will only ever work on Windows between the drive name and the <code>\\</code>s being hardcoded into the path.</p>\n<pre><code class=\"python\">from glob    import glob\nfrom os.path import join\n\n# Return everything under Users, admin, that contains a folder called wlp.\nglob(join('Users', 'admin', '*', 'wlp'))\n</code></pre>\n<p>The above works better, but it relies on the folder name <code>Users</code> which is often found on Windows and not so often found on other OSs. It also relies on the user having a specific name, <code>admin</code>.</p>\n<pre><code class=\"python\">from glob    import glob\nfrom os.path import expanduser, join\n\n# Return everything under the user directory that contains a folder called wlp.\nglob(join(expanduser('~'), '*', 'wlp'))\n</code></pre>\n<p>This works perfectly across all platforms.</p>\n<p>Another great example that works perfectly across platforms and does something a bit different:</p>\n<pre><code class=\"python\">from glob    import glob\nfrom os      import getcwd\nfrom os.path import join\n\n# Return everything under the current directory that contains a folder called wlp.\nglob(join(getcwd(), '*', 'wlp'))\n</code></pre>\n<p>Hope these examples help you see the power of a few of the functions you can find in the standard Python library modules.</p>\n", "abstract": "I really liked adamk's answer, suggesting that you use glob(), from the module of the same name. This allows you to have pattern matching with *s. But as other people pointed out in the comments, glob() can get tripped up over inconsistent slash directions. To help with that, I suggest you use the join() and expanduser() functions in the os.path module, and perhaps the getcwd() function in the os module, as well. As examples: The above is terrible - the path has been hardcoded and will only ever work on Windows between the drive name and the \\s being hardcoded into the path. The above works better, but it relies on the folder name Users which is often found on Windows and not so often found on other OSs. It also relies on the user having a specific name, admin. This works perfectly across all platforms. Another great example that works perfectly across platforms and does something a bit different: Hope these examples help you see the power of a few of the functions you can find in the standard Python library modules."}, {"id": 24145985, "score": 39, "vote": 0, "content": "<pre><code class=\"python\">def list_files(path):\n    # returns a list of names (with extension, without full path) of all files \n    # in folder path\n    files = []\n    for name in os.listdir(path):\n        if os.path.isfile(os.path.join(path, name)):\n            files.append(name)\n    return files \n</code></pre>\n", "abstract": ""}, {"id": 22990477, "score": 25, "vote": 0, "content": "<p>If you are looking for a Python implementation of <strong>find</strong>, this is a recipe I use rather frequently:</p>\n<pre><code class=\"python\">from findtools.find_files import (find_files, Match)\n\n# Recursively find all *.sh files in **/usr/bin**\nsh_files_pattern = Match(filetype='f', name='*.sh')\nfound_files = find_files(path='/usr/bin', match=sh_files_pattern)\n\nfor found_file in found_files:\n    print found_file\n</code></pre>\n<p>So I made a PyPI <a href=\"https://pypi.python.org/pypi/findtools/\" rel=\"noreferrer\">package</a> out of it and there is also a <a href=\"https://github.com/ewiger/findtools\" rel=\"noreferrer\">GitHub repository</a>. I hope that someone finds it potentially useful for this code.</p>\n", "abstract": "If you are looking for a Python implementation of find, this is a recipe I use rather frequently: So I made a PyPI package out of it and there is also a GitHub repository. I hope that someone finds it potentially useful for this code."}, {"id": 54107684, "score": 15, "vote": 0, "content": "<p>For greater results, you can use <code>listdir()</code> method of the <code>os</code> module along with a generator (a generator is a powerful iterator that keeps its state, remember?). The following code works fine with both versions: Python 2 and Python 3.</p>\n<p>Here's a code:</p>\n<pre><code class=\"python\">import os\n\ndef files(path):  \n    for file in os.listdir(path):\n        if os.path.isfile(os.path.join(path, file)):\n            yield file\n\nfor file in files(\".\"):  \n    print (file)\n</code></pre>\n<p>The <code>listdir()</code> method returns the list of entries for the given directory. The method <code>os.path.isfile()</code> returns <code>True</code> if the given entry is a file. And the <code>yield</code> operator quits the func but keeps its current state, and it returns only the name of the entry detected as a file. All the above allows us to loop over the generator function.</p>\n", "abstract": "For greater results, you can use listdir() method of the os module along with a generator (a generator is a powerful iterator that keeps its state, remember?). The following code works fine with both versions: Python 2 and Python 3. Here's a code: The listdir() method returns the list of entries for the given directory. The method os.path.isfile() returns True if the given entry is a file. And the yield operator quits the func but keeps its current state, and it returns only the name of the entry detected as a file. All the above allows us to loop over the generator function."}, {"id": 24209884, "score": 11, "vote": 0, "content": "<p><strong>Returning a list of absolute filepaths, does not recurse into subdirectories</strong></p>\n<pre><code class=\"python\">L = [os.path.join(os.getcwd(),f) for f in os.listdir('.') if os.path.isfile(os.path.join(os.getcwd(),f))]\n</code></pre>\n", "abstract": "Returning a list of absolute filepaths, does not recurse into subdirectories"}, {"id": 55321475, "score": 11, "vote": 0, "content": "<p>A wise teacher told me once that:</p>\n<blockquote>\n<p>When there are several established ways to do something, none of them is good for all cases.</p>\n</blockquote>\n<p>I will thus add a solution for a <strong>subset</strong> of the problem: quite often, we only want to check whether a file matches a start string and an end string, without going into subdirectories. We would thus like a function that returns a list of filenames, like:</p>\n<pre><code class=\"python\">filenames = dir_filter('foo/baz', radical='radical', extension='.txt')\n</code></pre>\n<p>If you care to first declare two functions, this can be done:</p>\n<pre><code class=\"python\">def file_filter(filename, radical='', extension=''):\n    \"Check if a filename matches a radical and extension\"\n    if not filename:\n        return False\n    filename = filename.strip()\n    return(filename.startswith(radical) and filename.endswith(extension))\n\ndef dir_filter(dirname='', radical='', extension=''):\n    \"Filter filenames in directory according to radical and extension\"\n    if not dirname:\n        dirname = '.'\n    return [filename for filename in os.listdir(dirname)\n                if file_filter(filename, radical, extension)]\n</code></pre>\n<p>This solution could be easily generalized with regular expressions (and you might want to add a <code>pattern</code> argument, if you do not want your patterns to always stick to the start or end of the filename).</p>\n", "abstract": "A wise teacher told me once that: When there are several established ways to do something, none of them is good for all cases. I will thus add a solution for a subset of the problem: quite often, we only want to check whether a file matches a start string and an end string, without going into subdirectories. We would thus like a function that returns a list of filenames, like: If you care to first declare two functions, this can be done: This solution could be easily generalized with regular expressions (and you might want to add a pattern argument, if you do not want your patterns to always stick to the start or end of the filename)."}, {"id": 50927977, "score": 10, "vote": 0, "content": "<pre><code class=\"python\">import os\nimport os.path\n\n\ndef get_files(target_dir):\n    item_list = os.listdir(target_dir)\n\n    file_list = list()\n    for item in item_list:\n        item_dir = os.path.join(target_dir,item)\n        if os.path.isdir(item_dir):\n            file_list += get_files(item_dir)\n        else:\n            file_list.append(item_dir)\n    return file_list\n</code></pre>\n<p>Here I use a recursive structure.</p>\n", "abstract": "Here I use a recursive structure."}, {"id": 40926538, "score": 8, "vote": 0, "content": "<p>Using generators</p>\n<pre><code class=\"python\">import os\ndef get_files(search_path):\n     for (dirpath, _, filenames) in os.walk(search_path):\n         for filename in filenames:\n             yield os.path.join(dirpath, filename)\nlist_files = get_files('.')\nfor filename in list_files:\n    print(filename)\n</code></pre>\n", "abstract": "Using generators"}, {"id": 49534391, "score": 7, "vote": 0, "content": "<p>Another very readable variant for Python 3.4+ is using pathlib.Path.glob:</p>\n<pre><code class=\"python\">from pathlib import Path\nfolder = '/foo'\n[f for f in Path(folder).glob('*') if f.is_file()]\n</code></pre>\n<p>It is simple to make more specific, e.g. only look for Python source files which are not symbolic links, also in all subdirectories:</p>\n<pre><code class=\"python\">[f for f in Path(folder).glob('**/*.py') if not f.is_symlink()]\n</code></pre>\n", "abstract": "Another very readable variant for Python 3.4+ is using pathlib.Path.glob: It is simple to make more specific, e.g. only look for Python source files which are not symbolic links, also in all subdirectories:"}, {"id": 52885096, "score": 4, "vote": 0, "content": "<p>For Python 2:</p>\n<pre><code class=\"python\">pip install rglob\n</code></pre>\n<p>Then do</p>\n<pre><code class=\"python\">import rglob\nfile_list = rglob.rglob(\"/home/base/dir/\", \"*\")\nprint file_list\n</code></pre>\n", "abstract": "For Python 2: Then do"}, {"id": 47703002, "score": 3, "vote": 0, "content": "<p>Here's my general-purpose function for this.  It returns a list of file paths rather than filenames since I found that to be more useful.  It has a few optional arguments that make it versatile.  For instance, I often use it with arguments like <code>pattern='*.txt'</code> or <code>subfolders=True</code>.</p>\n<pre><code class=\"python\">import os\nimport fnmatch\n\ndef list_paths(folder='.', pattern='*', case_sensitive=False, subfolders=False):\n    \"\"\"Return a list of the file paths matching the pattern in the specified \n    folder, optionally including files inside subfolders.\n    \"\"\"\n    match = fnmatch.fnmatchcase if case_sensitive else fnmatch.fnmatch\n    walked = os.walk(folder) if subfolders else [next(os.walk(folder))]\n    return [os.path.join(root, f)\n            for root, dirnames, filenames in walked\n            for f in filenames if match(f, pattern)]\n</code></pre>\n", "abstract": "Here's my general-purpose function for this.  It returns a list of file paths rather than filenames since I found that to be more useful.  It has a few optional arguments that make it versatile.  For instance, I often use it with arguments like pattern='*.txt' or subfolders=True."}, {"id": 47758562, "score": 3, "vote": 0, "content": "<p>I will provide a sample one liner where sourcepath and file type can be provided as input. The code returns a list of filenames with csv extension. Use <em>.</em> in case all files needs to be returned. This will also recursively scans the subdirectories. </p>\n<p><code>[y for x in os.walk(sourcePath) for y in glob(os.path.join(x[0], '*.csv'))]</code></p>\n<p>Modify file extensions and source path as needed. </p>\n", "abstract": "I will provide a sample one liner where sourcepath and file type can be provided as input. The code returns a list of filenames with csv extension. Use . in case all files needs to be returned. This will also recursively scans the subdirectories.  [y for x in os.walk(sourcePath) for y in glob(os.path.join(x[0], '*.csv'))] Modify file extensions and source path as needed. "}, {"id": 11647676, "score": 1, "vote": 0, "content": "<p><em><a href=\"http://docs.python.org/release/2.6.7/library/dircache.html\" rel=\"nofollow noreferrer\">dircache</a> is  \"Deprecated since version 2.6: The dircache module has been removed in Python 3.0.\"</em></p>\n<pre><code class=\"python\">import dircache\nlist = dircache.listdir(pathname)\ni = 0\ncheck = len(list[0])\ntemp = []\ncount = len(list)\nwhile count != 0:\n  if len(list[i]) != check:\n     temp.append(list[i-1])\n     check = len(list[i])\n  else:\n    i = i + 1\n    count = count - 1\n\nprint temp\n</code></pre>\n", "abstract": "dircache is  \"Deprecated since version 2.6: The dircache module has been removed in Python 3.0.\""}]}, {"link": "https://stackoverflow.com/questions/606191/convert-bytes-to-a-string", "question": {"id": "606191", "title": "Convert bytes to a string", "content": "<p>I captured the standard output of an external program into a <code>bytes</code> object:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; from subprocess import *\n&gt;&gt;&gt; command_stdout = Popen(['ls', '-l'], stdout=PIPE).communicate()[0]\n&gt;&gt;&gt;\n&gt;&gt;&gt; command_stdout\nb'total 0\\n-rw-rw-r-- 1 thomas thomas 0 Mar  3 07:03 file1\\n-rw-rw-r-- 1 thomas thomas 0 Mar  3 07:03 file2\\n'\n</code></pre>\n<p>I want to convert that to a normal Python string, so that I can print it like this:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; print(command_stdout)\n-rw-rw-r-- 1 thomas thomas 0 Mar  3 07:03 file1\n-rw-rw-r-- 1 thomas thomas 0 Mar  3 07:03 file2\n</code></pre>\n<p>I tried the <a href=\"http://docs.python.org/3.0/library/binascii.html?highlight=b2a#binascii.b2a_qp\" rel=\"noreferrer\"><code>binascii.b2a_qp()</code></a> method, but got the same <code>bytes</code> object again:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; binascii.b2a_qp(command_stdout)\nb'total 0\\n-rw-rw-r-- 1 thomas thomas 0 Mar  3 07:03 file1\\n-rw-rw-r-- 1 thomas thomas 0 Mar  3 07:03 file2\\n'\n</code></pre>\n<p>How do I convert the <code>bytes</code> object to a <code>str</code> with Python\u00a03?</p>\n", "abstract": "I captured the standard output of an external program into a bytes object: I want to convert that to a normal Python string, so that I can print it like this: I tried the binascii.b2a_qp() method, but got the same bytes object again: How do I convert the bytes object to a str with Python\u00a03?"}, "answers": [{"id": 606199, "score": 5302, "vote": 0, "content": "<p><a href=\"https://docs.python.org/3/library/stdtypes.html#bytes.decode\" rel=\"noreferrer\">Decode the <code>bytes</code> object</a> to produce a string:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; b\"abcde\".decode(\"utf-8\") \n'abcde'\n</code></pre>\n<p>The above example <em>assumes</em> that the <code>bytes</code> object is in UTF-8, because it is a common encoding. However, you should use the encoding your data is actually in!</p>\n", "abstract": "Decode the bytes object to produce a string: The above example assumes that the bytes object is in UTF-8, because it is a common encoding. However, you should use the encoding your data is actually in!"}, {"id": 606205, "score": 383, "vote": 0, "content": "<p>Decode the byte string and turn it in to a character (Unicode) string.</p>\n<hr/>\n<p>Python 3:</p>\n<pre><code class=\"python\">encoding = 'utf-8'\nb'hello'.decode(encoding)\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">str(b'hello', encoding)\n</code></pre>\n<hr/>\n<p>Python 2:</p>\n<pre><code class=\"python\">encoding = 'utf-8'\n'hello'.decode(encoding)\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">unicode('hello', encoding)\n</code></pre>\n", "abstract": "Decode the byte string and turn it in to a character (Unicode) string. Python 3: or Python 2: or"}, {"id": 12073686, "score": 253, "vote": 0, "content": "<p>This joins together a list of bytes into a string:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; bytes_data = [112, 52, 52]\n&gt;&gt;&gt; \"\".join(map(chr, bytes_data))\n'p44'\n</code></pre>\n", "abstract": "This joins together a list of bytes into a string:"}, {"id": 27527728, "score": 126, "vote": 0, "content": "<p>If you don't know the encoding, then to read binary input into string in Python 3 and Python 2 compatible way, use the ancient MS-DOS <a href=\"https://en.wikipedia.org/wiki/Code_page_437\" rel=\"noreferrer\">CP437</a> encoding:</p>\n<pre><code class=\"python\">PY3K = sys.version_info &gt;= (3, 0)\n\nlines = []\nfor line in stream:\n    if not PY3K:\n        lines.append(line)\n    else:\n        lines.append(line.decode('cp437'))\n</code></pre>\n<p>Because encoding is unknown, expect non-English symbols to translate to characters of <code>cp437</code> (English characters are not translated, because they match in most single byte encodings and UTF-8).</p>\n<p>Decoding arbitrary binary input to UTF-8 is unsafe, because you may get this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; b'\\x00\\x01\\xffsd'.decode('utf-8')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 2: invalid\nstart byte\n</code></pre>\n<p>The same applies to <code>latin-1</code>, which was popular (the default?) for Python 2. See the missing points in <a href=\"https://en.wikipedia.org/wiki/ISO/IEC_8859-1#Codepage_layout\" rel=\"noreferrer\">Codepage Layout</a> - it is where Python chokes with infamous <code>ordinal not in range</code>.</p>\n<p><strong>UPDATE 20150604</strong>: There are rumors that Python 3 has the <code>surrogateescape</code> error strategy for encoding stuff into binary data without data loss and crashes, but it needs conversion tests, <code>[binary] -&gt; [str] -&gt; [binary]</code>, to validate both performance and reliability.</p>\n<p><strong>UPDATE 20170116</strong>: Thanks to comment by Nearoo - there is also a possibility to slash escape all unknown bytes with <code>backslashreplace</code> error handler. That works only for Python 3, so even with this workaround you will still get inconsistent output from different Python versions:</p>\n<pre><code class=\"python\">PY3K = sys.version_info &gt;= (3, 0)\n\nlines = []\nfor line in stream:\n    if not PY3K:\n        lines.append(line)\n    else:\n        lines.append(line.decode('utf-8', 'backslashreplace'))\n</code></pre>\n<p>See <em><a href=\"https://docs.python.org/3/howto/unicode.html#python-s-unicode-support\" rel=\"noreferrer\">Python\u2019s Unicode Support</a></em> for details.</p>\n<p><strong>UPDATE 20170119</strong>: I decided to implement slash escaping decode that works for both Python\u00a02 and Python\u00a03. It should be slower than the <code>cp437</code> solution, but it should produce <strong>identical results</strong> on every Python version.</p>\n<pre><code class=\"python\"># --- preparation\n\nimport codecs\n\ndef slashescape(err):\n    \"\"\" codecs error handler. err is UnicodeDecode instance. return\n    a tuple with a replacement for the unencodable part of the input\n    and a position where encoding should continue\"\"\"\n    #print err, dir(err), err.start, err.end, err.object[:err.start]\n    thebyte = err.object[err.start:err.end]\n    repl = u'\\\\x'+hex(ord(thebyte))[2:]\n    return (repl, err.end)\n\ncodecs.register_error('slashescape', slashescape)\n\n# --- processing\n\nstream = [b'\\x80abc']\n\nlines = []\nfor line in stream:\n    lines.append(line.decode('utf-8', 'slashescape'))\n</code></pre>\n", "abstract": "If you don't know the encoding, then to read binary input into string in Python 3 and Python 2 compatible way, use the ancient MS-DOS CP437 encoding: Because encoding is unknown, expect non-English symbols to translate to characters of cp437 (English characters are not translated, because they match in most single byte encodings and UTF-8). Decoding arbitrary binary input to UTF-8 is unsafe, because you may get this: The same applies to latin-1, which was popular (the default?) for Python 2. See the missing points in Codepage Layout - it is where Python chokes with infamous ordinal not in range. UPDATE 20150604: There are rumors that Python 3 has the surrogateescape error strategy for encoding stuff into binary data without data loss and crashes, but it needs conversion tests, [binary] -> [str] -> [binary], to validate both performance and reliability. UPDATE 20170116: Thanks to comment by Nearoo - there is also a possibility to slash escape all unknown bytes with backslashreplace error handler. That works only for Python 3, so even with this workaround you will still get inconsistent output from different Python versions: See Python\u2019s Unicode Support for details. UPDATE 20170119: I decided to implement slash escaping decode that works for both Python\u00a02 and Python\u00a03. It should be slower than the cp437 solution, but it should produce identical results on every Python version."}, {"id": 38102444, "score": 117, "vote": 0, "content": "<p><a href=\"https://docs.python.org/3/library/stdtypes.html#bytes.decode\" rel=\"noreferrer\">In Python 3</a>, the default encoding is <code>\"utf-8\"</code>, so you can directly use:</p>\n<pre><code class=\"python\">b'hello'.decode()\n</code></pre>\n<p>which is equivalent to</p>\n<pre><code class=\"python\">b'hello'.decode(encoding=\"utf-8\")\n</code></pre>\n<p>On the other hand, <a href=\"https://docs.python.org/2.7/library/stdtypes.html#str.decode\" rel=\"noreferrer\">in Python 2</a>, encoding defaults to the default string encoding. Thus, you should use:</p>\n<pre><code class=\"python\">b'hello'.decode(encoding)\n</code></pre>\n<p>where <code>encoding</code> is the encoding you want.</p>\n<p><a href=\"https://docs.python.org/2.7/library/stdtypes.html#str.decode\" rel=\"noreferrer\"><strong>Note:</strong></a> support for keyword arguments was added in Python\u00a02.7.</p>\n", "abstract": "In Python 3, the default encoding is \"utf-8\", so you can directly use: which is equivalent to On the other hand, in Python 2, encoding defaults to the default string encoding. Thus, you should use: where encoding is the encoding you want. Note: support for keyword arguments was added in Python\u00a02.7."}, {"id": 6738578, "score": 49, "vote": 0, "content": "<p>I think you actually want this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from subprocess import *\n&gt;&gt;&gt; command_stdout = Popen(['ls', '-l'], stdout=PIPE).communicate()[0]\n&gt;&gt;&gt; command_text = command_stdout.decode(encoding='windows-1252')\n</code></pre>\n<p>Aaron's answer was correct, except that you need to know <em>which</em> encoding to use. And I believe that Windows uses 'windows-1252'. It will only matter if you have some unusual (non-ASCII) characters in your content, but then it will make a difference.</p>\n<p>By the way, the fact that it <em>does</em> matter is the reason that Python moved to using two different types for binary and text data: it can't convert magically between them, because it doesn't know the encoding unless you tell it! The only way YOU would know is to read the Windows documentation (or read it here).</p>\n", "abstract": "I think you actually want this: Aaron's answer was correct, except that you need to know which encoding to use. And I believe that Windows uses 'windows-1252'. It will only matter if you have some unusual (non-ASCII) characters in your content, but then it will make a difference. By the way, the fact that it does matter is the reason that Python moved to using two different types for binary and text data: it can't convert magically between them, because it doesn't know the encoding unless you tell it! The only way YOU would know is to read the Windows documentation (or read it here)."}, {"id": 50630091, "score": 42, "vote": 0, "content": "<p>Since this question is actually asking about <code>subprocess</code> output, you have more direct approaches available. The most modern would be using <a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.check_output\" rel=\"noreferrer\"><code>subprocess.check_output</code></a> and passing <code>text=True</code> (Python 3.7+) to automatically decode stdout using the system default coding:</p>\n<pre><code class=\"python\">text = subprocess.check_output([\"ls\", \"-l\"], text=True)\n</code></pre>\n<p>For Python 3.6, <code>Popen</code> accepts an <a href=\"https://docs.python.org/3/library/subprocess.html#frequently-used-arguments\" rel=\"noreferrer\"><em>encoding</em></a> keyword:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from subprocess import Popen, PIPE\n&gt;&gt;&gt; text = Popen(['ls', '-l'], stdout=PIPE, encoding='utf-8').communicate()[0]\n&gt;&gt;&gt; type(text)\nstr\n&gt;&gt;&gt; print(text)\ntotal 0\n-rw-r--r-- 1 wim badger 0 May 31 12:45 some_file.txt\n</code></pre>\n<p>The general answer to the question in the title, if you're not dealing with subprocess output, is to <em>decode</em> bytes to text:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; b'abcde'.decode()\n'abcde'\n</code></pre>\n<p>With no argument, <a href=\"https://docs.python.org/3/library/sys.html#sys.getdefaultencoding\" rel=\"noreferrer\"><code>sys.getdefaultencoding()</code></a> will be used.  If your data is not <code>sys.getdefaultencoding()</code>, then you must specify the encoding explicitly in the <a href=\"https://docs.python.org/3/library/stdtypes.html#bytes.decode\" rel=\"noreferrer\"><code>decode</code></a> call:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; b'caf\\xe9'.decode('cp1250')\n'caf\u00e9'\n</code></pre>\n", "abstract": "Since this question is actually asking about subprocess output, you have more direct approaches available. The most modern would be using subprocess.check_output and passing text=True (Python 3.7+) to automatically decode stdout using the system default coding: For Python 3.6, Popen accepts an encoding keyword: The general answer to the question in the title, if you're not dealing with subprocess output, is to decode bytes to text: With no argument, sys.getdefaultencoding() will be used.  If your data is not sys.getdefaultencoding(), then you must specify the encoding explicitly in the decode call:"}, {"id": 21262396, "score": 38, "vote": 0, "content": "<p>Set universal_newlines to True, i.e.</p>\n<pre><code class=\"python\">command_stdout = Popen(['ls', '-l'], stdout=PIPE, universal_newlines=True).communicate()[0]\n</code></pre>\n", "abstract": "Set universal_newlines to True, i.e."}, {"id": 40628661, "score": 34, "vote": 0, "content": "<p>To interpret a byte sequence as a text, you have to know the\ncorresponding character encoding:</p>\n<pre><code class=\"python\">unicode_text = bytestring.decode(character_encoding)\n</code></pre>\n<p>Example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; b'\\xc2\\xb5'.decode('utf-8')\n'\u00b5'\n</code></pre>\n<p><code>ls</code> command may produce output that can't be interpreted as text. File names\non Unix may be any sequence of bytes except slash <code>b'/'</code> and zero\n<code>b'\\0'</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; open(bytes(range(0x100)).translate(None, b'\\0/'), 'w').close()\n</code></pre>\n<p>Trying to decode such byte soup using utf-8 encoding raises <code>UnicodeDecodeError</code>.</p>\n<p>It can be worse. The decoding may fail silently and produce <a href=\"https://en.wikipedia.org/wiki/Mojibake\" rel=\"noreferrer\">mojibake</a>\nif you use a wrong incompatible encoding:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; '\u2014'.encode('utf-8').decode('cp1252')\n'\u00e2\u20ac\u201d'\n</code></pre>\n<p>The data is corrupted but your program remains unaware that a failure\nhas occurred.</p>\n<p>In general, what character encoding to use is not embedded in the byte sequence itself. You have to communicate this info out-of-band. Some outcomes are more likely than others and therefore <code>chardet</code> module exists that can <em>guess</em> the character encoding. A single Python script may use multiple character encodings in different places.</p>\n<hr/>\n<p><code>ls</code> output can be converted to a Python string using <code>os.fsdecode()</code>\nfunction that succeeds even for <a href=\"https://www.python.org/dev/peps/pep-0383/\" rel=\"noreferrer\">undecodable\nfilenames</a> (it uses\n<code>sys.getfilesystemencoding()</code> and <code>surrogateescape</code> error handler on\nUnix):</p>\n<pre><code class=\"python\">import os\nimport subprocess\n\noutput = os.fsdecode(subprocess.check_output('ls'))\n</code></pre>\n<p>To get the original bytes, you could use <code>os.fsencode()</code>.</p>\n<p>If you pass <code>universal_newlines=True</code> parameter then <code>subprocess</code> uses\n<code>locale.getpreferredencoding(False)</code> to decode bytes e.g., it can be\n<code>cp1252</code> on Windows.</p>\n<p>To decode the byte stream on-the-fly,\n<a href=\"https://docs.python.org/3/library/io.html#io.TextIOWrapper\" rel=\"noreferrer\"><code>io.TextIOWrapper()</code></a>\ncould be used: <a href=\"https://stackoverflow.com/a/25945031/4279\">example</a>.</p>\n<p>Different commands may use different character encodings for their\noutput e.g., <code>dir</code> internal command (<code>cmd</code>) may use cp437. To decode its\noutput, you could pass the encoding explicitly (Python 3.6+):</p>\n<pre><code class=\"python\">output = subprocess.check_output('dir', shell=True, encoding='cp437')\n</code></pre>\n<p>The filenames may differ from <code>os.listdir()</code> (which uses Windows\nUnicode API) e.g., <code>'\\xb6'</code> can be substituted with <code>'\\x14'</code>\u2014Python's\ncp437 codec maps <code>b'\\x14'</code> to control character U+0014 instead of\nU+00B6 (\u00b6). To support filenames with arbitrary Unicode characters, see  <a href=\"https://stackoverflow.com/q/33936074/4279\">Decode PowerShell output possibly containing non-ASCII Unicode characters into a Python string</a></p>\n", "abstract": "To interpret a byte sequence as a text, you have to know the\ncorresponding character encoding: Example: ls command may produce output that can't be interpreted as text. File names\non Unix may be any sequence of bytes except slash b'/' and zero\nb'\\0': Trying to decode such byte soup using utf-8 encoding raises UnicodeDecodeError. It can be worse. The decoding may fail silently and produce mojibake\nif you use a wrong incompatible encoding: The data is corrupted but your program remains unaware that a failure\nhas occurred. In general, what character encoding to use is not embedded in the byte sequence itself. You have to communicate this info out-of-band. Some outcomes are more likely than others and therefore chardet module exists that can guess the character encoding. A single Python script may use multiple character encodings in different places. ls output can be converted to a Python string using os.fsdecode()\nfunction that succeeds even for undecodable\nfilenames (it uses\nsys.getfilesystemencoding() and surrogateescape error handler on\nUnix): To get the original bytes, you could use os.fsencode(). If you pass universal_newlines=True parameter then subprocess uses\nlocale.getpreferredencoding(False) to decode bytes e.g., it can be\ncp1252 on Windows. To decode the byte stream on-the-fly,\nio.TextIOWrapper()\ncould be used: example. Different commands may use different character encodings for their\noutput e.g., dir internal command (cmd) may use cp437. To decode its\noutput, you could pass the encoding explicitly (Python 3.6+): The filenames may differ from os.listdir() (which uses Windows\nUnicode API) e.g., '\\xb6' can be substituted with '\\x14'\u2014Python's\ncp437 codec maps b'\\x14' to control character U+0014 instead of\nU+00B6 (\u00b6). To support filenames with arbitrary Unicode characters, see  Decode PowerShell output possibly containing non-ASCII Unicode characters into a Python string"}, {"id": 33690538, "score": 28, "vote": 0, "content": "<p>While <a href=\"https://stackoverflow.com/a/33688948/1587329\">@Aaron Maenpaa's answer</a> just works, a user <a href=\"https://stackoverflow.com/questions/33688837/urllib-for-python-3/33688948#comment55151210_33688948\">recently asked</a>:</p>\n<blockquote>\n<p>Is there any more simply way? 'fhand.read().decode(\"ASCII\")' [...] It's so long!</p>\n</blockquote>\n<p>You can use:</p>\n<pre><code class=\"python\">command_stdout.decode()\n</code></pre>\n<p><code>decode()</code> has a <a href=\"https://docs.python.org/3/library/stdtypes.html#bytes-and-bytearray-operations\" rel=\"noreferrer\">standard argument</a>:</p>\n<blockquote>\n<p><code>codecs.decode(obj, encoding='utf-8', errors='strict')</code></p>\n</blockquote>\n", "abstract": "While @Aaron Maenpaa's answer just works, a user recently asked: Is there any more simply way? 'fhand.read().decode(\"ASCII\")' [...] It's so long! You can use: decode() has a standard argument: codecs.decode(obj, encoding='utf-8', errors='strict')"}, {"id": 47426743, "score": 20, "vote": 0, "content": "<p>If you should get the following by trying <code>decode()</code>:</p>\n<blockquote>\n<p>AttributeError: 'str' object has no attribute 'decode'</p>\n</blockquote>\n<p>You can also specify the encoding type straight in a cast:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; my_byte_str\nb'Hello World'\n\n&gt;&gt;&gt; str(my_byte_str, 'utf-8')\n'Hello World'\n</code></pre>\n", "abstract": "If you should get the following by trying decode(): AttributeError: 'str' object has no attribute 'decode' You can also specify the encoding type straight in a cast:"}, {"id": 69656994, "score": 18, "vote": 0, "content": "<p>If you have had this error:</p>\n<blockquote>\n<p>utf-8 codec can't decode byte 0x8a,</p>\n</blockquote>\n<p>then it is better to use the following code to convert bytes to a string:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">bytes = b\"abcdefg\"\nstring = bytes.decode(\"utf-8\", \"ignore\") \n</code></pre>\n", "abstract": "If you have had this error: utf-8 codec can't decode byte 0x8a, then it is better to use the following code to convert bytes to a string:"}, {"id": 72701513, "score": 15, "vote": 0, "content": "<h2>Bytes</h2>\n<pre><code class=\"python\">m=b'This is bytes'\n</code></pre>\n<h2><em><strong>Converting to string</strong></em></h2>\n<h2>Method 1</h2>\n<pre><code class=\"python\">m.decode(\"utf-8\")\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">m.decode()\n</code></pre>\n<h2>Method 2</h2>\n<pre><code class=\"python\">import codecs\ncodecs.decode(m,encoding=\"utf-8\")\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">import codecs\ncodecs.decode(m)\n</code></pre>\n<h2>Method 3</h2>\n<pre><code class=\"python\">str(m,encoding=\"utf-8\")\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">str(m)[2:-1]\n</code></pre>\n<h2>Result</h2>\n<pre><code class=\"python\">'This is bytes'\n</code></pre>\n", "abstract": "or or or"}, {"id": 37557475, "score": 9, "vote": 0, "content": "<p>I made a function to clean a list</p>\n<pre><code class=\"python\">def cleanLists(self, lista):\n    lista = [x.strip() for x in lista]\n    lista = [x.replace('\\n', '') for x in lista]\n    lista = [x.replace('\\b', '') for x in lista]\n    lista = [x.encode('utf8') for x in lista]\n    lista = [x.decode('utf8') for x in lista]\n\n    return lista\n</code></pre>\n", "abstract": "I made a function to clean a list"}, {"id": 41713500, "score": 9, "vote": 0, "content": "<p>For Python 3, this is a much safer and <em>Pythonic</em> approach to convert from <code>byte</code> to <code>string</code>:</p>\n<pre><code class=\"python\">def byte_to_str(bytes_or_str):\n    if isinstance(bytes_or_str, bytes): # Check if it's in bytes\n        print(bytes_or_str.decode('utf-8'))\n    else:\n        print(\"Object not of byte type\")\n\nbyte_to_str(b'total 0\\n-rw-rw-r-- 1 thomas thomas 0 Mar  3 07:03 file1\\n-rw-rw-r-- 1 thomas thomas 0 Mar  3 07:03 file2\\n')\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">total 0\n-rw-rw-r-- 1 thomas thomas 0 Mar  3 07:03 file1\n-rw-rw-r-- 1 thomas thomas 0 Mar  3 07:03 file2\n</code></pre>\n", "abstract": "For Python 3, this is a much safer and Pythonic approach to convert from byte to string: Output:"}, {"id": 49321964, "score": 9, "vote": 0, "content": "<p>When working with data from Windows systems (with <code>\\r\\n</code> line endings), my answer is</p>\n<pre><code class=\"python\">String = Bytes.decode(\"utf-8\").replace(\"\\r\\n\", \"\\n\")\n</code></pre>\n<p>Why? Try this with a multiline Input.txt:</p>\n<pre><code class=\"python\">Bytes = open(\"Input.txt\", \"rb\").read()\nString = Bytes.decode(\"utf-8\")\nopen(\"Output.txt\", \"w\").write(String)\n</code></pre>\n<p>All your line endings will be doubled (to <code>\\r\\r\\n</code>), leading to extra empty lines. Python's text-read functions usually normalize line endings so that strings use only <code>\\n</code>. If you receive binary data from a Windows system, Python does not have a chance to do that. Thus,</p>\n<pre><code class=\"python\">Bytes = open(\"Input.txt\", \"rb\").read()\nString = Bytes.decode(\"utf-8\").replace(\"\\r\\n\", \"\\n\")\nopen(\"Output.txt\", \"w\").write(String)\n</code></pre>\n<p>will replicate your original file.</p>\n", "abstract": "When working with data from Windows systems (with \\r\\n line endings), my answer is Why? Try this with a multiline Input.txt: All your line endings will be doubled (to \\r\\r\\n), leading to extra empty lines. Python's text-read functions usually normalize line endings so that strings use only \\n. If you receive binary data from a Windows system, Python does not have a chance to do that. Thus, will replicate your original file."}, {"id": 21059713, "score": 5, "vote": 0, "content": "<p>From <em><a href=\"http://docs.python.org/3/library/sys.html\" rel=\"nofollow noreferrer\">sys \u2014 System-specific parameters and functions</a></em>:</p>\n<p>To write or read binary data from/to the standard streams, use the underlying binary buffer. For example, to write bytes to stdout, use <code>sys.stdout.buffer.write(b'abc')</code>.</p>\n", "abstract": "From sys \u2014 System-specific parameters and functions: To write or read binary data from/to the standard streams, use the underlying binary buffer. For example, to write bytes to stdout, use sys.stdout.buffer.write(b'abc')."}, {"id": 57396484, "score": 5, "vote": 0, "content": "<p>For your <em>specific</em> case of \"run a shell command and get its output as text instead of bytes\", on Python 3.7, you should use <a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.run\" rel=\"noreferrer\"><code>subprocess.run</code></a> and pass in <code>text=True</code> (as well as <code>capture_output=True</code> to capture the output)</p>\n<pre><code class=\"python\">command_result = subprocess.run([\"ls\", \"-l\"], capture_output=True, text=True)\ncommand_result.stdout  # is a `str` containing your program's stdout\n</code></pre>\n<p><code>text</code> used to be called <code>universal_newlines</code>, and was changed (well, aliased) in Python 3.7. If you want to support Python versions before 3.7, pass in <code>universal_newlines=True</code> instead of <code>text=True</code></p>\n", "abstract": "For your specific case of \"run a shell command and get its output as text instead of bytes\", on Python 3.7, you should use subprocess.run and pass in text=True (as well as capture_output=True to capture the output) text used to be called universal_newlines, and was changed (well, aliased) in Python 3.7. If you want to support Python versions before 3.7, pass in universal_newlines=True instead of text=True"}, {"id": 71237288, "score": 5, "vote": 0, "content": "<p>We can decode the bytes object to produce a string using <code>bytes.decode(encoding='utf-8', errors='strict')</code>.\nFor documentation see <em><a href=\"https://docs.python.org/3/library/stdtypes.html#bytes.decode\" rel=\"nofollow noreferrer\">bytes.decode</a></em>.</p>\n<p>Python 3 example:</p>\n<pre><code class=\"python\">byte_value = b\"abcde\"\nprint(\"Initial value = {}\".format(byte_value))\nprint(\"Initial value type = {}\".format(type(byte_value)))\nstring_value = byte_value.decode(\"utf-8\")\n# utf-8 is used here because it is a very common encoding, but you need to use the encoding your data is actually in.\nprint(\"------------\")\nprint(\"Converted value = {}\".format(string_value))\nprint(\"Converted value type = {}\".format(type(string_value)))\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">Initial value = b'abcde'\nInitial value type = &lt;class 'bytes'&gt;\n------------\nConverted value = abcde\nConverted value type = &lt;class 'str'&gt;\n</code></pre>\n<p>Note: In Python 3, by default the encoding type is UTF-8. So, <code>&lt;byte_string&gt;.decode(\"utf-8\")</code> can be also written as <code>&lt;byte_string&gt;.decode()</code></p>\n", "abstract": "We can decode the bytes object to produce a string using bytes.decode(encoding='utf-8', errors='strict').\nFor documentation see bytes.decode. Python 3 example: Output: Note: In Python 3, by default the encoding type is UTF-8. So, <byte_string>.decode(\"utf-8\") can be also written as <byte_string>.decode()"}, {"id": 68310461, "score": 4, "vote": 0, "content": "<p>Decode with <code>.decode()</code>. This will decode the string. Pass in <code>'utf-8'</code>) as the value in the inside.</p>\n", "abstract": "Decode with .decode(). This will decode the string. Pass in 'utf-8') as the value in the inside."}, {"id": 50671646, "score": 3, "vote": 0, "content": "<pre><code class=\"python\">def toString(string):    \n    try:\n        return v.decode(\"utf-8\")\n    except ValueError:\n        return string\n\nb = b'97.080.500'\ns = '97.080.500'\nprint(toString(b))\nprint(toString(s))\n</code></pre>\n", "abstract": ""}, {"id": 56403437, "score": 3, "vote": 0, "content": "<p>If you want to convert any bytes, not just string converted to bytes:</p>\n<pre><code class=\"python\">with open(\"bytesfile\", \"rb\") as infile:\n    str = base64.b85encode(imageFile.read())\n\nwith open(\"bytesfile\", \"rb\") as infile:\n    str2 = json.dumps(list(infile.read()))\n</code></pre>\n<p>This is not very efficient, however. It will turn a 2 MB picture into 9 MB.</p>\n", "abstract": "If you want to convert any bytes, not just string converted to bytes: This is not very efficient, however. It will turn a 2 MB picture into 9 MB."}, {"id": 59808347, "score": 3, "vote": 0, "content": "<p>Try this:</p>\n<pre><code class=\"python\">bytes.fromhex('c3a9').decode('utf-8') \n</code></pre>\n", "abstract": "Try this:"}, {"id": 67592546, "score": 2, "vote": 0, "content": "<p>Try using this one; this function will ignore all the non-character sets (like UTF-8) binaries and return a clean string. It is tested for Python\u00a03.6 and above.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def bin2str(text, encoding = 'utf-8'):\n    \"\"\"Converts a binary to Unicode string by removing all non Unicode char\n    text: binary string to work on\n    encoding: output encoding *utf-8\"\"\"\n\n    return text.decode(encoding, 'ignore')\n</code></pre>\n<p>Here, the function will take the binary and decode it (converts binary data to characters using the Python predefined character set and the <code>ignore</code> argument ignores all non-character set data from your binary and finally returns your desired <code>string</code> value.</p>\n<p>If you are not sure about the encoding, use <code>sys.getdefaultencoding()</code> to get the default encoding of your device.</p>\n", "abstract": "Try using this one; this function will ignore all the non-character sets (like UTF-8) binaries and return a clean string. It is tested for Python\u00a03.6 and above. Here, the function will take the binary and decode it (converts binary data to characters using the Python predefined character set and the ignore argument ignores all non-character set data from your binary and finally returns your desired string value. If you are not sure about the encoding, use sys.getdefaultencoding() to get the default encoding of your device."}]}, {"link": "https://stackoverflow.com/questions/123198/how-to-copy-files", "question": {"id": "123198", "title": "How to copy files?", "content": "<p>How do I copy a file in Python?</p>\n", "abstract": "How do I copy a file in Python?"}, "answers": [{"id": 123212, "score": 4249, "vote": 0, "content": "<p><a href=\"http://docs.python.org/3/library/shutil.html\" rel=\"noreferrer\"><code>shutil</code></a> has many methods you can use. One of which is:</p>\n<pre><code class=\"python\">import shutil\n\nshutil.copyfile(src, dst)\n\n# 2nd option\nshutil.copy(src, dst)  # dst can be a folder; use shutil.copy2() to preserve timestamp\n</code></pre>\n<ul>\n<li>Copy the contents of the file named <code>src</code> to a file named <code>dst</code>. Both <code>src</code> and <code>dst</code> need to be the entire filename of the files, including path.</li>\n<li>The destination location must be writable; otherwise, an <code>IOError</code> exception will be raised.</li>\n<li>If <code>dst</code> already exists, it will be replaced.</li>\n<li>Special files such as character or block devices and pipes cannot be copied with this function.</li>\n<li>With <code>copy</code>, <code>src</code> and <code>dst</code> are path names given as <code>str</code>s.</li>\n</ul>\n<p>Another <code>shutil</code> method to look at is <a href=\"https://docs.python.org/3/library/shutil.html#shutil.copy2\" rel=\"noreferrer\"><code>shutil.copy2()</code></a>. It's similar but preserves more metadata (e.g. time stamps).</p>\n<p>If you use <code>os.path</code> operations, use <code>copy</code> rather than <code>copyfile</code>. <code>copyfile</code> will only accept strings.</p>\n", "abstract": "shutil has many methods you can use. One of which is: Another shutil method to look at is shutil.copy2(). It's similar but preserves more metadata (e.g. time stamps). If you use os.path operations, use copy rather than copyfile. copyfile will only accept strings."}, {"id": 30359308, "score": 1923, "vote": 0, "content": "<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Function</th>\n<th>Copies<br/>metadata</th>\n<th>Copies<br/>permissions</th>\n<th>Uses file object</th>\n<th>Destination<br/>may be directory</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copy\" rel=\"noreferrer\">shutil.copy</a></td>\n<td>No</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copyfile\" rel=\"noreferrer\">shutil.copyfile</a></td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copy2\" rel=\"noreferrer\">shutil.copy2</a></td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copyfileobj\" rel=\"noreferrer\">shutil.copyfileobj</a></td>\n<td>No</td>\n<td>No</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n</div>", "abstract": ""}, {"id": 123238, "score": 908, "vote": 0, "content": "<p><a href=\"https://docs.python.org/2/library/shutil.html#shutil.copy2\" rel=\"noreferrer\"><code>copy2(src,dst)</code></a> is often more useful than <a href=\"https://docs.python.org/2/library/shutil.html#shutil.copyfile\" rel=\"noreferrer\"><code>copyfile(src,dst)</code></a> because:</p>\n<ul>\n<li>it allows <code>dst</code> to be a <em>directory</em> (instead of the complete target filename), in which case the <a href=\"https://docs.python.org/2/library/os.path.html#os.path.basename\" rel=\"noreferrer\">basename</a> of <code>src</code> is used for creating the new file;</li>\n<li>it preserves the original modification and access info (mtime and atime) in the file metadata (however, this comes with a slight overhead).</li>\n</ul>\n<p>Here is a short example:</p>\n<pre><code class=\"python\">import shutil\nshutil.copy2('/src/dir/file.ext', '/dst/dir/newname.ext') # complete target filename given\nshutil.copy2('/src/file.ext', '/dst/dir') # target filename is /dst/dir/file.ext\n</code></pre>\n", "abstract": "copy2(src,dst) is often more useful than copyfile(src,dst) because: Here is a short example:"}, {"id": 48374171, "score": 225, "vote": 0, "content": "<p>In Python, you can copy the files using</p>\n<ul>\n<li><strong><a href=\"https://docs.python.org/3/library/shutil.html\" rel=\"noreferrer\"><code>shutil</code></a></strong> module</li>\n<li><strong><a href=\"https://docs.python.org/3/library/os.html\" rel=\"noreferrer\"><code>os</code></a></strong> module</li>\n<li><strong><a href=\"https://docs.python.org/3/library/subprocess.html\" rel=\"noreferrer\"><code>subprocess</code></a></strong> module</li>\n</ul>\n<hr/>\n<pre><code class=\"python\">import os\nimport shutil\nimport subprocess\n</code></pre>\n<hr/>\n<h3>1) Copying files using <a href=\"https://docs.python.org/3/library/shutil.html\" rel=\"noreferrer\"><code>shutil</code></a> module</h3>\n<p><strong><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copyfile\" rel=\"noreferrer\"><code>shutil.copyfile</code></a></strong>  signature</p>\n<pre><code class=\"python\">shutil.copyfile(src_file, dest_file, *, follow_symlinks=True)\n\n# example    \nshutil.copyfile('source.txt', 'destination.txt')\n</code></pre>\n<hr/>\n<p><strong><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copy\" rel=\"noreferrer\"><code>shutil.copy</code></a></strong>  signature</p>\n<pre><code class=\"python\">shutil.copy(src_file, dest_file, *, follow_symlinks=True)\n\n# example\nshutil.copy('source.txt', 'destination.txt')\n</code></pre>\n<hr/>\n<p><strong><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copy2\" rel=\"noreferrer\"><code>shutil.copy2</code></a></strong>  signature</p>\n<pre><code class=\"python\">shutil.copy2(src_file, dest_file, *, follow_symlinks=True)\n\n# example\nshutil.copy2('source.txt', 'destination.txt')  \n</code></pre>\n<hr/>\n<p><strong><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copyfileobj\" rel=\"noreferrer\"><code>shutil.copyfileobj</code></a></strong>  signature</p>\n<pre><code class=\"python\">shutil.copyfileobj(src_file_object, dest_file_object[, length])\n\n# example\nfile_src = 'source.txt'  \nf_src = open(file_src, 'rb')\n\nfile_dest = 'destination.txt'  \nf_dest = open(file_dest, 'wb')\n\nshutil.copyfileobj(f_src, f_dest)  \n</code></pre>\n<hr/>\n<h3>2) Copying files using <a href=\"https://docs.python.org/3/library/os.html\" rel=\"noreferrer\"><code>os</code></a> module</h3>\n<p><strong><a href=\"https://docs.python.org/3/library/os.html#os.popen\" rel=\"noreferrer\"><code>os.popen</code></a></strong>  signature</p>\n<pre><code class=\"python\">os.popen(cmd[, mode[, bufsize]])\n\n# example\n# In Unix/Linux\nos.popen('cp source.txt destination.txt') \n\n# In Windows\nos.popen('copy source.txt destination.txt')\n</code></pre>\n<hr/>\n<p><strong><a href=\"https://docs.python.org/3/library/os.html#os.system\" rel=\"noreferrer\"><code>os.system</code></a></strong>  signature</p>\n<pre><code class=\"python\">os.system(command)\n\n\n# In Linux/Unix\nos.system('cp source.txt destination.txt')  \n\n# In Windows\nos.system('copy source.txt destination.txt')\n</code></pre>\n<hr/>\n<h3>3) Copying files using <a href=\"https://docs.python.org/3/library/subprocess.html\" rel=\"noreferrer\"><code>subprocess</code></a> module</h3>\n<p><strong><a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.call\" rel=\"noreferrer\"><code>subprocess.call</code></a></strong>  signature</p>\n<pre><code class=\"python\">subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)\n\n# example (WARNING: setting `shell=True` might be a security-risk)\n# In Linux/Unix\nstatus = subprocess.call('cp source.txt destination.txt', shell=True) \n\n# In Windows\nstatus = subprocess.call('copy source.txt destination.txt', shell=True)\n</code></pre>\n<hr/>\n<p><strong><a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.check_output\" rel=\"noreferrer\"><code>subprocess.check_output</code></a></strong>  signature</p>\n<pre><code class=\"python\">subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False)\n\n# example (WARNING: setting `shell=True` might be a security-risk)\n# In Linux/Unix\nstatus = subprocess.check_output('cp source.txt destination.txt', shell=True)\n\n# In Windows\nstatus = subprocess.check_output('copy source.txt destination.txt', shell=True)\n</code></pre>\n<hr/>\n", "abstract": "In Python, you can copy the files using shutil.copyfile  signature shutil.copy  signature shutil.copy2  signature shutil.copyfileobj  signature os.popen  signature os.system  signature subprocess.call  signature subprocess.check_output  signature"}, {"id": 44996087, "score": 175, "vote": 0, "content": "<p>You can use one of the copy functions from the <a href=\"https://docs.python.org/3/library/shutil.html\" rel=\"noreferrer\"><code>shutil</code></a> package:</p>\n<pre>\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nFunction              preserves     supports          accepts     copies other\n                      permissions   directory dest.   file obj    metadata  \n\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\u2015\n<a href=\"https://docs.python.org/3/library/shutil.html#shutil.copy\" rel=\"noreferrer\">shutil.copy</a>              \u2714             \u2714                 \u2610           \u2610\n<a href=\"https://docs.python.org/3/library/shutil.html#shutil.copy2\" rel=\"noreferrer\">shutil.copy2</a>             \u2714             \u2714                 \u2610           \u2714\n<a href=\"https://docs.python.org/3/library/shutil.html#shutil.copyfile\" rel=\"noreferrer\">shutil.copyfile</a>          \u2610             \u2610                 \u2610           \u2610\n<a href=\"https://docs.python.org/3/library/shutil.html#shutil.copyfileobj\" rel=\"noreferrer\">shutil.copyfileobj</a>       \u2610             \u2610                 \u2714           \u2610\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n</pre>\n<p>Example:</p>\n<pre><code class=\"python\">import shutil\nshutil.copy('/etc/hostname', '/var/tmp/testhostname')\n</code></pre>\n", "abstract": "You can use one of the copy functions from the shutil package: Example:"}, {"id": 125810, "score": 108, "vote": 0, "content": "<p>Copying a file is a relatively straightforward operation as shown by the examples below, but you should instead use the <a href=\"https://docs.python.org/library/shutil.html\" rel=\"noreferrer\">shutil stdlib module</a> for that.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def copyfileobj_example(source, dest, buffer_size=1024*1024):\n    \"\"\"      \n    Copy a file from source to dest. source and dest\n    must be file-like objects, i.e. any object with a read or\n    write method, like for example StringIO.\n    \"\"\"\n    while True:\n        copy_buffer = source.read(buffer_size)\n        if not copy_buffer:\n            break\n        dest.write(copy_buffer)\n</code></pre>\n<p>If you want to copy by filename you could do something like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def copyfile_example(source, dest):\n    # Beware, this example does not handle any edge cases!\n    with open(source, 'rb') as src, open(dest, 'wb') as dst:\n        copyfileobj_example(src, dst)\n</code></pre>\n", "abstract": "Copying a file is a relatively straightforward operation as shown by the examples below, but you should instead use the shutil stdlib module for that. If you want to copy by filename you could do something like this:"}, {"id": 123226, "score": 81, "vote": 0, "content": "<p>Use the <a href=\"https://docs.python.org/3/library/shutil.html\" rel=\"noreferrer\">shutil module</a>.</p>\n<pre><code class=\"python\">copyfile(src, dst)\n</code></pre>\n<p>Copy the contents of the file named src to a file named dst. The destination location must be writable; otherwise, an IOError exception will be raised. If dst already exists, it will be replaced. Special files such as character or block devices and pipes cannot be copied with this function. src and dst are path names given as strings.</p>\n<p>Take a look at <a href=\"https://docs.python.org/3/library/filesys.html\" rel=\"noreferrer\">filesys</a> for all the file and directory handling functions available in standard Python modules.</p>\n", "abstract": "Use the shutil module. Copy the contents of the file named src to a file named dst. The destination location must be writable; otherwise, an IOError exception will be raised. If dst already exists, it will be replaced. Special files such as character or block devices and pipes cannot be copied with this function. src and dst are path names given as strings. Take a look at filesys for all the file and directory handling functions available in standard Python modules."}, {"id": 5310215, "score": 49, "vote": 0, "content": "<p>Directory and File copy example - From Tim Golden's Python Stuff:</p>\n<p><a href=\"http://timgolden.me.uk/python/win32_how_do_i/copy-a-file.html\" rel=\"noreferrer\">http://timgolden.me.uk/python/win32_how_do_i/copy-a-file.html</a></p>\n<pre><code class=\"python\">import os\nimport shutil\nimport tempfile\n\nfilename1 = tempfile.mktemp (\".txt\")\nopen (filename1, \"w\").close ()\nfilename2 = filename1 + \".copy\"\nprint filename1, \"=&gt;\", filename2\n\nshutil.copy (filename1, filename2)\n\nif os.path.isfile (filename2): print \"Success\"\n\ndirname1 = tempfile.mktemp (\".dir\")\nos.mkdir (dirname1)\ndirname2 = dirname1 + \".copy\"\nprint dirname1, \"=&gt;\", dirname2\n\nshutil.copytree (dirname1, dirname2)\n\nif os.path.isdir (dirname2): print \"Success\"\n</code></pre>\n", "abstract": "Directory and File copy example - From Tim Golden's Python Stuff: http://timgolden.me.uk/python/win32_how_do_i/copy-a-file.html"}, {"id": 45694203, "score": 37, "vote": 0, "content": "<p>For small files and using only python built-ins, you can use the following one-liner:</p>\n<pre><code class=\"python\">with open(source, 'rb') as src, open(dest, 'wb') as dst: dst.write(src.read())\n</code></pre>\n<p>This is not optimal way for applications where the file is too large or when memory is critical, thus <a href=\"https://stackoverflow.com/a/123212/6327658\">Swati's</a> answer should be preferred.</p>\n", "abstract": "For small files and using only python built-ins, you can use the following one-liner: This is not optimal way for applications where the file is too large or when memory is critical, thus Swati's answer should be preferred."}, {"id": 48273637, "score": 33, "vote": 0, "content": "<p>Firstly, I made an exhaustive cheatsheet of shutil methods for your reference.</p>\n<pre><code class=\"python\">shutil_methods =\n{'copy':['shutil.copyfileobj',\n          'shutil.copyfile',\n          'shutil.copymode',\n          'shutil.copystat',\n          'shutil.copy',\n          'shutil.copy2',\n          'shutil.copytree',],\n 'move':['shutil.rmtree',\n         'shutil.move',],\n 'exception': ['exception shutil.SameFileError',\n                 'exception shutil.Error'],\n 'others':['shutil.disk_usage',\n             'shutil.chown',\n             'shutil.which',\n             'shutil.ignore_patterns',]\n}\n</code></pre>\n<p>Secondly, explain methods of copy in exmaples:</p>\n<blockquote>\n<ol>\n<li><code>shutil.copyfileobj(fsrc, fdst[, length])</code> manipulate opened objects</li>\n</ol>\n</blockquote>\n<pre><code class=\"python\">In [3]: src = '~/Documents/Head+First+SQL.pdf'\nIn [4]: dst = '~/desktop'\nIn [5]: shutil.copyfileobj(src, dst)\nAttributeError: 'str' object has no attribute 'read'\n#copy the file object\nIn [7]: with open(src, 'rb') as f1,open(os.path.join(dst,'test.pdf'), 'wb') as f2:\n    ...:      shutil.copyfileobj(f1, f2)\nIn [8]: os.stat(os.path.join(dst,'test.pdf'))\nOut[8]: os.stat_result(st_mode=33188, st_ino=8598319475, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067347, st_mtime=1516067335, st_ctime=1516067345)\n</code></pre>\n<blockquote>\n<ol start=\"2\">\n<li><code>shutil.copyfile(src, dst, *, follow_symlinks=True)</code>  Copy and rename</li>\n</ol>\n</blockquote>\n<pre><code class=\"python\">In [9]: shutil.copyfile(src, dst)\nIsADirectoryError: [Errno 21] Is a directory: ~/desktop'\n#so dst should be a filename instead of a directory name\n</code></pre>\n<blockquote>\n<ol start=\"3\">\n<li><code>shutil.copy()</code>  Copy without preseving the metadata</li>\n</ol>\n</blockquote>\n<pre><code class=\"python\">In [10]: shutil.copy(src, dst)\nOut[10]: ~/desktop/Head+First+SQL.pdf'\n#check their metadata\nIn [25]: os.stat(src)\nOut[25]: os.stat_result(st_mode=33188, st_ino=597749, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516066425, st_mtime=1493698739, st_ctime=1514871215)\nIn [26]: os.stat(os.path.join(dst, 'Head+First+SQL.pdf'))\nOut[26]: os.stat_result(st_mode=33188, st_ino=8598313736, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516066427, st_mtime=1516066425, st_ctime=1516066425)\n# st_atime,st_mtime,st_ctime changed\n</code></pre>\n<blockquote>\n<ol start=\"4\">\n<li><code>shutil.copy2()</code>  Copy with preseving the metadata</li>\n</ol>\n</blockquote>\n<pre><code class=\"python\">In [30]: shutil.copy2(src, dst)\nOut[30]: ~/desktop/Head+First+SQL.pdf'\nIn [31]: os.stat(src)\nOut[31]: os.stat_result(st_mode=33188, st_ino=597749, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067055, st_mtime=1493698739, st_ctime=1514871215)\nIn [32]: os.stat(os.path.join(dst, 'Head+First+SQL.pdf'))\nOut[32]: os.stat_result(st_mode=33188, st_ino=8598313736, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=13507926, st_atime=1516067063, st_mtime=1493698739, st_ctime=1516067055)\n# Preseved st_mtime\n</code></pre>\n<blockquote>\n<ol start=\"5\">\n<li><code>shutil.copytree()</code></li>\n</ol>\n</blockquote>\n<p>Recursively copy an entire directory tree rooted at src, returning the destination directory</p>\n", "abstract": "Firstly, I made an exhaustive cheatsheet of shutil methods for your reference. Secondly, explain methods of copy in exmaples: Recursively copy an entire directory tree rooted at src, returning the destination directory"}, {"id": 27575238, "score": 20, "vote": 0, "content": "<p>You could use <code>os.system('cp nameoffilegeneratedbyprogram /otherdirectory/')</code></p>\n<p>or as I did it,  </p>\n<pre><code class=\"python\">os.system('cp '+ rawfile + ' rawdata.dat')\n</code></pre>\n<p>where <code>rawfile</code> is the name that I had generated inside the program.</p>\n<p>This is a Linux only solution </p>\n", "abstract": "You could use os.system('cp nameoffilegeneratedbyprogram /otherdirectory/') or as I did it,   where rawfile is the name that I had generated inside the program. This is a Linux only solution "}, {"id": 55851299, "score": 19, "vote": 0, "content": "<p>As of <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes\" rel=\"noreferrer\">Python 3.5</a> you can do the following for small files (ie: text files, small jpegs):</p>\n<pre><code class=\"python\">from pathlib import Path\n\nsource = Path('../path/to/my/file.txt')\ndestination = Path('../path/where/i/want/to/store/it.txt')\ndestination.write_bytes(source.read_bytes())\n</code></pre>\n<p><code>write_bytes</code> will overwrite whatever was at the destination's location</p>\n", "abstract": "As of Python 3.5 you can do the following for small files (ie: text files, small jpegs): write_bytes will overwrite whatever was at the destination's location"}, {"id": 69313723, "score": 19, "vote": 0, "content": "<p><code>shutil</code> module offers some high-level operations on <code>files</code>. It supports file <code>copying</code> and <code>removal</code>.</p>\n<p>Refer to the table below for your use case.</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th>Function</th>\n<th>Utilize<br/>File Object</th>\n<th>Retain<br/>Metadata</th>\n<th>Retain<br/>Permissions</th>\n<th>Supports<br/> Directory Dest.</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copyfileobj\" rel=\"noreferrer\">shutil.copyfileobj</a></td>\n<td>\u2714</td>\n<td><strong>\u2179</strong></td>\n<td><strong>\u2179</strong></td>\n<td><strong>\u2179</strong></td>\n</tr>\n<tr>\n<td><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copyfile\" rel=\"noreferrer\">shutil.copyfile</a></td>\n<td><strong>\u2179</strong></td>\n<td><strong>\u2179</strong></td>\n<td><strong>\u2179</strong></td>\n<td><strong>\u2179</strong></td>\n</tr>\n<tr>\n<td><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copy2\" rel=\"noreferrer\">shutil.copy2</a></td>\n<td><strong>\u2179</strong></td>\n<td>\u2714</td>\n<td>\u2714</td>\n<td>\u2714</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.python.org/3/library/shutil.html#shutil.copy\" rel=\"noreferrer\">shutil.copy</a></td>\n<td><strong>\u2179</strong></td>\n<td><strong>\u2179</strong></td>\n<td>\u2714</td>\n<td>\u2714</td>\n</tr>\n</tbody>\n</table>\n</div>", "abstract": "shutil module offers some high-level operations on files. It supports file copying and removal. Refer to the table below for your use case."}, {"id": 30431587, "score": 13, "vote": 0, "content": "<p>For large files, what I did was read the file line by line and read each line into an array. Then, once the array reached a certain size, append it to a new file. </p>\n<pre><code class=\"python\">for line in open(\"file.txt\", \"r\"):\n    list.append(line)\n    if len(list) == 1000000: \n        output.writelines(list)\n        del list[:]\n</code></pre>\n", "abstract": "For large files, what I did was read the file line by line and read each line into an array. Then, once the array reached a certain size, append it to a new file. "}, {"id": 36396465, "score": 13, "vote": 0, "content": "<p>Use <code>subprocess.call</code> to copy the file</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from subprocess import call\ncall(\"cp -p &lt;file&gt; &lt;file&gt;\", shell=True)\n</code></pre>\n", "abstract": "Use subprocess.call to copy the file"}, {"id": 55309529, "score": 13, "vote": 0, "content": "<pre><code class=\"python\">open(destination, 'wb').write(open(source, 'rb').read())\n</code></pre>\n<p>Open the source file in read mode, and write to destination file in write mode.</p>\n", "abstract": "Open the source file in read mode, and write to destination file in write mode."}, {"id": 65709412, "score": 9, "vote": 0, "content": "<p>In case you've come this far down. The answer is that you need the entire path and file name</p>\n<pre><code class=\"python\">import os\n\nshutil.copy(os.path.join(old_dir, file), os.path.join(new_dir, file))\n</code></pre>\n", "abstract": "In case you've come this far down. The answer is that you need the entire path and file name"}, {"id": 65168236, "score": 8, "vote": 0, "content": "<p>Here is a simple way to do it, without any module. It's similar to <a href=\"https://stackoverflow.com/questions/123198/how-do-i-copy-a-file-in-python/45694203#45694203\">this answer</a>, but has the benefit to also work if it's a big file that doesn't fit in RAM:</p>\n<pre><code class=\"python\">with open('sourcefile', 'rb') as f, open('destfile', 'wb') as g:\n    while True:\n        block = f.read(16*1024*1024)  # work by blocks of 16 MB\n        if not block:  # end of file\n            break\n        g.write(block)\n</code></pre>\n<p>Since we're writing a new file, it does not preserve the modification time, etc.<br/>\nWe can then use <a href=\"https://docs.python.org/3/library/os.html#os.utime\" rel=\"noreferrer\"><code>os.utime</code></a> for this if needed.</p>\n", "abstract": "Here is a simple way to do it, without any module. It's similar to this answer, but has the benefit to also work if it's a big file that doesn't fit in RAM: Since we're writing a new file, it does not preserve the modification time, etc.\nWe can then use os.utime for this if needed."}, {"id": 65535130, "score": 5, "vote": 0, "content": "<p>Similar to the accepted answer, the following code block might come in handy if you also want to make sure to create any (non-existent) folders in the path to the destination.</p>\n<pre><code class=\"python\">from os import path, makedirs\nfrom shutil import copyfile\nmakedirs(path.dirname(path.abspath(destination_path)), exist_ok=True)\ncopyfile(source_path, destination_path)\n</code></pre>\n<p>As the accepted answers notes, these lines will overwrite any file which exists at the destination path, so sometimes it might be useful to also add: <code>if not path.exists(destination_path):</code> before this code block.</p>\n", "abstract": "Similar to the accepted answer, the following code block might come in handy if you also want to make sure to create any (non-existent) folders in the path to the destination. As the accepted answers notes, these lines will overwrite any file which exists at the destination path, so sometimes it might be useful to also add: if not path.exists(destination_path): before this code block."}, {"id": 73220840, "score": 0, "vote": 0, "content": "<p>Here is answer utilizing \" shutil.copyfileobj\" and is highly efficient. I used it in a tool I created some time ago. I didn't wrote this originally but tweaked it a little bit.</p>\n<pre><code class=\"python\">def copyFile(src, dst, buffer_size=10485760, perserveFileDate=True):\n    '''\n    Copies a file to a new location. Much faster performance than Apache Commons due to use of larger buffer\n    @param src:    Source File\n    @param dst:    Destination File (not file path)\n    @param buffer_size:    Buffer size to use during copy\n    @param perserveFileDate:    Preserve the original file date\n    '''\n    #    Check to make sure destination directory exists. If it doesn't create the directory\n    dstParent, dstFileName = os.path.split(dst)\n    if(not(os.path.exists(dstParent))):\n        os.makedirs(dstParent)\n   \n    #    Optimize the buffer for small files\n    buffer_size = min(buffer_size,os.path.getsize(src))\n    if(buffer_size == 0):\n        buffer_size = 1024\n   \n    if shutil._samefile(src, dst):\n        raise shutil.Error(\"`%s` and `%s` are the same file\" % (src, dst))\n    for fn in [src, dst]:\n        try:\n            st = os.stat(fn)\n        except OSError:\n            # File most likely does not exist\n            pass\n        else:\n            # XXX What about other special files? (sockets, devices...)\n            if shutil.stat.S_ISFIFO(st.st_mode):\n                raise shutil.SpecialFileError(\"`%s` is a named pipe\" % fn)\n    with open(src, 'rb') as fsrc:\n        with open(dst, 'wb') as fdst:\n            shutil.copyfileobj(fsrc, fdst, buffer_size)\n   \n    if(perserveFileDate):\n        shutil.copystat(src, dst)\n</code></pre>\n", "abstract": "Here is answer utilizing \" shutil.copyfileobj\" and is highly efficient. I used it in a tool I created some time ago. I didn't wrote this originally but tweaked it a little bit."}, {"id": 73673386, "score": 0, "vote": 0, "content": "<p>There are so many answers already, that I decided to add a different one.</p>\n<p>You can use <a href=\"https://docs.python.org/3/library/os.html#os.link\" rel=\"nofollow noreferrer\">os.link</a> to create a hard link to a file:</p>\n<pre><code class=\"python\">os.link(source, dest)\n</code></pre>\n<p>This is not an independent clone, but if you plan to only read (not modify) the new file and its content must remain the same as the original, this will work well. It also has a benefit that if you want to check whether the copy already exists, you can compare the hard links (with <em>os.stat</em>) instead of their content.</p>\n", "abstract": "There are so many answers already, that I decided to add a different one. You can use os.link to create a hard link to a file: This is not an independent clone, but if you plan to only read (not modify) the new file and its content must remain the same as the original, this will work well. It also has a benefit that if you want to check whether the copy already exists, you can compare the hard links (with os.stat) instead of their content."}, {"id": 56524267, "score": -3, "vote": 0, "content": "<p>Python provides in-built functions for easily copying files using the Operating System Shell utilities.</p>\n<p>Following command is used to Copy File</p>\n<pre><code class=\"python\">shutil.copy(src,dst)\n</code></pre>\n<p>Following command is used to Copy File with MetaData Information</p>\n<pre><code class=\"python\">shutil.copystat(src,dst)\n</code></pre>\n", "abstract": "Python provides in-built functions for easily copying files using the Operating System Shell utilities. Following command is used to Copy File Following command is used to Copy File with MetaData Information"}, {"id": 69868767, "score": -4, "vote": 0, "content": "<p>shutil.copy(src, dst, *, follow_symlinks=True)</p>\n", "abstract": "shutil.copy(src, dst, *, follow_symlinks=True)"}]}, {"link": "https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value", "question": {"id": "613183", "title": "How do I sort a dictionary by value?", "content": "<p>I have a dictionary of values read from two fields in a database: a string field and a numeric field. The string field is unique, so that is the key of the dictionary.</p>\n<p>I can sort on the keys, but how can I sort based on the values?</p>\n<p>Note: I have read Stack Overflow question here <em><a href=\"https://stackoverflow.com/questions/72899\">How do I sort a list of dictionaries by a value of the dictionary?</a></em> and probably could change my code to have a list of dictionaries, but since I do not really need a list of dictionaries I wanted to know if there is a simpler solution to sort either in ascending or descending order.</p>\n", "abstract": "I have a dictionary of values read from two fields in a database: a string field and a numeric field. The string field is unique, so that is the key of the dictionary. I can sort on the keys, but how can I sort based on the values? Note: I have read Stack Overflow question here How do I sort a list of dictionaries by a value of the dictionary? and probably could change my code to have a list of dictionaries, but since I do not really need a list of dictionaries I wanted to know if there is a simpler solution to sort either in ascending or descending order."}, "answers": [{"id": 613218, "score": 6571, "vote": 0, "content": "<h3>Python 3.7+ or CPython 3.6</h3>\n<p>Dicts preserve insertion order in Python 3.7+. Same in CPython 3.6, but <a href=\"https://stackoverflow.com/q/39980323/4518341\">it's an implementation detail</a>.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\n&gt;&gt;&gt; {k: v for k, v in sorted(x.items(), key=lambda item: item[1])}\n{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">&gt;&gt;&gt; dict(sorted(x.items(), key=lambda item: item[1]))\n{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}\n</code></pre>\n<h3>Older Python</h3>\n<p>It is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a list\u2014probably a list of tuples.</p>\n<p>For instance,</p>\n<pre><code class=\"python\">import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))\n</code></pre>\n<p><code>sorted_x</code> will be a list of tuples sorted by the second element in each tuple. <code>dict(sorted_x) == x</code>.</p>\n<p>And for those wishing to sort on keys instead of values:</p>\n<pre><code class=\"python\">import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))\n</code></pre>\n<p>In Python3 since <a href=\"https://stackoverflow.com/a/15712231/4293057\">unpacking is not allowed</a> we can use</p>\n<pre><code class=\"python\">x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = sorted(x.items(), key=lambda kv: kv[1])\n</code></pre>\n<p>If you want the output as a dict, you can use <a href=\"https://docs.python.org/3/library/collections.html#collections.OrderedDict\" rel=\"noreferrer\"><code>collections.OrderedDict</code></a>:</p>\n<pre><code class=\"python\">import collections\n\nsorted_dict = collections.OrderedDict(sorted_x)\n</code></pre>\n", "abstract": "Dicts preserve insertion order in Python 3.7+. Same in CPython 3.6, but it's an implementation detail. or It is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a list\u2014probably a list of tuples. For instance, sorted_x will be a list of tuples sorted by the second element in each tuple. dict(sorted_x) == x. And for those wishing to sort on keys instead of values: In Python3 since unpacking is not allowed we can use If you want the output as a dict, you can use collections.OrderedDict:"}, {"id": 3177911, "score": 1559, "vote": 0, "content": "<h2>As simple as: <code>sorted(dict1, key=dict1.get)</code></h2>\n<p>Well, it is actually possible to do a \"sort by dictionary values\". Recently I had to do that in a Code Golf (Stack Overflow question <em><a href=\"https://stackoverflow.com/questions/3169051/code-golf-word-frequency-chart#3170549\">Code golf: Word frequency chart</a></em>). Abridged, the problem was of the kind: given a text, count how often each word is encountered and display a list of the top words, sorted by decreasing frequency. </p>\n<p>If you construct a dictionary with the words as keys and the number of occurrences of each word as value, simplified here as:</p>\n<pre><code class=\"python\">from collections import defaultdict\nd = defaultdict(int)\nfor w in text.split():\n    d[w] += 1\n</code></pre>\n<p>then you can get a list of the words, ordered by frequency of use with <a href=\"https://docs.python.org/library/functions.html#sorted\" rel=\"noreferrer\"><code>sorted(d, key=d.get)</code></a> - the sort iterates over the dictionary keys, using the number of word occurrences as a sort key . </p>\n<pre><code class=\"python\">for w in sorted(d, key=d.get, reverse=True):\n    print(w, d[w])\n</code></pre>\n<p>I am writing this detailed explanation to illustrate what people often mean by \"I can easily sort a dictionary by key, but how do I sort by value\" - and I think the original post was trying to address such an issue. And the solution is to do sort of list of the keys, based on the values, as shown above.</p>\n", "abstract": "Well, it is actually possible to do a \"sort by dictionary values\". Recently I had to do that in a Code Golf (Stack Overflow question Code golf: Word frequency chart). Abridged, the problem was of the kind: given a text, count how often each word is encountered and display a list of the top words, sorted by decreasing frequency.  If you construct a dictionary with the words as keys and the number of occurrences of each word as value, simplified here as: then you can get a list of the words, ordered by frequency of use with sorted(d, key=d.get) - the sort iterates over the dictionary keys, using the number of word occurrences as a sort key .  I am writing this detailed explanation to illustrate what people often mean by \"I can easily sort a dictionary by key, but how do I sort by value\" - and I think the original post was trying to address such an issue. And the solution is to do sort of list of the keys, based on the values, as shown above."}, {"id": 2258273, "score": 1106, "vote": 0, "content": "<p>You could use:</p>\n<pre><code class=\"python\">sorted(d.items(), key=lambda x: x[1])\n</code></pre>\n<p>This will sort the dictionary by the values of each entry within the dictionary from smallest to largest.</p>\n<p>To sort it in descending order just add <code>reverse=True</code>:</p>\n<pre><code class=\"python\">sorted(d.items(), key=lambda x: x[1], reverse=True)\n</code></pre>\n<p><strong>Input:</strong></p>\n<pre><code class=\"python\">d = {'one':1,'three':3,'five':5,'two':2,'four':4}\na = sorted(d.items(), key=lambda x: x[1])    \nprint(a)\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"python\">[('one', 1), ('two', 2), ('three', 3), ('four', 4), ('five', 5)]\n</code></pre>\n", "abstract": "You could use: This will sort the dictionary by the values of each entry within the dictionary from smallest to largest. To sort it in descending order just add reverse=True: Input: Output:"}, {"id": 613228, "score": 261, "vote": 0, "content": "<p>Dicts can't be sorted, but you can build a sorted list from them.</p>\n<p>A sorted list of dict values:</p>\n<pre><code class=\"python\">sorted(d.values())\n</code></pre>\n<p>A list of (key, value) pairs, sorted by value:</p>\n<pre><code class=\"python\">from operator import itemgetter\nsorted(d.items(), key=itemgetter(1))\n</code></pre>\n", "abstract": "Dicts can't be sorted, but you can build a sorted list from them. A sorted list of dict values: A list of (key, value) pairs, sorted by value:"}, {"id": 3177025, "score": 180, "vote": 0, "content": "<p>In recent Python 2.7, we have the new <a href=\"http://docs.python.org/dev/whatsnew/2.7.html#pep-372-adding-an-ordered-dictionary-to-collections\" rel=\"noreferrer\">OrderedDict</a> type, which remembers the order in which the items were added.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d = {\"third\": 3, \"first\": 1, \"fourth\": 4, \"second\": 2}\n\n&gt;&gt;&gt; for k, v in d.items():\n...     print \"%s: %s\" % (k, v)\n...\nsecond: 2\nfourth: 4\nthird: 3\nfirst: 1\n\n&gt;&gt;&gt; d\n{'second': 2, 'fourth': 4, 'third': 3, 'first': 1}\n</code></pre>\n<p>To make a new ordered dictionary from the original, sorting by the values:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; d_sorted_by_value = OrderedDict(sorted(d.items(), key=lambda x: x[1]))\n</code></pre>\n<p>The OrderedDict behaves like a normal dict:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; for k, v in d_sorted_by_value.items():\n...     print \"%s: %s\" % (k, v)\n...\nfirst: 1\nsecond: 2\nthird: 3\nfourth: 4\n\n&gt;&gt;&gt; d_sorted_by_value\nOrderedDict([('first': 1), ('second': 2), ('third': 3), ('fourth': 4)])\n</code></pre>\n", "abstract": "In recent Python 2.7, we have the new OrderedDict type, which remembers the order in which the items were added. To make a new ordered dictionary from the original, sorting by the values: The OrderedDict behaves like a normal dict:"}, {"id": 34103440, "score": 120, "vote": 0, "content": "<h3>Using Python 3.5</h3>\n<p>Whilst I found the accepted answer useful, I was also surprised that it hasn't been updated to reference <strong><a href=\"https://docs.python.org/3/library/collections.html#collections.OrderedDict\" rel=\"nofollow noreferrer\">OrderedDict</a></strong> from the standard library <strong>collections</strong> module as a viable, modern alternative - designed to solve exactly this type of problem.</p>\n<pre><code class=\"python\">from operator import itemgetter\nfrom collections import OrderedDict\n\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = OrderedDict(sorted(x.items(), key=itemgetter(1)))\n# OrderedDict([(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)])\n</code></pre>\n<p>The official <strong><a href=\"https://docs.python.org/3/library/collections.html#collections.OrderedDict\" rel=\"nofollow noreferrer\">OrderedDict</a></strong> documentation offers a very similar example too, but using a lambda for the sort function:</p>\n<pre><code class=\"python\"># regular unsorted dictionary\nd = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}\n\n# dictionary sorted by value\nOrderedDict(sorted(d.items(), key=lambda t: t[1]))\n# OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])\n</code></pre>\n", "abstract": "Whilst I found the accepted answer useful, I was also surprised that it hasn't been updated to reference OrderedDict from the standard library collections module as a viable, modern alternative - designed to solve exactly this type of problem. The official OrderedDict documentation offers a very similar example too, but using a lambda for the sort function:"}, {"id": 613230, "score": 111, "vote": 0, "content": "<p>Pretty much the same as <a href=\"https://stackoverflow.com/a/613207/11044033\">Hank Gay's answer</a>:</p>\n<pre><code class=\"python\">sorted([(value,key) for (key,value) in mydict.items()])\n</code></pre>\n<p>Or optimized slightly as suggested by John Fouhy:</p>\n<pre><code class=\"python\">sorted((value,key) for (key,value) in mydict.items())\n</code></pre>\n", "abstract": "Pretty much the same as Hank Gay's answer: Or optimized slightly as suggested by John Fouhy:"}, {"id": 39424969, "score": 85, "vote": 0, "content": "<h1>As of <a href=\"https://docs.python.org/3.6/whatsnew/3.6.html\" rel=\"noreferrer\">Python 3.6</a> the built-in dict will be ordered</h1>\n<p>Good news, so the OP's original use case of mapping pairs retrieved from a database with unique string ids as keys and numeric values as values into a built-in Python v3.6+ dict, should now respect the insert order.</p>\n<p>If say the resulting two column table expressions from a database query like:</p>\n<pre><code class=\"python\">SELECT a_key, a_value FROM a_table ORDER BY a_value;\n</code></pre>\n<p>would be stored in two Python tuples, k_seq and v_seq (aligned by numerical index and with the same length of course), then:</p>\n<pre><code class=\"python\">k_seq = ('foo', 'bar', 'baz')\nv_seq = (0, 1, 42)\nordered_map = dict(zip(k_seq, v_seq))\n</code></pre>\n<p>Allow to output later as:</p>\n<pre><code class=\"python\">for k, v in ordered_map.items():\n    print(k, v)\n</code></pre>\n<p>yielding in this case (for the new Python 3.6+ built-in dict!):</p>\n<pre><code class=\"python\">foo 0\nbar 1\nbaz 42\n</code></pre>\n<p>in the same ordering per value of v.</p>\n<p>Where in the Python 3.5 install on my machine it currently yields:</p>\n<pre><code class=\"python\">bar 1\nfoo 0\nbaz 42\n</code></pre>\n<h2>Details:</h2>\n<p>As proposed in 2012 by Raymond Hettinger (cf. mail on python-dev with subject <a href=\"https://mail.python.org/pipermail/python-dev/2012-December/123028.html\" rel=\"noreferrer\">\"More compact dictionaries with faster iteration\"</a>) and now (in 2016) announced in a mail by Victor Stinner to python-dev with subject <a href=\"https://mail.python.org/pipermail/python-dev/2016-September/146327.html\" rel=\"noreferrer\">\"Python 3.6 dict becomes compact and gets a private version; and keywords become ordered\"</a> due to the fix/implementation of issue 27350 <a href=\"http://bugs.python.org/issue27350\" rel=\"noreferrer\">\"Compact and ordered dict\"</a> in Python 3.6 we will now be able, to use a built-in dict to maintain insert order!!</p>\n<p>Hopefully this will lead to a thin layer OrderedDict implementation as a first step. As @JimFasarakis-Hilliard indicated, some see use cases for the OrderedDict type also in the future. I think the Python community at large will carefully inspect, if this will stand the test of time, and what the next steps will be.</p>\n<p>Time to rethink our coding habits to not miss the possibilities opened by stable ordering of:</p>\n<ul>\n<li>Keyword arguments and</li>\n<li>(intermediate) dict storage</li>\n</ul>\n<p>The first because it eases dispatch in the implementation of functions and methods in some cases.</p>\n<p>The second as it encourages to more easily use <code>dict</code>s as intermediate storage in processing pipelines.</p>\n<p>Raymond Hettinger kindly provided documentation explaining \"<a href=\"https://dl.dropboxusercontent.com/u/3967849/sfmu2/_build/html/goal.html\" rel=\"noreferrer\" title=\"The Tech Behind Python 3.6 Dictionaries\">The Tech Behind Python 3.6 Dictionaries</a>\" - from his San Francisco Python Meetup Group presentation 2016-DEC-08.</p>\n<p>And maybe quite some Stack Overflow high decorated question and answer pages will receive variants of this information and many high quality answers will require a per version update too.</p>\n<h3>Caveat Emptor (but also see below update 2017-12-15):</h3>\n<p>As @ajcr rightfully notes: \"The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon.\" (from the <a href=\"https://docs.python.org/3.6/whatsnew/3.6.html\" rel=\"noreferrer\">whatsnew36</a>) not nit picking, <strong>but</strong> the citation was cut a bit pessimistic ;-). It continues as \" (this may change in the future, but it is desired to have this new dict implementation in the language for a few releases before changing the language spec to mandate order-preserving semantics for all current and future Python implementations; this also helps preserve backwards-compatibility with older versions of the language where random iteration order is still in effect, e.g. Python 3.5).\"</p>\n<p>So as in some human languages (e.g. German), usage shapes the language, and the will now has been declared ... in <a href=\"https://docs.python.org/3.6/whatsnew/3.6.html\" rel=\"noreferrer\">whatsnew36</a>.</p>\n<h3>Update 2017-12-15:</h3>\n<p>In a <a href=\"https://mail.python.org/pipermail/python-dev/2017-December/151283.html\" rel=\"noreferrer\">mail to the python-dev list</a>, Guido van Rossum declared:</p>\n<blockquote>\n<p>Make it so. \"Dict keeps insertion order\" is the ruling. Thanks! </p>\n</blockquote>\n<p>So, the version 3.6 CPython side-effect of dict insertion ordering is now becoming part of the language spec (and not anymore only an implementation detail). That mail thread also surfaced some distinguishing design goals for <code>collections.OrderedDict</code> as reminded by Raymond Hettinger during discussion.</p>\n", "abstract": "Good news, so the OP's original use case of mapping pairs retrieved from a database with unique string ids as keys and numeric values as values into a built-in Python v3.6+ dict, should now respect the insert order. If say the resulting two column table expressions from a database query like: would be stored in two Python tuples, k_seq and v_seq (aligned by numerical index and with the same length of course), then: Allow to output later as: yielding in this case (for the new Python 3.6+ built-in dict!): in the same ordering per value of v. Where in the Python 3.5 install on my machine it currently yields: As proposed in 2012 by Raymond Hettinger (cf. mail on python-dev with subject \"More compact dictionaries with faster iteration\") and now (in 2016) announced in a mail by Victor Stinner to python-dev with subject \"Python 3.6 dict becomes compact and gets a private version; and keywords become ordered\" due to the fix/implementation of issue 27350 \"Compact and ordered dict\" in Python 3.6 we will now be able, to use a built-in dict to maintain insert order!! Hopefully this will lead to a thin layer OrderedDict implementation as a first step. As @JimFasarakis-Hilliard indicated, some see use cases for the OrderedDict type also in the future. I think the Python community at large will carefully inspect, if this will stand the test of time, and what the next steps will be. Time to rethink our coding habits to not miss the possibilities opened by stable ordering of: The first because it eases dispatch in the implementation of functions and methods in some cases. The second as it encourages to more easily use dicts as intermediate storage in processing pipelines. Raymond Hettinger kindly provided documentation explaining \"The Tech Behind Python 3.6 Dictionaries\" - from his San Francisco Python Meetup Group presentation 2016-DEC-08. And maybe quite some Stack Overflow high decorated question and answer pages will receive variants of this information and many high quality answers will require a per version update too. As @ajcr rightfully notes: \"The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon.\" (from the whatsnew36) not nit picking, but the citation was cut a bit pessimistic ;-). It continues as \" (this may change in the future, but it is desired to have this new dict implementation in the language for a few releases before changing the language spec to mandate order-preserving semantics for all current and future Python implementations; this also helps preserve backwards-compatibility with older versions of the language where random iteration order is still in effect, e.g. Python 3.5).\" So as in some human languages (e.g. German), usage shapes the language, and the will now has been declared ... in whatsnew36. In a mail to the python-dev list, Guido van Rossum declared: Make it so. \"Dict keeps insertion order\" is the ruling. Thanks!  So, the version 3.6 CPython side-effect of dict insertion ordering is now becoming part of the language spec (and not anymore only an implementation detail). That mail thread also surfaced some distinguishing design goals for collections.OrderedDict as reminded by Raymond Hettinger during discussion."}, {"id": 7237524, "score": 83, "vote": 0, "content": "<p>It can often be very handy to use <b><a href=\"http://docs.python.org/library/collections.html#collections.namedtuple\" rel=\"noreferrer\">namedtuple</a></b>. For example, you have a dictionary of 'name' as keys and 'score' as values and you want to sort on 'score':</p>\n<pre><code class=\"python\">import collections\nPlayer = collections.namedtuple('Player', 'score name')\nd = {'John':5, 'Alex':10, 'Richard': 7}\n</code></pre>\n<p>sorting with lowest score first:</p>\n<pre><code class=\"python\">worst = sorted(Player(v,k) for (k,v) in d.items())\n</code></pre>\n<p>sorting with highest score first:</p>\n<pre><code class=\"python\">best = sorted([Player(v,k) for (k,v) in d.items()], reverse=True)\n</code></pre>\n<p>Now you can get the name and score of, let's say the second-best player (index=1) very Pythonically like this:</p>\n<pre><code class=\"python\">player = best[1]\nplayer.name\n    'Richard'\nplayer.score\n    7\n</code></pre>\n", "abstract": "It can often be very handy to use namedtuple. For example, you have a dictionary of 'name' as keys and 'score' as values and you want to sort on 'score': sorting with lowest score first: sorting with highest score first: Now you can get the name and score of, let's say the second-best player (index=1) very Pythonically like this:"}, {"id": 4215710, "score": 52, "vote": 0, "content": "<p>I had the same problem, and I solved it like this:</p>\n<pre><code class=\"python\">WantedOutput = sorted(MyDict, key=lambda x : MyDict[x]) \n</code></pre>\n<p>(People who answer \"It is not possible to sort a dict\" did not read the question! In fact, \"I can sort on the keys, but how can I sort based on the values?\" clearly means that he wants a list of the keys sorted according to the value of their values.)</p>\n<p>Please notice that the order is not well defined (keys with the same value will be in an arbitrary order in the output list).</p>\n", "abstract": "I had the same problem, and I solved it like this: (People who answer \"It is not possible to sort a dict\" did not read the question! In fact, \"I can sort on the keys, but how can I sort based on the values?\" clearly means that he wants a list of the keys sorted according to the value of their values.) Please notice that the order is not well defined (keys with the same value will be in an arbitrary order in the output list)."}, {"id": 11230132, "score": 50, "vote": 0, "content": "<p>If values are numeric you may also use <a href=\"https://docs.python.org/library/collections.html#collections.Counter\" rel=\"noreferrer\"><code>Counter</code></a> from <a href=\"https://docs.python.org/library/collections.html\" rel=\"noreferrer\">collections</a>.</p>\n<pre><code class=\"python\">from collections import Counter\n\nx = {'hello': 1, 'python': 5, 'world': 3}\nc = Counter(x)\nprint(c.most_common())\n\n&gt;&gt; [('python', 5), ('world', 3), ('hello', 1)]    \n</code></pre>\n", "abstract": "If values are numeric you may also use Counter from collections."}, {"id": 18375444, "score": 41, "vote": 0, "content": "<p>In Python 2.7, simply do:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from collections import OrderedDict\n# regular unsorted dictionary\nd = {'banana': 3, 'apple':4, 'pear': 1, 'orange': 2}\n\n# dictionary sorted by key\nOrderedDict(sorted(d.items(), key=lambda t: t[0]))\nOrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])\n\n# dictionary sorted by value\nOrderedDict(sorted(d.items(), key=lambda t: t[1]))\nOrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])\n</code></pre>\n<p>copy-paste from : <a href=\"http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipes\">http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipes</a></p>\n<p>Enjoy ;-)</p>\n", "abstract": "In Python 2.7, simply do: copy-paste from : http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipes Enjoy ;-)"}, {"id": 5227519, "score": 31, "vote": 0, "content": "<p>This is the code:</p>\n<pre><code class=\"python\">import operator\norigin_list = [\n    {\"name\": \"foo\", \"rank\": 0, \"rofl\": 20000},\n    {\"name\": \"Silly\", \"rank\": 15, \"rofl\": 1000},\n    {\"name\": \"Baa\", \"rank\": 300, \"rofl\": 20},\n    {\"name\": \"Zoo\", \"rank\": 10, \"rofl\": 200},\n    {\"name\": \"Penguin\", \"rank\": -1, \"rofl\": 10000}\n]\nprint \"&gt;&gt; Original &gt;&gt;\"\nfor foo in origin_list:\n    print foo\n\nprint \"\\n&gt;&gt; Rofl sort &gt;&gt;\"\nfor foo in sorted(origin_list, key=operator.itemgetter(\"rofl\")):\n    print foo\n\nprint \"\\n&gt;&gt; Rank sort &gt;&gt;\"\nfor foo in sorted(origin_list, key=operator.itemgetter(\"rank\")):\n    print foo\n</code></pre>\n<p>Here are the results:</p>\n<p><strong>Original</strong></p>\n<pre><code class=\"python\">{'name': 'foo', 'rank': 0, 'rofl': 20000}\n{'name': 'Silly', 'rank': 15, 'rofl': 1000}\n{'name': 'Baa', 'rank': 300, 'rofl': 20}\n{'name': 'Zoo', 'rank': 10, 'rofl': 200}\n{'name': 'Penguin', 'rank': -1, 'rofl': 10000}\n</code></pre>\n<p><strong>Rofl</strong></p>\n<pre><code class=\"python\">{'name': 'Baa', 'rank': 300, 'rofl': 20}\n{'name': 'Zoo', 'rank': 10, 'rofl': 200}\n{'name': 'Silly', 'rank': 15, 'rofl': 1000}\n{'name': 'Penguin', 'rank': -1, 'rofl': 10000}\n{'name': 'foo', 'rank': 0, 'rofl': 20000}\n</code></pre>\n<p><strong>Rank</strong> </p>\n<pre><code class=\"python\">{'name': 'Penguin', 'rank': -1, 'rofl': 10000}\n{'name': 'foo', 'rank': 0, 'rofl': 20000}\n{'name': 'Zoo', 'rank': 10, 'rofl': 200}\n{'name': 'Silly', 'rank': 15, 'rofl': 1000}\n{'name': 'Baa', 'rank': 300, 'rofl': 20}\n</code></pre>\n", "abstract": "This is the code: Here are the results: Original Rofl Rank "}, {"id": 22903797, "score": 31, "vote": 0, "content": "<p>Try the following approach. Let us define a dictionary called mydict with the following data:</p>\n<pre><code class=\"python\">mydict = {'carl':40,\n          'alan':2,\n          'bob':1,\n          'danny':3}\n</code></pre>\n<p>If one wanted to sort the dictionary by keys, one could do something like:</p>\n<pre><code class=\"python\">for key in sorted(mydict.iterkeys()):\n    print \"%s: %s\" % (key, mydict[key])\n</code></pre>\n<p>This should return the following output:</p>\n<pre><code class=\"python\">alan: 2\nbob: 1\ncarl: 40\ndanny: 3\n</code></pre>\n<p>On the other hand, if one wanted to sort a dictionary by value (as is asked in the question), one could do the following:</p>\n<pre><code class=\"python\">for key, value in sorted(mydict.iteritems(), key=lambda (k,v): (v,k)):\n    print \"%s: %s\" % (key, value)\n</code></pre>\n<p>The result of this command (sorting the dictionary by value) should return the following:</p>\n<pre><code class=\"python\">bob: 1\nalan: 2\ndanny: 3\ncarl: 40\n</code></pre>\n", "abstract": "Try the following approach. Let us define a dictionary called mydict with the following data: If one wanted to sort the dictionary by keys, one could do something like: This should return the following output: On the other hand, if one wanted to sort a dictionary by value (as is asked in the question), one could do the following: The result of this command (sorting the dictionary by value) should return the following:"}, {"id": 52345214, "score": 31, "vote": 0, "content": "<p>Starting from Python 3.6, <code>dict</code> objects are now ordered by insertion order. It's officially in the specifications of Python 3.7.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; words = {\"python\": 2, \"blah\": 4, \"alice\": 3}\n&gt;&gt;&gt; dict(sorted(words.items(), key=lambda x: x[1]))\n{'python': 2, 'alice': 3, 'blah': 4}\n</code></pre>\n<p>Before that, you had to use <code>OrderedDict</code>.</p>\n<p><a href=\"https://docs.python.org/3.7/library/stdtypes.html#typesmapping\" rel=\"nofollow noreferrer\">Python 3.7 documentation</a> says:</p>\n<blockquote>\n<p>Changed in version 3.7: Dictionary order is guaranteed to be insertion\norder. This behavior was implementation detail of CPython from 3.6.</p>\n</blockquote>\n", "abstract": "Starting from Python 3.6, dict objects are now ordered by insertion order. It's officially in the specifications of Python 3.7. Before that, you had to use OrderedDict. Python 3.7 documentation says: Changed in version 3.7: Dictionary order is guaranteed to be insertion\norder. This behavior was implementation detail of CPython from 3.6."}, {"id": 613326, "score": 27, "vote": 0, "content": "<p>You can create an \"inverted index\", also</p>\n<pre><code class=\"python\">from collections import defaultdict\ninverse= defaultdict( list )\nfor k, v in originalDict.items():\n    inverse[v].append( k )\n</code></pre>\n<p>Now your inverse has the values; each value has a list of applicable keys.</p>\n<pre><code class=\"python\">for k in sorted(inverse):\n    print k, inverse[k]\n</code></pre>\n", "abstract": "You can create an \"inverted index\", also Now your inverse has the values; each value has a list of applicable keys."}, {"id": 15310681, "score": 25, "vote": 0, "content": "<p>You can use the <a href=\"http://docs.python.org/2/library/collections.html#collections.Counter\">collections.Counter</a>. Note, this will work for both numeric and non-numeric values.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = {1: 2, 3: 4, 4:3, 2:1, 0:0}\n&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; #To sort in reverse order\n&gt;&gt;&gt; Counter(x).most_common()\n[(3, 4), (4, 3), (1, 2), (2, 1), (0, 0)]\n&gt;&gt;&gt; #To sort in ascending order\n&gt;&gt;&gt; Counter(x).most_common()[::-1]\n[(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]\n&gt;&gt;&gt; #To get a dictionary sorted by values\n&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; OrderedDict(Counter(x).most_common()[::-1])\nOrderedDict([(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)])\n</code></pre>\n", "abstract": "You can use the collections.Counter. Note, this will work for both numeric and non-numeric values."}, {"id": 22150003, "score": 22, "vote": 0, "content": "<p>The collections solution mentioned in another answer is absolutely superb, because you retain a connection between the key and value which in the case of dictionaries is extremely important.</p>\n<p>I don't agree with the number one choice presented in another answer, because it throws away the keys.</p>\n<p>I used the solution mentioned above (code shown below) and retained access to both keys and values and in my case the ordering was on the values, but the importance was the ordering of the keys after ordering the values.</p>\n<pre><code class=\"python\">from collections import Counter\n\nx = {'hello':1, 'python':5, 'world':3}\nc=Counter(x)\nprint( c.most_common() )\n\n\n&gt;&gt; [('python', 5), ('world', 3), ('hello', 1)]\n</code></pre>\n", "abstract": "The collections solution mentioned in another answer is absolutely superb, because you retain a connection between the key and value which in the case of dictionaries is extremely important. I don't agree with the number one choice presented in another answer, because it throws away the keys. I used the solution mentioned above (code shown below) and retained access to both keys and values and in my case the ordering was on the values, but the importance was the ordering of the keys after ordering the values."}, {"id": 26049456, "score": 20, "vote": 0, "content": "<p>You can use a <a href=\"https://pypi.python.org/pypi/skipdict/1.0\">skip dict</a> which is a dictionary that's permanently sorted by value.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; data = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\n&gt;&gt;&gt; SkipDict(data)\n{0: 0.0, 2: 1.0, 1: 2.0, 4: 3.0, 3: 4.0}\n</code></pre>\n<p>If you use <code>keys()</code>, <code>values()</code> or <code>items()</code> then you'll iterate in sorted order by value.</p>\n<p>It's implemented using the <a href=\"http://en.wikipedia.org/wiki/Skip_list\">skip list</a> datastructure.</p>\n", "abstract": "You can use a skip dict which is a dictionary that's permanently sorted by value. If you use keys(), values() or items() then you'll iterate in sorted order by value. It's implemented using the skip list datastructure."}, {"id": 44187197, "score": 19, "vote": 0, "content": "<p>You can also use a custom function that can be passed to parameter <em>key</em>.</p>\n<pre><code class=\"python\">def dict_val(x):\n    return x[1]\n\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = sorted(x.items(), key=dict_val)\n</code></pre>\n", "abstract": "You can also use a custom function that can be passed to parameter key."}, {"id": 31741215, "score": 17, "vote": 0, "content": "<p>Of course, remember, you need to use <code>OrderedDict</code> because regular Python dictionaries don't keep the original order. </p>\n<pre><code class=\"python\">from collections import OrderedDict\na = OrderedDict(sorted(originalDict.items(), key=lambda x: x[1]))\n</code></pre>\n<hr/>\n<p>If you do not have Python 2.7 or higher, the best you can do is iterate over the values in a generator function. (There is an <code>OrderedDict</code> for 2.4 and 2.6  <a href=\"https://pypi.python.org/pypi/ordereddict\" rel=\"noreferrer\">here</a>, but </p>\n<p>a) I don't know about how well it works </p>\n<p>and </p>\n<p>b) You have to download and install it of course. If you do not have administrative access, then I'm afraid the option's out.)</p>\n<hr/>\n<pre><code class=\"python\">def gen(originalDict):\n    for x, y in sorted(zip(originalDict.keys(), originalDict.values()), key=lambda z: z[1]):\n        yield (x, y)\n    #Yields as a tuple with (key, value). You can iterate with conditional clauses to get what you want. \n\nfor bleh, meh in gen(myDict):\n    if bleh == \"foo\":\n        print(myDict[bleh])\n</code></pre>\n<hr/>\n<p>You can also print out every value</p>\n<pre><code class=\"python\">for bleh, meh in gen(myDict):\n    print(bleh, meh)\n</code></pre>\n<p>Please remember to remove the parentheses after print if not using Python 3.0 or above</p>\n", "abstract": "Of course, remember, you need to use OrderedDict because regular Python dictionaries don't keep the original order.  If you do not have Python 2.7 or higher, the best you can do is iterate over the values in a generator function. (There is an OrderedDict for 2.4 and 2.6  here, but  a) I don't know about how well it works  and  b) You have to download and install it of course. If you do not have administrative access, then I'm afraid the option's out.) You can also print out every value Please remember to remove the parentheses after print if not using Python 3.0 or above"}, {"id": 4068769, "score": 16, "vote": 0, "content": "<pre><code class=\"python\">from django.utils.datastructures import SortedDict\n\ndef sortedDictByKey(self,data):\n    \"\"\"Sorted dictionary order by key\"\"\"\n    sortedDict = SortedDict()\n    if data:\n        if isinstance(data, dict):\n            sortedKey = sorted(data.keys())\n            for k in sortedKey:\n                sortedDict[k] = data[k]\n    return sortedDict\n</code></pre>\n", "abstract": ""}, {"id": 30949456, "score": 15, "vote": 0, "content": "<p>Here is a solution using zip on <a href=\"https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects\" rel=\"noreferrer\"><code>d.values()</code> and <code>d.keys()</code></a>.  A few lines down this link (on Dictionary view objects) is:</p>\n<blockquote>\n<p>This allows the creation of (value, key) pairs using zip(): pairs = zip(d.values(), d.keys()).</p>\n</blockquote>\n<p>So we can do the following:</p>\n<pre><code class=\"python\">d = {'key1': 874.7, 'key2': 5, 'key3': 8.1}\n\nd_sorted = sorted(zip(d.values(), d.keys()))\n\nprint d_sorted \n# prints: [(5, 'key2'), (8.1, 'key3'), (874.7, 'key1')]\n</code></pre>\n", "abstract": "Here is a solution using zip on d.values() and d.keys().  A few lines down this link (on Dictionary view objects) is: This allows the creation of (value, key) pairs using zip(): pairs = zip(d.values(), d.keys()). So we can do the following:"}, {"id": 49073645, "score": 14, "vote": 0, "content": "<p><a href=\"https://stackoverflow.com/a/39424969/1150683\">As pointed out by Dilettant</a>, Python 3.6 will now <em>keep the order</em>! I thought I'd share a function I wrote that eases the sorting of an iterable (tuple, list, dict). In the latter case, you can sort either on keys or values, and it can take numeric comparison into account. <strong>Only for &gt;= 3.6!</strong></p>\n<p>When you try using sorted on an iterable that holds e.g. strings as well as ints, sorted() will fail. Of course you can force string comparison with str(). However, in some cases you want to do <em>actual</em> numeric comparison where <code>12</code> is smaller than <code>20</code> (which is not the case in string comparison). So I came up with the following. When you want explicit numeric comparison you can use the flag <code>num_as_num</code> which will try to do explicit numeric sorting by trying to convert all values to floats. If that succeeds, it will do numeric sorting, otherwise it'll resort to string comparison.</p>\n<p>Comments for improvement welcome.</p>\n<pre><code class=\"python\">def sort_iterable(iterable, sort_on=None, reverse=False, num_as_num=False):\n    def _sort(i):\n      # sort by 0 = keys, 1 values, None for lists and tuples\n      try:\n        if num_as_num:\n          if i is None:\n            _sorted = sorted(iterable, key=lambda v: float(v), reverse=reverse)\n          else:\n            _sorted = dict(sorted(iterable.items(), key=lambda v: float(v[i]), reverse=reverse))\n        else:\n          raise TypeError\n      except (TypeError, ValueError):\n        if i is None:\n          _sorted = sorted(iterable, key=lambda v: str(v), reverse=reverse)\n        else:\n          _sorted = dict(sorted(iterable.items(), key=lambda v: str(v[i]), reverse=reverse))\n      \n      return _sorted\n      \n    if isinstance(iterable, list):\n      sorted_list = _sort(None)\n      return sorted_list\n    elif isinstance(iterable, tuple):\n      sorted_list = tuple(_sort(None))\n      return sorted_list\n    elif isinstance(iterable, dict):\n      if sort_on == 'keys':\n        sorted_dict = _sort(0)\n        return sorted_dict\n      elif sort_on == 'values':\n        sorted_dict = _sort(1)\n        return sorted_dict\n      elif sort_on is not None:\n        raise ValueError(f\"Unexpected value {sort_on} for sort_on. When sorting a dict, use key or values\")\n    else:\n      raise TypeError(f\"Unexpected type {type(iterable)} for iterable. Expected a list, tuple, or dict\")\n</code></pre>\n", "abstract": "As pointed out by Dilettant, Python 3.6 will now keep the order! I thought I'd share a function I wrote that eases the sorting of an iterable (tuple, list, dict). In the latter case, you can sort either on keys or values, and it can take numeric comparison into account. Only for >= 3.6! When you try using sorted on an iterable that holds e.g. strings as well as ints, sorted() will fail. Of course you can force string comparison with str(). However, in some cases you want to do actual numeric comparison where 12 is smaller than 20 (which is not the case in string comparison). So I came up with the following. When you want explicit numeric comparison you can use the flag num_as_num which will try to do explicit numeric sorting by trying to convert all values to floats. If that succeeds, it will do numeric sorting, otherwise it'll resort to string comparison. Comments for improvement welcome."}, {"id": 50554874, "score": 11, "vote": 0, "content": "<p>I just learned a relevant skill from <em><a href=\"https://www.coursera.org/learn/python-data/lecture/0ou0N/10-tuples\" rel=\"nofollow noreferrer\">Python for Everybody</a></em>.</p>\n<p>You may use a temporary list to help you to sort the dictionary:</p>\n<pre><code class=\"python\"># Assume dictionary to be:\nd = {'apple': 500.1, 'banana': 1500.2, 'orange': 1.0, 'pineapple': 789.0}\n\n# Create a temporary list\ntmp = []\n\n# Iterate through the dictionary and append each tuple into the temporary list\nfor key, value in d.items():\n    tmptuple = (value, key)\n    tmp.append(tmptuple)\n\n# Sort the list in ascending order\ntmp = sorted(tmp)\n\nprint (tmp)\n</code></pre>\n<p>If you want to sort the list in descending order, simply change the original sorting line to:</p>\n<pre><code class=\"python\">tmp = sorted(tmp, reverse=True)\n</code></pre>\n<p>Using list comprehension, the one-liner would be:</p>\n<pre><code class=\"python\"># Assuming the dictionary looks like\nd = {'apple': 500.1, 'banana': 1500.2, 'orange': 1.0, 'pineapple': 789.0}\n# One-liner for sorting in ascending order\nprint (sorted([(v, k) for k, v in d.items()]))\n# One-liner for sorting in descending order\nprint (sorted([(v, k) for k, v in d.items()], reverse=True))\n</code></pre>\n<p>Sample Output:</p>\n<pre><code class=\"python\"># Ascending order\n[(1.0, 'orange'), (500.1, 'apple'), (789.0, 'pineapple'), (1500.2, 'banana')]\n# Descending order\n[(1500.2, 'banana'), (789.0, 'pineapple'), (500.1, 'apple'), (1.0, 'orange')]\n</code></pre>\n", "abstract": "I just learned a relevant skill from Python for Everybody. You may use a temporary list to help you to sort the dictionary: If you want to sort the list in descending order, simply change the original sorting line to: Using list comprehension, the one-liner would be: Sample Output:"}, {"id": 7817348, "score": 10, "vote": 0, "content": "<p>Use <strong>ValueSortedDict</strong> from <a href=\"http://pypi.python.org/pypi/dicts\" rel=\"noreferrer\">dicts</a>:</p>\n<pre><code class=\"python\">from dicts.sorteddict import ValueSortedDict\nd = {1: 2, 3: 4, 4:3, 2:1, 0:0}\nsorted_dict = ValueSortedDict(d)\nprint sorted_dict.items() \n\n[(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]\n</code></pre>\n", "abstract": "Use ValueSortedDict from dicts:"}, {"id": 7947321, "score": 10, "vote": 0, "content": "<p>Iterate through a dict and sort it by its values in descending order:</p>\n<pre><code class=\"python\">$ python --version\nPython 3.2.2\n\n$ cat sort_dict_by_val_desc.py \ndictionary = dict(siis = 1, sana = 2, joka = 3, tuli = 4, aina = 5)\nfor word in sorted(dictionary, key=dictionary.get, reverse=True):\n  print(word, dictionary[word])\n\n$ python sort_dict_by_val_desc.py \naina 5\ntuli 4\njoka 3\nsana 2\nsiis 1\n</code></pre>\n", "abstract": "Iterate through a dict and sort it by its values in descending order:"}, {"id": 8992838, "score": 9, "vote": 0, "content": "<p>If your values are integers, and you use Python 2.7 or newer, you can use <a href=\"http://docs.python.org/py3k/library/collections.html#collections.Counter\" rel=\"noreferrer\"><code>collections.Counter</code></a> instead of <code>dict</code>. The <code>most_common</code> method will give you all items, sorted by the value.</p>\n", "abstract": "If your values are integers, and you use Python 2.7 or newer, you can use collections.Counter instead of dict. The most_common method will give you all items, sorted by the value."}, {"id": 8148132, "score": 8, "vote": 0, "content": "<p>This works in 3.1.x:</p>\n<pre><code class=\"python\">import operator\nslovar_sorted=sorted(slovar.items(), key=operator.itemgetter(1), reverse=True)\nprint(slovar_sorted)\n</code></pre>\n", "abstract": "This works in 3.1.x:"}, {"id": 15587800, "score": 8, "vote": 0, "content": "<p>For the sake of completeness, I am posting a solution using <a href=\"http://docs.python.org/2/library/heapq.html\" rel=\"noreferrer\">heapq</a>. Note, this method will work for both numeric and non-numeric values</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = {1: 2, 3: 4, 4:3, 2:1, 0:0}\n&gt;&gt;&gt; x_items = x.items()\n&gt;&gt;&gt; heapq.heapify(x_items)\n&gt;&gt;&gt; #To sort in reverse order\n&gt;&gt;&gt; heapq.nlargest(len(x_items),x_items, operator.itemgetter(1))\n[(3, 4), (4, 3), (1, 2), (2, 1), (0, 0)]\n&gt;&gt;&gt; #To sort in ascending order\n&gt;&gt;&gt; heapq.nsmallest(len(x_items),x_items, operator.itemgetter(1))\n[(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]\n</code></pre>\n", "abstract": "For the sake of completeness, I am posting a solution using heapq. Note, this method will work for both numeric and non-numeric values"}, {"id": 21767696, "score": 6, "vote": 0, "content": "<pre><code class=\"python\">months = {\"January\": 31, \"February\": 28, \"March\": 31, \"April\": 30, \"May\": 31,\n          \"June\": 30, \"July\": 31, \"August\": 31, \"September\": 30, \"October\": 31,\n          \"November\": 30, \"December\": 31}\n\ndef mykey(t):\n    \"\"\" Customize your sorting logic using this function.  The parameter to\n    this function is a tuple.  Comment/uncomment the return statements to test\n    different logics.\n    \"\"\"\n    return t[1]              # sort by number of days in the month\n    #return t[1], t[0]       # sort by number of days, then by month name\n    #return len(t[0])        # sort by length of month name\n    #return t[0][-1]         # sort by last character of month name\n\n\n# Since a dictionary can't be sorted by value, what you can do is to convert\n# it into a list of tuples with tuple length 2.\n# You can then do custom sorts by passing your own function to sorted().\nmonths_as_list = sorted(months.items(), key=mykey, reverse=False)\n\nfor month in months_as_list:\n    print month\n</code></pre>\n", "abstract": ""}, {"id": 54878340, "score": 2, "vote": 0, "content": "<p>Besides using built-in modules, etc., I try solve it manually...</p>\n<p><strong>First</strong>, I made a function whose job is to returning minimal value each items of the dict:</p>\n<pre><code class=\"python\">def returnminDict(_dct):\n    dict_items = _dct.items()\n    list_items = list(dict_items)\n    init_items = list_items[0]\n    for i in range(len(list_items)):\n        if list_items[i][1] &gt; init_items[1]:\n           continue\n        else:\n           init_items = list_items[i]\n    return init_items\n</code></pre>\n<p><strong>Second</strong>, now we have a function which returns an item that has the minimal value. Then I make a new dict and loop over the dict:</p>\n<pre><code class=\"python\">def SelectDictSort(_dct):\n    new_dict = {}\n    while _dct:\n        mindict = returnminDict(_dct)\n        new_dict.update(dict((mindict,)))\n        _dct.pop(mindict[0])\n    return new_dict\n</code></pre>\n<p>I try with <code>SelectDictSort({2: 5, 5: 1, 4: 3, 1: 1, 0: 1, 9: 2, 8: 2})</code>. It will return:</p>\n<pre><code class=\"python\">{0: 1, 1: 1, 5: 1, 8: 2, 9: 2, 4: 3, 2: 5}\n</code></pre>\n<p>Hmmm... I don\u2019t know which is correct, but this what I have tried...</p>\n", "abstract": "Besides using built-in modules, etc., I try solve it manually... First, I made a function whose job is to returning minimal value each items of the dict: Second, now we have a function which returns an item that has the minimal value. Then I make a new dict and loop over the dict: I try with SelectDictSort({2: 5, 5: 1, 4: 3, 1: 1, 0: 1, 9: 2, 8: 2}). It will return: Hmmm... I don\u2019t know which is correct, but this what I have tried..."}, {"id": 13208582, "score": 1, "vote": 0, "content": "<p>Using Python 3.2:</p>\n<pre><code class=\"python\">x = {\"b\":4, \"a\":3, \"c\":1}\nfor i in sorted(x.values()):\n    print(list(x.keys())[list(x.values()).index(i)])\n</code></pre>\n", "abstract": "Using Python 3.2:"}, {"id": 44148366, "score": -1, "vote": 0, "content": "<p>This method will not use lambda and works well on Python 3.6:</p>\n<pre><code class=\"python\"> # sort dictionary by value\nd = {'a1': 'fsdfds', 'g5': 'aa3432ff', 'ca':'zz23432'}\ndef getkeybyvalue(d,i):\n    for k, v in d.items():\n        if v == i:\n            return (k)\n\nsortvaluelist = sorted(d.values())\n\n# In &gt;&gt; Python 3.6+ &lt;&lt; the INSERTION-ORDER of a dict is preserved. That is,\n# when creating a NEW dictionary and filling it 'in sorted order',\n# that order will be maintained.\nsortresult ={}\nfor i1 in sortvaluelist:   \n    key = getkeybyvalue(d,i1)\n    sortresult[key] = i1\nprint ('=====sort by value=====')\nprint (sortresult)\nprint ('=======================')\n</code></pre>\n", "abstract": "This method will not use lambda and works well on Python 3.6:"}]}, {"link": "https://stackoverflow.com/questions/1024847/how-can-i-add-new-keys-to-a-dictionary", "question": {"id": "1024847", "title": "How can I add new keys to a dictionary?", "content": "<p>How do I add a key to an existing dictionary? It doesn't have an <code>.add()</code> method.</p>\n", "abstract": "How do I add a key to an existing dictionary? It doesn't have an .add() method."}, "answers": [{"id": 1024851, "score": 4260, "vote": 0, "content": "<p>You create a new key/value pair on a dictionary by assigning a value to that key</p>\n<pre><code class=\"python\">d = {'key': 'value'}\nprint(d)  # {'key': 'value'}\n\nd['mynewkey'] = 'mynewvalue'\n\nprint(d)  # {'key': 'value', 'mynewkey': 'mynewvalue'}\n</code></pre>\n<p>If the key doesn't exist, it's added and points to that value. If it exists, the current value it points to is overwritten.</p>\n", "abstract": "You create a new key/value pair on a dictionary by assigning a value to that key If the key doesn't exist, it's added and points to that value. If it exists, the current value it points to is overwritten."}, {"id": 8381589, "score": 1230, "vote": 0, "content": "<p>I feel like consolidating info about Python dictionaries:</p>\n<h2>Creating an empty dictionary</h2>\n<pre><code class=\"python\">data = {}\n# OR\ndata = dict()\n</code></pre>\n<h2>Creating a dictionary with initial values</h2>\n<pre><code class=\"python\">data = {'a': 1, 'b': 2, 'c': 3}\n# OR\ndata = dict(a=1, b=2, c=3)\n# OR\ndata = {k: v for k, v in (('a', 1), ('b',2), ('c',3))}\n</code></pre>\n<h2>Inserting/Updating a single value</h2>\n<pre><code class=\"python\">data['a'] = 1  # Updates if 'a' exists, else adds 'a'\n# OR\ndata.update({'a': 1})\n# OR\ndata.update(dict(a=1))\n# OR\ndata.update(a=1)\n</code></pre>\n<h2>Inserting/Updating multiple values</h2>\n<pre><code class=\"python\">data.update({'c':3,'d':4})  # Updates 'c' and adds 'd'\n</code></pre>\n<h3>Python\u00a03.9+:</h3>\n<p>The <em>update operator</em> <code>|=</code> now works for dictionaries:</p>\n<pre><code class=\"python\">data |= {'c':3,'d':4}\n</code></pre>\n<h2>Creating a merged dictionary without modifying originals</h2>\n<pre><code class=\"python\">data3 = {}\ndata3.update(data)  # Modifies data3, not data\ndata3.update(data2)  # Modifies data3, not data2\n</code></pre>\n<h3>Python\u00a03.5+:</h3>\n<p>This uses a new feature called <em>dictionary unpacking</em>.</p>\n<pre><code class=\"python\">data = {**data1, **data2, **data3}\n</code></pre>\n<h3>Python\u00a03.9+:</h3>\n<p>The <em>merge operator</em> <code>|</code> now works for dictionaries:</p>\n<pre><code class=\"python\">data = data1 | {'c':3,'d':4}\n</code></pre>\n<h2>Deleting items in dictionary</h2>\n<pre><code class=\"python\">del data[key]  # Removes specific element in a dictionary\ndata.pop(key)  # Removes the key &amp; returns the value\ndata.clear()  # Clears entire dictionary\n</code></pre>\n<h2>Check if a key is already in dictionary</h2>\n<pre><code class=\"python\">key in data\n</code></pre>\n<h2>Iterate through pairs in a dictionary</h2>\n<pre><code class=\"python\">for key in data: # Iterates just through the keys, ignoring the values\nfor key, value in d.items(): # Iterates through the pairs\nfor key in d.keys(): # Iterates just through key, ignoring the values\nfor value in d.values(): # Iterates just through value, ignoring the keys\n</code></pre>\n<h2>Create a dictionary from two lists</h2>\n<pre><code class=\"python\">data = dict(zip(list_with_keys, list_with_values))\n</code></pre>\n", "abstract": "I feel like consolidating info about Python dictionaries: The update operator |= now works for dictionaries: This uses a new feature called dictionary unpacking. The merge operator | now works for dictionaries:"}, {"id": 1165836, "score": 1228, "vote": 0, "content": "<p>To add multiple keys simultaneously, use <a href=\"https://docs.python.org/library/stdtypes.html#dict.update\" rel=\"noreferrer\"><code>dict.update()</code></a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = {1:2}\n&gt;&gt;&gt; print(x)\n{1: 2}\n\n&gt;&gt;&gt; d = {3:4, 5:6, 7:8}\n&gt;&gt;&gt; x.update(d)\n&gt;&gt;&gt; print(x)\n{1: 2, 3: 4, 5: 6, 7: 8}\n</code></pre>\n<p>For adding a single key, the accepted answer has less computational overhead.</p>\n", "abstract": "To add multiple keys simultaneously, use dict.update(): For adding a single key, the accepted answer has less computational overhead."}, {"id": 27208535, "score": 169, "vote": 0, "content": "<blockquote>\n<h1>\"Is it possible to add a key to a Python dictionary after it has been created? It doesn't seem to have an .add() method.\"</h1>\n</blockquote>\n<p>Yes it is possible, and it does have a method that implements this, but you don't want to use it directly.</p>\n<p>To demonstrate how and how not to use it, let's create an empty dict with the dict literal, <code>{}</code>:</p>\n<pre><code class=\"python\">my_dict = {}\n</code></pre>\n<h2>Best Practice 1: Subscript notation</h2>\n<p>To update this dict with a single new key and value, you can use <a href=\"https://docs.python.org/2/reference/datamodel.html#the-standard-type-hierarchy\" rel=\"noreferrer\">the subscript notation (see Mappings here)</a> that provides for item assignment:</p>\n<pre><code class=\"python\">my_dict['new key'] = 'new value'\n</code></pre>\n<p><code>my_dict</code> is now:</p>\n<pre><code class=\"python\">{'new key': 'new value'}\n</code></pre>\n<h2>Best Practice 2: The <code>update</code> method - 2 ways</h2>\n<p>We can also update the dict with multiple values efficiently as well using <a href=\"https://docs.python.org/2/library/stdtypes.html#dict.update\" rel=\"noreferrer\">the <code>update</code> method</a>.  We may be unnecessarily creating an extra <code>dict</code> here, so we hope our <code>dict</code> has already been created and came from or was used for another purpose:</p>\n<pre><code class=\"python\">my_dict.update({'key 2': 'value 2', 'key 3': 'value 3'})\n</code></pre>\n<p><code>my_dict</code> is now:</p>\n<pre><code class=\"python\">{'key 2': 'value 2', 'key 3': 'value 3', 'new key': 'new value'}\n</code></pre>\n<p>Another efficient way of doing this with the update method is with keyword arguments, but since they have to be legitimate python words, you can't have spaces or special symbols or start the name with a number, but many consider this a more readable way to create keys for a dict, and here we certainly avoid creating an extra unnecessary <code>dict</code>:</p>\n<pre><code class=\"python\">my_dict.update(foo='bar', foo2='baz')\n</code></pre>\n<p>and <code>my_dict</code> is now:</p>\n<pre><code class=\"python\">{'key 2': 'value 2', 'key 3': 'value 3', 'new key': 'new value', \n 'foo': 'bar', 'foo2': 'baz'}\n</code></pre>\n<p>So now we have covered three Pythonic ways of updating a <code>dict</code>.</p>\n<hr/>\n<h1>Magic method, <code>__setitem__</code>, and why it should be avoided</h1>\n<p>There's another way of updating a <code>dict</code> that you shouldn't use, which uses the <code>__setitem__</code> method. Here's an example of how one might use the <code>__setitem__</code> method to add a key-value pair to a <code>dict</code>, and a demonstration of the poor performance of using it:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d = {}\n&gt;&gt;&gt; d.__setitem__('foo', 'bar')\n&gt;&gt;&gt; d\n{'foo': 'bar'}\n\n\n&gt;&gt;&gt; def f():\n...     d = {}\n...     for i in xrange(100):\n...         d['foo'] = i\n... \n&gt;&gt;&gt; def g():\n...     d = {}\n...     for i in xrange(100):\n...         d.__setitem__('foo', i)\n... \n&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; number = 100\n&gt;&gt;&gt; min(timeit.repeat(f, number=number))\n0.0020880699157714844\n&gt;&gt;&gt; min(timeit.repeat(g, number=number))\n0.005071878433227539\n</code></pre>\n<p>So we see that using the subscript notation is actually much faster than using <code>__setitem__</code>. Doing the Pythonic thing, that is, using the language in the way it was intended to be used, usually is both more readable and computationally efficient.</p>\n", "abstract": "Yes it is possible, and it does have a method that implements this, but you don't want to use it directly. To demonstrate how and how not to use it, let's create an empty dict with the dict literal, {}: To update this dict with a single new key and value, you can use the subscript notation (see Mappings here) that provides for item assignment: my_dict is now: We can also update the dict with multiple values efficiently as well using the update method.  We may be unnecessarily creating an extra dict here, so we hope our dict has already been created and came from or was used for another purpose: my_dict is now: Another efficient way of doing this with the update method is with keyword arguments, but since they have to be legitimate python words, you can't have spaces or special symbols or start the name with a number, but many consider this a more readable way to create keys for a dict, and here we certainly avoid creating an extra unnecessary dict: and my_dict is now: So now we have covered three Pythonic ways of updating a dict. There's another way of updating a dict that you shouldn't use, which uses the __setitem__ method. Here's an example of how one might use the __setitem__ method to add a key-value pair to a dict, and a demonstration of the poor performance of using it: So we see that using the subscript notation is actually much faster than using __setitem__. Doing the Pythonic thing, that is, using the language in the way it was intended to be used, usually is both more readable and computationally efficient."}, {"id": 1024850, "score": 122, "vote": 0, "content": "<pre><code class=\"python\">dictionary[key] = value\n</code></pre>\n", "abstract": ""}, {"id": 10339748, "score": 65, "vote": 0, "content": "<p>If you want to add a dictionary within a dictionary you can do it this way. </p>\n<p>Example: Add a new entry to your dictionary &amp; sub dictionary</p>\n<pre><code class=\"python\">dictionary = {}\ndictionary[\"new key\"] = \"some new entry\" # add new dictionary entry\ndictionary[\"dictionary_within_a_dictionary\"] = {} # this is required by python\ndictionary[\"dictionary_within_a_dictionary\"][\"sub_dict\"] = {\"other\" : \"dictionary\"}\nprint (dictionary)\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"python\">{'new key': 'some new entry', 'dictionary_within_a_dictionary': {'sub_dict': {'other': 'dictionarly'}}}\n</code></pre>\n<p><strong>NOTE:</strong> Python requires that you first add a sub  </p>\n<pre><code class=\"python\">dictionary[\"dictionary_within_a_dictionary\"] = {}\n</code></pre>\n<p>before adding entries.</p>\n", "abstract": "If you want to add a dictionary within a dictionary you can do it this way.  Example: Add a new entry to your dictionary & sub dictionary Output: NOTE: Python requires that you first add a sub   before adding entries."}, {"id": 15994607, "score": 63, "vote": 0, "content": "<p>The conventional syntax is <code>d[key] = value</code>, but if your keyboard is missing the square bracket keys you could also do:</p>\n<pre><code class=\"python\">d.__setitem__(key, value)\n</code></pre>\n<p>In fact, defining <code>__getitem__</code> and <code>__setitem__</code> methods is how you can make your own class support the  square bracket syntax. See <em><a href=\"https://diveintopython3.net/special-method-names.html#acts-like-dict\" rel=\"nofollow noreferrer\">Dive Into Python, Classes That Act Like Dictionaries</a></em>.</p>\n", "abstract": "The conventional syntax is d[key] = value, but if your keyboard is missing the square bracket keys you could also do: In fact, defining __getitem__ and __setitem__ methods is how you can make your own class support the  square bracket syntax. See Dive Into Python, Classes That Act Like Dictionaries."}, {"id": 16750088, "score": 43, "vote": 0, "content": "<p>You can create one:</p>\n<pre><code class=\"python\">class myDict(dict):\n\n    def __init__(self):\n        self = dict()\n\n    def add(self, key, value):\n        self[key] = value\n\n## example\n\nmyd = myDict()\nmyd.add('apples',6)\nmyd.add('bananas',3)\nprint(myd)\n</code></pre>\n<p>Gives:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; \n{'apples': 6, 'bananas': 3}\n</code></pre>\n", "abstract": "You can create one: Gives:"}, {"id": 18294122, "score": 34, "vote": 0, "content": "<p><a href=\"https://stackoverflow.com/questions/38987/how-can-i-merge-union-two-python-dictionaries-in-a-single-expression\">This popular question</a> addresses <em>functional</em> methods of merging dictionaries <code>a</code> and <code>b</code>.</p>\n<p>Here are some of the more straightforward methods (tested in Python 3)...</p>\n<pre><code class=\"python\">c = dict( a, **b ) ## see also https://stackoverflow.com/q/2255878\nc = dict( list(a.items()) + list(b.items()) )\nc = dict( i for d in [a,b] for i in d.items() )\n</code></pre>\n<p><em>Note: The first method above only works if the keys in <code>b</code> are strings.</em></p>\n<p><strong>To add or modify a single element</strong>, the <code>b</code> dictionary would contain only that one element...</p>\n<pre><code class=\"python\">c = dict( a, **{'d':'dog'} ) ## returns a dictionary based on 'a'\n</code></pre>\n<p>This is equivalent to...</p>\n<pre><code class=\"python\">def functional_dict_add( dictionary, key, value ):\n   temp = dictionary.copy()\n   temp[key] = value\n   return temp\n\nc = functional_dict_add( a, 'd', 'dog' )\n</code></pre>\n", "abstract": "This popular question addresses functional methods of merging dictionaries a and b. Here are some of the more straightforward methods (tested in Python 3)... Note: The first method above only works if the keys in b are strings. To add or modify a single element, the b dictionary would contain only that one element... This is equivalent to..."}, {"id": 48232916, "score": 33, "vote": 0, "content": "<p>Let's pretend you want to live in the immutable world and do <em>not</em> want to modify the original but want to create a new <code>dict</code> that is the result of adding a new key to the original.</p>\n<p><strong>In Python 3.5+ you can do:</strong></p>\n<pre><code class=\"python\">params = {'a': 1, 'b': 2}\nnew_params = {**params, **{'c': 3}}\n</code></pre>\n<p><strong>The Python 2 equivalent is:</strong></p>\n<pre><code class=\"python\">params = {'a': 1, 'b': 2}\nnew_params = dict(params, **{'c': 3})\n</code></pre>\n<p>After either of these:</p>\n<p><code>params</code> is still equal to <code>{'a': 1, 'b': 2}</code></p>\n<p>and</p>\n<p><code>new_params</code> is equal to <code>{'a': 1, 'b': 2, 'c': 3}</code></p>\n<p>There will be times when you don't want to modify the original (you only want the result of adding to the original). <strong>I find this a refreshing alternative to the following:</strong></p>\n<pre><code class=\"python\">params = {'a': 1, 'b': 2}\nnew_params = params.copy()\nnew_params['c'] = 3\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">params = {'a': 1, 'b': 2}\nnew_params = params.copy()\nnew_params.update({'c': 3})\n</code></pre>\n<p>Reference: <em><a href=\"https://stackoverflow.com/questions/2255878/what-does-mean-in-the-expression-dictd1-d2/2255892#2255892\">What does `**` mean in the expression `dict(d1, **d2)`?</a></em></p>\n", "abstract": "Let's pretend you want to live in the immutable world and do not want to modify the original but want to create a new dict that is the result of adding a new key to the original. In Python 3.5+ you can do: The Python 2 equivalent is: After either of these: params is still equal to {'a': 1, 'b': 2} and new_params is equal to {'a': 1, 'b': 2, 'c': 3} There will be times when you don't want to modify the original (you only want the result of adding to the original). I find this a refreshing alternative to the following: or Reference: What does `**` mean in the expression `dict(d1, **d2)`?"}, {"id": 46891314, "score": 24, "vote": 0, "content": "<p>There is also the strangely named, oddly behaved, and yet still handy <a href=\"https://docs.python.org/3/library/stdtypes.html#dict.setdefault\" rel=\"nofollow noreferrer\"><code>dict.setdefault()</code></a>.</p>\n<p>This</p>\n<pre><code class=\"python\">value = my_dict.setdefault(key, default)\n</code></pre>\n<p>basically just does this:</p>\n<pre><code class=\"python\">try:\n    value = my_dict[key]\nexcept KeyError: # key not found\n    value = my_dict[key] = default\n</code></pre>\n<p>E.g.,</p>\n<pre><code class=\"python\">&gt;&gt;&gt; mydict = {'a':1, 'b':2, 'c':3}\n&gt;&gt;&gt; mydict.setdefault('d', 4)\n4 # returns new value at mydict['d']\n&gt;&gt;&gt; print(mydict)\n{'a':1, 'b':2, 'c':3, 'd':4} # a new key/value pair was indeed added\n# but see what happens when trying it on an existing key...\n&gt;&gt;&gt; mydict.setdefault('a', 111)\n1 # old value was returned\n&gt;&gt;&gt; print(mydict)\n{'a':1, 'b':2, 'c':3, 'd':4} # existing key was ignored\n</code></pre>\n", "abstract": "There is also the strangely named, oddly behaved, and yet still handy dict.setdefault(). This basically just does this: E.g.,"}, {"id": 69412024, "score": 16, "vote": 0, "content": "<blockquote>\n<p>This question has already been answered ad nauseam, but since my\n<a href=\"https://stackoverflow.com/questions/1024847/how-can-i-add-new-keys-to-a-dictionary?noredirect=1#comment94551424_1024847\">comment</a>\ngained a lot of traction, here it is as an answer:</p>\n</blockquote>\n<h1>Adding new keys without updating the existing dict</h1>\n<p>If you are here trying to figure out how to add a key and return a <em>new</em> dictionary (without modifying the existing one), you can do this using the techniques below</p>\n<h3>python &gt;= 3.5</h3>\n<pre><code class=\"python\">new_dict = {**mydict, 'new_key': new_val}\n</code></pre>\n<h3>python &lt; 3.5</h3>\n<pre><code class=\"python\">new_dict = dict(mydict, new_key=new_val)\n</code></pre>\n<p>Note that with this approach, your key will need to follow the <a href=\"https://docs.python.org/3/reference/lexical_analysis.html#identifiers\" rel=\"noreferrer\">rules of valid identifier names</a> in python.</p>\n", "abstract": "This question has already been answered ad nauseam, but since my\ncomment\ngained a lot of traction, here it is as an answer: If you are here trying to figure out how to add a key and return a new dictionary (without modifying the existing one), you can do this using the techniques below Note that with this approach, your key will need to follow the rules of valid identifier names in python."}, {"id": 52756111, "score": 9, "vote": 0, "content": "<p>If you're not joining two dictionaries, but adding new key-value pairs to a dictionary, then using the subscript notation seems like the best way.</p>\n<pre><code class=\"python\">import timeit\n\ntimeit.timeit('dictionary = {\"karga\": 1, \"darga\": 2}; dictionary.update({\"aaa\": 123123, \"asd\": 233})')\n&gt;&gt; 0.49582505226135254\n\ntimeit.timeit('dictionary = {\"karga\": 1, \"darga\": 2}; dictionary[\"aaa\"] = 123123; dictionary[\"asd\"] = 233;')\n&gt;&gt; 0.20782899856567383\n</code></pre>\n<p>However, if you'd like to add, for example, thousands of new key-value pairs, you should consider using the <code>update()</code> method.</p>\n", "abstract": "If you're not joining two dictionaries, but adding new key-value pairs to a dictionary, then using the subscript notation seems like the best way. However, if you'd like to add, for example, thousands of new key-value pairs, you should consider using the update() method."}, {"id": 58926921, "score": 8, "vote": 0, "content": "<p>Here's another way that I didn't see here: </p>\n<pre><code class=\"python\">&gt;&gt;&gt; foo = dict(a=1,b=2)\n&gt;&gt;&gt; foo\n{'a': 1, 'b': 2}\n&gt;&gt;&gt; goo = dict(c=3,**foo)\n&gt;&gt;&gt; goo\n{'c': 3, 'a': 1, 'b': 2}\n</code></pre>\n<p>You can use the dictionary constructor and implicit expansion to reconstruct a dictionary. Moreover, interestingly, this method can be used to control the positional order during dictionary construction (<a href=\"https://stackoverflow.com/q/39980323/325452\">post Python 3.6</a>). <a href=\"https://mail.python.org/pipermail/python-dev/2017-December/151283.html\" rel=\"noreferrer\">In fact, insertion order is guaranteed for Python 3.7 and above!</a></p>\n<pre><code class=\"python\">&gt;&gt;&gt; foo = dict(a=1,b=2,c=3,d=4)\n&gt;&gt;&gt; new_dict = {k: v for k, v in list(foo.items())[:2]}\n&gt;&gt;&gt; new_dict\n{'a': 1, 'b': 2}\n&gt;&gt;&gt; new_dict.update(newvalue=99)\n&gt;&gt;&gt; new_dict\n{'a': 1, 'b': 2, 'newvalue': 99}\n&gt;&gt;&gt; new_dict.update({k: v for k, v in list(foo.items())[2:]})\n&gt;&gt;&gt; new_dict\n{'a': 1, 'b': 2, 'newvalue': 99, 'c': 3, 'd': 4}\n&gt;&gt;&gt; \n</code></pre>\n<p>The above is using dictionary comprehension.</p>\n", "abstract": "Here's another way that I didn't see here:  You can use the dictionary constructor and implicit expansion to reconstruct a dictionary. Moreover, interestingly, this method can be used to control the positional order during dictionary construction (post Python 3.6). In fact, insertion order is guaranteed for Python 3.7 and above! The above is using dictionary comprehension."}, {"id": 55338408, "score": 6, "vote": 0, "content": "<p>First to check whether the key already exists:</p>\n<pre><code class=\"python\">a={1:2,3:4}\na.get(1)\n2\na.get(5)\nNone\n</code></pre>\n<p>Then you can add the new key and value.</p>\n", "abstract": "First to check whether the key already exists: Then you can add the new key and value."}, {"id": 60049491, "score": 5, "vote": 0, "content": "<p>Add a dictionary <em>(key,value)</em> class.</p>\n<pre><code class=\"python\">class myDict(dict):\n\n    def __init__(self):\n        self = dict()\n\n    def add(self, key, value):\n        #self[key] = value # add new key and value overwriting any exiting same key\n        if self.get(key)!=None:\n            print('key', key, 'already used') # report if key already used\n        self.setdefault(key, value) # if key exit do nothing\n\n\n## example\n\nmyd = myDict()\nname = \"fred\"\n\nmyd.add('apples',6)\nprint('\\n', myd)\nmyd.add('bananas',3)\nprint('\\n', myd)\nmyd.add('jack', 7)\nprint('\\n', myd)\nmyd.add(name, myd)\nprint('\\n', myd)\nmyd.add('apples', 23)\nprint('\\n', myd)\nmyd.add(name, 2)\nprint(myd)\n</code></pre>\n", "abstract": "Add a dictionary (key,value) class."}, {"id": 57682416, "score": 4, "vote": 0, "content": "<p>I think it would also be useful to point out Python's <strong><a href=\"https://docs.python.org/3/library/collections.html\" rel=\"nofollow noreferrer\"><code>collections</code></a></strong> module that consists of many useful dictionary subclasses and wrappers that simplify the <strong>addition and modification of data types in a dictionary</strong>, specifically <a href=\"https://docs.python.org/3/library/collections.html#collections.defaultdict\" rel=\"nofollow noreferrer\"><strong><code>defaultdict</code></strong></a>:</p>\n<blockquote>\n<p>dict subclass that calls a factory function to supply missing values</p>\n</blockquote>\n<p>This is particularly useful if you are working with dictionaries that always consist of the same data types or structures, for example a dictionary of lists. </p>\n<pre><code class=\"python\">&gt;&gt;&gt; from collections import defaultdict\n&gt;&gt;&gt; example = defaultdict(int)\n&gt;&gt;&gt; example['key'] += 1\n&gt;&gt;&gt; example['key']\ndefaultdict(&lt;class 'int'&gt;, {'key': 1})\n</code></pre>\n<p>If the key does not yet exist, <code>defaultdict</code> assigns the value given (in our case <code>10</code>) as the initial value to the dictionary (often used inside loops). This operation therefore does two things: it <strong>adds a new key to a dictionary (as per question), <em>and</em> assigns the value if the key doesn't yet exist.</strong> With the standard dictionary, this would have raised an error as the <code>+=</code> operation is trying to access a value that doesn't yet exist:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; example = dict()\n&gt;&gt;&gt; example['key'] += 1\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: 'key'\n</code></pre>\n<p>Without the use of <code>defaultdict</code>, the amount of code to add a new element would be much greater and perhaps looks something like: </p>\n<pre><code class=\"python\"># This type of code would often be inside a loop\nif 'key' not in example:\n    example['key'] = 0  # add key and initial value to dict; could also be a list\nexample['key'] += 1  # this is implementing a counter\n</code></pre>\n<p><code>defaultdict</code> can also be used with complex data types such as <code>list</code> and <code>set</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; example = defaultdict(list)\n&gt;&gt;&gt; example['key'].append(1)\n&gt;&gt;&gt; example\ndefaultdict(&lt;class 'list'&gt;, {'key': [1]})\n</code></pre>\n<p>Adding an element automatically initialises the list.</p>\n", "abstract": "I think it would also be useful to point out Python's collections module that consists of many useful dictionary subclasses and wrappers that simplify the addition and modification of data types in a dictionary, specifically defaultdict: dict subclass that calls a factory function to supply missing values This is particularly useful if you are working with dictionaries that always consist of the same data types or structures, for example a dictionary of lists.  If the key does not yet exist, defaultdict assigns the value given (in our case 10) as the initial value to the dictionary (often used inside loops). This operation therefore does two things: it adds a new key to a dictionary (as per question), and assigns the value if the key doesn't yet exist. With the standard dictionary, this would have raised an error as the += operation is trying to access a value that doesn't yet exist: Without the use of defaultdict, the amount of code to add a new element would be much greater and perhaps looks something like:  defaultdict can also be used with complex data types such as list and set: Adding an element automatically initialises the list."}, {"id": 72570068, "score": 3, "vote": 0, "content": "<h1>Adding keys to dictionary without using add</h1>\n<pre><code class=\"python\">        # Inserting/Updating single value\n        # subscript notation method\n        d['mynewkey'] = 'mynewvalue' # Updates if 'a' exists, else adds 'a'\n        # OR\n        d.update({'mynewkey': 'mynewvalue'})\n        # OR\n        d.update(dict('mynewkey'='mynewvalue'))\n        # OR\n        d.update('mynewkey'='mynewvalue')\n        print(d)  # {'key': 'value', 'mynewkey': 'mynewvalue'}\n        # To add/update multiple keys simultaneously, use d.update():\n        x = {3:4, 5:6, 7:8}\n        d.update(x)\n        print(d) # {'key': 'value', 'mynewkey': 'mynewvalue', 3: 4, 5: 6, 7: 8}\n        # update operator |= now works for dictionaries:\n        d |= {'c':3,'d':4}\n        # Assigning new key value pair using dictionary unpacking.\n        data1 = {4:6, 9:10, 17:20}\n        data2 = {20:30, 32:48, 90:100}\n        data3 = { 38:\"value\", 99:\"notvalid\"}\n        d = {**data1, **data2, **data3}\n        # The merge operator | now works for dictionaries:\n        data = data1 | {'c':3,'d':4}\n        # Create a dictionary from two lists\n        data = dict(zip(list_with_keys, list_with_values))\n</code></pre>\n", "abstract": ""}, {"id": 73924595, "score": -2, "vote": 0, "content": "<p>dico[\"new key\"] = \"value\"</p>\n", "abstract": "dico[\"new key\"] = \"value\""}]}, {"link": "https://stackoverflow.com/questions/448271/what-is-init-py-for", "question": {"id": "448271", "title": "What is __init__.py for?", "content": "<p>What is <a href=\"https://docs.python.org/3/tutorial/modules.html#packages\" rel=\"noreferrer\"><code>__init__.py</code></a> for in a Python source directory?</p>\n", "abstract": "What is __init__.py for in a Python source directory?"}, "answers": [{"id": 448279, "score": 1874, "vote": 0, "content": "<p>It used to be a required part of a package (<a href=\"https://docs.python.org/3/reference/import.html#regular-packages\" rel=\"noreferrer\">old, pre-3.3 \"regular package\"</a>, not <a href=\"https://docs.python.org/3/reference/import.html#namespace-packages\" rel=\"noreferrer\">newer 3.3+ \"namespace package\"</a>).</p>\n<p><a href=\"https://docs.python.org/3/reference/import.html#regular-packages\" rel=\"noreferrer\">Here's the documentation.</a></p>\n<blockquote>\n<p>Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an <code>__init__.py</code> file. When a regular package is imported, this <code>__init__.py</code> file is implicitly executed, and the objects it defines are bound to names in the package\u2019s namespace. The <code>__init__.py</code> file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.</p>\n</blockquote>\n<p>But just click the link, it contains an example, more information, and an explanation of namespace packages, the kind of packages without <code>__init__.py</code>.</p>\n", "abstract": "It used to be a required part of a package (old, pre-3.3 \"regular package\", not newer 3.3+ \"namespace package\"). Here's the documentation. Python defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an __init__.py file. When a regular package is imported, this __init__.py file is implicitly executed, and the objects it defines are bound to names in the package\u2019s namespace. The __init__.py file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported. But just click the link, it contains an example, more information, and an explanation of namespace packages, the kind of packages without __init__.py."}, {"id": 4116384, "score": 1144, "vote": 0, "content": "<p>Files named <code>__init__.py</code> are used to mark directories on disk as Python package directories.\nIf you have the files</p>\n<pre><code class=\"python\">mydir/spam/__init__.py\nmydir/spam/module.py\n</code></pre>\n<p>and <code>mydir</code> is on your path, you can import the code in <code>module.py</code> as</p>\n<pre><code class=\"python\">import spam.module\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">from spam import module\n</code></pre>\n<p>If you remove the <code>__init__.py</code> file, Python will no longer look for submodules inside that directory, so attempts to import the module will fail.</p>\n<p>The <code>__init__.py</code> file is usually empty, but can be used to export selected portions of the package under more convenient name, hold convenience functions, etc.\nGiven the example above, the contents of the init module can be accessed as</p>\n<pre><code class=\"python\">import spam\n</code></pre>\n<p>based on <a href=\"https://web.archive.org/web/20200721150953/http://effbot.org/pyfaq/what-is-init-py-used-for.htm\" rel=\"noreferrer\">this</a></p>\n", "abstract": "Files named __init__.py are used to mark directories on disk as Python package directories.\nIf you have the files and mydir is on your path, you can import the code in module.py as or If you remove the __init__.py file, Python will no longer look for submodules inside that directory, so attempts to import the module will fail. The __init__.py file is usually empty, but can be used to export selected portions of the package under more convenient name, hold convenience functions, etc.\nGiven the example above, the contents of the init module can be accessed as based on this"}, {"id": 18979314, "score": 624, "vote": 0, "content": "<p>In addition to labeling a directory as a Python package and defining <code>__all__</code>, <strong><code>__init__.py</code> allows you to define any variable at the package level.</strong> Doing so is often convenient if a package defines something that will be imported frequently, in an API-like fashion. This pattern promotes adherence to the Pythonic \"flat is better than nested\" philosophy.</p>\n<h2>An example</h2>\n<p>Here is an example from one of my projects, in which I frequently import a <code>sessionmaker</code> called <code>Session</code> to interact with my database. I wrote a \"database\" package with a few modules:</p>\n<pre><code class=\"python\">database/\n    __init__.py\n    schema.py\n    insertions.py\n    queries.py\n</code></pre>\n<p>My <code>__init__.py</code> contains the following code:</p>\n<pre><code class=\"python\">import os\n\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy import create_engine\n\nengine = create_engine(os.environ['DATABASE_URL'])\nSession = sessionmaker(bind=engine)\n</code></pre>\n<p>Since I define <code>Session</code> here, I can start a new session using the syntax below. This code would be the same executed from inside or outside of the \"database\" package directory.</p>\n<pre><code class=\"python\">from database import Session\nsession = Session()\n</code></pre>\n<p>Of course, this is a small convenience -- the alternative would be to define <code>Session</code> in a new file like \"create_session.py\" in my database package, and start new sessions using:</p>\n<pre><code class=\"python\">from database.create_session import Session\nsession = Session()\n</code></pre>\n<h2>Further reading</h2>\n<p>There is a pretty interesting reddit thread covering appropriate uses of <code>__init__.py</code> here:</p>\n<p><a href=\"http://www.reddit.com/r/Python/comments/1bbbwk/whats_your_opinion_on_what_to_include_in_init_py/\">http://www.reddit.com/r/Python/comments/1bbbwk/whats_your_opinion_on_what_to_include_in_init_py/</a></p>\n<p>The majority opinion seems to be that <code>__init__.py</code> files should be very thin to avoid violating the \"explicit is better than implicit\" philosophy.</p>\n", "abstract": "In addition to labeling a directory as a Python package and defining __all__, __init__.py allows you to define any variable at the package level. Doing so is often convenient if a package defines something that will be imported frequently, in an API-like fashion. This pattern promotes adherence to the Pythonic \"flat is better than nested\" philosophy. Here is an example from one of my projects, in which I frequently import a sessionmaker called Session to interact with my database. I wrote a \"database\" package with a few modules: My __init__.py contains the following code: Since I define Session here, I can start a new session using the syntax below. This code would be the same executed from inside or outside of the \"database\" package directory. Of course, this is a small convenience -- the alternative would be to define Session in a new file like \"create_session.py\" in my database package, and start new sessions using: There is a pretty interesting reddit thread covering appropriate uses of __init__.py here: http://www.reddit.com/r/Python/comments/1bbbwk/whats_your_opinion_on_what_to_include_in_init_py/ The majority opinion seems to be that __init__.py files should be very thin to avoid violating the \"explicit is better than implicit\" philosophy."}, {"id": 29509611, "score": 464, "vote": 0, "content": "<p>There are 2 main reasons for <code>__init__.py</code></p>\n<ol>\n<li><p>For convenience: the other users will not need to know your functions' exact location in your package hierarchy (<a href=\"https://docs.python.org/3/reference/import.html#submodules\" rel=\"noreferrer\">documentation</a>).</p>\n<pre><code class=\"python\">your_package/\n  __init__.py\n  file1.py\n  file2.py\n    ...\n  fileN.py\n</code></pre>\n<pre><code class=\"python\"># in __init__.py\nfrom .file1 import *\nfrom .file2 import *\n...\nfrom .fileN import *\n</code></pre>\n<pre><code class=\"python\"># in file1.py\ndef add():\n    pass\n</code></pre>\n<p>then others can call add() by</p>\n<pre><code class=\"python\"> from your_package import add\n</code></pre>\n<p>without knowing file1's inside functions, like</p>\n<pre><code class=\"python\"> from your_package.file1 import add\n</code></pre>\n</li>\n<li><p>If you want something to be initialized; for example, logging (which should be put in the top level):</p>\n<pre><code class=\"python\"> import logging.config\n logging.config.dictConfig(Your_logging_config)\n</code></pre>\n</li>\n</ol>\n", "abstract": "There are 2 main reasons for __init__.py For convenience: the other users will not need to know your functions' exact location in your package hierarchy (documentation). then others can call add() by without knowing file1's inside functions, like If you want something to be initialized; for example, logging (which should be put in the top level):"}, {"id": 448311, "score": 174, "vote": 0, "content": "<p>The <code>__init__.py</code> file makes Python treat directories containing it as modules. </p>\n<p>Furthermore, this is the first file to be loaded in a module, so you can use it to execute code that you want to run each time a module is loaded, or specify the submodules to be exported.</p>\n", "abstract": "The __init__.py file makes Python treat directories containing it as modules.  Furthermore, this is the first file to be loaded in a module, so you can use it to execute code that you want to run each time a module is loaded, or specify the submodules to be exported."}, {"id": 39991978, "score": 130, "vote": 0, "content": "<p>Since Python 3.3, <code>__init__.py</code> is no longer required to define directories as importable Python packages.</p>\n<p>Check <a href=\"https://docs.python.org/3/whatsnew/3.3.html#pep-420-implicit-namespace-packages\" rel=\"noreferrer\">PEP 420: Implicit Namespace Packages</a>:</p>\n<blockquote>\n<p>Native support for package directories that don\u2019t require <code>__init__.py</code> marker files and can automatically span multiple path segments (inspired by various third party approaches to namespace packages, as described in <a href=\"https://www.python.org/dev/peps/pep-0420/\" rel=\"noreferrer\">PEP 420</a>)</p>\n</blockquote>\n<p>Here's the test:  </p>\n<pre><code class=\"python\">$ mkdir -p /tmp/test_init\n$ touch /tmp/test_init/module.py /tmp/test_init/__init__.py\n$ tree -at /tmp/test_init\n/tmp/test_init\n\u251c\u2500\u2500 module.py\n\u2514\u2500\u2500 __init__.py\n$ python3\n\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.path.insert(0, '/tmp')\n&gt;&gt;&gt; from test_init import module\n&gt;&gt;&gt; import test_init.module\n\n$ rm -f /tmp/test_init/__init__.py\n$ tree -at /tmp/test_init\n/tmp/test_init\n\u2514\u2500\u2500 module.py\n$ python3\n\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.path.insert(0, '/tmp')\n&gt;&gt;&gt; from test_init import module\n&gt;&gt;&gt; import test_init.module\n</code></pre>\n<p>references:<br/>\n<a href=\"https://docs.python.org/3/whatsnew/3.3.html#pep-420-implicit-namespace-packages\" rel=\"noreferrer\">https://docs.python.org/3/whatsnew/3.3.html#pep-420-implicit-namespace-packages</a><br/>\n<a href=\"https://www.python.org/dev/peps/pep-0420/\" rel=\"noreferrer\">https://www.python.org/dev/peps/pep-0420/</a><br/>\n<a href=\"https://stackoverflow.com/questions/37139786/is-init-py-not-required-for-packages-in-python-3\">Is __init__.py not required for packages in Python 3?</a> </p>\n", "abstract": "Since Python 3.3, __init__.py is no longer required to define directories as importable Python packages. Check PEP 420: Implicit Namespace Packages: Native support for package directories that don\u2019t require __init__.py marker files and can automatically span multiple path segments (inspired by various third party approaches to namespace packages, as described in PEP 420) Here's the test:   references:\nhttps://docs.python.org/3/whatsnew/3.3.html#pep-420-implicit-namespace-packages\nhttps://www.python.org/dev/peps/pep-0420/\nIs __init__.py not required for packages in Python 3? "}, {"id": 50307979, "score": 103, "vote": 0, "content": "<p>Although Python works without an <code>__init__.py</code> file you should still include one.</p>\n<p>It specifies that the directory should be treated as a package, so therefore include it (even if it is empty).</p>\n<p><strong>There is also a case where you may actually use an <code>__init__.py</code> file:</strong></p>\n<p><em>Imagine you had the following file structure:</em></p>\n<pre><code class=\"python\">main_methods \n    |- methods.py\n</code></pre>\n<p>And <code>methods.py</code> contained this:</p>\n<pre><code class=\"python\">def foo():\n    return 'foo'\n</code></pre>\n<p>To use <code>foo()</code> you would need one of the following:</p>\n<pre><code class=\"python\">from main_methods.methods import foo # Call with foo()\nfrom main_methods import methods # Call with methods.foo()\nimport main_methods.methods # Call with main_methods.methods.foo()\n</code></pre>\n<p>Maybe there you need (or want) to keep <code>methods.py</code> inside <code>main_methods</code> (runtimes/dependencies for example) but you only want to import <code>main_methods</code>.</p>\n<hr/>\n<p>If you changed the name of <code>methods.py</code> to <code>__init__.py</code> then you could use <code>foo()</code> by just importing <code>main_methods</code>:</p>\n<pre><code class=\"python\">import main_methods\nprint(main_methods.foo()) # Prints 'foo'\n</code></pre>\n<p>This works because <code>__init__.py</code> is treated as part of the package.</p>\n<hr/>\n<p>Some Python packages actually do this.  An example is with <a href=\"https://docs.python.org/3/library/json.html\" rel=\"noreferrer\">JSON</a>, where running <code>import json</code> is actually importing <code>__init__.py</code> from the <code>json</code> package (<a href=\"https://github.com/python/cpython/tree/3.6/Lib/json\" rel=\"noreferrer\">see the package file structure here</a>):</p>\n<blockquote>\n<p><strong>Source code:</strong> <code>Lib/json/__init__.py</code></p>\n</blockquote>\n", "abstract": "Although Python works without an __init__.py file you should still include one. It specifies that the directory should be treated as a package, so therefore include it (even if it is empty). There is also a case where you may actually use an __init__.py file: Imagine you had the following file structure: And methods.py contained this: To use foo() you would need one of the following: Maybe there you need (or want) to keep methods.py inside main_methods (runtimes/dependencies for example) but you only want to import main_methods. If you changed the name of methods.py to __init__.py then you could use foo() by just importing main_methods: This works because __init__.py is treated as part of the package. Some Python packages actually do this.  An example is with JSON, where running import json is actually importing __init__.py from the json package (see the package file structure here): Source code: Lib/json/__init__.py"}, {"id": 21019300, "score": 70, "vote": 0, "content": "<p>In Python the definition of package is very simple. Like Java the hierarchical structure and the directory structure are the same. But you have to have <code>__init__.py</code> in a package. I will explain the <code>__init__.py</code> file with the example below:</p>\n<pre><code class=\"python\">package_x/\n|--  __init__.py\n|--    subPackage_a/\n|------  __init__.py\n|------  module_m1.py\n|--    subPackage_b/\n|------  __init__.py\n|------  module_n1.py\n|------  module_n2.py\n|------  module_n3.py\n</code></pre>\n<p><code>__init__.py</code> can be empty, as long as it exists. It indicates that the directory should be regarded as a package. Of course, <code>__init__.py</code> can also set the appropriate content.</p>\n<p>If we add a function in module_n1:</p>\n<pre><code class=\"python\">def function_X():\n    print \"function_X in module_n1\"\n    return\n</code></pre>\n<p>After running:</p>\n<pre><code class=\"python\">&gt;&gt;&gt;from package_x.subPackage_b.module_n1 import function_X\n&gt;&gt;&gt;function_X()\n\nfunction_X in module_n1 \n</code></pre>\n<p>Then we followed the hierarchy package and called module_n1 the function. We can use <code>__init__.py</code> in subPackage_b like this:</p>\n<pre><code class=\"python\">__all__ = ['module_n2', 'module_n3']\n</code></pre>\n<p>After running: </p>\n<pre><code class=\"python\">&gt;&gt;&gt;from package_x.subPackage_b import * \n&gt;&gt;&gt;module_n1.function_X()\n\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nImportError: No module named module_n1\n</code></pre>\n<p>Hence using * importing, module package is subject to <code>__init__.py</code> content.</p>\n", "abstract": "In Python the definition of package is very simple. Like Java the hierarchical structure and the directory structure are the same. But you have to have __init__.py in a package. I will explain the __init__.py file with the example below: __init__.py can be empty, as long as it exists. It indicates that the directory should be regarded as a package. Of course, __init__.py can also set the appropriate content. If we add a function in module_n1: After running: Then we followed the hierarchy package and called module_n1 the function. We can use __init__.py in subPackage_b like this: After running:  Hence using * importing, module package is subject to __init__.py content."}, {"id": 27757676, "score": 49, "vote": 0, "content": "<p><code>__init__.py</code> will treat the directory it is in as a loadable module.</p>\n<p>For people who prefer reading code, I put <a href=\"https://stackoverflow.com/users/2588818/two-bit-alchemist\">Two-Bit Alchemist's</a> comment here.</p>\n<pre><code class=\"python\">$ find /tmp/mydir/\n/tmp/mydir/\n/tmp/mydir//spam\n/tmp/mydir//spam/__init__.py\n/tmp/mydir//spam/module.py\n$ cd ~\n$ python\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.path.insert(0, '/tmp/mydir')\n&gt;&gt;&gt; from spam import module\n&gt;&gt;&gt; module.myfun(3)\n9\n&gt;&gt;&gt; exit()\n$ \n$ rm /tmp/mydir/spam/__init__.py*\n$ \n$ python\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.path.insert(0, '/tmp/mydir')\n&gt;&gt;&gt; from spam import module\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nImportError: No module named spam\n&gt;&gt;&gt; \n</code></pre>\n", "abstract": "__init__.py will treat the directory it is in as a loadable module. For people who prefer reading code, I put Two-Bit Alchemist's comment here."}, {"id": 448292, "score": 41, "vote": 0, "content": "<p>It facilitates importing other python files. When you placed this file in a directory (say stuff)containing other py files, then you can do something like import stuff.other.</p>\n<pre><code class=\"python\">root\\\n    stuff\\\n         other.py\n\n    morestuff\\\n         another.py\n</code></pre>\n<p>Without this <code>__init__.py</code> inside the directory stuff, you couldn't import other.py, because Python doesn't know where the source code for stuff is and unable to recognize it as a package. </p>\n", "abstract": "It facilitates importing other python files. When you placed this file in a directory (say stuff)containing other py files, then you can do something like import stuff.other. Without this __init__.py inside the directory stuff, you couldn't import other.py, because Python doesn't know where the source code for stuff is and unable to recognize it as a package. "}, {"id": 56301295, "score": 14, "vote": 0, "content": "<p>An <code>__init__.py</code> file makes imports easy. When an <code>__init__.py</code> is present within a package, function <code>a()</code> can be imported from file <code>b.py</code> like so:</p>\n<pre><code class=\"python\">from b import a\n</code></pre>\n<p>Without it, however, you can't import directly. You have to amend the system path:</p>\n<pre><code class=\"python\">import sys\nsys.path.insert(0, 'path/to/b.py')\n\nfrom b import a\n</code></pre>\n", "abstract": "An __init__.py file makes imports easy. When an __init__.py is present within a package, function a() can be imported from file b.py like so: Without it, however, you can't import directly. You have to amend the system path:"}, {"id": 62985979, "score": 5, "vote": 0, "content": "<p>One thing __init__.py allows is converting a module to a package without breaking the API or creating extraneous nested namespaces or private modules*. This helps when I want to extend a namespace.</p>\n<p>If I have a file util.py containing</p>\n<pre><code class=\"python\">def foo():\n    ...\n</code></pre>\n<p>then users will access <code>foo</code> with</p>\n<pre><code class=\"python\">from util import foo\n</code></pre>\n<p>If I then want to add utility functions for database interaction, and I want them to have their own namespace under <code>util</code>, I'll need a new directory**, and to keep API compatibility (so that <code>from util import foo</code> still works), I'll call it util/. I <em>could</em> move util.py into util/ like so,</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">util/\n  __init__.py\n  util.py\n  db.py\n</code></pre>\n<p>and in util/__init__.py do</p>\n<pre><code class=\"python\">from util import *\n</code></pre>\n<p>but this is redundant. Instead of having a util/util.py file, we can just put the util.py contents in __init__.py and the user can now</p>\n<pre><code class=\"python\">from util import foo\nfrom util.db import check_schema\n</code></pre>\n<p>I think this nicely highlights how a <code>util</code> package's __init__.py acts in a similar way to a <code>util</code> module</p>\n<p>* this is hinted at in the other answers, but I want to highlight it here<br/>\n** short of employing import gymnastics. Note it won't work to create a new package with the same name as the file, see <a href=\"https://stackoverflow.com/q/6393861/5986907\">this</a></p>\n", "abstract": "One thing __init__.py allows is converting a module to a package without breaking the API or creating extraneous nested namespaces or private modules*. This helps when I want to extend a namespace. If I have a file util.py containing then users will access foo with If I then want to add utility functions for database interaction, and I want them to have their own namespace under util, I'll need a new directory**, and to keep API compatibility (so that from util import foo still works), I'll call it util/. I could move util.py into util/ like so, and in util/__init__.py do but this is redundant. Instead of having a util/util.py file, we can just put the util.py contents in __init__.py and the user can now I think this nicely highlights how a util package's __init__.py acts in a similar way to a util module * this is hinted at in the other answers, but I want to highlight it here\n** short of employing import gymnastics. Note it won't work to create a new package with the same name as the file, see this"}, {"id": 72981281, "score": 0, "vote": 0, "content": "<p>If you're using Python 2 and want to load siblings of your file you can simply add the parent folder of your file to your system paths of the session. It will behave about the same as if your current file was an init file.</p>\n<pre><code class=\"python\">import os\nimport sys\ndir_path = os.path.dirname(__file__)\nsys.path.insert(0, dir_path)\n</code></pre>\n<p>After that regular imports relative to the file's directory will work just fine. E.g.</p>\n<pre><code class=\"python\">import cheese\nfrom vehicle_parts import *\n# etc.\n</code></pre>\n<p>Generally you want to use a proper <strong>init</strong>.py file instead though, but when dealing with legacy code you might be stuck with f.ex. a library hard-coded to load a particular file and nothing but. For those cases this is an alternative.</p>\n", "abstract": "If you're using Python 2 and want to load siblings of your file you can simply add the parent folder of your file to your system paths of the session. It will behave about the same as if your current file was an init file. After that regular imports relative to the file's directory will work just fine. E.g. Generally you want to use a proper init.py file instead though, but when dealing with legacy code you might be stuck with f.ex. a library hard-coded to load a particular file and nothing but. For those cases this is an alternative."}, {"id": 71742178, "score": -1, "vote": 0, "content": "<p><strong>init</strong>.py : It is a python file found in a package directory, it is invoked when the package or a module in the package is imported. You can use this to execute package initialization code, i.e. whenever the package is imported the python statements are executed first before the other modules in this folder gets executed. It is similar to main function of c or java program but this exists in the python package module(folder) rather than in the core python file.\nalso it has access to global variables defined in this <strong>init</strong>.py file as when the module is imported into python file.</p>\n<p>for eg.\nI have a <strong>init</strong>.py file in a folder called pymodlib, this file contains the following statements:</p>\n<p>print(f'Invoking <strong>init</strong>.py for {<strong>name</strong>}')\npystructures = ['for_loop', 'while__loop', 'ifCondition']</p>\n<p>when I import this package \"pymodlib\" in the my solution module or notebook or python console:\nthis two statements gets executed while importing.\nSo in the log or console you would see the following output:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>import pymodlib\nInvoking <strong>init</strong>.py for pymodlib</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>in the next statement of python console: I can access the global variable:</p>\n<blockquote>\n<blockquote>\n<p>pymodlib.pystructures\nit gives the following output:</p>\n</blockquote>\n</blockquote>\n<p>['for_loop', 'while__loop', 'ifCondition']</p>\n<p>Now from python3.3 onwards the use of this file has been optional to make folder a python module. So you skip from including it in the python module folder.</p>\n", "abstract": "init.py : It is a python file found in a package directory, it is invoked when the package or a module in the package is imported. You can use this to execute package initialization code, i.e. whenever the package is imported the python statements are executed first before the other modules in this folder gets executed. It is similar to main function of c or java program but this exists in the python package module(folder) rather than in the core python file.\nalso it has access to global variables defined in this init.py file as when the module is imported into python file. for eg.\nI have a init.py file in a folder called pymodlib, this file contains the following statements: print(f'Invoking init.py for {name}')\npystructures = ['for_loop', 'while__loop', 'ifCondition'] when I import this package \"pymodlib\" in the my solution module or notebook or python console:\nthis two statements gets executed while importing.\nSo in the log or console you would see the following output: import pymodlib\nInvoking init.py for pymodlib in the next statement of python console: I can access the global variable: pymodlib.pystructures\nit gives the following output: ['for_loop', 'while__loop', 'ifCondition'] Now from python3.3 onwards the use of this file has been optional to make folder a python module. So you skip from including it in the python module folder."}]}, {"link": "https://stackoverflow.com/questions/1720421/how-do-i-concatenate-two-lists-in-python", "question": {"id": "1720421", "title": "How do I concatenate two lists in Python?", "content": "<p>How do I concatenate two lists in Python?</p>\n<p>Example:</p>\n<pre><code class=\"python\">listone = [1, 2, 3]\nlisttwo = [4, 5, 6]\n</code></pre>\n<p>Expected outcome:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; joinedlist\n[1, 2, 3, 4, 5, 6]\n</code></pre>\n", "abstract": "How do I concatenate two lists in Python? Example: Expected outcome:"}, "answers": [{"id": 1720432, "score": 5109, "vote": 0, "content": "<p>Use the <code>+</code> operator to combine the lists:</p>\n<pre><code class=\"python\">listone = [1, 2, 3]\nlisttwo = [4, 5, 6]\n\njoinedlist = listone + listtwo\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; joinedlist\n[1, 2, 3, 4, 5, 6]\n</code></pre>\n", "abstract": "Use the + operator to combine the lists: Output:"}, {"id": 35631185, "score": 553, "vote": 0, "content": "<p>Python &gt;= 3.5 alternative: <code>[*l1, *l2]</code></p>\n<p>Another alternative has been introduced via the acceptance of <a href=\"https://www.python.org/dev/peps/pep-0448/\" rel=\"noreferrer\">PEP 448</a> which deserves mentioning.</p>\n<p>The PEP, titled <em><strong>Additional Unpacking Generalizations</strong></em>, generally reduced some syntactic restrictions when using the starred <code>*</code> expression in Python; with it, joining two lists (applies to any iterable) can now also be done with:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; l1 = [1, 2, 3]\n&gt;&gt;&gt; l2 = [4, 5, 6]\n&gt;&gt;&gt; joined_list = [*l1, *l2]  # unpack both iterables in a list literal\n&gt;&gt;&gt; print(joined_list)\n[1, 2, 3, 4, 5, 6]\n</code></pre>\n<p>This functionality <em>was defined</em> for Python 3.5, but it hasn't been backported to previous versions in the 3.x family. In unsupported versions a <code>SyntaxError</code> is going to be raised.</p>\n<p>As with the other approaches, this too <em>creates as shallow copy</em> of the elements in the corresponding lists.</p>\n<hr/>\n<p>The <strong>upside</strong> to this approach is that you really don't need lists in order to perform it; anything that is iterable will do. As stated in the PEP:</p>\n<blockquote>\n<p>This is also useful as a more readable way of summing iterables into a\nlist, such as <code>my_list + list(my_tuple) + list(my_range)</code> which is now\nequivalent to just <code>[*my_list, *my_tuple, *my_range]</code>.</p>\n</blockquote>\n<p>So while addition with <code>+</code> would raise a <code>TypeError</code> due to type mismatch:</p>\n<pre><code class=\"python\">l = [1, 2, 3]\nr = range(4, 7)\nres = l + r\n</code></pre>\n<p>The following won't:</p>\n<pre><code class=\"python\">res = [*l, *r]\n</code></pre>\n<p>because it will first unpack the contents of the iterables and then simply create a <code>list</code> from the contents.</p>\n", "abstract": "Python >= 3.5 alternative: [*l1, *l2] Another alternative has been introduced via the acceptance of PEP 448 which deserves mentioning. The PEP, titled Additional Unpacking Generalizations, generally reduced some syntactic restrictions when using the starred * expression in Python; with it, joining two lists (applies to any iterable) can now also be done with: This functionality was defined for Python 3.5, but it hasn't been backported to previous versions in the 3.x family. In unsupported versions a SyntaxError is going to be raised. As with the other approaches, this too creates as shallow copy of the elements in the corresponding lists. The upside to this approach is that you really don't need lists in order to perform it; anything that is iterable will do. As stated in the PEP: This is also useful as a more readable way of summing iterables into a\nlist, such as my_list + list(my_tuple) + list(my_range) which is now\nequivalent to just [*my_list, *my_tuple, *my_range]. So while addition with + would raise a TypeError due to type mismatch: The following won't: because it will first unpack the contents of the iterables and then simply create a list from the contents."}, {"id": 1724975, "score": 391, "vote": 0, "content": "<p>It's also possible to create a generator that simply iterates over the items in both lists using <a href=\"https://docs.python.org/library/itertools.html#itertools.chain\" rel=\"noreferrer\"><code>itertools.chain()</code></a>. This allows you to chain lists (or any iterable) together for processing without copying the items to a new list:</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">import itertools\nfor item in itertools.chain(listone, listtwo):\n    # Do something with each list item\n</code></pre>\n", "abstract": "It's also possible to create a generator that simply iterates over the items in both lists using itertools.chain(). This allows you to chain lists (or any iterable) together for processing without copying the items to a new list:"}, {"id": 14453876, "score": 290, "vote": 0, "content": "<p>You could also use the <a href=\"https://docs.python.org/2.7/tutorial/datastructures.html#more-on-lists\" rel=\"noreferrer\"><code>list.extend()</code></a> method in order to add a <code>list</code> to the end of another one:</p>\n<pre><code class=\"python\">listone = [1,2,3]\nlisttwo = [4,5,6]\n\nlistone.extend(listtwo)\n</code></pre>\n<p>If you want to keep the original list intact, you can create a new <code>list</code> object, and <code>extend</code> both lists to it:</p>\n<pre><code class=\"python\">mergedlist = []\nmergedlist.extend(listone)\nmergedlist.extend(listtwo)\n</code></pre>\n", "abstract": "You could also use the list.extend() method in order to add a list to the end of another one: If you want to keep the original list intact, you can create a new list object, and extend both lists to it:"}, {"id": 56407963, "score": 262, "vote": 0, "content": "<blockquote>\n<h3><strong>How do I concatenate two lists in Python?</strong></h3>\n</blockquote>\n<p>As of 3.9, these are the most popular stdlib methods for concatenating two (or more) lists in Python.</p>\n<div class=\"s-table-container\">\n<table class=\"s-table\">\n<thead>\n<tr>\n<th></th>\n<th>Version Restrictions</th>\n<th>In-Place?</th>\n<th>Generalize to N lists?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>a+b</code></td>\n<td>-</td>\n<td>No</td>\n<td><code>sum([a, b, c], [])</code><sup>1</sup></td>\n</tr>\n<tr>\n<td><code>list(chain(a,b))</code><sup>2</sup></td>\n<td>&gt;=2.3</td>\n<td>No</td>\n<td><code>list(chain(a, b, c))</code></td>\n</tr>\n<tr>\n<td><code>[*a, *b]</code><sup>3</sup></td>\n<td>&gt;=3.5</td>\n<td>No</td>\n<td><code>[*a, *b, *c]</code></td>\n</tr>\n<tr>\n<td><code>a += b</code></td>\n<td>-</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td><code>a.extend(b)</code></td>\n<td>-</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p><strong>Footnotes</strong></p>\n<ol>\n<li><p>This is a slick solution because of its succinctness. But <code>sum</code> performs concatenation in a pairwise fashion, which means this is a\nquadratic operation as memory has to be allocated for each step. DO\nNOT USE if your lists are large.</p>\n</li>\n<li><p>See <a href=\"https://docs.python.org/3/library/itertools.html#itertools.chain\" rel=\"noreferrer\"><code>chain</code></a>\nand\n<a href=\"https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable\" rel=\"noreferrer\"><code>chain.from_iterable</code></a>\nfrom the docs. You will need to <code>from itertools import chain</code> first.\nConcatenation is linear in memory, so this is the best in terms of\nperformance and version compatibility. <code>chain.from_iterable</code> was introduced in 2.6.</p>\n</li>\n<li><p>This method uses <a href=\"https://www.python.org/dev/peps/pep-0448/\" rel=\"noreferrer\">Additional Unpacking Generalizations (PEP 448)</a>, but cannot\ngeneralize to N lists unless you manually unpack each one yourself.</p>\n</li>\n<li><p><code>a += b</code> and <code>a.extend(b)</code> are more or less equivalent for all practical purposes. <code>+=</code> when called on a list will internally call\n<code>list.__iadd__</code>, which extends the first list by the second.</p>\n</li>\n</ol>\n</blockquote>\n<hr/>\n<h1>Performance</h1>\n<p><strong>2-List Concatenation</strong><sup>1</sup></p>\n<p><a href=\"https://i.stack.imgur.com/mfQTe.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/mfQTe.png\"/></a></p>\n<p>There's not much difference between these methods but that makes sense given they all have the same order of complexity (linear). There's no particular reason to prefer one over the other except as a matter of style.</p>\n<p><strong>N-List Concatenation</strong></p>\n<p><a href=\"https://i.stack.imgur.com/XcX7A.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/XcX7A.png\"/></a></p>\n<p>Plots have been generated using the <a href=\"https://github.com/nschloe/perfplot\" rel=\"noreferrer\">perfplot</a> module. <a href=\"https://gist.github.com/Coldsp33d/0a0e0e0eee8377489aed01358fe33a47\" rel=\"noreferrer\">Code, for your reference.</a></p>\n<p><sub>1. The <code>iadd</code> (<code>+=</code>) and <code>extend</code> methods operate in-place, so a copy has to be generated each time before testing. To keep things fair, all methods have a pre-copy step for the left-hand list which can be ignored.</sub></p>\n<hr/>\n<h1>Comments on Other Solutions</h1>\n<ul>\n<li><p>DO NOT USE THE DUNDER METHOD <code>list.__add__</code> directly in any way, shape or form. In fact, stay clear of dunder methods, and use the operators and <code>operator</code> functions like they were designed for. Python has careful semantics baked into these which are more complicated than just calling the dunder directly. Here is <a href=\"https://stackoverflow.com/a/53984203/4909087\">an example</a>. So, to summarise, <code>a.__add__(b)</code> =&gt; BAD; <code>a + b</code> =&gt; GOOD.</p>\n</li>\n<li><p>Some answers here offer <code>reduce(operator.add, [a, b])</code> for pairwise concatenation -- this is the same as <code>sum([a, b], [])</code> only more wordy.</p>\n</li>\n<li><p>Any method that uses <code>set</code> will drop duplicates and lose ordering. Use with caution.</p>\n</li>\n<li><p><code>for i in b: a.append(i)</code> is more wordy, and slower than <code>a.extend(b)</code>, which is single function call and more idiomatic. <code>append</code> is slower because of the semantics with which memory is allocated and grown for lists. See <a href=\"https://stackoverflow.com/questions/537086/reserve-memory-for-list-in-python\">here</a> for a similar discussion.</p>\n</li>\n<li><p><code>heapq.merge</code> will work, but its use case is for merging sorted lists in linear time. Using it in any other situation is an anti-pattern.</p>\n</li>\n<li><p><code>yield</code>ing list elements from a function is an acceptable method, but <code>chain</code> does this faster and better (it has a code path in C, so it is fast).</p>\n</li>\n<li><p><code>operator.add(a, b)</code> is an acceptable functional equivalent to <code>a + b</code>. It's use cases are mainly for dynamic method dispatch. Otherwise, prefer <code>a + b</code> which is shorter and more readable, <em>in my opinion</em>. YMMV.</p>\n</li>\n</ul>\n", "abstract": "As of 3.9, these are the most popular stdlib methods for concatenating two (or more) lists in Python. Footnotes This is a slick solution because of its succinctness. But sum performs concatenation in a pairwise fashion, which means this is a\nquadratic operation as memory has to be allocated for each step. DO\nNOT USE if your lists are large. See chain\nand\nchain.from_iterable\nfrom the docs. You will need to from itertools import chain first.\nConcatenation is linear in memory, so this is the best in terms of\nperformance and version compatibility. chain.from_iterable was introduced in 2.6. This method uses Additional Unpacking Generalizations (PEP 448), but cannot\ngeneralize to N lists unless you manually unpack each one yourself. a += b and a.extend(b) are more or less equivalent for all practical purposes. += when called on a list will internally call\nlist.__iadd__, which extends the first list by the second. 2-List Concatenation1  There's not much difference between these methods but that makes sense given they all have the same order of complexity (linear). There's no particular reason to prefer one over the other except as a matter of style. N-List Concatenation  Plots have been generated using the perfplot module. Code, for your reference. 1. The iadd (+=) and extend methods operate in-place, so a copy has to be generated each time before testing. To keep things fair, all methods have a pre-copy step for the left-hand list which can be ignored. DO NOT USE THE DUNDER METHOD list.__add__ directly in any way, shape or form. In fact, stay clear of dunder methods, and use the operators and operator functions like they were designed for. Python has careful semantics baked into these which are more complicated than just calling the dunder directly. Here is an example. So, to summarise, a.__add__(b) => BAD; a + b => GOOD. Some answers here offer reduce(operator.add, [a, b]) for pairwise concatenation -- this is the same as sum([a, b], []) only more wordy. Any method that uses set will drop duplicates and lose ordering. Use with caution. for i in b: a.append(i) is more wordy, and slower than a.extend(b), which is single function call and more idiomatic. append is slower because of the semantics with which memory is allocated and grown for lists. See here for a similar discussion. heapq.merge will work, but its use case is for merging sorted lists in linear time. Using it in any other situation is an anti-pattern. yielding list elements from a function is an acceptable method, but chain does this faster and better (it has a code path in C, so it is fast). operator.add(a, b) is an acceptable functional equivalent to a + b. It's use cases are mainly for dynamic method dispatch. Otherwise, prefer a + b which is shorter and more readable, in my opinion. YMMV."}, {"id": 3749835, "score": 257, "vote": 0, "content": "<p>You can use sets to obtain merged list of unique values</p>\n<pre><code class=\"python\">mergedlist = list(set(listone + listtwo))\n</code></pre>\n", "abstract": "You can use sets to obtain merged list of unique values"}, {"id": 1720436, "score": 93, "vote": 0, "content": "<p>This is quite simple, and I think it was even shown in <a href=\"http://docs.python.org/tutorial/\" rel=\"noreferrer\">the tutorial</a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; listone = [1,2,3]\n&gt;&gt;&gt; listtwo = [4,5,6]\n&gt;&gt;&gt;\n&gt;&gt;&gt; listone + listtwo\n[1, 2, 3, 4, 5, 6]\n</code></pre>\n", "abstract": "This is quite simple, and I think it was even shown in the tutorial:"}, {"id": 33048483, "score": 68, "vote": 0, "content": "<p>This question directly asks about joining two lists. However it's pretty high in search even when you are looking for a way of joining many lists (including the case when you joining zero lists).</p>\n<p>I think the best option is to use list comprehensions:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = [[1,2,3], [4,5,6], [7,8,9]]\n&gt;&gt;&gt; [x for xs in a for x in xs]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<p>You can create generators as well:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; map(str, (x for xs in a for x in xs))\n['1', '2', '3', '4', '5', '6', '7', '8', '9']\n</code></pre>\n<p><strong>Old Answer</strong></p>\n<p>Consider this more generic approach:</p>\n<pre><code class=\"python\">a = [[1,2,3], [4,5,6], [7,8,9]]\nreduce(lambda c, x: c + x, a, [])\n</code></pre>\n<p>Will output:</p>\n<pre><code class=\"python\">[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<p>Note, this also works correctly when <code>a</code> is <code>[]</code> or <code>[[1,2,3]]</code>.</p>\n<p>However, this can be done more efficiently with <code>itertools</code>:</p>\n<pre><code class=\"python\">a = [[1,2,3], [4,5,6], [7,8,9]]\nlist(itertools.chain(*a))\n</code></pre>\n<p>If you don't need a <code>list</code>, but just an iterable, omit <code>list()</code>.</p>\n<p><strong>Update</strong></p>\n<p>Alternative suggested by Patrick Collins in the comments could also work for you:</p>\n<pre><code class=\"python\">sum(a, [])\n</code></pre>\n", "abstract": "This question directly asks about joining two lists. However it's pretty high in search even when you are looking for a way of joining many lists (including the case when you joining zero lists). I think the best option is to use list comprehensions: You can create generators as well: Old Answer Consider this more generic approach: Will output: Note, this also works correctly when a is [] or [[1,2,3]]. However, this can be done more efficiently with itertools: If you don't need a list, but just an iterable, omit list(). Update Alternative suggested by Patrick Collins in the comments could also work for you:"}, {"id": 15219904, "score": 50, "vote": 0, "content": "<p>You could simply use the <code>+</code> or <code>+=</code> operator as follows:</p>\n<pre><code class=\"python\">a = [1, 2, 3]\nb = [4, 5, 6]\n\nc = a + b\n</code></pre>\n<p>Or:</p>\n<pre><code class=\"python\">c = []\na = [1, 2, 3]\nb = [4, 5, 6]\n\nc += (a + b)\n</code></pre>\n<p>Also, if you want the values in the merged list to be unique you can do:</p>\n<pre><code class=\"python\">c = list(set(a + b))\n</code></pre>\n", "abstract": "You could simply use the + or += operator as follows: Or: Also, if you want the values in the merged list to be unique you can do:"}, {"id": 14700501, "score": 35, "vote": 0, "content": "<p>It's worth noting that the <code>itertools.chain</code> function accepts variable number of arguments:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; l1 = ['a']; l2 = ['b', 'c']; l3 = ['d', 'e', 'f']\n&gt;&gt;&gt; [i for i in itertools.chain(l1, l2)]\n['a', 'b', 'c']\n&gt;&gt;&gt; [i for i in itertools.chain(l1, l2, l3)]\n['a', 'b', 'c', 'd', 'e', 'f']\n</code></pre>\n<p>If an iterable (tuple, list, generator, etc.) is the input, the <code>from_iterable</code> class method may be used:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; il = [['a'], ['b', 'c'], ['d', 'e', 'f']]\n&gt;&gt;&gt; [i for i in itertools.chain.from_iterable(il)]\n['a', 'b', 'c', 'd', 'e', 'f']\n</code></pre>\n", "abstract": "It's worth noting that the itertools.chain function accepts variable number of arguments: If an iterable (tuple, list, generator, etc.) is the input, the from_iterable class method may be used:"}, {"id": 31254671, "score": 33, "vote": 0, "content": "<p>For cases with a low number of lists you can simply add the lists together or use in-place unpacking (available in Python-3.5+):</p>\n<pre><code class=\"python\">In [1]: listone = [1, 2, 3] \n   ...: listtwo = [4, 5, 6]                                                                                                                                                                                 \n\nIn [2]: listone + listtwo                                                                                                                                                                                   \nOut[2]: [1, 2, 3, 4, 5, 6]\n                                                                                                                                                                                     \nIn [3]: [*listone, *listtwo]                                                                                                                                                                                \nOut[3]: [1, 2, 3, 4, 5, 6]\n</code></pre>\n<p>As a more general way for cases with more number of lists you can use <code>chain.from_iterable()</code><sup>1</sup> function from <code>itertools</code> module. Also, based on <a href=\"https://stackoverflow.com/a/953097/2867928\"><em>this</em> answer</a> this function is the best; or at least a very good way for flatting a nested list as well.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; l=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; list(itertools.chain.from_iterable(l))\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<hr/>\n<sub>\n1. Note that `chain.from_iterable()` is available in Python 2.6 and later. In other versions, use `chain(*l)`.\n</sub>\n", "abstract": "For cases with a low number of lists you can simply add the lists together or use in-place unpacking (available in Python-3.5+): As a more general way for cases with more number of lists you can use chain.from_iterable()1 function from itertools module. Also, based on this answer this function is the best; or at least a very good way for flatting a nested list as well."}, {"id": 24856361, "score": 31, "vote": 0, "content": "<p>With Python 3.3+ you can use <a href=\"https://docs.python.org/3/whatsnew/3.3.html#pep-380\" rel=\"noreferrer\">yield from</a>:</p>\n<pre><code class=\"python\">listone = [1,2,3]\nlisttwo = [4,5,6]\n\ndef merge(l1, l2):\n    yield from l1\n    yield from l2\n\n&gt;&gt;&gt; list(merge(listone, listtwo))\n[1, 2, 3, 4, 5, 6]\n</code></pre>\n<p>Or, if you want to support an arbitrary number of iterators:</p>\n<pre><code class=\"python\">def merge(*iters):\n    for it in iters:\n        yield from it\n\n&gt;&gt;&gt; list(merge(listone, listtwo, 'abcd', [20, 21, 22]))\n[1, 2, 3, 4, 5, 6, 'a', 'b', 'c', 'd', 20, 21, 22]\n</code></pre>\n", "abstract": "With Python 3.3+ you can use yield from: Or, if you want to support an arbitrary number of iterators:"}, {"id": 31270002, "score": 26, "vote": 0, "content": "<p>If you want to merge the two lists in sorted form, you can use the <code>merge</code> function from the <code>heapq</code> library.</p>\n<pre><code class=\"python\">from heapq import merge\n\na = [1, 2, 4]\nb = [2, 4, 6, 7]\n\nprint list(merge(a, b))\n</code></pre>\n", "abstract": "If you want to merge the two lists in sorted form, you can use the merge function from the heapq library."}, {"id": 26462448, "score": 22, "vote": 0, "content": "<p>If you can't use the plus operator (<code>+</code>),  you can use the <code>operator</code> import:</p>\n<pre><code class=\"python\">import operator\n\nlistone = [1,2,3]\nlisttwo = [4,5,6]\n\nresult = operator.add(listone, listtwo)\nprint(result)\n\n&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]\n</code></pre>\n<p>Alternatively, you could also use the <code>__add__</code> <a href=\"https://wiki.python.org/moin/DunderAlias\" rel=\"noreferrer\">dunder</a> function:</p>\n<pre><code class=\"python\">listone = [1,2,3]\nlisttwo = [4,5,6]\n\nresult = list.__add__(listone, listtwo)\nprint(result)\n\n&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]\n</code></pre>\n", "abstract": "If you can't use the plus operator (+),  you can use the operator import: Alternatively, you could also use the __add__ dunder function:"}, {"id": 19843368, "score": 15, "vote": 0, "content": "<p>If you need to merge two ordered lists with complicated sorting rules, you might have to roll it yourself like in the following code (using a simple sorting rule for readability :-) ).</p>\n<pre><code class=\"python\">list1 = [1,2,5]\nlist2 = [2,3,4]\nnewlist = []\n\nwhile list1 and list2:\n    if list1[0] == list2[0]:\n        newlist.append(list1.pop(0))\n        list2.pop(0)\n    elif list1[0] &lt; list2[0]:\n        newlist.append(list1.pop(0))\n    else:\n        newlist.append(list2.pop(0))\n\nif list1:\n    newlist.extend(list1)\nif list2:\n    newlist.extend(list2)\n\nassert(newlist == [1, 2, 3, 4, 5])\n</code></pre>\n", "abstract": "If you need to merge two ordered lists with complicated sorting rules, you might have to roll it yourself like in the following code (using a simple sorting rule for readability :-) )."}, {"id": 51688033, "score": 11, "vote": 0, "content": "<p>If you are using NumPy, you can concatenate two arrays of compatible dimensions with this command:</p>\n<pre><code class=\"python\">numpy.concatenate([a,b])\n</code></pre>\n", "abstract": "If you are using NumPy, you can concatenate two arrays of compatible dimensions with this command:"}, {"id": 50681038, "score": 9, "vote": 0, "content": "<p>Use a simple list comprehension:</p>\n<pre><code class=\"python\">joined_list = [item for list_ in [list_one, list_two] for item in list_]\n</code></pre>\n<p>It has all the advantages of the newest approach of using <a href=\"https://www.python.org/dev/peps/pep-0448/\" rel=\"noreferrer\">Additional Unpacking Generalizations</a> - i.e. you can concatenate an arbitrary number of different iterables (for example, lists, tuples, ranges, and generators) that way - and it's not limited to Python 3.5 or later.</p>\n", "abstract": "Use a simple list comprehension: It has all the advantages of the newest approach of using Additional Unpacking Generalizations - i.e. you can concatenate an arbitrary number of different iterables (for example, lists, tuples, ranges, and generators) that way - and it's not limited to Python 3.5 or later."}, {"id": 67802980, "score": 9, "vote": 0, "content": "<p><strong>Another way:</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; listone = [1, 2, 3]\n&gt;&gt;&gt; listtwo = [4, 5, 6]\n&gt;&gt;&gt; joinedlist = [*listone, *listtwo]\n&gt;&gt;&gt; joinedlist\n[1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; \n</code></pre>\n", "abstract": "Another way:"}, {"id": 38240019, "score": 8, "vote": 0, "content": "<pre><code class=\"python\">list(set(listone) | set(listtwo))\n</code></pre>\n<p>The above code does not preserve order and removes duplicates from each list (but not from the concatenated list).</p>\n", "abstract": "The above code does not preserve order and removes duplicates from each list (but not from the concatenated list)."}, {"id": 17666852, "score": 7, "vote": 0, "content": "<p>You could use the <code>append()</code> method defined on <code>list</code> objects: </p>\n<pre><code class=\"python\">mergedlist =[]\nfor elem in listone:\n    mergedlist.append(elem)\nfor elem in listtwo:\n    mergedlist.append(elem)\n</code></pre>\n", "abstract": "You could use the append() method defined on list objects: "}, {"id": 33484904, "score": 7, "vote": 0, "content": "<p>As already pointed out by many, <code>itertools.chain()</code> is the way to go if one needs to apply <em>exactly the same treatment</em> to both lists. In my case, I had a label and a flag which were different from one list to the other, so I needed something slightly more complex. As it turns out, behind the scenes <code>itertools.chain()</code> simply does the following:</p>\n<pre><code class=\"python\">for it in iterables:\n    for element in it:\n        yield element\n</code></pre>\n<p>(see <a href=\"https://docs.python.org/2/library/itertools.html\" rel=\"noreferrer\">https://docs.python.org/2/library/itertools.html</a>), so I took inspiration from here and wrote something along these lines:</p>\n<pre><code class=\"python\">for iterable, header, flag in ( (newList, 'New', ''), (modList, 'Modified', '-f')):\n    print header + ':'\n    for path in iterable:\n        [...]\n        command = 'cp -r' if os.path.isdir(srcPath) else 'cp'\n        print &gt;&gt; SCRIPT , command, flag, srcPath, mergedDirPath\n        [...]\n</code></pre>\n<p>The main points to understand here are that lists are just a special case of iterable, which are objects like any other; and that <code>for ... in</code> loops in python can work with tuple variables, so it is simple to loop on multiple variables at the same time. </p>\n", "abstract": "As already pointed out by many, itertools.chain() is the way to go if one needs to apply exactly the same treatment to both lists. In my case, I had a label and a flag which were different from one list to the other, so I needed something slightly more complex. As it turns out, behind the scenes itertools.chain() simply does the following: (see https://docs.python.org/2/library/itertools.html), so I took inspiration from here and wrote something along these lines: The main points to understand here are that lists are just a special case of iterable, which are objects like any other; and that for ... in loops in python can work with tuple variables, so it is simple to loop on multiple variables at the same time. "}, {"id": 69423586, "score": 6, "vote": 0, "content": "<p>I recommend three methods to concatenate the list, but the first method is most recommended,</p>\n<pre><code class=\"python\"># Easiest and least complexity method &lt;= recommended\n\nlistone = [1, 2, 3]\nlisttwo = [4, 5, 6]\n\nnewlist = listone + listtwo\nprint(newlist)\n\n# Second-easiest method\nnewlist = listone.copy()\nnewlist.extend(listtwo)\nprint(newlist)\n</code></pre>\n<p>In the second method, I assign <code>newlist</code> to a copy of the <code>listone</code>, because I don't want to change <code>listone</code>.</p>\n<pre><code class=\"python\"># Third method\nnewlist = listone.copy()\nfor j in listtwo:\n    newlist.append(j)\n\nprint(newlist)\n</code></pre>\n<p>This is not a good way to concatenate lists because we are using a <em>for</em> loop to concatenate the lists. So time complexity is much higher than with the other two methods.</p>\n", "abstract": "I recommend three methods to concatenate the list, but the first method is most recommended, In the second method, I assign newlist to a copy of the listone, because I don't want to change listone. This is not a good way to concatenate lists because we are using a for loop to concatenate the lists. So time complexity is much higher than with the other two methods."}, {"id": 70524677, "score": 6, "vote": 0, "content": "<p>The most common method used to concatenate lists are the <strong>plus operator</strong> and the built-in method <strong>append</strong>, for example:</p>\n<pre><code class=\"python\">list = [1,2]\n\nlist = list + [3]\n# list = [1,2,3]\n\nlist.append(3)\n# list = [1,2,3]\n\nlist.append([3,4])\n# list = [1,2,[3,4]]\n</code></pre>\n<p>For most of the cases, this will work, but the <strong>append</strong> function will not extend a list if one was added. Because that is not expected, you can use another method called <strong>extend</strong>. It should work with structures:</p>\n<pre><code class=\"python\">list = [1,2]\nlist.extend([3,4])\n# list = [1,2,3,4]\n</code></pre>\n", "abstract": "The most common method used to concatenate lists are the plus operator and the built-in method append, for example: For most of the cases, this will work, but the append function will not extend a list if one was added. Because that is not expected, you can use another method called extend. It should work with structures:"}, {"id": 49497578, "score": 5, "vote": 0, "content": "<p>A really concise way to combine a list of lists is</p>\n<pre><code class=\"python\">list_of_lists = [[1,2,3], [4,5,6], [7,8,9]]\nreduce(list.__add__, list_of_lists)\n</code></pre>\n<p>which gives us</p>\n<pre><code class=\"python\">[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n", "abstract": "A really concise way to combine a list of lists is which gives us"}, {"id": 52008429, "score": 4, "vote": 0, "content": "<p>So there are two easy ways.</p>\n<ol>\n<li><strong>Using <code>+</code></strong>: It creates a new list from provided lists</li>\n</ol>\n<p>Example:</p>\n<pre><code class=\"python\">In [1]: a = [1, 2, 3]\n\nIn [2]: b = [4, 5, 6]\n\nIn [3]: a + b\nOut[3]: [1, 2, 3, 4, 5, 6]\n\nIn [4]: %timeit a + b\n10000000 loops, best of 3: 126 ns per loop\n</code></pre>\n<ol start=\"2\">\n<li><strong>Using extend</strong>: It appends new list to existing list. That means it does not create a separate list.</li>\n</ol>\n<p>Example:</p>\n<pre><code class=\"python\">In [1]: a = [1, 2, 3]\n\nIn [2]: b = [4, 5, 6]\n\nIn [3]: %timeit a.extend(b)\n10000000 loops, best of 3: 91.1 ns per loop\n</code></pre>\n<p>Thus we see that out of two of most popular methods, <code>extend</code> is efficient.</p>\n", "abstract": "So there are two easy ways. Example: Example: Thus we see that out of two of most popular methods, extend is efficient."}, {"id": 69147880, "score": 4, "vote": 0, "content": "<p>You could also just use <a href=\"https://docs.python.org/3.8/library/functions.html#sum\" rel=\"nofollow noreferrer\">sum</a>.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; b = [4, 5, 6]\n&gt;&gt;&gt; sum([a, b], [])\n[1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt;\n</code></pre>\n<p>This works for any length and any element type of list:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = ['a', 'b', 'c', 'd']\n&gt;&gt;&gt; b = [1, 2, 3, 4]\n&gt;&gt;&gt; c = [1, 2]\n&gt;&gt;&gt; sum([a, b, c], [])\n['a', 'b', 'c', 'd', 1, 2, 3, 4, 1, 2]\n&gt;&gt;&gt;\n</code></pre>\n<p>The reason I add <code>[]</code>, is because the <code>start</code> argument is set to <code>0</code> by default, so it loops through the list and adds to <code>start</code>, but <code>0 + [1, 2, 3]</code> would give an error, so if we set the <code>start</code> to <code>[]</code>. It would add to <code>[]</code>, and <code>[] + [1, 2, 3]</code> would work as expected.</p>\n", "abstract": "You could also just use sum. This works for any length and any element type of list: The reason I add [], is because the start argument is set to 0 by default, so it loops through the list and adds to start, but 0 + [1, 2, 3] would give an error, so if we set the start to []. It would add to [], and [] + [1, 2, 3] would work as expected."}, {"id": 62778742, "score": 3, "vote": 0, "content": "<pre><code class=\"python\"> a = [1, 2, 3]\n b = [4, 5, 6]\n     \n c = a + b\n print(c)\n</code></pre>\n<h3>Output</h3>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]\n</code></pre>\n<p>In the above code, the \"+\" operator is used to concatenate the two lists into a single list.</p>\n<h3>Another solution</h3>\n<pre><code class=\"python\"> a = [1, 2, 3]\n b = [4, 5, 6]\n c = [] # Empty list in which we are going to append the values of list (a) and (b)\n\n for i in a:\n     c.append(i)\n for j in b:\n     c.append(j)\n\n print(c)\n</code></pre>\n<h3>Output</h3>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; [1, 2, 3, 4, 5, 6]\n</code></pre>\n", "abstract": "In the above code, the \"+\" operator is used to concatenate the two lists into a single list."}, {"id": 64830302, "score": 3, "vote": 0, "content": "<p>I assume you want one of the two methods:</p>\n<p><strong>Keep duplicate elements</strong></p>\n<p>It is very easy. Just concatenate like a string:</p>\n<pre><code class=\"python\">def concat_list(l1,l2):\n    l3 = l1+l2\n    return l3\n</code></pre>\n<p><strong>Next, if you want to eliminate duplicate elements</strong></p>\n<pre><code class=\"python\">def concat_list(l1,l2):\n   l3 = []\n   for i in [l1,l2]:\n     for j in i:\n       if j not in l3:\n         # Check if element exists in final list, if no then add element to list\n         l3.append(j)\n   return l3\n</code></pre>\n", "abstract": "I assume you want one of the two methods: Keep duplicate elements It is very easy. Just concatenate like a string: Next, if you want to eliminate duplicate elements"}, {"id": 69808422, "score": 1, "vote": 0, "content": "<p>The solutions provided are for a single list. In case there are lists within a list and the merging of corresponding lists is required, the \"+\" operation through a <em>for</em> loop does the work.</p>\n<pre><code class=\"python\">a = [[1,2,3], [4,5,6]]\n\nb = [[0,1,2], [7,8,9]]\n\nfor i in range(len(a)):\n    cc.append(a[i] + b[i])\n</code></pre>\n<p>Output: [[1, 2, 3, 0, 1, 2], [4, 5, 6, 7, 8, 9]]</p>\n", "abstract": "The solutions provided are for a single list. In case there are lists within a list and the merging of corresponding lists is required, the \"+\" operation through a for loop does the work. Output: [[1, 2, 3, 0, 1, 2], [4, 5, 6, 7, 8, 9]]"}, {"id": 48819774, "score": -1, "vote": 0, "content": "<p>All the possible ways to join lists that I could find</p>\n<pre><code class=\"python\">import itertools\n\nA = [1,3,5,7,9] + [2,4,6,8,10]\n\nB = [1,3,5,7,9]\nB.append([2,4,6,8,10])\n\nC = [1,3,5,7,9]\nC.extend([2,4,6,8,10])\n\nD = list(zip([1,3,5,7,9],[2,4,6,8,10]))\nE = [1,3,5,7,9]+[2,4,6,8,10]\nF = list(set([1,3,5,7,9] + [2,4,6,8,10]))\n\nG = []\nfor a in itertools.chain([1,3,5,7,9], [2,4,6,8,10]):\n    G.append(a)\n\n\nprint(\"A: \" + str(A))\nprint(\"B: \" + str(B))\nprint(\"C: \" + str(C))\nprint(\"D: \" + str(D))\nprint(\"E: \" + str(E))\nprint(\"F: \" + str(F))\nprint(\"G: \" + str(G))\n</code></pre>\n<p>Output</p>\n<pre><code class=\"python\">A: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\nB: [1, 3, 5, 7, 9, [2, 4, 6, 8, 10]]\nC: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\nD: [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]\nE: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\nF: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nG: [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\n</code></pre>\n", "abstract": "All the possible ways to join lists that I could find Output"}, {"id": 65756144, "score": -8, "vote": 0, "content": "<p>You can use the union() function in Python.</p>\n<pre><code class=\"python\">joinedlist = union(listone, listtwo)\nprint(joinedlist)\n</code></pre>\n<p>Essentially, it\u2019s removing one of every duplicate in the two lists. Since your lists don't have any duplicates it, it just returns the concatenated version of the two lists.</p>\n", "abstract": "You can use the union() function in Python. Essentially, it\u2019s removing one of every duplicate in the two lists. Since your lists don't have any duplicates it, it just returns the concatenated version of the two lists."}]}, {"link": "https://stackoverflow.com/questions/53513/how-do-i-check-if-a-list-is-empty", "question": {"id": "53513", "title": "How do I check if a list is empty?", "content": "<p>For example, if passed the following:</p>\n<pre><code class=\"python\">a = []\n</code></pre>\n<p>How do I check to see if <code>a</code> is empty?</p>\n", "abstract": "For example, if passed the following: How do I check to see if a is empty?"}, "answers": [{"id": 53522, "score": 6888, "vote": 0, "content": "<pre><code class=\"python\">if not a:\n    print(\"List is empty\")\n</code></pre>\n<p>Using the <a href=\"https://docs.python.org/library/stdtypes.html#truth-value-testing\" rel=\"noreferrer\">implicit booleanness</a> of the empty <code>list</code> is quite Pythonic.</p>\n", "abstract": "Using the implicit booleanness of the empty list is quite Pythonic."}, {"id": 53752, "score": 1434, "vote": 0, "content": "<p>The Pythonic way to do it is from the <a href=\"https://www.python.org/dev/peps/pep-0008\" rel=\"noreferrer\">PEP 8 style guide</a>.</p>\n<blockquote>\n<p>For sequences, (strings, lists, tuples), use the fact that empty sequences are false:</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\"># Correct:\nif not seq:\nif seq:\n\n# Wrong:\nif len(seq):\nif not len(seq):\n</code></pre>\n</blockquote>\n", "abstract": "The Pythonic way to do it is from the PEP 8 style guide. For sequences, (strings, lists, tuples), use the fact that empty sequences are false:"}, {"id": 7302987, "score": 1026, "vote": 0, "content": "<p>I prefer it explicitly:</p>\n<pre><code class=\"python\">if len(li) == 0:\n    print('the list is empty')\n</code></pre>\n<p>This way it's 100% clear that <code>li</code> is a sequence (list) and we want to test its size. My problem with <code>if not li: ...</code> is that it gives the false impression that <code>li</code> is a boolean variable.</p>\n", "abstract": "I prefer it explicitly: This way it's 100% clear that li is a sequence (list) and we want to test its size. My problem with if not li: ... is that it gives the false impression that li is a boolean variable."}, {"id": 9381545, "score": 404, "vote": 0, "content": "<p><sub>This is the first google hit for \"python test empty array\" and similar queries, and other people are generalizing the question beyond just lists, so here's a caveat for a different type of sequence that a lot of people use.</sub></p>\n<h1>Other methods don't work for NumPy arrays</h1>\n<p>You need to be careful with NumPy arrays, because other methods that work fine for <code>list</code>s or other standard containers fail for NumPy arrays.  I explain why below, but in short, the <a href=\"http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array\" rel=\"nofollow noreferrer\">preferred method</a> is to use <code>size</code>.</p>\n<h2>The \"pythonic\" way doesn't work: Part 1</h2>\n<p>The \"pythonic\" way fails with NumPy arrays because NumPy tries to cast the array to an array of <code>bool</code>s, and <code>if x</code> tries to evaluate all of those <code>bool</code>s at once for some kind of aggregate truth value.  But this doesn't make any sense, so you get a <code>ValueError</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = numpy.array([0,1])\n&gt;&gt;&gt; if x: print(\"x\")\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n</code></pre>\n<h2>The \"pythonic\" way doesn't work: Part 2</h2>\n<p>But at least the case above tells you that it failed.  If you happen to have a NumPy array with exactly one element, the <code>if</code> statement will \"work\", in the sense that you don't get an error.  However, if that one element happens to be <code>0</code> (or <code>0.0</code>, or <code>False</code>, ...), the <code>if</code> statement will incorrectly result in <code>False</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = numpy.array([0,])\n&gt;&gt;&gt; if x: print(\"x\")\n... else: print(\"No x\")\nNo x\n</code></pre>\n<p>But clearly <code>x</code> exists and is not empty!  This result is not what you wanted.</p>\n<h2>Using <code>len</code> can give unexpected results</h2>\n<p>For example,</p>\n<pre><code class=\"python\">len( numpy.zeros((1,0)) )\n</code></pre>\n<p>returns 1, even though the array has zero elements.</p>\n<h2>The numpythonic way</h2>\n<p>As explained in the <a href=\"http://www.scipy.org/scipylib/faq.html#what-is-the-preferred-way-to-check-for-an-empty-zero-element-array\" rel=\"nofollow noreferrer\">SciPy FAQ</a>, the correct method in all cases where you know you have a NumPy array is to use <code>if x.size</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = numpy.array([0,1])\n&gt;&gt;&gt; if x.size: print(\"x\")\nx\n\n&gt;&gt;&gt; x = numpy.array([0,])\n&gt;&gt;&gt; if x.size: print(\"x\")\n... else: print(\"No x\")\nx\n\n&gt;&gt;&gt; x = numpy.zeros((1,0))\n&gt;&gt;&gt; if x.size: print(\"x\")\n... else: print(\"No x\")\nNo x\n</code></pre>\n<p>If you're not sure whether it might be a <code>list</code>, a NumPy array, or something else, you could combine this approach with <a href=\"https://stackoverflow.com/a/10835703/1194883\">the answer @dubiousjim gives</a> to make sure the right test is used for each type.  Not very \"pythonic\", but it turns out that NumPy intentionally broke pythonicity in at least this sense.</p>\n<p>If you need to do more than just check if the input is empty, and you're using other NumPy features like indexing or math operations, it's probably more efficient (and certainly more common) to force the input <em>to be</em> a NumPy array.  There are a few nice functions for doing this quickly \u2014\u00a0most importantly <a href=\"https://docs.scipy.org/doc/numpy-dev/reference/generated/numpy.asarray.html\" rel=\"nofollow noreferrer\"><code>numpy.asarray</code></a>.  This takes your input, does nothing if it's already an array, or wraps your input into an array if it's a list, tuple, etc., and optionally converts it to your chosen <code>dtype</code>.  So it's very quick whenever it can be, and it ensures that you just get to assume the input is a NumPy array.  We usually even just use the same name, as the conversion to an array won't make it back outside of the current <a href=\"http://python-textbok.readthedocs.io/en/1.0/Variables_and_Scope.html\" rel=\"nofollow noreferrer\">scope</a>:</p>\n<pre><code class=\"python\">x = numpy.asarray(x, dtype=numpy.double)\n</code></pre>\n<p>This will make the <code>x.size</code> check work in all cases I see on this page.</p>\n", "abstract": "This is the first google hit for \"python test empty array\" and similar queries, and other people are generalizing the question beyond just lists, so here's a caveat for a different type of sequence that a lot of people use. You need to be careful with NumPy arrays, because other methods that work fine for lists or other standard containers fail for NumPy arrays.  I explain why below, but in short, the preferred method is to use size. The \"pythonic\" way fails with NumPy arrays because NumPy tries to cast the array to an array of bools, and if x tries to evaluate all of those bools at once for some kind of aggregate truth value.  But this doesn't make any sense, so you get a ValueError: But at least the case above tells you that it failed.  If you happen to have a NumPy array with exactly one element, the if statement will \"work\", in the sense that you don't get an error.  However, if that one element happens to be 0 (or 0.0, or False, ...), the if statement will incorrectly result in False: But clearly x exists and is not empty!  This result is not what you wanted. For example, returns 1, even though the array has zero elements. As explained in the SciPy FAQ, the correct method in all cases where you know you have a NumPy array is to use if x.size: If you're not sure whether it might be a list, a NumPy array, or something else, you could combine this approach with the answer @dubiousjim gives to make sure the right test is used for each type.  Not very \"pythonic\", but it turns out that NumPy intentionally broke pythonicity in at least this sense. If you need to do more than just check if the input is empty, and you're using other NumPy features like indexing or math operations, it's probably more efficient (and certainly more common) to force the input to be a NumPy array.  There are a few nice functions for doing this quickly \u2014\u00a0most importantly numpy.asarray.  This takes your input, does nothing if it's already an array, or wraps your input into an array if it's a list, tuple, etc., and optionally converts it to your chosen dtype.  So it's very quick whenever it can be, and it ensures that you just get to assume the input is a NumPy array.  We usually even just use the same name, as the conversion to an array won't make it back outside of the current scope: This will make the x.size check work in all cases I see on this page."}, {"id": 45778282, "score": 338, "vote": 0, "content": "<blockquote>\n<h2>Best way to check if a list is empty</h2>\n<p>For example, if passed the following:</p>\n<pre><code class=\"python\">a = []\n</code></pre>\n<p>How do I check to see if a is empty?</p>\n</blockquote>\n<h2>Short Answer:</h2>\n<p>Place the list in a boolean context (for example, with an <code>if</code> or <code>while</code> statement). It will test <code>False</code> if it is empty, and <code>True</code> otherwise. For example:</p>\n<pre><code class=\"python\">if not a:                           # do this!\n    print('a is an empty list')\n</code></pre>\n<h2>PEP 8</h2>\n<p><a href=\"https://www.python.org/dev/peps/pep-0008/#programming-recommendations\" rel=\"noreferrer\">PEP 8</a>, the official Python style guide for Python code in Python's standard library, asserts:</p>\n<blockquote>\n<p>For sequences, (strings, lists, tuples), use the fact that empty sequences are false.</p>\n<pre><code class=\"python\">Yes: if not seq:\n     if seq:\n\nNo: if len(seq):\n    if not len(seq):\n</code></pre>\n</blockquote>\n<p>We should expect that standard library code should be as performant and correct as possible. But why is that the case, and why do we need this guidance?</p>\n<h2>Explanation</h2>\n<p>I frequently see code like this from experienced programmers new to Python:</p>\n<pre><code class=\"python\">if len(a) == 0:                     # Don't do this!\n    print('a is an empty list')\n</code></pre>\n<p>And users of lazy languages may be tempted to do this:</p>\n<pre><code class=\"python\">if a == []:                         # Don't do this!\n    print('a is an empty list')\n</code></pre>\n<p>These are correct in their respective other languages. And this is even semantically correct in Python. </p>\n<p>But we consider it un-Pythonic because Python supports these semantics directly in the list object's interface via boolean coercion.</p>\n<p>From the <a href=\"https://docs.python.org/3/library/stdtypes.html#truth-value-testing\" rel=\"noreferrer\">docs</a> (and note specifically the inclusion of the empty list, <code>[]</code>):</p>\n<blockquote>\n<p>By default, an object is considered true unless its class defines\n  either a <code>__bool__()</code> method that returns <code>False</code> or a <code>__len__()</code> method\n  that returns zero, when called with the object. Here are most of the built-in objects considered false:</p>\n<ul>\n<li>constants defined to be false: <code>None</code> and <code>False</code>.</li>\n<li>zero of any numeric type: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li>\n<li>empty sequences and collections: <code>''</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li>\n</ul>\n</blockquote>\n<p>And the datamodel documentation:</p>\n<blockquote>\n<p><a href=\"https://docs.python.org/3/reference/datamodel.html#object.__bool__\" rel=\"noreferrer\"><code>object.__bool__(self)</code></a></p>\n<p>Called to implement truth value testing and the built-in operation <code>bool()</code>; should return <code>False</code> or <code>True</code>. When this method is not defined,\n  <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither <code>__len__()</code>\n  nor <code>__bool__()</code>, all its instances are considered true.</p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p><a href=\"https://docs.python.org/3/reference/datamodel.html#object.__len__\" rel=\"noreferrer\"><code>object.__len__(self)</code></a></p>\n<p>Called to implement the built-in function <code>len()</code>. Should return the length of the object, an integer &gt;= 0. Also, an object that doesn\u2019t define a <code>__bool__()</code> method and whose <code>__len__()</code> method returns zero is considered to be false in a Boolean context.</p>\n</blockquote>\n<p>So instead of this:</p>\n<pre><code class=\"python\">if len(a) == 0:                     # Don't do this!\n    print('a is an empty list')\n</code></pre>\n<p>or this:</p>\n<pre><code class=\"python\">if a == []:                     # Don't do this!\n    print('a is an empty list')\n</code></pre>\n<p>Do this:</p>\n<pre><code class=\"python\">if not a:\n    print('a is an empty list')\n</code></pre>\n<h2>Doing what's Pythonic usually pays off in performance:</h2>\n<p>Does it pay off? (Note that less time to perform an equivalent operation is better:)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; min(timeit.repeat(lambda: len([]) == 0, repeat=100))\n0.13775854044661884\n&gt;&gt;&gt; min(timeit.repeat(lambda: [] == [], repeat=100))\n0.0984637276455409\n&gt;&gt;&gt; min(timeit.repeat(lambda: not [], repeat=100))\n0.07878462291455435\n</code></pre>\n<p>For scale, here's the cost of calling the function and constructing and returning an empty list, which you might subtract from the costs of the emptiness checks used above:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; min(timeit.repeat(lambda: [], repeat=100))\n0.07074015751817342\n</code></pre>\n<p>We see that <em>either</em> checking for length with the builtin function <code>len</code> compared to <code>0</code> <em>or</em> checking against an empty list is <strong>much</strong> less performant than using the builtin syntax of the language as documented.</p>\n<p>Why?</p>\n<p>For the <code>len(a) == 0</code> check:</p>\n<p>First Python has to check the globals to see if <code>len</code> is shadowed. </p>\n<p>Then it must call the function, load <code>0</code>, and do the equality comparison in Python (instead of with C):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(lambda: len([]) == 0)\n  1           0 LOAD_GLOBAL              0 (len)\n              2 BUILD_LIST               0\n              4 CALL_FUNCTION            1\n              6 LOAD_CONST               1 (0)\n              8 COMPARE_OP               2 (==)\n             10 RETURN_VALUE\n</code></pre>\n<p>And for the <code>[] == []</code> it has to build an unnecessary list and then, again, do the comparison operation in Python's virtual machine (as opposed to C)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; dis.dis(lambda: [] == [])\n  1           0 BUILD_LIST               0\n              2 BUILD_LIST               0\n              4 COMPARE_OP               2 (==)\n              6 RETURN_VALUE\n</code></pre>\n<p>The \"Pythonic\" way is a much simpler and faster check since the length of the list is cached in the object instance header:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; dis.dis(lambda: not [])\n  1           0 BUILD_LIST               0\n              2 UNARY_NOT\n              4 RETURN_VALUE\n</code></pre>\n<h2>Evidence from the C source and documentation</h2>\n<blockquote>\n<p><a href=\"https://docs.python.org/2/c-api/structures.html#c.PyVarObject\" rel=\"noreferrer\"><code>PyVarObject</code></a></p>\n<p>This is an extension of <code>PyObject</code> that adds the <code>ob_size</code> field. This is only used for objects that have some notion of length. This type does not often appear in the Python/C API. It corresponds to the fields defined by the expansion of the <code>PyObject_VAR_HEAD</code> macro.</p>\n</blockquote>\n<p>From the c source in <a href=\"https://github.com/python/cpython/blob/master/Include/listobject.h\" rel=\"noreferrer\">Include/listobject.h</a>:</p>\n<pre><code class=\"python\">typedef struct {\n    PyObject_VAR_HEAD\n    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */\n    PyObject **ob_item;\n\n    /* ob_item contains space for 'allocated' elements.  The number\n     * currently in use is ob_size.\n     * Invariants:\n     *     0 &lt;= ob_size &lt;= allocated\n     *     len(list) == ob_size\n</code></pre>\n<h2>Response to comments:</h2>\n<blockquote>\n<p>I would point out that this is also true for the non-empty case though its pretty ugly as with <code>l=[]</code> then <code>%timeit len(l) != 0</code> 90.6 ns \u00b1 8.3 ns, <code>%timeit l != []</code> 55.6 ns \u00b1 3.09, <code>%timeit not not l</code> 38.5 ns \u00b1 0.372. But there is no way anyone is going to enjoy <code>not not l</code> despite triple the speed. It looks ridiculous. But the speed wins out<br/>\n  I suppose the problem is testing with timeit since just <code>if l:</code> is sufficient but surprisingly <code>%timeit bool(l)</code> yields 101 ns \u00b1 2.64 ns. Interesting there is no way to coerce to bool without this penalty. <code>%timeit l</code> is useless since no conversion would occur.</p>\n</blockquote>\n<p>IPython magic, <code>%timeit</code>, is not entirely useless here:</p>\n<pre><code class=\"python\">In [1]: l = []                                                                  \n\nIn [2]: %timeit l                                                               \n20 ns \u00b1 0.155 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000000 loops each)\n\nIn [3]: %timeit not l                                                           \n24.4 ns \u00b1 1.58 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n\nIn [4]: %timeit not not l                                                       \n30.1 ns \u00b1 2.16 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n</code></pre>\n<p>We can see there's a bit of linear cost for each additional <code>not</code> here. We want to see the costs, <em>ceteris paribus</em>, that is, all else equal - where all else is minimized as far as possible:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">In [5]: %timeit if l: pass                                                      \n22.6 ns \u00b1 0.963 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n\nIn [6]: %timeit if not l: pass                                                  \n24.4 ns \u00b1 0.796 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n\nIn [7]: %timeit if not not l: pass                                              \n23.4 ns \u00b1 0.793 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n</code></pre>\n<p>Now let's look at the case for an unempty list:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">In [8]: l = [1]                                                                 \n\nIn [9]: %timeit if l: pass                                                      \n23.7 ns \u00b1 1.06 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n\nIn [10]: %timeit if not l: pass                                                 \n23.6 ns \u00b1 1.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n\nIn [11]: %timeit if not not l: pass                                             \n26.3 ns \u00b1 1 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n</code></pre>\n<p>What we can see here is that it makes little difference whether you pass in an actual <code>bool</code> to the condition check or the list itself, and if anything, giving the list, as is, is faster.</p>\n<p>Python is written in C; it uses its logic at the C level. Anything you write in Python will be slower. And it will likely be orders of magnitude slower unless you're using the mechanisms built into Python directly.</p>\n", "abstract": "For example, if passed the following: How do I check to see if a is empty? Place the list in a boolean context (for example, with an if or while statement). It will test False if it is empty, and True otherwise. For example: PEP 8, the official Python style guide for Python code in Python's standard library, asserts: For sequences, (strings, lists, tuples), use the fact that empty sequences are false. We should expect that standard library code should be as performant and correct as possible. But why is that the case, and why do we need this guidance? I frequently see code like this from experienced programmers new to Python: And users of lazy languages may be tempted to do this: These are correct in their respective other languages. And this is even semantically correct in Python.  But we consider it un-Pythonic because Python supports these semantics directly in the list object's interface via boolean coercion. From the docs (and note specifically the inclusion of the empty list, []): By default, an object is considered true unless its class defines\n  either a __bool__() method that returns False or a __len__() method\n  that returns zero, when called with the object. Here are most of the built-in objects considered false: And the datamodel documentation: object.__bool__(self) Called to implement truth value testing and the built-in operation bool(); should return False or True. When this method is not defined,\n  __len__() is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither __len__()\n  nor __bool__(), all its instances are considered true. and  object.__len__(self) Called to implement the built-in function len(). Should return the length of the object, an integer >= 0. Also, an object that doesn\u2019t define a __bool__() method and whose __len__() method returns zero is considered to be false in a Boolean context. So instead of this: or this: Do this: Does it pay off? (Note that less time to perform an equivalent operation is better:) For scale, here's the cost of calling the function and constructing and returning an empty list, which you might subtract from the costs of the emptiness checks used above: We see that either checking for length with the builtin function len compared to 0 or checking against an empty list is much less performant than using the builtin syntax of the language as documented. Why? For the len(a) == 0 check: First Python has to check the globals to see if len is shadowed.  Then it must call the function, load 0, and do the equality comparison in Python (instead of with C): And for the [] == [] it has to build an unnecessary list and then, again, do the comparison operation in Python's virtual machine (as opposed to C) The \"Pythonic\" way is a much simpler and faster check since the length of the list is cached in the object instance header: PyVarObject This is an extension of PyObject that adds the ob_size field. This is only used for objects that have some notion of length. This type does not often appear in the Python/C API. It corresponds to the fields defined by the expansion of the PyObject_VAR_HEAD macro. From the c source in Include/listobject.h: I would point out that this is also true for the non-empty case though its pretty ugly as with l=[] then %timeit len(l) != 0 90.6 ns \u00b1 8.3 ns, %timeit l != [] 55.6 ns \u00b1 3.09, %timeit not not l 38.5 ns \u00b1 0.372. But there is no way anyone is going to enjoy not not l despite triple the speed. It looks ridiculous. But the speed wins out\n  I suppose the problem is testing with timeit since just if l: is sufficient but surprisingly %timeit bool(l) yields 101 ns \u00b1 2.64 ns. Interesting there is no way to coerce to bool without this penalty. %timeit l is useless since no conversion would occur. IPython magic, %timeit, is not entirely useless here: We can see there's a bit of linear cost for each additional not here. We want to see the costs, ceteris paribus, that is, all else equal - where all else is minimized as far as possible: Now let's look at the case for an unempty list: What we can see here is that it makes little difference whether you pass in an actual bool to the condition check or the list itself, and if anything, giving the list, as is, is faster. Python is written in C; it uses its logic at the C level. Anything you write in Python will be slower. And it will likely be orders of magnitude slower unless you're using the mechanisms built into Python directly."}, {"id": 53525, "score": 164, "vote": 0, "content": "<p>An empty list is itself considered false in true value testing (see <a href=\"https://docs.python.org/2/library/stdtypes.html#truth-value-testing\" rel=\"nofollow noreferrer\">python documentation</a>):</p>\n<pre><code class=\"python\">a = []\nif a:\n     print \"not empty\"\n</code></pre>\n<p>To <a href=\"https://stackoverflow.com/questions/53513/how-do-i-check-if-a-list-is-empty/53530#53530\">Daren Thomas's answer</a>:</p>\n<blockquote>\n<p>EDIT: Another point against testing\nthe empty list as False: What about\npolymorphism? You shouldn't depend on\na list being a list. It should just\nquack like a duck - how are you going\nto get your duckCollection to quack\n''False'' when it has no elements?</p>\n</blockquote>\n<p>Your duckCollection should implement <code>__nonzero__</code> or <code>__len__</code> so the if a: will work without problems.</p>\n", "abstract": "An empty list is itself considered false in true value testing (see python documentation): To Daren Thomas's answer: EDIT: Another point against testing\nthe empty list as False: What about\npolymorphism? You shouldn't depend on\na list being a list. It should just\nquack like a duck - how are you going\nto get your duckCollection to quack\n''False'' when it has no elements? Your duckCollection should implement __nonzero__ or __len__ so the if a: will work without problems."}, {"id": 27262598, "score": 119, "vote": 0, "content": "<p><a href=\"https://stackoverflow.com/a/53522/908494\">Patrick's (accepted) answer</a> is right: <code>if not a:</code> is the right way to do it. <a href=\"https://stackoverflow.com/a/53752/908494\">Harley Holcombe's answer</a> is right that this is in the PEP 8 style guide. But what none of the answers explain is why it's a good idea to follow the idiom\u2014even if you personally find it's not explicit enough or confusing to Ruby users or whatever.</p>\n<p>Python code, and the Python community, has very strong idioms. Following those idioms makes your code easier to read for anyone experienced in Python. And when you violate those idioms, that's a strong signal.</p>\n<p>It's true that <code>if not a:</code> doesn't distinguish empty lists from <code>None</code>, or numeric 0, or empty tuples, or empty user-created collection types, or empty user-created not-quite-collection types, or single-element NumPy array acting as scalars with falsey values, etc. And sometimes it's important to be explicit about that. And in that case, you know <em>what</em> you want to be explicit about, so you can test for exactly that. For example, <code>if not a and a is not None:</code> means \"anything falsey except None\", while <code>if len(a) != 0:</code> means \"only empty sequences\u2014and anything besides a sequence is an error here\", and so on. Besides testing for exactly what you want to test, this also signals to the reader that this test is important.</p>\n<p>But when you don't have anything to be explicit about, anything other than <code>if not a:</code> is misleading the reader. You're signaling something as important when it isn't. (You may also be making the code less flexible, or slower, or whatever, but that's all less important.) And if you <em>habitually</em> mislead the reader like this, then when you <em>do</em> need to make a distinction, it's going to pass unnoticed because you've been \"crying wolf\" all over your code.</p>\n", "abstract": "Patrick's (accepted) answer is right: if not a: is the right way to do it. Harley Holcombe's answer is right that this is in the PEP 8 style guide. But what none of the answers explain is why it's a good idea to follow the idiom\u2014even if you personally find it's not explicit enough or confusing to Ruby users or whatever. Python code, and the Python community, has very strong idioms. Following those idioms makes your code easier to read for anyone experienced in Python. And when you violate those idioms, that's a strong signal. It's true that if not a: doesn't distinguish empty lists from None, or numeric 0, or empty tuples, or empty user-created collection types, or empty user-created not-quite-collection types, or single-element NumPy array acting as scalars with falsey values, etc. And sometimes it's important to be explicit about that. And in that case, you know what you want to be explicit about, so you can test for exactly that. For example, if not a and a is not None: means \"anything falsey except None\", while if len(a) != 0: means \"only empty sequences\u2014and anything besides a sequence is an error here\", and so on. Besides testing for exactly what you want to test, this also signals to the reader that this test is important. But when you don't have anything to be explicit about, anything other than if not a: is misleading the reader. You're signaling something as important when it isn't. (You may also be making the code less flexible, or slower, or whatever, but that's all less important.) And if you habitually mislead the reader like this, then when you do need to make a distinction, it's going to pass unnoticed because you've been \"crying wolf\" all over your code."}, {"id": 32978062, "score": 103, "vote": 0, "content": "<h1>Why check at all?</h1>\n<p>No one seems to have addressed questioning your <em>need</em> to test the list in the first place.  Because you provided no additional context, I can imagine that you may not need to do this check in the first place, but are unfamiliar with list processing in Python.</p>\n<p>I would argue that the <em>most Pythonic</em> way is to not check at all, but rather to just process the list.  That way it will do the right thing whether empty or full.</p>\n<pre><code class=\"python\">a = []\n\nfor item in a:\n    # &lt;Do something with item&gt;\n\n# &lt;The rest of code&gt;\n</code></pre>\n<p>This has the benefit of handling any contents of <strong>a</strong>, while not requiring a specific check for emptiness.  If <strong>a</strong> is empty, the dependent block will not execute and the interpreter will fall through to the next line.</p>\n<p>If you do actually need to check the array for emptiness:</p>\n<pre><code class=\"python\">a = []\n\nif not a:\n    # &lt;React to empty list&gt;\n\n# &lt;The rest of code&gt;\n</code></pre>\n<p>is sufficient.</p>\n", "abstract": "No one seems to have addressed questioning your need to test the list in the first place.  Because you provided no additional context, I can imagine that you may not need to do this check in the first place, but are unfamiliar with list processing in Python. I would argue that the most Pythonic way is to not check at all, but rather to just process the list.  That way it will do the right thing whether empty or full. This has the benefit of handling any contents of a, while not requiring a specific check for emptiness.  If a is empty, the dependent block will not execute and the interpreter will fall through to the next line. If you do actually need to check the array for emptiness: is sufficient."}, {"id": 61918, "score": 75, "vote": 0, "content": "<p><a href=\"http://books.google.com/books?id=vpTAq4dnmuAC&amp;pg=RA1-PA479&amp;lpg=RA1-PA479&amp;dq=Python+len+big+O&amp;source=web&amp;ots=AOM6A1K9Fy&amp;sig=iQo8mV6Xf9KdzuNSa-Jkr8wDEuw&amp;hl=en&amp;sa=X&amp;oi=book_result&amp;resnum=4&amp;ct=result\" rel=\"noreferrer\"><code>len()</code> is an O(1) operation</a> for Python lists, strings, dicts, and sets. Python internally keeps track of the number of elements in these containers.</p>\n<p>JavaScript <a href=\"http://www.isolani.co.uk/blog/javascript/TruthyFalsyAndTypeCasting\" rel=\"noreferrer\">has a similar notion of truthy/falsy</a>.</p>\n", "abstract": "len() is an O(1) operation for Python lists, strings, dicts, and sets. Python internally keeps track of the number of elements in these containers. JavaScript has a similar notion of truthy/falsy."}, {"id": 10835703, "score": 53, "vote": 0, "content": "<p>I had written:</p>\n<pre><code class=\"python\">if isinstance(a, (list, some, other, types, i, accept)) and not a:\n    do_stuff\n</code></pre>\n<p>which was voted -1. I'm not sure if that's because readers objected to the strategy or thought the answer wasn't helpful as presented. I'll pretend it was the latter, since---whatever counts as \"pythonic\"---this is the correct strategy. Unless you've already ruled out, or are prepared to handle cases where <code>a</code> is, for example, <code>False</code>, you need a test more restrictive than just <code>if not a:</code>. You could use something like this:</p>\n<pre><code class=\"python\">if isinstance(a, numpy.ndarray) and not a.size:\n    do_stuff\nelif isinstance(a, collections.Sized) and not a:\n    do_stuff\n</code></pre>\n<p>the first test is in response to @Mike's answer, above. The third line could also be replaced with:</p>\n<pre><code class=\"python\">elif isinstance(a, (list, tuple)) and not a:\n</code></pre>\n<p>if you only want to accept instances of particular types (and their subtypes), or with:</p>\n<pre><code class=\"python\">elif isinstance(a, (list, tuple)) and not len(a):\n</code></pre>\n<p>You can get away without the explicit type check, but only if the surrounding context already assures you that <code>a</code> is a value of the types you're prepared to handle, or if you're sure that types you're not prepared to handle are going to raise errors (e.g., a <code>TypeError</code> if you call <code>len</code> on a value for which it's undefined) that you're prepared to handle. In general, the \"pythonic\" conventions seem to go this last way. Squeeze it like a duck and let it raise a DuckError if it doesn't know how to quack. You still have to <em>think</em> about what type assumptions you're making, though, and whether the cases you're not prepared to handle properly really are going to error out in the right places. The Numpy arrays are a good example where just blindly relying on <code>len</code> or the boolean typecast may not do precisely what you're expecting.</p>\n", "abstract": "I had written: which was voted -1. I'm not sure if that's because readers objected to the strategy or thought the answer wasn't helpful as presented. I'll pretend it was the latter, since---whatever counts as \"pythonic\"---this is the correct strategy. Unless you've already ruled out, or are prepared to handle cases where a is, for example, False, you need a test more restrictive than just if not a:. You could use something like this: the first test is in response to @Mike's answer, above. The third line could also be replaced with: if you only want to accept instances of particular types (and their subtypes), or with: You can get away without the explicit type check, but only if the surrounding context already assures you that a is a value of the types you're prepared to handle, or if you're sure that types you're not prepared to handle are going to raise errors (e.g., a TypeError if you call len on a value for which it's undefined) that you're prepared to handle. In general, the \"pythonic\" conventions seem to go this last way. Squeeze it like a duck and let it raise a DuckError if it doesn't know how to quack. You still have to think about what type assumptions you're making, though, and whether the cases you're not prepared to handle properly really are going to error out in the right places. The Numpy arrays are a good example where just blindly relying on len or the boolean typecast may not do precisely what you're expecting."}, {"id": 53533, "score": 37, "vote": 0, "content": "<p>I prefer the following:</p>\n<pre><code class=\"python\">if a == []:\n   print \"The list is empty.\"\n</code></pre>\n", "abstract": "I prefer the following:"}, {"id": 34558732, "score": 37, "vote": 0, "content": "<p>From <a href=\"https://docs.python.org/3.5/library/stdtypes.html#truth-value-testing\">documentation</a> on truth value testing:</p>\n<p>All values other than what is listed here are considered <code>True</code></p>\n<ul>\n<li><code>None</code></li>\n<li><code>False</code></li>\n<li>zero of any numeric type, for example, <code>0</code>, <code>0.0</code>, <code>0j</code>.</li>\n<li>any empty sequence, for example, <code>''</code>, <code>()</code>, <code>[]</code>.</li>\n<li>any empty mapping, for example, <code>{}</code>.</li>\n<li>instances of user-defined classes, if the class defines a <code>__bool__()</code> or <code>__len__()</code> method, when that method returns the integer zero or bool value <code>False</code>.</li>\n</ul>\n<p>As can be seen, empty list <code>[]</code> is <em>falsy</em>, so doing what would be done to a boolean value sounds most efficient:</p>\n<pre><code class=\"python\">if not a:\n    print('\"a\" is empty!')\n</code></pre>\n", "abstract": "From documentation on truth value testing: All values other than what is listed here are considered True As can be seen, empty list [] is falsy, so doing what would be done to a boolean value sounds most efficient:"}, {"id": 40846473, "score": 35, "vote": 0, "content": "<p>Here are a few ways you can check if a list is empty:</p>\n<pre><code class=\"python\">a = [] #the list\n</code></pre>\n<p><strong>1)</strong> The pretty simple pythonic way:</p>\n<pre><code class=\"python\">if not a:\n    print(\"a is empty\")\n</code></pre>\n<p>In Python, <strong>empty containers</strong> such as lists,tuples,sets,dicts,variables etc are seen as <code>False</code>. One could simply treat the list as a predicate (<em>returning a Boolean value</em>). And  a <code>True</code> value would indicate that it's non-empty.</p>\n<p><strong>2)</strong> A much explicit way: using the <code>len()</code> to find the length and check if it equals to <code>0</code>:</p>\n<pre><code class=\"python\">if len(a) == 0:\n    print(\"a is empty\")\n</code></pre>\n<p><strong>3)</strong> Or comparing it to an anonymous empty list:</p>\n<pre><code class=\"python\">if a == []:\n    print(\"a is empty\")\n</code></pre>\n<p><strong>4)</strong> Another yet <em>silly</em> way to do is using <code>exception</code> and <code>iter()</code>:</p>\n<pre><code class=\"python\">try:\n    next(iter(a))\n    # list has elements\nexcept StopIteration:\n    print(\"Error: a is empty\")\n</code></pre>\n", "abstract": "Here are a few ways you can check if a list is empty: 1) The pretty simple pythonic way: In Python, empty containers such as lists,tuples,sets,dicts,variables etc are seen as False. One could simply treat the list as a predicate (returning a Boolean value). And  a True value would indicate that it's non-empty. 2) A much explicit way: using the len() to find the length and check if it equals to 0: 3) Or comparing it to an anonymous empty list: 4) Another yet silly way to do is using exception and iter():"}, {"id": 54612063, "score": 29, "vote": 0, "content": "<p>Method 1 (preferred):</p>\n<pre><code class=\"python\">if not a:\n   print (\"Empty\")\n</code></pre>\n<p>Method 2:</p>\n<pre><code class=\"python\">if len(a) == 0:\n   print(\"Empty\")\n</code></pre>\n<p>Method 3:</p>\n<pre><code class=\"python\">if a == []:\n  print (\"Empty\")\n</code></pre>\n", "abstract": "Method 1 (preferred): Method 2: Method 3:"}, {"id": 39469420, "score": 25, "vote": 0, "content": "<p>You can even try using <code>bool()</code> like this. Although it is less readable surely it's a concise way to perform this.</p>\n<pre><code class=\"python\">    a = [1,2,3];\n    print bool(a); # it will return True\n    a = [];\n    print bool(a); # it will return False\n</code></pre>\n<p>I love this way for the checking list is empty or not.</p>\n<p>Very handy and useful.</p>\n", "abstract": "You can even try using bool() like this. Although it is less readable surely it's a concise way to perform this. I love this way for the checking list is empty or not. Very handy and useful."}, {"id": 36610301, "score": 18, "vote": 0, "content": "<pre><code class=\"python\">def list_test (L):\n    if   L is None  : print('list is None')\n    elif not L      : print('list is empty')\n    else: print('list has %d elements' % len(L))\n\nlist_test(None)\nlist_test([])\nlist_test([1,2,3])\n</code></pre>\n<p>It is sometimes good to test for <code>None</code> and for emptiness separately as those are two different states. The code above produces the following output:</p>\n<pre><code class=\"python\">list is None \nlist is empty \nlist has 3 elements\n</code></pre>\n<p>Although it's worth nothing that <code>None</code> is falsy. So if you don't want to separate test for <code>None</code>-ness, you don't have to do that. </p>\n<pre><code class=\"python\">def list_test2 (L):\n    if not L      : print('list is empty')\n    else: print('list has %d elements' % len(L))\n\nlist_test2(None)\nlist_test2([])\nlist_test2([1,2,3])\n</code></pre>\n<p>produces expected</p>\n<pre><code class=\"python\">list is empty\nlist is empty\nlist has 3 elements\n</code></pre>\n", "abstract": "It is sometimes good to test for None and for emptiness separately as those are two different states. The code above produces the following output: Although it's worth nothing that None is falsy. So if you don't want to separate test for None-ness, you don't have to do that.  produces expected"}, {"id": 53926417, "score": 18, "vote": 0, "content": "<p>To check whether a list is empty or not you can use two following ways. But remember, we should avoid the way of explicitly checking for a type of sequence (it's a <strong>less Pythonic</strong> way):</p>\n<pre><code class=\"python\">def enquiry(list1):\n    return len(list1) == 0\n\n# \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\n\nlist1 = []\n\nif enquiry(list1):\n    print(\"The list isn't empty\")\nelse:\n    print(\"The list is Empty\")\n\n# Result: \"The list is Empty\".\n</code></pre>\n<p>The second way is a <strong>more Pythonic</strong> one. This method is an implicit way of checking and much more preferable than the previous one.</p>\n<pre><code class=\"python\">def enquiry(list1):\n    return not list1\n\n# \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\n\nlist1 = []\n\nif enquiry(list1):\n    print(\"The list is Empty\")\nelse:\n    print(\"The list isn't empty\")\n\n# Result: \"The list is Empty\"\n</code></pre>\n", "abstract": "To check whether a list is empty or not you can use two following ways. But remember, we should avoid the way of explicitly checking for a type of sequence (it's a less Pythonic way): The second way is a more Pythonic one. This method is an implicit way of checking and much more preferable than the previous one."}, {"id": 49109480, "score": 15, "vote": 0, "content": "<p>If you want to check if a list is empty:</p>\n<pre><code class=\"python\">l = []\nif l:\n    # do your stuff.\n</code></pre>\n<p>If you want to check whether all the values in list is empty. However it will be <code>True</code> for an empty list:</p>\n<pre><code class=\"python\">l = [\"\", False, 0, '', [], {}, ()]\nif all(bool(x) for x in l):\n    # do your stuff.\n</code></pre>\n<p>If you want to use both cases together:</p>\n<pre><code class=\"python\">def empty_list(lst):\n    if len(lst) == 0:\n        return False\n    else:\n        return all(bool(x) for x in l)\n</code></pre>\n<p>Now you can use:</p>\n<pre><code class=\"python\">if empty_list(lst):\n    # do your stuff.\n</code></pre>\n", "abstract": "If you want to check if a list is empty: If you want to check whether all the values in list is empty. However it will be True for an empty list: If you want to use both cases together: Now you can use:"}, {"id": 52772082, "score": 15, "vote": 0, "content": "<p>Many answers have been given, and a lot of them are pretty good. I just wanted to add that the check</p>\n<pre><code class=\"python\">not a\n</code></pre>\n<p>will also pass for <code>None</code> and other types of empty structures. If you truly want to check for an empty list, you can do this:</p>\n<pre><code class=\"python\">if isinstance(a, list) and len(a)==0:\n    print(\"Received an empty list\")\n</code></pre>\n", "abstract": "Many answers have been given, and a lot of them are pretty good. I just wanted to add that the check will also pass for None and other types of empty structures. If you truly want to check for an empty list, you can do this:"}, {"id": 53127845, "score": 13, "vote": 0, "content": "<pre><code class=\"python\">print('not empty' if a else 'empty')\n</code></pre>\n<p>a little more practical:</p>\n<pre><code class=\"python\">a.pop() if a else None\n</code></pre>\n<p>and the shortest version:</p>\n<pre><code class=\"python\">if a: a.pop() \n</code></pre>\n", "abstract": "a little more practical: and the shortest version:"}, {"id": 43083496, "score": 11, "vote": 0, "content": "<p>Being inspired by <a href=\"https://stackoverflow.com/questions/53513/how-do-i-check-if-a-list-is-empty/10835703#10835703\">dubiousjim's solution</a>, I propose to use an additional general check of whether is it something iterable:</p>\n<pre><code class=\"python\">import collections\ndef is_empty(a):\n    return not a and isinstance(a, collections.Iterable)\n</code></pre>\n<p>Note: a string is considered to be iterable\u2014add <code>and not isinstance(a,(str,unicode))</code> if you want the empty string to be excluded</p>\n<p>Test:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; is_empty('sss')\nFalse\n&gt;&gt;&gt; is_empty(555)\nFalse\n&gt;&gt;&gt; is_empty(0)\nFalse\n&gt;&gt;&gt; is_empty('')\nTrue\n&gt;&gt;&gt; is_empty([3])\nFalse\n&gt;&gt;&gt; is_empty([])\nTrue\n&gt;&gt;&gt; is_empty({})\nTrue\n&gt;&gt;&gt; is_empty(())\nTrue\n</code></pre>\n", "abstract": "Being inspired by dubiousjim's solution, I propose to use an additional general check of whether is it something iterable: Note: a string is considered to be iterable\u2014add and not isinstance(a,(str,unicode)) if you want the empty string to be excluded Test:"}, {"id": 54065002, "score": 11, "vote": 0, "content": "<p>We could use a simple <em>if else</em>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">item_list=[]\nif len(item_list) == 0:\n    print(\"list is empty\")\nelse:\n    print(\"list is not empty\")\n</code></pre>\n", "abstract": "We could use a simple if else:"}, {"id": 45898755, "score": 8, "vote": 0, "content": "<p>Simply use is_empty() or make function like:- </p>\n<pre><code class=\"python\">def is_empty(any_structure):\n    if any_structure:\n        print('Structure is not empty.')\n        return True\n    else:\n        print('Structure is empty.')\n        return False  \n</code></pre>\n<p>It can be used for any data_structure like a list,tuples, dictionary and many more. By these, you can call it many times using just <code>is_empty(any_structure)</code>. </p>\n", "abstract": "Simply use is_empty() or make function like:-  It can be used for any data_structure like a list,tuples, dictionary and many more. By these, you can call it many times using just is_empty(any_structure). "}, {"id": 52771578, "score": 8, "vote": 0, "content": "<p>Simple way is checking the length is equal zero.</p>\n<pre><code class=\"python\">if len(a) == 0:\n    print(\"a is empty\")\n</code></pre>\n", "abstract": "Simple way is checking the length is equal zero."}, {"id": 53169502, "score": 7, "vote": 0, "content": "<p>From python3 onwards you can use</p>\n<pre><code class=\"python\">a == []\n</code></pre>\n<p>to check if the list is empty</p>\n<p>EDIT : This works with python2.7 too.. </p>\n<p>I am not sure why there are so many complicated answers.\nIt's pretty clear and straightforward</p>\n", "abstract": "From python3 onwards you can use to check if the list is empty EDIT : This works with python2.7 too..  I am not sure why there are so many complicated answers.\nIt's pretty clear and straightforward"}, {"id": 50362360, "score": 6, "vote": 0, "content": "<p>The truth value of an empty list is <code>False</code> whereas for a non-empty list it is <code>True</code>.</p>\n", "abstract": "The truth value of an empty list is False whereas for a non-empty list it is True."}, {"id": 55833259, "score": 6, "vote": 0, "content": "<p>What brought me here is a special use-case: I actually wanted a <em>function</em> to tell me if a list is empty or not. I wanted to avoid writing my own function or using a lambda-expression here (because it seemed like it should be simple enough):</p>\n<pre><code class=\"python\">foo = itertools.takewhile(is_not_empty, (f(x) for x in itertools.count(1)))\n</code></pre>\n<p>And, of course, there is a very natural way to do it:</p>\n<pre><code class=\"python\">foo = itertools.takewhile(bool, (f(x) for x in itertools.count(1)))\n</code></pre>\n<p>Of course, do <strong>not</strong> use <code>bool</code> in <code>if</code> (i.e., <code>if bool(L):</code>) because it's implied. But, for the cases when \"is not empty\" is explicitly needed as a function, <code>bool</code> is the best choice.</p>\n", "abstract": "What brought me here is a special use-case: I actually wanted a function to tell me if a list is empty or not. I wanted to avoid writing my own function or using a lambda-expression here (because it seemed like it should be simple enough): And, of course, there is a very natural way to do it: Of course, do not use bool in if (i.e., if bool(L):) because it's implied. But, for the cases when \"is not empty\" is explicitly needed as a function, bool is the best choice."}]}, {"link": "https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument", "question": {"id": "1132941", "title": "&quot;Least Astonishment&quot; and the Mutable Default Argument", "content": "<p>Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:</p>\n<pre><code class=\"python\">def foo(a=[]):\n    a.append(5)\n    return a\n</code></pre>\n<p>Python novices would expect this function called with no parameter to always return a list with only one element: <code>[5]</code>. The result is instead very different, and very astonishing (for a novice):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; foo()\n[5]\n&gt;&gt;&gt; foo()\n[5, 5]\n&gt;&gt;&gt; foo()\n[5, 5, 5]\n&gt;&gt;&gt; foo()\n[5, 5, 5, 5]\n&gt;&gt;&gt; foo()\n</code></pre>\n<p>A manager of mine once had his first encounter with this feature, and called it \"a dramatic design flaw\" of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don't understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)</p>\n<p><strong>Edit</strong>:</p>\n<p><a href=\"https://stackoverflow.com/a/1137164/7487335\">Baczek made an interesting example</a>. Together with most of your comments and <a href=\"https://stackoverflow.com/a/1134623/7487335\">Utaal's in particular</a>, I elaborated further:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def a():\n...     print(\"a executed\")\n...     return []\n... \n&gt;&gt;&gt;            \n&gt;&gt;&gt; def b(x=a()):\n...     x.append(5)\n...     print(x)\n... \na executed\n&gt;&gt;&gt; b()\n[5]\n&gt;&gt;&gt; b()\n[5, 5]\n</code></pre>\n<p>To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function, or \"together\" with it?</p>\n<p>Doing the binding inside the function would mean that <code>x</code> is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the <code>def</code> line would be \"hybrid\" in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.</p>\n<p>The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.</p>\n", "abstract": "Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue: Python novices would expect this function called with no parameter to always return a list with only one element: [5]. The result is instead very different, and very astonishing (for a novice): A manager of mine once had his first encounter with this feature, and called it \"a dramatic design flaw\" of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don't understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?) Edit: Baczek made an interesting example. Together with most of your comments and Utaal's in particular, I elaborated further: To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function, or \"together\" with it? Doing the binding inside the function would mean that x is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the def line would be \"hybrid\" in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time. The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition."}, "answers": [{"id": 1145781, "score": 1844, "vote": 0, "content": "<p>Actually, this is not a design flaw, and it is not because of internals or performance. It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.</p>\n<p>As soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of \"member data\" and therefore their state may change from one call to the other - exactly as in any other object.</p>\n<p>In any case, the effbot (Fredrik Lundh) has a very nice explanation of the reasons for this behavior in <a href=\"https://web.archive.org/web/20200221224620id_/http://effbot.org/zone/default-values.htm\" rel=\"noreferrer\">Default Parameter Values in Python</a>.\nI found it very clear, and I really suggest reading it for a better knowledge of how function objects work.</p>\n", "abstract": "Actually, this is not a design flaw, and it is not because of internals or performance. It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code. As soon as you think of it this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of \"member data\" and therefore their state may change from one call to the other - exactly as in any other object. In any case, the effbot (Fredrik Lundh) has a very nice explanation of the reasons for this behavior in Default Parameter Values in Python.\nI found it very clear, and I really suggest reading it for a better knowledge of how function objects work."}, {"id": 1133013, "score": 320, "vote": 0, "content": "<p>Suppose you have the following code</p>\n<pre><code class=\"python\">fruits = (\"apples\", \"bananas\", \"loganberries\")\n\ndef eat(food=fruits):\n    ...\n</code></pre>\n<p>When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple <code>(\"apples\", \"bananas\", \"loganberries\")</code></p>\n<p>However, suppose later on in the code, I do something like</p>\n<pre><code class=\"python\">def some_random_function():\n    global fruits\n    fruits = (\"blueberries\", \"mangos\")\n</code></pre>\n<p>then if default parameters were bound at function execution rather than function declaration, I would be astonished (in a very bad way) to discover that fruits had been changed. This would be more astonishing IMO than discovering that your <code>foo</code> function above was mutating the list.</p>\n<p>The real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code:</p>\n<pre class=\"lang-java prettyprint-override\"><code class=\"python\">StringBuffer s = new StringBuffer(\"Hello World!\");\nMap&lt;StringBuffer,Integer&gt; counts = new HashMap&lt;StringBuffer,Integer&gt;();\ncounts.put(s, 5);\ns.append(\"!!!!\");\nSystem.out.println( counts.get(s) );  // does this work?\n</code></pre>\n<p>Now, does my map use the value of the <code>StringBuffer</code> key when it was placed into the map, or does it store the key by reference? Either way, someone is astonished; either the person who tried to get the object out of the <code>Map</code> using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys).</p>\n<p>Your example is a good one of a case where Python newcomers will be surprised and bitten. But I'd argue that if we \"fixed\" this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing.</p>\n<p>I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.</p>\n", "abstract": "Suppose you have the following code When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple (\"apples\", \"bananas\", \"loganberries\") However, suppose later on in the code, I do something like then if default parameters were bound at function execution rather than function declaration, I would be astonished (in a very bad way) to discover that fruits had been changed. This would be more astonishing IMO than discovering that your foo function above was mutating the list. The real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code: Now, does my map use the value of the StringBuffer key when it was placed into the map, or does it store the key by reference? Either way, someone is astonished; either the person who tried to get the object out of the Map using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys). Your example is a good one of a case where Python newcomers will be surprised and bitten. But I'd argue that if we \"fixed\" this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing. I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible."}, {"id": 11416002, "score": 302, "vote": 0, "content": "<p>The relevant part of the <a href=\"http://docs.python.org/reference/compound_stmts.html#function-definitions\" rel=\"noreferrer\">documentation</a>:</p>\n<blockquote>\n<p><strong>Default parameter values are evaluated from left to right when the function definition is executed.</strong> This means that the expression is evaluated once, when the function is defined, and that the same \u201cpre-computed\u201d value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use <code>None</code> as the default, and explicitly test for it in the body of the function, e.g.:</p>\n<pre><code class=\"python\">def whats_on_the_telly(penguin=None):\n    if penguin is None:\n        penguin = []\n    penguin.append(\"property of the zoo\")\n    return penguin\n</code></pre>\n</blockquote>\n", "abstract": "The relevant part of the documentation: Default parameter values are evaluated from left to right when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that the same \u201cpre-computed\u201d value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use None as the default, and explicitly test for it in the body of the function, e.g.:"}, {"id": 1134623, "score": 139, "vote": 0, "content": "<p>I know nothing about the Python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible.</p>\n<p>Provided that python objects <strong>are mutable</strong> I think that this should be taken into account when designing the default arguments stuff.\nWhen you instantiate a list:</p>\n<pre><code class=\"python\">a = []\n</code></pre>\n<p>you expect to get a <strong>new</strong> list referenced by <code>a</code>.</p>\n<p>Why should the <code>a=[]</code> in</p>\n<pre><code class=\"python\">def x(a=[]):\n</code></pre>\n<p>instantiate a new list on function definition and not on invocation?\nIt's just like you're asking \"if the user doesn't provide the argument then <em>instantiate</em> a new list and use it as if it was produced by the caller\".\nI think this is ambiguous instead:</p>\n<pre><code class=\"python\">def x(a=datetime.datetime.now()):\n</code></pre>\n<p>user, do you want <code>a</code> to default to the datetime corresponding to when you're defining or executing <code>x</code>?\nIn this case, as in the previous one, I'll keep the same behaviour as if the default argument \"assignment\" was the first instruction of the function (<code>datetime.now()</code> called on function invocation).\nOn the other hand, if the user wanted the definition-time mapping he could write:</p>\n<pre><code class=\"python\">b = datetime.datetime.now()\ndef x(a=b):\n</code></pre>\n<p>I know, I know: that's a closure. Alternatively Python might provide a keyword to force definition-time binding:</p>\n<pre><code class=\"python\">def x(static a=b):\n</code></pre>\n", "abstract": "I know nothing about the Python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible. Provided that python objects are mutable I think that this should be taken into account when designing the default arguments stuff.\nWhen you instantiate a list: you expect to get a new list referenced by a. Why should the a=[] in instantiate a new list on function definition and not on invocation?\nIt's just like you're asking \"if the user doesn't provide the argument then instantiate a new list and use it as if it was produced by the caller\".\nI think this is ambiguous instead: user, do you want a to default to the datetime corresponding to when you're defining or executing x?\nIn this case, as in the previous one, I'll keep the same behaviour as if the default argument \"assignment\" was the first instruction of the function (datetime.now() called on function invocation).\nOn the other hand, if the user wanted the definition-time mapping he could write: I know, I know: that's a closure. Alternatively Python might provide a keyword to force definition-time binding:"}, {"id": 1133255, "score": 94, "vote": 0, "content": "<p>Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.</p>\n<p>Compare this:</p>\n<pre><code class=\"python\">class BananaBunch:\n    bananas = []\n\n    def addBanana(self, banana):\n        self.bananas.append(banana)\n</code></pre>\n<p>This code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it's added to all instances of that class. The reason is exactly the same.</p>\n<p>It's just \"How It Works\", and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.</p>\n<p>Yes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better.</p>\n<p>That said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.</p>\n", "abstract": "Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined. Compare this: This code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it's added to all instances of that class. The reason is exactly the same. It's just \"How It Works\", and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created. Yes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better. That said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later."}, {"id": 34172768, "score": 83, "vote": 0, "content": "<h2>Why don't you introspect?</h2>\n<p>I'm <em>really</em> surprised no one has performed the insightful introspection offered by Python (<code>2</code> and <code>3</code> apply) on callables. </p>\n<p>Given a simple little function <code>func</code> defined as:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def func(a = []):\n...    a.append(5)\n</code></pre>\n<p>When Python encounters it, the first thing it will do is compile it in order to create a <code>code</code> object for this function. While this compilation step is done, <em>Python <strong>evaluates</strong>* and then <strong>stores</strong> the default arguments (an empty list <code>[]</code> here) in the function object itself</em>. As the top answer mentioned: the list <code>a</code> can now be considered a <em>member</em> of the function <code>func</code>.</p>\n<p>So, let's do some introspection, a before and after to examine how the list gets expanded <strong>inside</strong> the function object. I'm using <code>Python 3.x</code> for this, for Python 2 the same applies (use <code>__defaults__</code> or <code>func_defaults</code> in Python 2; yes, two names for the same thing).</p>\n<h3>Function Before Execution:</h3>\n<pre><code class=\"python\">&gt;&gt;&gt; def func(a = []):\n...     a.append(5)\n...     \n</code></pre>\n<p>After Python executes this definition it will take any default parameters specified (<code>a = []</code> here) and <a href=\"https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy\" rel=\"noreferrer\">cram them in the <code>__defaults__</code> attribute for the function object</a> (relevant section: Callables):     </p>\n<pre><code class=\"python\">&gt;&gt;&gt; func.__defaults__\n([],)\n</code></pre>\n<p>O.k, so an empty list as the single entry in <code>__defaults__</code>, just as expected. </p>\n<h3>Function After Execution:</h3>\n<p>Let's now execute this function:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; func()\n</code></pre>\n<p>Now, let's see those <code>__defaults__</code> again: </p>\n<pre><code class=\"python\">&gt;&gt;&gt; func.__defaults__\n([5],)\n</code></pre>\n<p><em>Astonished?</em> The value inside the object changes! Consecutive calls to the function will now simply append to that embedded <code>list</code> object:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; func(); func(); func()\n&gt;&gt;&gt; func.__defaults__\n([5, 5, 5, 5],)\n</code></pre>\n<p>So, there you have it, the reason why this <em>'flaw'</em> happens, is because default arguments are part of the function object. There's nothing weird going on here, it's all just a bit surprising.</p>\n<p>The common solution to combat this is to use <code>None</code> as the default and then initialize in the function body:</p>\n<pre><code class=\"python\">def func(a = None):\n    # or: a = [] if a is None else a\n    if a is None:\n        a = []\n</code></pre>\n<p>Since the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for <code>a</code>.</p>\n<hr/>\n<p>To further verify that the list in <code>__defaults__</code> is the same as that used in the function <code>func</code> you can just change your function to return the <code>id</code> of the list <code>a</code> used inside the function body. Then, compare it to the list in <code>__defaults__</code> (position <code>[0]</code> in <code>__defaults__</code>) and you'll see how these are indeed refering to the same list instance:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def func(a = []): \n...     a.append(5)\n...     return id(a)\n&gt;&gt;&gt;\n&gt;&gt;&gt; id(func.__defaults__[0]) == func()\nTrue\n</code></pre>\n<p>All with the power of introspection! </p>\n<hr/>\n<p><sup>*</sup> To verify that Python evaluates the default arguments during compilation of the function, try executing the following:</p>\n<pre><code class=\"python\">def bar(a=input('Did you just see me without calling the function?')): \n    pass  # use raw_input in Py2\n</code></pre>\n<p>as you'll notice, <code>input()</code> is called before the process of building the function and binding it to the name <code>bar</code> is made.</p>\n", "abstract": "I'm really surprised no one has performed the insightful introspection offered by Python (2 and 3 apply) on callables.  Given a simple little function func defined as: When Python encounters it, the first thing it will do is compile it in order to create a code object for this function. While this compilation step is done, Python evaluates* and then stores the default arguments (an empty list [] here) in the function object itself. As the top answer mentioned: the list a can now be considered a member of the function func. So, let's do some introspection, a before and after to examine how the list gets expanded inside the function object. I'm using Python 3.x for this, for Python 2 the same applies (use __defaults__ or func_defaults in Python 2; yes, two names for the same thing). After Python executes this definition it will take any default parameters specified (a = [] here) and cram them in the __defaults__ attribute for the function object (relevant section: Callables):      O.k, so an empty list as the single entry in __defaults__, just as expected.  Let's now execute this function: Now, let's see those __defaults__ again:  Astonished? The value inside the object changes! Consecutive calls to the function will now simply append to that embedded list object: So, there you have it, the reason why this 'flaw' happens, is because default arguments are part of the function object. There's nothing weird going on here, it's all just a bit surprising. The common solution to combat this is to use None as the default and then initialize in the function body: Since the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for a. To further verify that the list in __defaults__ is the same as that used in the function func you can just change your function to return the id of the list a used inside the function body. Then, compare it to the list in __defaults__ (position [0] in __defaults__) and you'll see how these are indeed refering to the same list instance: All with the power of introspection!  * To verify that Python evaluates the default arguments during compilation of the function, try executing the following: as you'll notice, input() is called before the process of building the function and binding it to the name bar is made."}, {"id": 1136611, "score": 65, "vote": 0, "content": "<p>I used to think that creating the objects at runtime would be the better approach.  I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:</p>\n<p><strong>1. Performance</strong></p>\n<pre><code class=\"python\">def foo(arg=something_expensive_to_compute())):\n    ...\n</code></pre>\n<p>If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.</p>\n<p><strong>2. Forcing bound parameters</strong></p>\n<p>A useful trick is to bind parameters of a lambda to the <em>current</em> binding of a variable when the lambda is created.  For example:</p>\n<pre><code class=\"python\">funcs = [ lambda i=i: i for i in range(10)]\n</code></pre>\n<p>This returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind <code>i</code> to the <em>call-time</em> value of i, so you would get a list of functions that all returned <code>9</code>.</p>\n<p>The only way to implement this otherwise would be to create a further closure with the i bound, ie:</p>\n<pre><code class=\"python\">def make_func(i): return lambda: i\nfuncs = [make_func(i) for i in range(10)]\n</code></pre>\n<p><strong>3. Introspection</strong></p>\n<p>Consider the code:</p>\n<pre><code class=\"python\">def foo(a='test', b=100, c=[]):\n   print a,b,c\n</code></pre>\n<p>We can get information about the arguments and defaults using the <code>inspect</code> module, which </p>\n<pre><code class=\"python\">&gt;&gt;&gt; inspect.getargspec(foo)\n(['a', 'b', 'c'], None, None, ('test', 100, []))\n</code></pre>\n<p>This information is very useful for things like document generation, metaprogramming, decorators etc.</p>\n<p>Now, suppose the behaviour of defaults could be changed so that this is the equivalent of:</p>\n<pre><code class=\"python\">_undefined = object()  # sentinel value\n\ndef foo(a=_undefined, b=_undefined, c=_undefined)\n    if a is _undefined: a='test'\n    if b is _undefined: b=100\n    if c is _undefined: c=[]\n</code></pre>\n<p>However, we've lost the ability to introspect, and see what the default arguments <em>are</em>.  Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.</p>\n", "abstract": "I used to think that creating the objects at runtime would be the better approach.  I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are: 1. Performance If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity. 2. Forcing bound parameters A useful trick is to bind parameters of a lambda to the current binding of a variable when the lambda is created.  For example: This returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind i to the call-time value of i, so you would get a list of functions that all returned 9. The only way to implement this otherwise would be to create a further closure with the i bound, ie: 3. Introspection Consider the code: We can get information about the arguments and defaults using the inspect module, which  This information is very useful for things like document generation, metaprogramming, decorators etc. Now, suppose the behaviour of defaults could be changed so that this is the equivalent of: However, we've lost the ability to introspect, and see what the default arguments are.  Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string."}, {"id": 29344819, "score": 65, "vote": 0, "content": "<h1>5 points in defense of Python</h1>\n<ol>\n<li><p><strong>Simplicity</strong>: The behavior is simple in the following sense:\nMost people fall into this trap only once, not several times.</p>\n</li>\n<li><p><strong>Consistency</strong>: Python <em>always</em> passes objects, not names.\nThe default parameter is, obviously, part of the function\nheading (not the function body). It therefore ought to be evaluated\nat module load time (and only at module load time, unless nested), not\nat function call time.</p>\n</li>\n<li><p><strong>Usefulness</strong>: As Frederik Lundh points out in his explanation\nof <a href=\"https://web.archive.org/web/20201112004749/http://effbot.org/zone/default-values.htm\" rel=\"noreferrer\">\"Default Parameter Values in Python\"</a>, the\ncurrent behavior can be quite useful for advanced programming.\n(Use sparingly.)</p>\n</li>\n<li><p><strong>Sufficient documentation</strong>: In the most basic Python documentation,\nthe tutorial, the issue is loudly announced as\nan <strong>\"Important warning\"</strong> in the <em>first</em> subsection of Section\n<a href=\"https://docs.python.org/3/tutorial/controlflow.html#default-argument-values\" rel=\"noreferrer\">\"More on Defining Functions\"</a>.\nThe warning even uses boldface,\nwhich is rarely applied outside of headings.\nRTFM: Read the fine manual.</p>\n</li>\n<li><p><strong>Meta-learning</strong>: Falling into the trap is actually a very\nhelpful moment (at least if you are a reflective learner),\nbecause you will subsequently better understand the point\n\"Consistency\" above and that will\nteach you a great deal about Python.</p>\n</li>\n</ol>\n", "abstract": "Simplicity: The behavior is simple in the following sense:\nMost people fall into this trap only once, not several times. Consistency: Python always passes objects, not names.\nThe default parameter is, obviously, part of the function\nheading (not the function body). It therefore ought to be evaluated\nat module load time (and only at module load time, unless nested), not\nat function call time. Usefulness: As Frederik Lundh points out in his explanation\nof \"Default Parameter Values in Python\", the\ncurrent behavior can be quite useful for advanced programming.\n(Use sparingly.) Sufficient documentation: In the most basic Python documentation,\nthe tutorial, the issue is loudly announced as\nan \"Important warning\" in the first subsection of Section\n\"More on Defining Functions\".\nThe warning even uses boldface,\nwhich is rarely applied outside of headings.\nRTFM: Read the fine manual. Meta-learning: Falling into the trap is actually a very\nhelpful moment (at least if you are a reflective learner),\nbecause you will subsequently better understand the point\n\"Consistency\" above and that will\nteach you a great deal about Python."}, {"id": 1133375, "score": 57, "vote": 0, "content": "<p>This behavior is easy explained by:</p>\n<ol>\n<li>function (class etc.) declaration is executed only once, creating all default value objects</li>\n<li>everything is passed by reference</li>\n</ol>\n<p>So:</p>\n<pre><code class=\"python\">def x(a=0, b=[], c=[], d=0):\n    a = a + 1\n    b = b + [1]\n    c.append(1)\n    print a, b, c\n</code></pre>\n<ol>\n<li><code>a</code> doesn't change - every assignment call creates new int object - new object is printed</li>\n<li><code>b</code> doesn't change - new array is build from default value and printed</li>\n<li><code>c</code> changes - operation is performed on same object - and it is printed</li>\n</ol>\n", "abstract": "This behavior is easy explained by: So:"}, {"id": 13518071, "score": 39, "vote": 0, "content": "<p>1)  The so-called problem of \"Mutable Default Argument\" is in general a special example demonstrating that:<br/>\n\"All functions with this problem <strong>suffer also from similar side effect problem on the actual parameter</strong>,\"<br/>\nThat is against the rules of functional programming, usually undesiderable and should be fixed both together.</p>\n<p>Example:</p>\n<pre><code class=\"python\">def foo(a=[]):                 # the same problematic function\n    a.append(5)\n    return a\n\n&gt;&gt;&gt; somevar = [1, 2]           # an example without a default parameter\n&gt;&gt;&gt; foo(somevar)\n[1, 2, 5]\n&gt;&gt;&gt; somevar\n[1, 2, 5]                      # usually expected [1, 2]\n</code></pre>\n<p><strong>Solution</strong>:  a <strong>copy</strong><br/>\nAn absolutely safe solution is to <strong><code>copy</code></strong> or <strong><code>deepcopy</code></strong> the input object first and then to do whatever with the copy.</p>\n<pre><code class=\"python\">def foo(a=[]):\n    a = a[:]     # a copy\n    a.append(5)\n    return a     # or everything safe by one line: \"return a + [5]\"\n</code></pre>\n<p>Many builtin mutable types have a copy method like <code>some_dict.copy()</code> or <code>some_set.copy()</code> or can be copied easy like <code>somelist[:]</code> or <code>list(some_list)</code>. Every object can be also copied by <code>copy.copy(any_object)</code> or more thorough by <code>copy.deepcopy()</code> (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like \"file\" object and can not be meaningfully reproduced by copy. <a href=\"http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm\" rel=\"noreferrer\">copying</a></p>\n<p>Example problem for <a href=\"https://stackoverflow.com/q/13484107/448474\">a similar SO question</a></p>\n<pre><code class=\"python\">class Test(object):            # the original problematic class\n  def __init__(self, var1=[]):\n    self._var1 = var1\n\nsomevar = [1, 2]               # an example without a default parameter\nt1 = Test(somevar)\nt2 = Test(somevar)\nt1._var1.append([1])\nprint somevar                  # [1, 2, [1]] but usually expected [1, 2]\nprint t2._var1                 # [1, 2, [1]] but usually expected [1, 2]\n</code></pre>\n<p>It shouldn't be neither saved in any <em>public</em> attribute of an instance returned by this function. (Assuming that <em>private</em> attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. <code>_var1</code> is a private attribute )</p>\n<p>Conclusion:<br/>\nInput parameters objects shouldn't be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see <a href=\"http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29\" rel=\"noreferrer\">Wiki about \"side effect\"</a> (The first two paragraphs are relevent in this context.)\n.)</p>\n<p>2)<br/>\nOnly if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is <code>def ...(var1=None):</code> <code>if var1 is None:</code> <code>var1 = []</code> <a href=\"http://effbot.org/zone/default-values.htm#what-to-do-instead\" rel=\"noreferrer\">More..</a></p>\n<p>3) In some cases is <a href=\"http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults\" rel=\"noreferrer\">the mutable behavior of default parameters useful</a>.</p>\n", "abstract": "1)  The so-called problem of \"Mutable Default Argument\" is in general a special example demonstrating that:\n\"All functions with this problem suffer also from similar side effect problem on the actual parameter,\"\nThat is against the rules of functional programming, usually undesiderable and should be fixed both together. Example: Solution:  a copy\nAn absolutely safe solution is to copy or deepcopy the input object first and then to do whatever with the copy. Many builtin mutable types have a copy method like some_dict.copy() or some_set.copy() or can be copied easy like somelist[:] or list(some_list). Every object can be also copied by copy.copy(any_object) or more thorough by copy.deepcopy() (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like \"file\" object and can not be meaningfully reproduced by copy. copying Example problem for a similar SO question It shouldn't be neither saved in any public attribute of an instance returned by this function. (Assuming that private attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. _var1 is a private attribute ) Conclusion:\nInput parameters objects shouldn't be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see Wiki about \"side effect\" (The first two paragraphs are relevent in this context.)\n.) 2)\nOnly if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is def ...(var1=None): if var1 is None: var1 = [] More.. 3) In some cases is the mutable behavior of default parameters useful."}, {"id": 1133737, "score": 38, "vote": 0, "content": "<p>What you're asking is why this:</p>\n<pre><code class=\"python\">def func(a=[], b = 2):\n    pass\n</code></pre>\n<p>isn't internally equivalent to this:</p>\n<pre><code class=\"python\">def func(a=None, b = None):\n    a_default = lambda: []\n    b_default = lambda: 2\n    def actual_func(a=None, b=None):\n        if a is None: a = a_default()\n        if b is None: b = b_default()\n    return actual_func\nfunc = func()\n</code></pre>\n<p>except for the case of explicitly calling func(None, None), which we'll ignore.</p>\n<p>In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?</p>\n<p>One answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.  It'd be slower and use more memory.</p>\n", "abstract": "What you're asking is why this: isn't internally equivalent to this: except for the case of explicitly calling func(None, None), which we'll ignore. In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called? One answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.  It'd be slower and use more memory."}, {"id": 6092808, "score": 30, "vote": 0, "content": "<p>This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def foo(a):\n    a.append(5)\n    print a\n\n&gt;&gt;&gt; a  = [5]\n&gt;&gt;&gt; foo(a)\n[5, 5]\n&gt;&gt;&gt; foo(a)\n[5, 5, 5]\n&gt;&gt;&gt; foo(a)\n[5, 5, 5, 5]\n&gt;&gt;&gt; foo(a)\n[5, 5, 5, 5, 5]\n</code></pre>\n<p>No default values in sight in this code, but you get exactly the same problem.</p>\n<p>The problem is that <code>foo</code> is <em>modifying</em> a mutable variable passed in from the caller, when the caller doesn't expect this. Code like this would be fine if the function was called something like <code>append_5</code>; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in).</p>\n<p>Your original <code>foo</code>, with a default argument, shouldn't be modifying <code>a</code> whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not.</p>\n<p>If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.</p>\n", "abstract": "This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values. No default values in sight in this code, but you get exactly the same problem. The problem is that foo is modifying a mutable variable passed in from the caller, when the caller doesn't expect this. Code like this would be fine if the function was called something like append_5; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in). Your original foo, with a default argument, shouldn't be modifying a whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not. If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy."}, {"id": 1137164, "score": 28, "vote": 0, "content": "<p>The shortest answer would probably be \"definition is execution\", therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:</p>\n<pre><code class=\"python\">def a(): return []\n\ndef b(x=a()):\n    print x\n</code></pre>\n<p>Hopefully it's enough to show that not executing the default argument expressions at the execution time of the <code>def</code> statement isn't easy or doesn't make sense, or both.</p>\n<p>I agree it's a gotcha when you try to use default constructors, though.</p>\n", "abstract": "The shortest answer would probably be \"definition is execution\", therefore the whole argument makes no strict sense. As a more contrived example, you may cite this: Hopefully it's enough to show that not executing the default argument expressions at the execution time of the def statement isn't easy or doesn't make sense, or both. I agree it's a gotcha when you try to use default constructors, though."}, {"id": 36968932, "score": 28, "vote": 0, "content": "<h1>Python: The Mutable Default Argument</h1>\n<p>Default arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object. </p>\n<p>When they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls.</p>\n<p>They stay mutated because they are the same object each time.</p>\n<h2>Equivalent code:</h2>\n<p>Since the list is bound to the function when the function object is compiled and instantiated, this:</p>\n<pre><code class=\"python\">def foo(mutable_default_argument=[]): # make a list the default argument\n    \"\"\"function that uses a list\"\"\"\n</code></pre>\n<p>is almost exactly equivalent to this:</p>\n<pre><code class=\"python\">_a_list = [] # create a list in the globals\n\ndef foo(mutable_default_argument=_a_list): # make it the default argument\n    \"\"\"function that uses a list\"\"\"\n\ndel _a_list # remove globals name binding\n</code></pre>\n<h2>Demonstration</h2>\n<p>Here's a demonstration - you can verify that they are the same object each time they are referenced by </p>\n<ul>\n<li>seeing that the list is created before the function has finished compiling to a function object,</li>\n<li>observing that the id is the same each time the list is referenced,</li>\n<li>observing that the list stays changed when the function that uses it is called a second time,</li>\n<li>observing the order in which the output is printed from the source (which I conveniently numbered for you):</li>\n</ul>\n<p><code>example.py</code></p>\n<pre><code class=\"python\">print('1. Global scope being evaluated')\n\ndef create_list():\n    '''noisily create a list for usage as a kwarg'''\n    l = []\n    print('3. list being created and returned, id: ' + str(id(l)))\n    return l\n\nprint('2. example_function about to be compiled to an object')\n\ndef example_function(default_kwarg1=create_list()):\n    print('appending \"a\" in default default_kwarg1')\n    default_kwarg1.append(\"a\")\n    print('list with id: ' + str(id(default_kwarg1)) + \n          ' - is now: ' + repr(default_kwarg1))\n\nprint('4. example_function compiled: ' + repr(example_function))\n\n\nif __name__ == '__main__':\n    print('5. calling example_function twice!:')\n    example_function()\n    example_function()\n</code></pre>\n<p>and running it with <code>python example.py</code>:</p>\n<pre><code class=\"python\">1. Global scope being evaluated\n2. example_function about to be compiled to an object\n3. list being created and returned, id: 140502758808032\n4. example_function compiled: &lt;function example_function at 0x7fc9590905f0&gt;\n5. calling example_function twice!:\nappending \"a\" in default default_kwarg1\nlist with id: 140502758808032 - is now: ['a']\nappending \"a\" in default default_kwarg1\nlist with id: 140502758808032 - is now: ['a', 'a']\n</code></pre>\n<h2>Does this violate the principle of \"Least Astonishment\"?</h2>\n<p>This order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected. </p>\n<h2>The usual instruction to new Python users:</h2>\n<p>But this is why the usual instruction to new users is to create their default arguments like this instead:</p>\n<pre><code class=\"python\">def example_function_2(default_kwarg=None):\n    if default_kwarg is None:\n        default_kwarg = []\n</code></pre>\n<p>This uses the None singleton as a sentinel object to tell the function whether or not we've gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, <code>[]</code>, as the default.</p>\n<p>As the <a href=\"https://docs.python.org/tutorial/controlflow.html#default-argument-values\" rel=\"noreferrer\">tutorial section on control flow</a> says:</p>\n<blockquote>\n<p>If you don\u2019t want the default to be shared between subsequent calls,\n  you can write the function like this instead:</p>\n<pre><code class=\"python\">def f(a, L=None):\n    if L is None:\n        L = []\n    L.append(a)\n    return L\n</code></pre>\n</blockquote>\n", "abstract": "Default arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object.  When they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls. They stay mutated because they are the same object each time. Since the list is bound to the function when the function object is compiled and instantiated, this: is almost exactly equivalent to this: Here's a demonstration - you can verify that they are the same object each time they are referenced by  example.py and running it with python example.py: This order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected.  But this is why the usual instruction to new users is to create their default arguments like this instead: This uses the None singleton as a sentinel object to tell the function whether or not we've gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, [], as the default. As the tutorial section on control flow says: If you don\u2019t want the default to be shared between subsequent calls,\n  you can write the function like this instead:"}, {"id": 29290566, "score": 27, "vote": 0, "content": "<p>Already busy topic, but from what I read here, the following helped me realizing how it's working internally:</p>\n<pre><code class=\"python\">def bar(a=[]):\n     print id(a)\n     a = a + [1]\n     print id(a)\n     return a\n\n&gt;&gt;&gt; bar()\n4484370232\n4484524224\n[1]\n&gt;&gt;&gt; bar()\n4484370232\n4484524152\n[1]\n&gt;&gt;&gt; bar()\n4484370232 # Never change, this is 'class property' of the function\n4484523720 # Always a new object \n[1]\n&gt;&gt;&gt; id(bar.func_defaults[0])\n4484370232\n</code></pre>\n", "abstract": "Already busy topic, but from what I read here, the following helped me realizing how it's working internally:"}, {"id": 1134613, "score": 26, "vote": 0, "content": "<p>It's a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?</p>\n<pre><code class=\"python\">def print_tuple(some_tuple=(1,2,3)):\n    print some_tuple\n\nprint_tuple()        #1\nprint_tuple((1,2,3)) #2\n</code></pre>\n<p>I'll give you a hint.  Here's the disassembly (see <a href=\"http://docs.python.org/library/dis.html\" rel=\"noreferrer\">http://docs.python.org/library/dis.html</a>):</p>\n<h1><code>#</code>1</h1>\n<pre><code class=\"python\">0 LOAD_GLOBAL              0 (print_tuple)\n3 CALL_FUNCTION            0\n6 POP_TOP\n7 LOAD_CONST               0 (None)\n10 RETURN_VALUE\n</code></pre>\n<h1><code>#</code>2</h1>\n<pre><code class=\"python\"> 0 LOAD_GLOBAL              0 (print_tuple)\n 3 LOAD_CONST               4 ((1, 2, 3))\n 6 CALL_FUNCTION            1\n 9 POP_TOP\n10 LOAD_CONST               0 (None)\n13 RETURN_VALUE\n</code></pre>\n<blockquote>\n<p>I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)</p>\n</blockquote>\n<p>As you can see, there <em>is</em> a performance benefit when using immutable default arguments.  This can make a difference if it's a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.  In Python you don't have this benefit.</p>\n", "abstract": "It's a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster? I'll give you a hint.  Here's the disassembly (see http://docs.python.org/library/dis.html): I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?) As you can see, there is a performance benefit when using immutable default arguments.  This can make a difference if it's a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.  In Python you don't have this benefit."}, {"id": 10304917, "score": 22, "vote": 0, "content": "<p>This behavior is not surprising if you take the following into consideration:</p>\n<ol>\n<li>The behavior of read-only class attributes upon assignment attempts, and that</li>\n<li>Functions are objects (explained well in the accepted answer).</li>\n</ol>\n<p>The role of <strong>(2)</strong> has been covered extensively in this thread. <strong>(1)</strong> is likely the astonishment causing factor, as this behavior is not \"intuitive\" when coming from other languages.</p>\n<p><strong>(1)</strong> is described in the Python <a href=\"http://docs.python.org/tutorial/classes.html\" rel=\"nofollow noreferrer\">tutorial on classes</a>. In an attempt to assign a value to a read-only class attribute:</p>\n<blockquote>\n<p>...all variables found outside of the innermost scope are\nread-only (<em><strong>an attempt to write to such a variable will simply create a\nnew local variable in the innermost scope, leaving the identically\nnamed outer variable unchanged</strong></em>).</p>\n</blockquote>\n<p>Look back to the original example and consider the above points:</p>\n<pre><code class=\"python\">def foo(a=[]):\n    a.append(5)\n    return a\n</code></pre>\n<p>Here <code>foo</code> is an object and <code>a</code> is an attribute of <code>foo</code> (available at <code>foo.func_defs[0]</code>). Since <code>a</code> is a list, <code>a</code> is mutable and is thus a read-write attribute of <code>foo</code>. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.</p>\n<p>Calling <code>foo</code> without overriding a default uses that default's value from <code>foo.func_defs</code>. In this case, <code>foo.func_defs[0]</code> is used for <code>a</code> within function object's code scope. Changes to <code>a</code> change <code>foo.func_defs[0]</code>, which is part of the <code>foo</code> object and persists between execution of the code in <code>foo</code>.</p>\n<p>Now, compare this to the example from the documentation on <a href=\"http://docs.python.org/tutorial/controlflow.html#default-argument-values\" rel=\"nofollow noreferrer\">emulating the default argument behavior of other languages</a>, such that the function signature defaults are used every time the function is executed:</p>\n<pre><code class=\"python\">def foo(a, L=None):\n    if L is None:\n        L = []\n    L.append(a)\n    return L\n</code></pre>\n<p>Taking <strong>(1)</strong> and <strong>(2)</strong> into account, one can see why this accomplishes the desired behavior:</p>\n<ul>\n<li>When the <code>foo</code> function object is instantiated, <code>foo.func_defs[0]</code> is set to <code>None</code>, an immutable object.</li>\n<li>When the function is executed with defaults (with no parameter specified for <code>L</code> in the function call), <code>foo.func_defs[0]</code> (<code>None</code>) is available in the local scope as <code>L</code>.</li>\n<li>Upon <code>L = []</code>, the assignment cannot succeed at <code>foo.func_defs[0]</code>, because that attribute is read-only.</li>\n<li>Per <strong>(1)</strong>, <em><strong>a new local variable also named <code>L</code> is created in the local scope</strong></em> and used for the remainder of the function call. <code>foo.func_defs[0]</code> thus remains unchanged for future invocations of <code>foo</code>.</li>\n</ul>\n", "abstract": "This behavior is not surprising if you take the following into consideration: The role of (2) has been covered extensively in this thread. (1) is likely the astonishment causing factor, as this behavior is not \"intuitive\" when coming from other languages. (1) is described in the Python tutorial on classes. In an attempt to assign a value to a read-only class attribute: ...all variables found outside of the innermost scope are\nread-only (an attempt to write to such a variable will simply create a\nnew local variable in the innermost scope, leaving the identically\nnamed outer variable unchanged). Look back to the original example and consider the above points: Here foo is an object and a is an attribute of foo (available at foo.func_defs[0]). Since a is a list, a is mutable and is thus a read-write attribute of foo. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists. Calling foo without overriding a default uses that default's value from foo.func_defs. In this case, foo.func_defs[0] is used for a within function object's code scope. Changes to a change foo.func_defs[0], which is part of the foo object and persists between execution of the code in foo. Now, compare this to the example from the documentation on emulating the default argument behavior of other languages, such that the function signature defaults are used every time the function is executed: Taking (1) and (2) into account, one can see why this accomplishes the desired behavior:"}, {"id": 15133978, "score": 21, "vote": 0, "content": "<p>A simple workaround using None</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def bar(b, data=None):\n...     data = data or []\n...     data.append(b)\n...     return data\n... \n&gt;&gt;&gt; bar(3)\n[3]\n&gt;&gt;&gt; bar(3)\n[3]\n&gt;&gt;&gt; bar(3)\n[3]\n&gt;&gt;&gt; bar(3, [34])\n[34, 3]\n&gt;&gt;&gt; bar(3, [34])\n[34, 3]\n</code></pre>\n", "abstract": "A simple workaround using None"}, {"id": 1139730, "score": 20, "vote": 0, "content": "<p>It may be true that:</p>\n<ol>\n<li>Someone is using every language/library feature, and</li>\n<li>Switching the behavior here would be ill-advised, but</li>\n</ol>\n<p>it is entirely consistent to hold to both of the features above and still make another point:</p>\n<ol start=\"3\">\n<li>It is a confusing feature and it is unfortunate in Python.</li>\n</ol>\n<p>The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. <strong>But all three are true.</strong></p>\n<p>It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. <em>However,</em></p>\n<p>The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere <em>near</em> this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it <strong>Just Works</strong>.</p>\n", "abstract": "It may be true that: it is entirely consistent to hold to both of the features above and still make another point: The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. But all three are true. It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. However, The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere near this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it Just Works."}, {"id": 32535706, "score": 19, "vote": 0, "content": "<p>I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).  </p>\n<p>As others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function's shared parameter at the same time oblivious to the changes made by the other.</p>\n<p><strong>Wrong Method (probably...)</strong>:</p>\n<pre><code class=\"python\">def foo(list_arg=[5]):\n    return list_arg\n\na = foo()\na.append(6)\n&gt;&gt;&gt; a\n[5, 6]\n\nb = foo()\nb.append(7)\n# The value of 6 appended to variable 'a' is now part of the list held by 'b'.\n&gt;&gt;&gt; b\n[5, 6, 7]  \n\n# Although 'a' is expecting to receive 6 (the last element it appended to the list),\n# it actually receives the last element appended to the shared list.\n# It thus receives the value 7 previously appended by 'b'.\n&gt;&gt;&gt; a.pop()             \n7\n</code></pre>\n<p>You can verify that they are one and the same object by using <code>id</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; id(a)\n5347866528\n\n&gt;&gt;&gt; id(b)\n5347866528\n</code></pre>\n<p>Per Brett Slatkin's \"Effective Python: 59 Specific Ways to Write Better Python\", <em>Item 20: Use <code>None</code> and Docstrings to specify dynamic default arguments</em> (p. 48)</p>\n<blockquote>\n<p>The convention for achieving the desired result in Python is to\n  provide a default value of <code>None</code> and to document the actual behaviour\n  in the docstring.</p>\n</blockquote>\n<p>This implementation ensures that each call to the function either receives the default list or else the list passed to the function.</p>\n<p><strong>Preferred Method</strong>:</p>\n<pre><code class=\"python\">def foo(list_arg=None):\n   \"\"\"\n   :param list_arg:  A list of input values. \n                     If none provided, used a list with a default value of 5.\n   \"\"\"\n   if not list_arg:\n       list_arg = [5]\n   return list_arg\n\na = foo()\na.append(6)\n&gt;&gt;&gt; a\n[5, 6]\n\nb = foo()\nb.append(7)\n&gt;&gt;&gt; b\n[5, 7]\n\nc = foo([10])\nc.append(11)\n&gt;&gt;&gt; c\n[10, 11]\n</code></pre>\n<p>There may be legitimate use cases for the 'Wrong Method' whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.</p>\n", "abstract": "I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).   As others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function's shared parameter at the same time oblivious to the changes made by the other. Wrong Method (probably...): You can verify that they are one and the same object by using id: Per Brett Slatkin's \"Effective Python: 59 Specific Ways to Write Better Python\", Item 20: Use None and Docstrings to specify dynamic default arguments (p. 48) The convention for achieving the desired result in Python is to\n  provide a default value of None and to document the actual behaviour\n  in the docstring. This implementation ensures that each call to the function either receives the default list or else the list passed to the function. Preferred Method: There may be legitimate use cases for the 'Wrong Method' whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule."}, {"id": 9791799, "score": 17, "vote": 0, "content": "<p>The solutions here are:</p>\n<ol>\n<li>Use <code>None</code> as your default value (or a nonce <code>object</code>), and switch on that to create your values at runtime; or</li>\n<li>Use a <code>lambda</code> as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).</li>\n</ol>\n<p>The second option is nice because users of the function can pass in a callable, which may be already existing (such as a <code>type</code>)</p>\n", "abstract": "The solutions here are: The second option is nice because users of the function can pass in a callable, which may be already existing (such as a type)"}, {"id": 14336301, "score": 16, "vote": 0, "content": "<p>You can get round this by replacing the object (and therefore the tie with the scope):</p>\n<pre><code class=\"python\">def foo(a=[]):\n    a = list(a)\n    a.append(5)\n    return a\n</code></pre>\n<p>Ugly, but it works.</p>\n", "abstract": "You can get round this by replacing the object (and therefore the tie with the scope): Ugly, but it works."}, {"id": 25797695, "score": 16, "vote": 0, "content": "<p>When we do this:</p>\n<pre><code class=\"python\">def foo(a=[]):\n    ...\n</code></pre>\n<p>... we assign the argument <code>a</code> to an <em>unnamed</em> list, if the caller does not pass the value of a.</p>\n<p>To make things simpler for this discussion, let's temporarily give the unnamed list a name. How about <code>pavlo</code> ?</p>\n<pre><code class=\"python\">def foo(a=pavlo):\n   ...\n</code></pre>\n<p>At any time, if the caller doesn't tell us what <code>a</code> is, we reuse <code>pavlo</code>.</p>\n<p>If <code>pavlo</code> is mutable (modifiable), and <code>foo</code> ends up modifying it, an effect we notice the next time <code>foo</code> is called without specifying <code>a</code>.</p>\n<p>So this is what you see (Remember, <code>pavlo</code> is initialized to []):</p>\n<pre><code class=\"python\"> &gt;&gt;&gt; foo()\n [5]\n</code></pre>\n<p>Now, <code>pavlo</code> is [5].</p>\n<p>Calling <code>foo()</code> again modifies <code>pavlo</code> again:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; foo()\n[5, 5]\n</code></pre>\n<p>Specifying <code>a</code> when calling <code>foo()</code> ensures <code>pavlo</code> is not touched.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; ivan = [1, 2, 3, 4]\n&gt;&gt;&gt; foo(a=ivan)\n[1, 2, 3, 4, 5]\n&gt;&gt;&gt; ivan\n[1, 2, 3, 4, 5]\n</code></pre>\n<p>So, <code>pavlo</code> is still <code>[5, 5]</code>.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; foo()\n[5, 5, 5]\n</code></pre>\n", "abstract": "When we do this: ... we assign the argument a to an unnamed list, if the caller does not pass the value of a. To make things simpler for this discussion, let's temporarily give the unnamed list a name. How about pavlo ? At any time, if the caller doesn't tell us what a is, we reuse pavlo. If pavlo is mutable (modifiable), and foo ends up modifying it, an effect we notice the next time foo is called without specifying a. So this is what you see (Remember, pavlo is initialized to []): Now, pavlo is [5]. Calling foo() again modifies pavlo again: Specifying a when calling foo() ensures pavlo is not touched. So, pavlo is still [5, 5]."}, {"id": 28354667, "score": 16, "vote": 0, "content": "<p>I sometimes exploit this behavior as an alternative to the following pattern:</p>\n<pre><code class=\"python\">singleton = None\n\ndef use_singleton():\n    global singleton\n\n    if singleton is None:\n        singleton = _make_singleton()\n\n    return singleton.use_me()\n</code></pre>\n<p>If <code>singleton</code> is only used by <code>use_singleton</code>, I like the following pattern as a replacement:</p>\n<pre><code class=\"python\"># _make_singleton() is called only once when the def is executed\ndef use_singleton(singleton=_make_singleton()):\n    return singleton.use_me()\n</code></pre>\n<p>I've used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.</p>\n<p>Since I don't think this pattern is well known, I do put a short comment in to guard against future misunderstandings.</p>\n", "abstract": "I sometimes exploit this behavior as an alternative to the following pattern: If singleton is only used by use_singleton, I like the following pattern as a replacement: I've used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization. Since I don't think this pattern is well known, I do put a short comment in to guard against future misunderstandings."}, {"id": 54018161, "score": 12, "vote": 0, "content": "<p>Every other answer explains why this is actually a nice and desired behavior, or why you shouldn't be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.</p>\n<p>We will \"fix\" this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import inspect\nfrom copy import deepcopy  # copy would fail on deep arguments like nested dicts\n\ndef sanify(function):\n    def wrapper(*a, **kw):\n        # store the default values\n        defaults = inspect.getargspec(function).defaults # for python2\n        # construct a new argument list\n        new_args = []\n        for i, arg in enumerate(defaults):\n            # allow passing positional arguments\n            if i in range(len(a)):\n                new_args.append(a[i])\n            else:\n                # copy the value\n                new_args.append(deepcopy(arg))\n        return function(*new_args, **kw)\n    return wrapper\n</code></pre>\n<p>Now let's redefine our function using this decorator:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">@sanify\ndef foo(a=[]):\n    a.append(5)\n    return a\n\nfoo() # '[5]'\nfoo() # '[5]' -- as desired\n</code></pre>\n<p>This is particularly neat for functions that take multiple arguments. Compare:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># the 'correct' approach\ndef bar(a=None, b=None, c=None):\n    if a is None:\n        a = []\n    if b is None:\n        b = []\n    if c is None:\n        c = []\n    # finally do the actual work\n</code></pre>\n<p>with</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># the nasty decorator hack\n@sanify\ndef bar(a=[], b=[], c=[]):\n    # wow, works right out of the box!\n</code></pre>\n<p>It's important to note that the above solution breaks if you try to use keyword args, like so:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">foo(a=[4])\n</code></pre>\n<p>The decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)</p>\n", "abstract": "Every other answer explains why this is actually a nice and desired behavior, or why you shouldn't be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around. We will \"fix\" this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value. Now let's redefine our function using this decorator: This is particularly neat for functions that take multiple arguments. Compare: with It's important to note that the above solution breaks if you try to use keyword args, like so: The decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)"}, {"id": 17782210, "score": 9, "vote": 0, "content": "<p>This \"bug\" gave me a lot of overtime work hours! But I'm beginning to see a potential use of it (but I would have liked it to be at the execution time, still)</p>\n<p>I'm gonna give you what I see as a useful example.</p>\n<pre><code class=\"python\">def example(errors=[]):\n    # statements\n    # Something went wrong\n    mistake = True\n    if mistake:\n        tryToFixIt(errors)\n        # Didn't work.. let's try again\n        tryToFixItAnotherway(errors)\n        # This time it worked\n    return errors\n\ndef tryToFixIt(err):\n    err.append('Attempt to fix it')\n\ndef tryToFixItAnotherway(err):\n    err.append('Attempt to fix it by another way')\n\ndef main():\n    for item in range(2):\n        errors = example()\n    print '\\n'.join(errors)\n\nmain()\n</code></pre>\n<p>prints the following</p>\n<pre><code class=\"python\">Attempt to fix it\nAttempt to fix it by another way\nAttempt to fix it\nAttempt to fix it by another way\n</code></pre>\n", "abstract": "This \"bug\" gave me a lot of overtime work hours! But I'm beginning to see a potential use of it (but I would have liked it to be at the execution time, still) I'm gonna give you what I see as a useful example. prints the following"}, {"id": 46796007, "score": 8, "vote": 0, "content": "<p><em>This is not a design flaw</em>. Anyone who trips over this is doing something wrong.</p>\n<p>There are 3 cases I see where you might run into this problem:</p>\n<ol>\n<li>You intend to modify the argument as a side effect of the function. In this case it <em>never makes sense</em> to have a default argument. The only exception is when you're abusing the argument list to have function attributes, e.g. <code>cache={}</code>, and you wouldn't be expected to call the function with an actual argument at all.</li>\n<li>You intend to leave the argument unmodified, but you accidentally <em>did</em> modify it. That's a bug, fix it.</li>\n<li>You intend to modify the argument for use inside the function, but didn't expect the modification to be viewable outside of the function. In that case you need to make a <em>copy</em> of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn't make the copy for you, you need to be explicit about it.</li>\n</ol>\n<p>The example in the question could fall into category 1 or 3. It's odd that it both modifies the passed list and returns it; you should pick one or the other.</p>\n", "abstract": "This is not a design flaw. Anyone who trips over this is doing something wrong. There are 3 cases I see where you might run into this problem: The example in the question could fall into category 1 or 3. It's odd that it both modifies the passed list and returns it; you should pick one or the other."}, {"id": 30447095, "score": 7, "vote": 0, "content": "<p>Just change the function to be:</p>\n<pre><code class=\"python\">def notastonishinganymore(a = []): \n    '''The name is just a joke :)'''\n    a = a[:]\n    a.append(5)\n    return a\n</code></pre>\n", "abstract": "Just change the function to be:"}, {"id": 53792207, "score": 7, "vote": 0, "content": "<p>TLDR: Define-time defaults are consistent and strictly more expressive.</p>\n<hr/>\n<p>Defining a function affects two scopes: the defining scope <em>containing</em> the function, and the execution  scope <em>contained by</em> the function. While it is pretty clear how blocks map to scopes, the question is where <code>def &lt;name&gt;(&lt;args=defaults&gt;):</code> belongs to:</p>\n<pre><code class=\"python\">...                           # defining scope\ndef name(parameter=default):  # ???\n    ...                       # execution scope\n</code></pre>\n<p>The <code>def name</code> part <strong>must</strong> evaluate in the defining scope - we want <code>name</code> to be available there, after all. Evaluating the function only inside itself would make it inaccessible.</p>\n<p>Since <code>parameter</code> is a constant name, we can \"evaluate\" it at the same time as <code>def name</code>. This also has the advantage it produces the function with a known signature as <code>name(parameter=...):</code>, instead of a bare <code>name(...):</code>.</p>\n<p>Now, when to evaluate <code>default</code>?</p>\n<p>Consistency already says \"at definition\": everything else of <code>def &lt;name&gt;(&lt;args=defaults&gt;):</code> is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.</p>\n<p>The two choices are not equivalent, either: If <code>default</code> is evaluated at definition time, it <em>can still</em> affect execution time. If <code>default</code> is evaluated at execution time, it <em>cannot</em> affect definition time. Choosing \"at definition\" allows expressing both cases, while choosing \"at execution\" can express only one:</p>\n<pre><code class=\"python\">def name(parameter=defined):  # set default at definition time\n    ...\n\ndef name(parameter=default):     # delay default until execution time\n    parameter = default if parameter is None else parameter\n    ...\n</code></pre>\n", "abstract": "TLDR: Define-time defaults are consistent and strictly more expressive. Defining a function affects two scopes: the defining scope containing the function, and the execution  scope contained by the function. While it is pretty clear how blocks map to scopes, the question is where def <name>(<args=defaults>): belongs to: The def name part must evaluate in the defining scope - we want name to be available there, after all. Evaluating the function only inside itself would make it inaccessible. Since parameter is a constant name, we can \"evaluate\" it at the same time as def name. This also has the advantage it produces the function with a known signature as name(parameter=...):, instead of a bare name(...):. Now, when to evaluate default? Consistency already says \"at definition\": everything else of def <name>(<args=defaults>): is best evaluated at definition as well. Delaying parts of it would be the astonishing choice. The two choices are not equivalent, either: If default is evaluated at definition time, it can still affect execution time. If default is evaluated at execution time, it cannot affect definition time. Choosing \"at definition\" allows expressing both cases, while choosing \"at execution\" can express only one:"}, {"id": 18372696, "score": 6, "vote": 0, "content": "<p>I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the \"def\" statement.</p>\n<p>A brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.</p>\n<p>Admitting the above two points, let's explain what happened to the python code. It's only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that \"def\" statement is executed only once when it is defined.</p>\n<p>[] is an object, so python pass the reference of [] to <code>a</code>, i.e., <code>a</code> is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to <a href=\"http://effbot.org/zone/default-values.htm\" rel=\"noreferrer\">1</a> by append method. But Note that there is only one copy of the list object and this object now becomes <a href=\"http://effbot.org/zone/default-values.htm\" rel=\"noreferrer\">1</a>. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. <code>a</code> is evaluated to be the list object, although now the content of the object is <a href=\"http://effbot.org/zone/default-values.htm\" rel=\"noreferrer\">1</a>. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.</p>\n<p>To further validate my answer, let's take a look at two additional codes.</p>\n<p>====== No. 2 ========</p>\n<pre><code class=\"python\">def foo(x, items=None):\n    if items is None:\n        items = []\n    items.append(x)\n    return items\n\nfoo(1)  #return [1]\nfoo(2)  #return [2]\nfoo(3)  #return [3]\n</code></pre>\n<p><code>[]</code> is an object, so is <code>None</code> (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it's there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address. </p>\n<p>====== No. 3 =======</p>\n<pre><code class=\"python\">def foo(x, items=[]):\n    items.append(x)\n    return items\n\nfoo(1)    # returns [1]\nfoo(2,[]) # returns [2]\nfoo(3)    # returns [1,3]\n</code></pre>\n<p>The invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to <a href=\"http://effbot.org/zone/default-values.htm\" rel=\"noreferrer\">1</a> in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, <code>items</code> has to take the address of this new <code>[]</code>, say 2222222, and return it after making some change. Now foo(3) is executed. since only <code>x</code> is provided, items has to take its default value again. What's the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make <code>items</code> [1,3]. </p>\n<p>From the above explanations, we can see that the <a href=\"http://effbot.org/zone/default-values.htm\" rel=\"noreferrer\">effbot</a> webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:</p>\n<pre><code class=\"python\">for i in range(10):\n    def callback():\n        print \"clicked button\", i\n    UI.Button(\"button %s\" % i, callback)\n</code></pre>\n<p>Each button can hold a distinct callback function which will display different value of <code>i</code>. I can provide an example to show this:</p>\n<pre><code class=\"python\">x=[]\nfor i in range(10):\n    def callback():\n        print(i)\n    x.append(callback) \n</code></pre>\n<p>If we execute <code>x[7]()</code> we'll get 7 as expected, and <code>x[9]()</code> will gives 9, another value of <code>i</code>.</p>\n", "abstract": "I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the \"def\" statement. A brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object. Admitting the above two points, let's explain what happened to the python code. It's only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that \"def\" statement is executed only once when it is defined. [] is an object, so python pass the reference of [] to a, i.e., a is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to 1 by append method. But Note that there is only one copy of the list object and this object now becomes 1. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. a is evaluated to be the list object, although now the content of the object is 1. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way. To further validate my answer, let's take a look at two additional codes. ====== No. 2 ======== [] is an object, so is None (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it's there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address.  ====== No. 3 ======= The invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to 1 in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, items has to take the address of this new [], say 2222222, and return it after making some change. Now foo(3) is executed. since only x is provided, items has to take its default value again. What's the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make items [1,3].  From the above explanations, we can see that the effbot webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct: Each button can hold a distinct callback function which will display different value of i. I can provide an example to show this: If we execute x[7]() we'll get 7 as expected, and x[9]() will gives 9, another value of i."}, {"id": 71674471, "score": 3, "vote": 0, "content": "<h3>Yes, this is  a design flaw in Python</h3>\n<p>I've read all the other answers and I'm not convinced. This design does violate the principle of least astonishment.</p>\n<p>The defaults could have been designed to be evaluated when the function is called, rather than when the function is defined. This is how Javascript does it:</p>\n<p><div class=\"snippet\" data-babel=\"false\" data-console=\"true\" data-hide=\"false\" data-lang=\"js\">\n<div class=\"snippet-code\">\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code class=\"python\">function foo(a=[]) {\n  a.push(5);\n  return a;\n}\nconsole.log(foo()); // [5]\nconsole.log(foo()); // [5]\nconsole.log(foo()); // [5]</code></pre>\n</div>\n</div>\n</p>\n<p>As further evidence that this is a design flaw, Python core developers are currently discussing introducing new syntax to fix this problem. See this article: <a href=\"https://lwn.net/Articles/875441/\" rel=\"noreferrer\">Late-bound argument defaults for Python</a>.</p>\n<p>For even more evidence that this a design flaw, if you Google \"Python gotchas\", this design is mentioned as a gotcha, usually the first gotcha in the list, in the first 9 Google results (<a href=\"https://docs.python-guide.org/writing/gotchas/\" rel=\"noreferrer\">1</a>, <a href=\"https://inventwithpython.com/beyond/chapter8.html\" rel=\"noreferrer\">2</a>, <a href=\"https://towardsdatascience.com/five-python-gotchas-3073145fe083\" rel=\"noreferrer\">3</a>, <a href=\"https://www.geeksforgeeks.org/gotchas-in-python/\" rel=\"noreferrer\">4</a>, <a href=\"https://8thlight.com/blog/shibani-mookerjee/2019/05/07/some-common-gotchas-in-python.html\" rel=\"noreferrer\">5</a>, <a href=\"https://miguendes.me/python-gotchas\" rel=\"noreferrer\">6</a>, <a href=\"https://medium.com/codex/python-beginner-gotchas-af16f26325dd\" rel=\"noreferrer\">7</a>, <a href=\"https://www.reddit.com/r/learnpython/comments/2xwc6s/python_gotchas/\" rel=\"noreferrer\">8</a>, <a href=\"https://www.toptal.com/python/top-10-mistakes-that-python-programmers-make\" rel=\"noreferrer\">9</a>). In contrast, if you Google \"Javascript gotchas\", the behaviour of default arguments in Javascript is not mentioned as a gotcha even once.</p>\n<p>Gotchas, by definition, violate the principle of least astonishment. They astonish. Given there are superiour designs for the behaviour of default argument values, the inescapable conclusion is that Python's behaviour here represents a design flaw.</p>\n", "abstract": "I've read all the other answers and I'm not convinced. This design does violate the principle of least astonishment. The defaults could have been designed to be evaluated when the function is called, rather than when the function is defined. This is how Javascript does it: \n\nfunction foo(a=[]) {\n  a.push(5);\n  return a;\n}\nconsole.log(foo()); // [5]\nconsole.log(foo()); // [5]\nconsole.log(foo()); // [5]\n\n\n As further evidence that this is a design flaw, Python core developers are currently discussing introducing new syntax to fix this problem. See this article: Late-bound argument defaults for Python. For even more evidence that this a design flaw, if you Google \"Python gotchas\", this design is mentioned as a gotcha, usually the first gotcha in the list, in the first 9 Google results (1, 2, 3, 4, 5, 6, 7, 8, 9). In contrast, if you Google \"Javascript gotchas\", the behaviour of default arguments in Javascript is not mentioned as a gotcha even once. Gotchas, by definition, violate the principle of least astonishment. They astonish. Given there are superiour designs for the behaviour of default argument values, the inescapable conclusion is that Python's behaviour here represents a design flaw."}, {"id": 59638236, "score": -3, "vote": 0, "content": "<p>There is a simple way to understand why this happens.</p>\n<p><strong>Python executes code, from top to bottom, in a namespace.</strong></p>\n<p>The 'internals' just embody of this rule.   </p>\n<p>The reason for this choice is to \"let the language fit in your head\".  All the odd corner cases tend to simplify to executing code in a namespace:  default immutables, nested functions, classes (with a little patch-up when done compiling), the self argument, etc.  Similarly, complex syntax could be written in simple syntax:  <code>a.foo(...)</code> is just <code>a.lookup('foo').__call__(a,...)</code>.  This works with list comprehensions; decorators; metaclasses; and more.  This gives you a near perfect  view of the strange corners.  The language fits in your head.</p>\n<p>You should keep at it.  Learning Python has a period of railing at the language, but it gets comfortable.  It's the only language I've worked in that gets simpler the more you look at corner cases. </p>\n<p>Keep Hacking!  Keep notes.</p>\n<p>For your specific code, in too much detail:</p>\n<pre><code class=\"python\">def foo(a=[]):\n    a.append(5)\n    return a\n\nfoo()\n</code></pre>\n<p>is one statement, equivalent to:</p>\n<ol>\n<li>Start making a code object.</li>\n<li>Interpreting <code>(a=[])</code> right now, as we go.  The <code>[]</code> is the default value of argument a.  It is of type list, as <code>[]</code> always is.</li>\n<li>Compile all the code after the <code>:</code> into Python bytecode and stick it in another list.</li>\n<li>Create the callable dictionary, with the arguments and code in the '<strong>code</strong>' field</li>\n<li>Add the callable to the current namespace in the 'foo' field.</li>\n</ol>\n<p>Then, it goes to the next line, <code>foo()</code>.</p>\n<ol>\n<li>It's not a reserved word, so <a href=\"https://stackoverflow.com/questions/291978/short-description-of-the-scoping-rules\">look it up in the namespace</a>.  </li>\n<li>Call the function, which will use the list as the default argument. Start executing its bytecode in its namespace. </li>\n<li><code>append</code> does not create a new list, so the old one is modified.</li>\n</ol>\n", "abstract": "There is a simple way to understand why this happens. Python executes code, from top to bottom, in a namespace. The 'internals' just embody of this rule.    The reason for this choice is to \"let the language fit in your head\".  All the odd corner cases tend to simplify to executing code in a namespace:  default immutables, nested functions, classes (with a little patch-up when done compiling), the self argument, etc.  Similarly, complex syntax could be written in simple syntax:  a.foo(...) is just a.lookup('foo').__call__(a,...).  This works with list comprehensions; decorators; metaclasses; and more.  This gives you a near perfect  view of the strange corners.  The language fits in your head. You should keep at it.  Learning Python has a period of railing at the language, but it gets comfortable.  It's the only language I've worked in that gets simpler the more you look at corner cases.  Keep Hacking!  Keep notes. For your specific code, in too much detail: is one statement, equivalent to: Then, it goes to the next line, foo()."}]}, {"link": "https://stackoverflow.com/questions/17071871/how-do-i-select-rows-from-a-dataframe-based-on-column-values", "question": {"id": "17071871", "title": "How do I select rows from a DataFrame based on column values?", "content": "<p>How can I select rows from a DataFrame based on values in some column in Pandas?</p>\n<p>In SQL, I would use:</p>\n<pre class=\"lang-sql prettyprint-override\"><code class=\"python\">SELECT *\nFROM table\nWHERE column_name = some_value\n</code></pre>\n", "abstract": "How can I select rows from a DataFrame based on values in some column in Pandas? In SQL, I would use:"}, "answers": [{"id": 17071908, "score": 5879, "vote": 0, "content": "<p>To select rows whose column value equals a scalar, <code>some_value</code>, use <code>==</code>:</p>\n<pre><code class=\"python\">df.loc[df['column_name'] == some_value]\n</code></pre>\n<p>To select rows whose column value is in an iterable, <code>some_values</code>, use <code>isin</code>:</p>\n<pre><code class=\"python\">df.loc[df['column_name'].isin(some_values)]\n</code></pre>\n<p>Combine multiple conditions with <code>&amp;</code>: </p>\n<pre><code class=\"python\">df.loc[(df['column_name'] &gt;= A) &amp; (df['column_name'] &lt;= B)]\n</code></pre>\n<p>Note the parentheses. Due to Python's <a href=\"https://docs.python.org/3/reference/expressions.html#operator-precedence\" rel=\"noreferrer\">operator precedence rules</a>, <code>&amp;</code> binds more tightly than <code>&lt;=</code> and <code>&gt;=</code>. Thus, the parentheses in the last example are necessary. Without the parentheses </p>\n<pre><code class=\"python\">df['column_name'] &gt;= A &amp; df['column_name'] &lt;= B\n</code></pre>\n<p>is parsed as </p>\n<pre><code class=\"python\">df['column_name'] &gt;= (A &amp; df['column_name']) &lt;= B\n</code></pre>\n<p>which results in a <a href=\"https://stackoverflow.com/questions/36921951/truth-value-of-a-series-is-ambiguous-use-a-empty-a-bool-a-item-a-any-o\">Truth value of a Series is ambiguous error</a>.</p>\n<hr/>\n<p>To select rows whose column value <em>does not equal</em> <code>some_value</code>, use <code>!=</code>:</p>\n<pre><code class=\"python\">df.loc[df['column_name'] != some_value]\n</code></pre>\n<p><code>isin</code> returns a boolean Series, so to select rows whose value is <em>not</em> in <code>some_values</code>, negate the boolean Series using <code>~</code>:</p>\n<pre><code class=\"python\">df.loc[~df['column_name'].isin(some_values)]\n</code></pre>\n<hr/>\n<p>For example,</p>\n<pre><code class=\"python\">import pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),\n                   'B': 'one one two three two two one three'.split(),\n                   'C': np.arange(8), 'D': np.arange(8) * 2})\nprint(df)\n#      A      B  C   D\n# 0  foo    one  0   0\n# 1  bar    one  1   2\n# 2  foo    two  2   4\n# 3  bar  three  3   6\n# 4  foo    two  4   8\n# 5  bar    two  5  10\n# 6  foo    one  6  12\n# 7  foo  three  7  14\n\nprint(df.loc[df['A'] == 'foo'])\n</code></pre>\n<p>yields</p>\n<pre><code class=\"python\">     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<hr/>\n<p>If you have multiple values you want to include, put them in a\nlist (or more generally, any iterable) and use <code>isin</code>:</p>\n<pre><code class=\"python\">print(df.loc[df['B'].isin(['one','three'])])\n</code></pre>\n<p>yields</p>\n<pre><code class=\"python\">     A      B  C   D\n0  foo    one  0   0\n1  bar    one  1   2\n3  bar  three  3   6\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<hr/>\n<p>Note, however, that if you wish to do this many times, it is more efficient to\nmake an index first, and then use <code>df.loc</code>:</p>\n<pre><code class=\"python\">df = df.set_index(['B'])\nprint(df.loc['one'])\n</code></pre>\n<p>yields</p>\n<pre><code class=\"python\">       A  C   D\nB              \none  foo  0   0\none  bar  1   2\none  foo  6  12\n</code></pre>\n<p>or, to include multiple values from the index use <code>df.index.isin</code>:</p>\n<pre><code class=\"python\">df.loc[df.index.isin(['one','two'])]\n</code></pre>\n<p>yields</p>\n<pre><code class=\"python\">       A  C   D\nB              \none  foo  0   0\none  bar  1   2\ntwo  foo  2   4\ntwo  foo  4   8\ntwo  bar  5  10\none  foo  6  12\n</code></pre>\n", "abstract": "To select rows whose column value equals a scalar, some_value, use ==: To select rows whose column value is in an iterable, some_values, use isin: Combine multiple conditions with &:  Note the parentheses. Due to Python's operator precedence rules, & binds more tightly than <= and >=. Thus, the parentheses in the last example are necessary. Without the parentheses  is parsed as  which results in a Truth value of a Series is ambiguous error. To select rows whose column value does not equal some_value, use !=: isin returns a boolean Series, so to select rows whose value is not in some_values, negate the boolean Series using ~: For example, yields If you have multiple values you want to include, put them in a\nlist (or more generally, any iterable) and use isin: yields Note, however, that if you wish to do this many times, it is more efficient to\nmake an index first, and then use df.loc: yields or, to include multiple values from the index use df.index.isin: yields"}, {"id": 46165056, "score": 704, "vote": 0, "content": "<p>There are several ways to select rows from a Pandas dataframe:</p>\n<ol>\n<li><strong>Boolean indexing (<code>df[df['col'] == value</code>] )</strong></li>\n<li><strong>Positional indexing (<code>df.iloc[...]</code>)</strong></li>\n<li><strong>Label indexing (<code>df.xs(...)</code>)</strong></li>\n<li><strong><code>df.query(...)</code> API</strong></li>\n</ol>\n<p>Below I show you examples of each, with advice when to use certain techniques. Assume our criterion is column <code>'A'</code> == <code>'foo'</code></p>\n<p>(Note on performance: For each base type, we can keep things simple by using the Pandas API or we can venture outside the API, usually into NumPy, and speed things up.)</p>\n<hr/>\n<p><strong>Setup</strong></p>\n<p>The first thing we'll need is to identify a condition that will act as our criterion for selecting rows. We'll start with the OP's case <code>column_name == some_value</code>, and include some other common use cases.</p>\n<p>Borrowing from @unutbu:</p>\n<pre><code class=\"python\">import pandas as pd, numpy as np\n\ndf = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),\n                   'B': 'one one two three two two one three'.split(),\n                   'C': np.arange(8), 'D': np.arange(8) * 2})\n</code></pre>\n<hr/>\n<h1><strong>1. Boolean indexing</strong></h1>\n<p>... Boolean indexing requires finding the true value of each row's <code>'A'</code> column being equal to <code>'foo'</code>, then using those truth values to identify which rows to keep.  Typically, we'd name this series, an array of truth values, <code>mask</code>.  We'll do so here as well.</p>\n<pre><code class=\"python\">mask = df['A'] == 'foo'\n</code></pre>\n<p>We can then use this mask to slice or index the data frame</p>\n<pre><code class=\"python\">df[mask]\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<p>This is one of the simplest ways to accomplish this task and if performance or intuitiveness isn't an issue, this should be your chosen method.  However, if performance is a concern, then you might want to consider an alternative way of creating the <code>mask</code>.</p>\n<hr/>\n<h1><strong>2. Positional indexing</strong></h1>\n<p>Positional indexing (<code>df.iloc[...]</code>) has its use cases, but this isn't one of them.  In order to identify where to slice, we first need to perform the same boolean analysis we did above.  This leaves us performing one extra step to accomplish the same task.</p>\n<pre><code class=\"python\">mask = df['A'] == 'foo'\npos = np.flatnonzero(mask)\ndf.iloc[pos]\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<h1><strong>3. Label indexing</strong></h1>\n<p><em>Label</em> indexing can be very handy, but in this case, we are again doing more work for no benefit</p>\n<pre><code class=\"python\">df.set_index('A', append=True, drop=False).xs('foo', level=1)\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<h1><strong>4. <code>df.query()</code> API</strong></h1>\n<p><em><code>pd.DataFrame.query</code></em> is a very elegant/intuitive way to perform this task, but is often slower. <strong>However</strong>, if you pay attention to the timings below, for large data, the query is very efficient. More so than the standard approach and of similar magnitude as my best suggestion.</p>\n<pre><code class=\"python\">df.query('A == \"foo\"')\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<hr/>\n<p>My preference is to use the <code>Boolean</code> <code>mask</code></p>\n<p>Actual improvements can be made by modifying how we create our <code>Boolean</code> <code>mask</code>.</p>\n<p><strong><code>mask</code> alternative 1</strong>\n<em>Use the underlying NumPy array and forgo the overhead of creating another <code>pd.Series</code></em></p>\n<pre><code class=\"python\">mask = df['A'].values == 'foo'\n</code></pre>\n<p>I'll show more complete time tests at the end, but just take a look at the performance gains we get using the sample data frame.  First, we look at the difference in creating the <code>mask</code></p>\n<pre><code class=\"python\">%timeit mask = df['A'].values == 'foo'\n%timeit mask = df['A'] == 'foo'\n\n5.84 \u00b5s \u00b1 195 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n166 \u00b5s \u00b1 4.45 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n</code></pre>\n<p>Evaluating the <code>mask</code> with the NumPy array is ~ 30 times faster.  This is partly due to NumPy evaluation often being faster. It is also partly due to the lack of overhead necessary to build an index and a corresponding <code>pd.Series</code> object.</p>\n<p>Next, we'll look at the timing for slicing with one <code>mask</code> versus the other.</p>\n<pre><code class=\"python\">mask = df['A'].values == 'foo'\n%timeit df[mask]\nmask = df['A'] == 'foo'\n%timeit df[mask]\n\n219 \u00b5s \u00b1 12.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n239 \u00b5s \u00b1 7.03 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n</code></pre>\n<p>The performance gains aren't as pronounced.  We'll see if this holds up over more robust testing.</p>\n<hr/>\n<p><strong><code>mask</code> alternative 2</strong>\nWe could have reconstructed the data frame as well.  There is a big caveat when reconstructing a dataframe\u2014you must take care of the <code>dtypes</code> when doing so!</p>\n<p>Instead of <code>df[mask]</code> we will do this</p>\n<pre><code class=\"python\">pd.DataFrame(df.values[mask], df.index[mask], df.columns).astype(df.dtypes)\n</code></pre>\n<p>If the data frame is of mixed type, which our example is, then when we get <code>df.values</code> the resulting array is of <code>dtype</code> <code>object</code> and consequently, all columns of the new data frame will be of <code>dtype</code> <code>object</code>.  Thus requiring the <code>astype(df.dtypes)</code> and killing any potential performance gains.</p>\n<pre><code class=\"python\">%timeit df[m]\n%timeit pd.DataFrame(df.values[mask], df.index[mask], df.columns).astype(df.dtypes)\n\n216 \u00b5s \u00b1 10.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n1.43 ms \u00b1 39.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n</code></pre>\n<p>However, if the data frame is not of mixed type, this is a very useful way to do it.</p>\n<p>Given</p>\n<pre><code class=\"python\">np.random.seed([3,1415])\nd1 = pd.DataFrame(np.random.randint(10, size=(10, 5)), columns=list('ABCDE'))\n\nd1\n\n   A  B  C  D  E\n0  0  2  7  3  8\n1  7  0  6  8  6\n2  0  2  0  4  9\n3  7  3  2  4  3\n4  3  6  7  7  4\n5  5  3  7  5  9\n6  8  7  6  4  7\n7  6  2  6  6  5\n8  2  8  7  5  8\n9  4  7  6  1  5\n</code></pre>\n<hr/>\n<pre><code class=\"python\">%%timeit\nmask = d1['A'].values == 7\nd1[mask]\n\n179 \u00b5s \u00b1 8.73 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n</code></pre>\n<p>Versus</p>\n<pre><code class=\"python\">%%timeit\nmask = d1['A'].values == 7\npd.DataFrame(d1.values[mask], d1.index[mask], d1.columns)\n\n87 \u00b5s \u00b1 5.12 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n</code></pre>\n<p>We cut the time in half.</p>\n<hr/>\n<p><strong><code>mask</code> alternative 3</strong></p>\n<p>@unutbu also shows us how to use <code>pd.Series.isin</code> to account for each element of <code>df['A']</code> being in a set of values.  This evaluates to the same thing if our set of values is a set of one value, namely <code>'foo'</code>.  But it also generalizes to include larger sets of values if needed.  Turns out, this is still pretty fast even though it is a more general solution.  The only real loss is in intuitiveness for those not familiar with the concept.</p>\n<pre><code class=\"python\">mask = df['A'].isin(['foo'])\ndf[mask]\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<p>However, as before, we can utilize NumPy to improve performance while sacrificing virtually nothing. We'll use <code>np.in1d</code></p>\n<pre><code class=\"python\">mask = np.in1d(df['A'].values, ['foo'])\ndf[mask]\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<hr/>\n<p><strong>Timing</strong></p>\n<p>I'll include other concepts mentioned in other posts as well for reference.</p>\n<p><em>Code Below</em></p>\n<p>Each <em>column</em> in this table represents a different length data frame over which we test each function. Each column shows relative time taken, with the fastest function given a base index of <code>1.0</code>.</p>\n<pre><code class=\"python\">res.div(res.min())\n\n                         10        30        100       300       1000      3000      10000     30000\nmask_standard         2.156872  1.850663  2.034149  2.166312  2.164541  3.090372  2.981326  3.131151\nmask_standard_loc     1.879035  1.782366  1.988823  2.338112  2.361391  3.036131  2.998112  2.990103\nmask_with_values      1.010166  1.000000  1.005113  1.026363  1.028698  1.293741  1.007824  1.016919\nmask_with_values_loc  1.196843  1.300228  1.000000  1.000000  1.038989  1.219233  1.037020  1.000000\nquery                 4.997304  4.765554  5.934096  4.500559  2.997924  2.397013  1.680447  1.398190\nxs_label              4.124597  4.272363  5.596152  4.295331  4.676591  5.710680  6.032809  8.950255\nmask_with_isin        1.674055  1.679935  1.847972  1.724183  1.345111  1.405231  1.253554  1.264760\nmask_with_in1d        1.000000  1.083807  1.220493  1.101929  1.000000  1.000000  1.000000  1.144175\n</code></pre>\n<p>You'll notice that the fastest times seem to be shared between <code>mask_with_values</code> and <code>mask_with_in1d</code>.</p>\n<pre><code class=\"python\">res.T.plot(loglog=True)\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/ljeTd.png\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/ljeTd.png\"/></a></p>\n<p><strong>Functions</strong></p>\n<pre><code class=\"python\">def mask_standard(df):\n    mask = df['A'] == 'foo'\n    return df[mask]\n\ndef mask_standard_loc(df):\n    mask = df['A'] == 'foo'\n    return df.loc[mask]\n\ndef mask_with_values(df):\n    mask = df['A'].values == 'foo'\n    return df[mask]\n\ndef mask_with_values_loc(df):\n    mask = df['A'].values == 'foo'\n    return df.loc[mask]\n\ndef query(df):\n    return df.query('A == \"foo\"')\n\ndef xs_label(df):\n    return df.set_index('A', append=True, drop=False).xs('foo', level=-1)\n\ndef mask_with_isin(df):\n    mask = df['A'].isin(['foo'])\n    return df[mask]\n\ndef mask_with_in1d(df):\n    mask = np.in1d(df['A'].values, ['foo'])\n    return df[mask]\n</code></pre>\n<hr/>\n<p><strong>Testing</strong></p>\n<pre><code class=\"python\">res = pd.DataFrame(\n    index=[\n        'mask_standard', 'mask_standard_loc', 'mask_with_values', 'mask_with_values_loc',\n        'query', 'xs_label', 'mask_with_isin', 'mask_with_in1d'\n    ],\n    columns=[10, 30, 100, 300, 1000, 3000, 10000, 30000],\n    dtype=float\n)\n\nfor j in res.columns:\n    d = pd.concat([df] * j, ignore_index=True)\n    for i in res.index:a\n        stmt = '{}(d)'.format(i)\n        setp = 'from __main__ import d, {}'.format(i)\n        res.at[i, j] = timeit(stmt, setp, number=50)\n</code></pre>\n<hr/>\n<p><strong>Special Timing</strong></p>\n<p>Looking at the special case when we have a single non-object <code>dtype</code> for the entire data frame.</p>\n<p><em>Code Below</em></p>\n<pre><code class=\"python\">spec.div(spec.min())\n\n                     10        30        100       300       1000      3000      10000     30000\nmask_with_values  1.009030  1.000000  1.194276  1.000000  1.236892  1.095343  1.000000  1.000000\nmask_with_in1d    1.104638  1.094524  1.156930  1.072094  1.000000  1.000000  1.040043  1.027100\nreconstruct       1.000000  1.142838  1.000000  1.355440  1.650270  2.222181  2.294913  3.406735\n</code></pre>\n<p>Turns out, reconstruction isn't worth it past a few hundred rows.</p>\n<pre><code class=\"python\">spec.T.plot(loglog=True)\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/K1bNc.png\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/K1bNc.png\"/></a></p>\n<p><strong>Functions</strong></p>\n<pre><code class=\"python\">np.random.seed([3,1415])\nd1 = pd.DataFrame(np.random.randint(10, size=(10, 5)), columns=list('ABCDE'))\n\ndef mask_with_values(df):\n    mask = df['A'].values == 'foo'\n    return df[mask]\n\ndef mask_with_in1d(df):\n    mask = np.in1d(df['A'].values, ['foo'])\n    return df[mask]\n\ndef reconstruct(df):\n    v = df.values\n    mask = np.in1d(df['A'].values, ['foo'])\n    return pd.DataFrame(v[mask], df.index[mask], df.columns)\n\nspec = pd.DataFrame(\n    index=['mask_with_values', 'mask_with_in1d', 'reconstruct'],\n    columns=[10, 30, 100, 300, 1000, 3000, 10000, 30000],\n    dtype=float\n)\n</code></pre>\n<p><strong>Testing</strong></p>\n<pre><code class=\"python\">for j in spec.columns:\n    d = pd.concat([df] * j, ignore_index=True)\n    for i in spec.index:\n        stmt = '{}(d)'.format(i)\n        setp = 'from __main__ import d, {}'.format(i)\n        spec.at[i, j] = timeit(stmt, setp, number=50)\n</code></pre>\n", "abstract": "There are several ways to select rows from a Pandas dataframe: Below I show you examples of each, with advice when to use certain techniques. Assume our criterion is column 'A' == 'foo' (Note on performance: For each base type, we can keep things simple by using the Pandas API or we can venture outside the API, usually into NumPy, and speed things up.) Setup The first thing we'll need is to identify a condition that will act as our criterion for selecting rows. We'll start with the OP's case column_name == some_value, and include some other common use cases. Borrowing from @unutbu: ... Boolean indexing requires finding the true value of each row's 'A' column being equal to 'foo', then using those truth values to identify which rows to keep.  Typically, we'd name this series, an array of truth values, mask.  We'll do so here as well. We can then use this mask to slice or index the data frame This is one of the simplest ways to accomplish this task and if performance or intuitiveness isn't an issue, this should be your chosen method.  However, if performance is a concern, then you might want to consider an alternative way of creating the mask. Positional indexing (df.iloc[...]) has its use cases, but this isn't one of them.  In order to identify where to slice, we first need to perform the same boolean analysis we did above.  This leaves us performing one extra step to accomplish the same task. Label indexing can be very handy, but in this case, we are again doing more work for no benefit pd.DataFrame.query is a very elegant/intuitive way to perform this task, but is often slower. However, if you pay attention to the timings below, for large data, the query is very efficient. More so than the standard approach and of similar magnitude as my best suggestion. My preference is to use the Boolean mask Actual improvements can be made by modifying how we create our Boolean mask. mask alternative 1\nUse the underlying NumPy array and forgo the overhead of creating another pd.Series I'll show more complete time tests at the end, but just take a look at the performance gains we get using the sample data frame.  First, we look at the difference in creating the mask Evaluating the mask with the NumPy array is ~ 30 times faster.  This is partly due to NumPy evaluation often being faster. It is also partly due to the lack of overhead necessary to build an index and a corresponding pd.Series object. Next, we'll look at the timing for slicing with one mask versus the other. The performance gains aren't as pronounced.  We'll see if this holds up over more robust testing. mask alternative 2\nWe could have reconstructed the data frame as well.  There is a big caveat when reconstructing a dataframe\u2014you must take care of the dtypes when doing so! Instead of df[mask] we will do this If the data frame is of mixed type, which our example is, then when we get df.values the resulting array is of dtype object and consequently, all columns of the new data frame will be of dtype object.  Thus requiring the astype(df.dtypes) and killing any potential performance gains. However, if the data frame is not of mixed type, this is a very useful way to do it. Given Versus We cut the time in half. mask alternative 3 @unutbu also shows us how to use pd.Series.isin to account for each element of df['A'] being in a set of values.  This evaluates to the same thing if our set of values is a set of one value, namely 'foo'.  But it also generalizes to include larger sets of values if needed.  Turns out, this is still pretty fast even though it is a more general solution.  The only real loss is in intuitiveness for those not familiar with the concept. However, as before, we can utilize NumPy to improve performance while sacrificing virtually nothing. We'll use np.in1d Timing I'll include other concepts mentioned in other posts as well for reference. Code Below Each column in this table represents a different length data frame over which we test each function. Each column shows relative time taken, with the fastest function given a base index of 1.0. You'll notice that the fastest times seem to be shared between mask_with_values and mask_with_in1d.  Functions Testing Special Timing Looking at the special case when we have a single non-object dtype for the entire data frame. Code Below Turns out, reconstruction isn't worth it past a few hundred rows.  Functions Testing"}, {"id": 31296878, "score": 335, "vote": 0, "content": "<h3>tl;dr</h3>\n<p>The Pandas equivalent to</p>\n<pre><code class=\"python\">select * from table where column_name = some_value\n</code></pre>\n<p>is</p>\n<pre><code class=\"python\">table[table.column_name == some_value]\n</code></pre>\n<p>Multiple conditions:</p>\n<pre><code class=\"python\">table[(table.column_name == some_value) | (table.column_name2 == some_value2)]\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">table.query('column_name == some_value | column_name2 == some_value2')\n</code></pre>\n<h3>Code example</h3>\n<pre><code class=\"python\">import pandas as pd\n\n# Create data set\nd = {'foo':[100, 111, 222],\n     'bar':[333, 444, 555]}\ndf = pd.DataFrame(d)\n\n# Full dataframe:\ndf\n\n# Shows:\n#    bar   foo\n# 0  333   100\n# 1  444   111\n# 2  555   222\n\n# Output only the row(s) in df where foo is 222:\ndf[df.foo == 222]\n\n# Shows:\n#    bar  foo\n# 2  555  222\n</code></pre>\n<p>In the above code it is the line <code>df[df.foo == 222]</code> that gives the rows based on the column value, <code>222</code> in this case.</p>\n<p>Multiple conditions are also possible:</p>\n<pre><code class=\"python\">df[(df.foo == 222) | (df.bar == 444)]\n#    bar  foo\n# 1  444  111\n# 2  555  222\n</code></pre>\n<p>But at that point I would recommend using the <a href=\"https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.query.html\" rel=\"noreferrer\">query</a> function, since it's less verbose and yields the same result:</p>\n<pre><code class=\"python\">df.query('foo == 222 | bar == 444')\n</code></pre>\n", "abstract": "The Pandas equivalent to is Multiple conditions: or In the above code it is the line df[df.foo == 222] that gives the rows based on the column value, 222 in this case. Multiple conditions are also possible: But at that point I would recommend using the query function, since it's less verbose and yields the same result:"}, {"id": 35282530, "score": 85, "vote": 0, "content": "<p>I find the syntax of the previous answers to be redundant and difficult to remember. Pandas introduced the <code>query()</code> method in v0.13 and I much prefer it. For your question, you could do <code>df.query('col == val')</code>.</p>\n<p>Reproduced from <em><a href=\"http://pandas.pydata.org/pandas-docs/version/0.17.0/indexing.html#indexing-query\" rel=\"nofollow noreferrer\">The query() Method (Experimental)</a></em>:</p>\n<pre><code class=\"python\">In [167]: n = 10\n\nIn [168]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [169]: df\nOut[169]:\n          a         b         c\n0  0.687704  0.582314  0.281645\n1  0.250846  0.610021  0.420121\n2  0.624328  0.401816  0.932146\n3  0.011763  0.022921  0.244186\n4  0.590198  0.325680  0.890392\n5  0.598892  0.296424  0.007312\n6  0.634625  0.803069  0.123872\n7  0.924168  0.325076  0.303746\n8  0.116822  0.364564  0.454607\n9  0.986142  0.751953  0.561512\n\n# pure python\nIn [170]: df[(df.a &lt; df.b) &amp; (df.b &lt; df.c)]\nOut[170]:\n          a         b         c\n3  0.011763  0.022921  0.244186\n8  0.116822  0.364564  0.454607\n\n# query\nIn [171]: df.query('(a &lt; b) &amp; (b &lt; c)')\nOut[171]:\n          a         b         c\n3  0.011763  0.022921  0.244186\n8  0.116822  0.364564  0.454607\n</code></pre>\n<p>You can also access variables in the environment by prepending an <code>@</code>.</p>\n<pre><code class=\"python\">exclude = ('red', 'orange')\ndf.query('color not in @exclude')\n</code></pre>\n", "abstract": "I find the syntax of the previous answers to be redundant and difficult to remember. Pandas introduced the query() method in v0.13 and I much prefer it. For your question, you could do df.query('col == val'). Reproduced from The query() Method (Experimental): You can also access variables in the environment by prepending an @."}, {"id": 57338153, "score": 65, "vote": 0, "content": "<h3>More flexibility using <code>.query</code> with pandas &gt;= 0.25.0:</h3>\n<p>Since pandas &gt;= 0.25.0 we can use the <code>query</code> method to filter dataframes with pandas methods and even column names which have spaces. Normally the spaces in column names would give an error, but now we can solve that using a backtick (`) - see <a href=\"https://github.com/pandas-dev/pandas/issues/6508\" rel=\"noreferrer\">GitHub</a>:</p>\n<pre><code class=\"python\"># Example dataframe\ndf = pd.DataFrame({'Sender email':['ex@example.com', \"reply@shop.com\", \"buy@shop.com\"]})\n\n     Sender email\n0  ex@example.com\n1  reply@shop.com\n2    buy@shop.com\n</code></pre>\n<p>Using <code>.query</code> with method <code>str.endswith</code>:</p>\n<pre><code class=\"python\">df.query('`Sender email`.str.endswith(\"@shop.com\")')\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code class=\"python\">     Sender email\n1  reply@shop.com\n2    buy@shop.com\n</code></pre>\n<hr/>\n<p>Also we can use local variables by prefixing it with an <code>@</code> in our query:</p>\n<pre><code class=\"python\">domain = 'shop.com'\ndf.query('`Sender email`.str.endswith(@domain)')\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code class=\"python\">     Sender email\n1  reply@shop.com\n2    buy@shop.com\n</code></pre>\n", "abstract": "Since pandas >= 0.25.0 we can use the query method to filter dataframes with pandas methods and even column names which have spaces. Normally the spaces in column names would give an error, but now we can solve that using a backtick (`) - see GitHub: Using .query with method str.endswith: Output Also we can use local variables by prefixing it with an @ in our query: Output"}, {"id": 47693145, "score": 37, "vote": 0, "content": "<p>For selecting only specific columns out of multiple columns for a given value in Pandas:</p>\n<pre><code class=\"python\">select col_name1, col_name2 from table where column_name = some_value.\n</code></pre>\n<p>Options <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html\" rel=\"noreferrer\"><code>loc</code></a>:</p>\n<pre><code class=\"python\">df.loc[df['column_name'] == some_value, [col_name1, col_name2]]\n</code></pre>\n<p>or <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.query.html\" rel=\"noreferrer\"><code>query</code></a>:</p>\n<pre><code class=\"python\">df.query('column_name == some_value')[[col_name1, col_name2]]\n</code></pre>\n", "abstract": "For selecting only specific columns out of multiple columns for a given value in Pandas: Options loc: or query:"}, {"id": 65578196, "score": 33, "vote": 0, "content": "<p>In newer versions of Pandas, inspired by the documentation (<em><a href=\"https://pandas.pydata.org/docs/user_guide/10min.html#viewing-data\" rel=\"noreferrer\">Viewing data</a></em>):</p>\n<pre><code class=\"python\">df[df[\"colume_name\"] == some_value] #Scalar, True/False..\n\ndf[df[\"colume_name\"] == \"some_value\"] #String\n</code></pre>\n<p>Combine multiple conditions by putting the clause in parentheses, <code>()</code>, and combining them with <code>&amp;</code> and <code>|</code> (and/or). Like this:</p>\n<pre><code class=\"python\">df[(df[\"colume_name\"] == \"some_value1\") &amp; (pd[pd[\"colume_name\"] == \"some_value2\"])]\n</code></pre>\n<p>Other filters</p>\n<pre><code class=\"python\">pandas.notna(df[\"colume_name\"]) == True # Not NaN\ndf['colume_name'].str.contains(\"text\") # Search for \"text\"\ndf['colume_name'].str.lower().str.contains(\"text\") # Search for \"text\", after converting  to lowercase\n</code></pre>\n", "abstract": "In newer versions of Pandas, inspired by the documentation (Viewing data): Combine multiple conditions by putting the clause in parentheses, (), and combining them with & and | (and/or). Like this: Other filters"}, {"id": 44931669, "score": 31, "vote": 0, "content": "<p>Faster results can be achieved using <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html\" rel=\"noreferrer\">numpy.where</a>. </p>\n<p>For example, with <a href=\"https://stackoverflow.com/questions/17071871/select-rows-from-a-dataframe-based-on-values-in-a-column-in-pandas/17071908#17071908\">unubtu's setup</a> -</p>\n<pre><code class=\"python\">In [76]: df.iloc[np.where(df.A.values=='foo')]\nOut[76]: \n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<p>Timing comparisons:</p>\n<pre><code class=\"python\">In [68]: %timeit df.iloc[np.where(df.A.values=='foo')]  # fastest\n1000 loops, best of 3: 380 \u00b5s per loop\n\nIn [69]: %timeit df.loc[df['A'] == 'foo']\n1000 loops, best of 3: 745 \u00b5s per loop\n\nIn [71]: %timeit df.loc[df['A'].isin(['foo'])]\n1000 loops, best of 3: 562 \u00b5s per loop\n\nIn [72]: %timeit df[df.A=='foo']\n1000 loops, best of 3: 796 \u00b5s per loop\n\nIn [74]: %timeit df.query('(A==\"foo\")')  # slowest\n1000 loops, best of 3: 1.71 ms per loop\n</code></pre>\n", "abstract": "Faster results can be achieved using numpy.where.  For example, with unubtu's setup - Timing comparisons:"}, {"id": 17086321, "score": 29, "vote": 0, "content": "<p>Here is a simple example  </p>\n<pre><code class=\"python\">from pandas import DataFrame\n\n# Create data set\nd = {'Revenue':[100,111,222], \n     'Cost':[333,444,555]}\ndf = DataFrame(d)\n\n\n# mask = Return True when the value in column \"Revenue\" is equal to 111\nmask = df['Revenue'] == 111\n\nprint mask\n\n# Result:\n# 0    False\n# 1     True\n# 2    False\n# Name: Revenue, dtype: bool\n\n\n# Select * FROM df WHERE Revenue = 111\ndf[mask]\n\n# Result:\n#    Cost    Revenue\n# 1  444     111\n</code></pre>\n", "abstract": "Here is a simple example  "}, {"id": 40676816, "score": 19, "vote": 0, "content": "<p>To add: You can also do <code>df.groupby('column_name').get_group('column_desired_value').reset_index()</code> to make a new data frame with specified column having a particular value. E.g.,</p>\n<pre><code class=\"python\">import pandas as pd\ndf = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),\n                   'B': 'one one two three two two one three'.split()})\nprint(\"Original dataframe:\")\nprint(df)\n\nb_is_two_dataframe = pd.DataFrame(df.groupby('B').get_group('two').reset_index()).drop('index', axis = 1) \n#NOTE: the final drop is to remove the extra index column returned by groupby object\nprint('Sub dataframe where B is two:')\nprint(b_is_two_dataframe)\n</code></pre>\n<p>Running this gives:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">Original dataframe:\n     A      B\n0  foo    one\n1  bar    one\n2  foo    two\n3  bar  three\n4  foo    two\n5  bar    two\n6  foo    one\n7  foo  three\nSub dataframe where B is two:\n     A    B\n0  foo  two\n1  foo  two\n2  bar  two\n</code></pre>\n", "abstract": "To add: You can also do df.groupby('column_name').get_group('column_desired_value').reset_index() to make a new data frame with specified column having a particular value. E.g., Running this gives:"}, {"id": 53674430, "score": 11, "vote": 0, "content": "<p>You can also use .apply:</p>\n<pre><code class=\"python\">df.apply(lambda row: row[df['B'].isin(['one','three'])])\n</code></pre>\n<p>It actually works row-wise (i.e., applies the function to each row).</p>\n<p>The output is </p>\n<pre><code class=\"python\">   A      B  C   D\n0  foo    one  0   0\n1  bar    one  1   2\n3  bar  three  3   6\n6  foo    one  6  12\n7  foo  three  7  14\n</code></pre>\n<p>The results is the same as using as mentioned by @unutbu</p>\n<pre><code class=\"python\">df[[df['B'].isin(['one','three'])]]\n</code></pre>\n", "abstract": "You can also use .apply: It actually works row-wise (i.e., applies the function to each row). The output is  The results is the same as using as mentioned by @unutbu"}, {"id": 70120429, "score": 5, "vote": 0, "content": "<p>If you want to make query to your dataframe repeatedly and speed is important to you, the best thing is to convert your dataframe to dictionary and then by doing this you can make query thousands of times faster.</p>\n<pre><code class=\"python\">my_df = df.set_index(column_name)\nmy_dict = my_df.to_dict('index')\n</code></pre>\n<p>After make my_dict dictionary you can go through:</p>\n<pre><code class=\"python\">if some_value in my_dict.keys():\n   my_result = my_dict[some_value]\n</code></pre>\n<p>If you have duplicated values in column_name you can't make a dictionary. but you can use:</p>\n<pre><code class=\"python\">my_result = my_df.loc[some_value]\n</code></pre>\n", "abstract": "If you want to make query to your dataframe repeatedly and speed is important to you, the best thing is to convert your dataframe to dictionary and then by doing this you can make query thousands of times faster. After make my_dict dictionary you can go through: If you have duplicated values in column_name you can't make a dictionary. but you can use:"}, {"id": 71952267, "score": 3, "vote": 0, "content": "<h3>SQL statements on DataFrames to select rows using DuckDB</h3>\n<p>With <a href=\"https://duckdb.org/docs/guides/python/sql_on_pandas\" rel=\"nofollow noreferrer\">DuckDB</a> we can query pandas DataFrames with SQL statements, in a <a href=\"https://duckdb.org/2021/05/14/sql-on-pandas.html\" rel=\"nofollow noreferrer\">highly performant way</a>.</p>\n<p>Since the question is <em>How do I select rows from a DataFrame based on column values?</em>, and the example in the question is a SQL query, this answer looks logical in this topic.</p>\n<p><strong>Example</strong>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">In [1]: import duckdb\n\nIn [2]: import pandas as pd\n\nIn [3]: con = duckdb.connect()\n\nIn [4]: df = pd.DataFrame({\"A\": range(11), \"B\": range(11, 22)})\n\nIn [5]: df\nOut[5]:\n     A   B\n0    0  11\n1    1  12\n2    2  13\n3    3  14\n4    4  15\n5    5  16\n6    6  17\n7    7  18\n8    8  19\n9    9  20\n10  10  21\n\nIn [6]: results = con.execute(\"SELECT * FROM df where A &gt; 2\").df()\n\nIn [7]: results\nOut[7]:\n    A   B\n0   3  14\n1   4  15\n2   5  16\n3   6  17\n4   7  18\n5   8  19\n6   9  20\n7  10  21\n</code></pre>\n", "abstract": "With DuckDB we can query pandas DataFrames with SQL statements, in a highly performant way. Since the question is How do I select rows from a DataFrame based on column values?, and the example in the question is a SQL query, this answer looks logical in this topic. Example:"}, {"id": 73213567, "score": 2, "vote": 0, "content": "<p>You can use <code>loc</code> (square brackets) with a function:</p>\n<pre><code class=\"python\"># Series\ns = pd.Series([1, 2, 3, 4]) \ns.loc[lambda x: x &gt; 1]\n# s[lambda x: x &gt; 1]\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">1    2\n2    3\n3    4\ndtype: int64\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\"># DataFrame\ndf = pd.DataFrame({'A': [1, 2, 3], 'B': [10, 20, 30]})\ndf.loc[lambda x: x['A'] &gt; 1]\n# df[lambda x: x['A'] &gt; 1]\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">   A   B\n1  2  20\n2  3  30\n</code></pre>\n<p>The advantage of this method is that you can chain selection with previous operations. For example:</p>\n<pre><code class=\"python\">df.mul(2).loc[lambda x: x['A'] &gt; 3, 'B']\n# (df * 2).loc[lambda x: x['A'] &gt; 3, 'B']\n</code></pre>\n<p>vs</p>\n<pre><code class=\"python\">df_temp = df * 2\ndf_temp.loc[df_temp['A'] &gt; 3, 'B']\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">1    40\n2    60\nName: B, dtype: int64\n</code></pre>\n", "abstract": "You can use loc (square brackets) with a function: Output: or Output: The advantage of this method is that you can chain selection with previous operations. For example: vs Output:"}, {"id": 71149332, "score": 1, "vote": 0, "content": "<p>Great answers. Only, when the <strong>size of the dataframe approaches million rows</strong>, many of the methods tend to take ages when using <code>df[df['col']==val]</code>. I wanted to have all possible values of \"another_column\" that correspond to specific values in \"some_column\" (in this case in a dictionary). This worked and fast.</p>\n<pre><code class=\"python\">s=datetime.datetime.now()\n\nmy_dict={}\n\nfor i, my_key in enumerate(df['some_column'].values): \n    if i%100==0:\n        print(i)  # to see the progress\n    if my_key not in my_dict.keys():\n        my_dict[my_key]={}\n        my_dict[my_key]['values']=[df.iloc[i]['another_column']]\n    else:\n        my_dict[my_key]['values'].append(df.iloc[i]['another_column'])\n        \ne=datetime.datetime.now()\n\nprint('operation took '+str(e-s)+' seconds')```\n\n</code></pre>\n", "abstract": "Great answers. Only, when the size of the dataframe approaches million rows, many of the methods tend to take ages when using df[df['col']==val]. I wanted to have all possible values of \"another_column\" that correspond to specific values in \"some_column\" (in this case in a dictionary). This worked and fast."}, {"id": 73762002, "score": 1, "vote": 0, "content": "<h2>1. Install <code>numexpr</code> to speed up <code>query()</code> calls</h2>\n<p>The pandas documentation <a href=\"https://pandas.pydata.org/docs/getting_started/install.html#install-recommended-dependencies\" rel=\"nofollow noreferrer\">recommends installing numexpr</a> to speed up numeric calculation when using <code>query()</code>. Use <code>pip install numexpr</code> (or <code>conda</code>, <code>sudo</code> etc. depending on your environment) to install it.</p>\n<p>For larger dataframes (where performance actually matters), <code>df.query()</code> with <code>numexpr</code> engine performs much faster than <code>df[mask]</code>. In particular, it performs better for the following cases.</p>\n<p><strong>Logical and/or comparison operators on columns of strings</strong></p>\n<p>If a column of strings are compared to some other string(s) and matching rows are to be selected, even for a single comparison operation, <code>query()</code> performs faster than <code>df[mask]</code>. For example, for a dataframe with 80k rows, it's 30% faster<sup>1</sup> and for a dataframe with 800k rows, it's 60% faster.<sup>2</sup></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">df[df.A == 'foo']\ndf.query(\"A == 'foo'\")  # &lt;--- performs 30%-60% faster\n</code></pre>\n<p>This gap increases as the number of operations increases (if 4 comparisons are chained <code>df.query()</code> is 2-2.3 times faster than <code>df[mask]</code>)<sup>1,2</sup> and/or the dataframe length increases.<sup>2</sup></p>\n<p><strong>Multiple operations on numeric columns</strong></p>\n<p>If multiple arithmetic, logical or comparison operations need to be computed to create a boolean mask to filter <code>df</code>, <code>query()</code> performs faster. For example, for a frame with 80k rows, it's 20% faster<sup>1</sup> and for a frame with 800k rows, it's 2 times faster.<sup>2</sup></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">df[(df.B % 5) **2 &lt; 0.1]\ndf.query(\"(B % 5) **2 &lt; 0.1\")  # &lt;--- performs 20%-100% faster.\n</code></pre>\n<p>This gap in performance increases as the number of operations increases and/or the dataframe length increases.<sup>2</sup></p>\n<p>The following plot shows how the methods perform as the dataframe length increases.<sup>3</sup></p>\n<p><a href=\"https://i.stack.imgur.com/AgEhg.png\" rel=\"nofollow noreferrer\"><img alt=\"perfplot\" src=\"https://i.stack.imgur.com/AgEhg.png\"/></a></p>\n<h2>2. Access <code>.values</code> to call pandas methods inside <code>query()</code></h2>\n<p><code>Numexpr</code> <a href=\"https://numexpr.readthedocs.io/projects/NumExpr3/en/latest/user_guide.html#supported-operators\" rel=\"nofollow noreferrer\">currently supports</a> only logical (<code>&amp;</code>, <code>|</code>, <code>~</code>), comparison (<code>==</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>) and basic arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code>, <code>%</code>).</p>\n<p>For example, it doesn't support integer division (<code>//</code>). However, calling the equivalent pandas method (<code>floordiv()</code>) and accessing the <code>values</code> attribute on the resulting Series makes <code>numexpr</code> evaluate its underlying numpy array and <code>query()</code> works. Or setting <code>engine</code> parameter to <code>'python'</code> also works.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">df.query('B.floordiv(2).values &lt;= 3')  # or \ndf.query('B.floordiv(2).le(3).values') # or\ndf.query('B.floordiv(2).le(3)', engine='python')\n</code></pre>\n<p>The same applies for <a href=\"https://stackoverflow.com/a/57338153/19123103\">Erfan</a>'s suggested method calls as well. The code in their answer spits TypeError as is (as of Pandas 1.3.4) for <code>numexpr</code> engine but accessing <code>.values</code> attribute makes it work.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">df.query('`Sender email`.str.endswith(\"@shop.com\")')         # &lt;--- TypeError\ndf.query('`Sender email`.str.endswith(\"@shop.com\").values')  # OK\n</code></pre>\n<br/>\n<hr/>\n<p><sup>1</sup>: Benchmark code using a frame with 80k rows</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import numpy as np\ndf = pd.DataFrame({'A': 'foo bar foo baz foo bar foo foo'.split()*10000, \n                   'B': np.random.rand(80000)})\n\n%timeit df[df.A == 'foo']\n# 8.5 ms \u00b1 104.5 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n%timeit df.query(\"A == 'foo'\")\n# 6.36 ms \u00b1 95.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n\n%timeit df[((df.A == 'foo') &amp; (df.A != 'bar')) | ((df.A != 'baz') &amp; (df.A != 'buz'))]\n# 29 ms \u00b1 554 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 100 loops each)\n%timeit df.query(\"A == 'foo' &amp; A != 'bar' | A != 'baz' &amp; A != 'buz'\")\n# 16 ms \u00b1 339 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 100 loops each)\n\n%timeit df[(df.B % 5) **2 &lt; 0.1]\n# 5.35 ms \u00b1 37.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n%timeit df.query(\"(B % 5) **2 &lt; 0.1\")\n# 4.37 ms \u00b1 46.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n</code></pre>\n<p><sup>2</sup>: Benchmark code using a frame with 800k rows</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">df = pd.DataFrame({'A': 'foo bar foo baz foo bar foo foo'.split()*100000, \n                   'B': np.random.rand(800000)})\n\n%timeit df[df.A == 'foo']\n# 87.9 ms \u00b1 873 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 100 loops each)\n%timeit df.query(\"A == 'foo'\")\n# 54.4 ms \u00b1 726 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 100 loops each)\n\n%timeit df[((df.A == 'foo') &amp; (df.A != 'bar')) | ((df.A != 'baz') &amp; (df.A != 'buz'))]\n# 310 ms \u00b1 3.4 ms per loop (mean \u00b1 std. dev. of 10 runs, 100 loops each)\n%timeit df.query(\"A == 'foo' &amp; A != 'bar' | A != 'baz' &amp; A != 'buz'\")\n# 132 ms \u00b1 2.43 ms per loop (mean \u00b1 std. dev. of 10 runs, 100 loops each)\n\n%timeit df[(df.B % 5) **2 &lt; 0.1]\n# 54 ms \u00b1 488 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 100 loops each)\n%timeit df.query(\"(B % 5) **2 &lt; 0.1\")\n# 26.3 ms \u00b1 320 \u00b5s per loop (mean \u00b1 std. dev. of 10 runs, 100 loops each)\n</code></pre>\n<p><sup>3</sup>: Code used to produce the performance graphs of the two methods for strings and numbers.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from perfplot import plot\nconstructor = lambda n: pd.DataFrame({'A': 'foo bar foo baz foo bar foo foo'.split()*n, 'B': np.random.rand(8*n)})\nplot(\n    setup=constructor,\n    kernels=[lambda df: df[(df.B%5)**2&lt;0.1], lambda df: df.query(\"(B%5)**2&lt;0.1\")],\n    labels= ['df[(df.B % 5) **2 &lt; 0.1]', 'df.query(\"(B % 5) **2 &lt; 0.1\")'],\n    n_range=[2**k for k in range(4, 24)],\n    xlabel='Rows in DataFrame',\n    title='Multiple mathematical operations on numbers',\n    equality_check=pd.DataFrame.equals);\nplot(\n    setup=constructor,\n    kernels=[lambda df: df[df.A == 'foo'], lambda df: df.query(\"A == 'foo'\")],\n    labels= [\"df[df.A == 'foo']\", \"\"\"df.query(\"A == 'foo'\")\"\"\"],\n    n_range=[2**k for k in range(4, 24)],\n    xlabel='Rows in DataFrame',\n    title='Comparison operation on strings',\n    equality_check=pd.DataFrame.equals);\n</code></pre>\n", "abstract": "The pandas documentation recommends installing numexpr to speed up numeric calculation when using query(). Use pip install numexpr (or conda, sudo etc. depending on your environment) to install it. For larger dataframes (where performance actually matters), df.query() with numexpr engine performs much faster than df[mask]. In particular, it performs better for the following cases. Logical and/or comparison operators on columns of strings If a column of strings are compared to some other string(s) and matching rows are to be selected, even for a single comparison operation, query() performs faster than df[mask]. For example, for a dataframe with 80k rows, it's 30% faster1 and for a dataframe with 800k rows, it's 60% faster.2 This gap increases as the number of operations increases (if 4 comparisons are chained df.query() is 2-2.3 times faster than df[mask])1,2 and/or the dataframe length increases.2 Multiple operations on numeric columns If multiple arithmetic, logical or comparison operations need to be computed to create a boolean mask to filter df, query() performs faster. For example, for a frame with 80k rows, it's 20% faster1 and for a frame with 800k rows, it's 2 times faster.2 This gap in performance increases as the number of operations increases and/or the dataframe length increases.2 The following plot shows how the methods perform as the dataframe length increases.3  Numexpr currently supports only logical (&, |, ~), comparison (==, >, <, >=, <=, !=) and basic arithmetic operators (+, -, *, /, **, %). For example, it doesn't support integer division (//). However, calling the equivalent pandas method (floordiv()) and accessing the values attribute on the resulting Series makes numexpr evaluate its underlying numpy array and query() works. Or setting engine parameter to 'python' also works. The same applies for Erfan's suggested method calls as well. The code in their answer spits TypeError as is (as of Pandas 1.3.4) for numexpr engine but accessing .values attribute makes it work. 1: Benchmark code using a frame with 80k rows 2: Benchmark code using a frame with 800k rows 3: Code used to produce the performance graphs of the two methods for strings and numbers."}]}, {"link": "https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference", "question": {"id": "986006", "title": "How do I pass a variable by reference?", "content": "<p>Are parameters passed by reference or by value? How do I pass by reference so that the code below outputs <code>'Changed'</code> instead of <code>'Original'</code>?</p>\n<pre><code class=\"python\">class PassByReference:\n    def __init__(self):\n        self.variable = 'Original'\n        self.change(self.variable)\n        print(self.variable)\n\n    def change(self, var):\n        var = 'Changed'\n</code></pre>\n", "abstract": "Are parameters passed by reference or by value? How do I pass by reference so that the code below outputs 'Changed' instead of 'Original'?"}, "answers": [{"id": 986145, "score": 3385, "vote": 0, "content": "<p>Arguments are <a href=\"http://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference\" rel=\"noreferrer\">passed by assignment</a>. The rationale behind this is twofold:</p>\n<ol>\n<li>the parameter passed in is actually a <em>reference</em> to an object (but the reference is passed by value)</li>\n<li>some data types are mutable, but others aren't</li>\n</ol>\n<p>So:</p>\n<ul>\n<li><p>If you pass a <em>mutable</em> object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object. </p></li>\n<li><p>If you pass an <em>immutable</em> object to a method, you still can't rebind the outer reference, and you can't even mutate the object.</p></li>\n</ul>\n<p>To make it even more clear, let's have some examples. </p>\n<h2>List - a mutable type</h2>\n<p><strong>Let's try to modify the list that was passed to a method:</strong></p>\n<pre><code class=\"python\">def try_to_change_list_contents(the_list):\n    print('got', the_list)\n    the_list.append('four')\n    print('changed to', the_list)\n\nouter_list = ['one', 'two', 'three']\n\nprint('before, outer_list =', outer_list)\ntry_to_change_list_contents(outer_list)\nprint('after, outer_list =', outer_list)\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">before, outer_list = ['one', 'two', 'three']\ngot ['one', 'two', 'three']\nchanged to ['one', 'two', 'three', 'four']\nafter, outer_list = ['one', 'two', 'three', 'four']\n</code></pre>\n<p>Since the parameter passed in is a reference to <code>outer_list</code>, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.</p>\n<p><strong>Now let's see what happens when we try to change the reference that was passed in as a parameter:</strong></p>\n<pre><code class=\"python\">def try_to_change_list_reference(the_list):\n    print('got', the_list)\n    the_list = ['and', 'we', 'can', 'not', 'lie']\n    print('set to', the_list)\n\nouter_list = ['we', 'like', 'proper', 'English']\n\nprint('before, outer_list =', outer_list)\ntry_to_change_list_reference(outer_list)\nprint('after, outer_list =', outer_list)\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">before, outer_list = ['we', 'like', 'proper', 'English']\ngot ['we', 'like', 'proper', 'English']\nset to ['and', 'we', 'can', 'not', 'lie']\nafter, outer_list = ['we', 'like', 'proper', 'English']\n</code></pre>\n<p>Since the <code>the_list</code> parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The <code>the_list</code> was a copy of the <code>outer_list</code> reference, and we had <code>the_list</code> point to a new list, but there was no way to change where <code>outer_list</code> pointed.</p>\n<h2>String - an immutable type</h2>\n<p><strong>It's immutable, so there's nothing we can do to change the contents of the string</strong></p>\n<p><strong>Now, let's try to change the reference</strong></p>\n<pre><code class=\"python\">def try_to_change_string_reference(the_string):\n    print('got', the_string)\n    the_string = 'In a kingdom by the sea'\n    print('set to', the_string)\n\nouter_string = 'It was many and many a year ago'\n\nprint('before, outer_string =', outer_string)\ntry_to_change_string_reference(outer_string)\nprint('after, outer_string =', outer_string)\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">before, outer_string = It was many and many a year ago\ngot It was many and many a year ago\nset to In a kingdom by the sea\nafter, outer_string = It was many and many a year ago\n</code></pre>\n<p>Again, since the <code>the_string</code> parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The <code>the_string</code> was a copy of the <code>outer_string</code> reference, and we had <code>the_string</code> point to a new string, but there was no way to change where <code>outer_string</code> pointed.</p>\n<p>I hope this clears things up a little.</p>\n<p><strong>EDIT:</strong> It's been noted that this doesn't answer the question that @David originally asked, \"Is there something I can do to pass the variable by actual reference?\". Let's work on that.</p>\n<h2>How do we get around this?</h2>\n<p>As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:</p>\n<pre><code class=\"python\">def return_a_whole_new_string(the_string):\n    new_string = something_to_do_with_the_old_string(the_string)\n    return new_string\n\n# then you could call it like\nmy_string = return_a_whole_new_string(my_string)\n</code></pre>\n<p>If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:</p>\n<pre><code class=\"python\">def use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):\n    new_string = something_to_do_with_the_old_string(stuff_to_change[0])\n    stuff_to_change[0] = new_string\n\n# then you could call it like\nwrapper = [my_string]\nuse_a_wrapper_to_simulate_pass_by_reference(wrapper)\n\ndo_something_with(wrapper[0])\n</code></pre>\n<p>Although this seems a little cumbersome.</p>\n", "abstract": "Arguments are passed by assignment. The rationale behind this is twofold: So: If you pass a mutable object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object.  If you pass an immutable object to a method, you still can't rebind the outer reference, and you can't even mutate the object. To make it even more clear, let's have some examples.  Let's try to modify the list that was passed to a method: Output: Since the parameter passed in is a reference to outer_list, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope. Now let's see what happens when we try to change the reference that was passed in as a parameter: Output: Since the the_list parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The the_list was a copy of the outer_list reference, and we had the_list point to a new list, but there was no way to change where outer_list pointed. It's immutable, so there's nothing we can do to change the contents of the string Now, let's try to change the reference Output: Again, since the the_string parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The the_string was a copy of the outer_string reference, and we had the_string point to a new string, but there was no way to change where outer_string pointed. I hope this clears things up a little. EDIT: It's been noted that this doesn't answer the question that @David originally asked, \"Is there something I can do to pass the variable by actual reference?\". Let's work on that. As @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out: If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list: Although this seems a little cumbersome."}, {"id": 8140747, "score": 840, "vote": 0, "content": "<p>The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:</p>\n<pre><code class=\"python\">a = 1\na = 2\n</code></pre>\n<p>You believe that <code>a</code> is a memory location that stores the value <code>1</code>, then is updated to store the value <code>2</code>. That's not how things work in Python. Rather, <code>a</code> starts as a reference to an object with the value <code>1</code>, then gets reassigned as a reference to an object with the value <code>2</code>. Those two objects may continue to coexist even though <code>a</code> doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.</p>\n<p>When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:</p>\n<pre><code class=\"python\">def __init__(self):\n    self.variable = 'Original'\n    self.Change(self.variable)\n\ndef Change(self, var):\n    var = 'Changed'\n</code></pre>\n<p><code>self.variable</code> is a reference to the string object <code>'Original'</code>. When you call <code>Change</code> you create a second reference <code>var</code> to the object. Inside the function you reassign the reference <code>var</code> to a different string object <code>'Changed'</code>, but the reference <code>self.variable</code> is separate and does not change.</p>\n<p>The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.</p>\n<pre><code class=\"python\">def __init__(self):         \n    self.variable = ['Original']\n    self.Change(self.variable)\n\ndef Change(self, var):\n    var[0] = 'Changed'\n</code></pre>\n", "abstract": "The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence: You believe that a is a memory location that stores the value 1, then is updated to store the value 2. That's not how things work in Python. Rather, a starts as a reference to an object with the value 1, then gets reassigned as a reference to an object with the value 2. Those two objects may continue to coexist even though a doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program. When you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example: self.variable is a reference to the string object 'Original'. When you call Change you create a second reference var to the object. Inside the function you reassign the reference var to a different string object 'Changed', but the reference self.variable is separate and does not change. The only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places."}, {"id": 25670170, "score": 436, "vote": 0, "content": "<p>I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.\n<a href=\"https://i.stack.imgur.com/FdaCu.png\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/FdaCu.png\"/></a></p>\n", "abstract": "I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.\n"}, {"id": 986495, "score": 269, "vote": 0, "content": "<p>It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh:</p>\n<p><a href=\"http://web.archive.org/web/20201111195827/http://www.effbot.org/zone/call-by-object.htm\" rel=\"noreferrer\">http://effbot.org/zone/call-by-object.htm</a></p>\n<p>Here is a significant quote:</p>\n<blockquote>\n<p>\"...variables [names] are <em>not</em> objects; they cannot be denoted by other variables or referred to by objects.\"</p>\n</blockquote>\n<p>In your example, when the <code>Change</code> method is called--a <a href=\"http://docs.python.org/2/tutorial/classes.html#python-scopes-and-namespaces\" rel=\"noreferrer\">namespace</a> is created for it; and <code>var</code> becomes a name, within that namespace, for the string object <code>'Original'</code>. That object then has a name in two namespaces. Next, <code>var = 'Changed'</code> binds <code>var</code> to a new string object, and thus the method's namespace forgets about <code>'Original'</code>. Finally, that namespace is forgotten, and the string <code>'Changed'</code> along with it.</p>\n", "abstract": "It is neither pass-by-value or pass-by-reference - it is call-by-object. See this, by Fredrik Lundh: http://effbot.org/zone/call-by-object.htm Here is a significant quote: \"...variables [names] are not objects; they cannot be denoted by other variables or referred to by objects.\" In your example, when the Change method is called--a namespace is created for it; and var becomes a name, within that namespace, for the string object 'Original'. That object then has a name in two namespaces. Next, var = 'Changed' binds var to a new string object, and thus the method's namespace forgets about 'Original'. Finally, that namespace is forgotten, and the string 'Changed' along with it."}, {"id": 986339, "score": 212, "vote": 0, "content": "<p>Think of stuff being passed <strong>by assignment</strong> instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment.</p>\n<p>So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list <em>inside</em> the function will not change the original list, since:</p>\n<pre><code class=\"python\">a = [1, 2, 3]\nb = a\nb.append(4)\nb = ['a', 'b']\nprint a, b      # prints [1, 2, 3, 4] ['a', 'b']\n</code></pre>\n<p>Since immutable types cannot be modified, they <em>seem</em> like being passed by value - passing an int into a function means assigning the int to the function's parameter. You can only ever reassign that, but it won't change the original variables value.</p>\n", "abstract": "Think of stuff being passed by assignment instead of by reference/by value. That way, it is always clear, what is happening as long as you understand what happens during the normal assignment. So, when passing a list to a function/method, the list is assigned to the parameter name. Appending to the list will result in the list being modified. Reassigning the list inside the function will not change the original list, since: Since immutable types cannot be modified, they seem like being passed by value - passing an int into a function means assigning the int to the function's parameter. You can only ever reassign that, but it won't change the original variables value."}, {"id": 21700609, "score": 93, "vote": 0, "content": "<h1>There are no variables in Python</h1>\n<p>The key to understanding parameter passing is to stop thinking about \"variables\". There are names and objects in Python and together they\nappear like variables, but it is useful to always distinguish the three.</p>\n<ol>\n<li>Python has names and objects.</li>\n<li>Assignment binds a name to an object.</li>\n<li>Passing an argument into a function also binds a name (the parameter name of the function) to an object.</li>\n</ol>\n<p>That is all there is to it. Mutability is irrelevant to this question.</p>\n<p>Example:</p>\n<pre><code class=\"python\">a = 1\n</code></pre>\n<p>This binds the name <code>a</code> to an object of type integer that holds the value 1.</p>\n<pre><code class=\"python\">b = x\n</code></pre>\n<p>This binds the name <code>b</code> to the same object that the name <code>x</code> is currently bound to.\nAfterward, the name <code>b</code> has nothing to do with the name <code>x</code> anymore.</p>\n<p>See sections <a href=\"https://docs.python.org/3/reference/datamodel.html#objects-values-and-types\" rel=\"noreferrer\">3.1</a> and <a href=\"https://docs.python.org/3/reference/executionmodel.html#naming-and-binding\" rel=\"noreferrer\">4.2</a> in the Python 3 language reference.</p>\n<h1>How to read the example in the question</h1>\n<p>In the code shown in the question, the statement <code>self.Change(self.variable)</code> binds the name <code>var</code> (in the scope of function <code>Change</code>) to the object that holds the value <code>'Original'</code> and the assignment <code>var = 'Changed'</code> (in the body of function <code>Change</code>) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely).</p>\n<h1>How to pass by reference</h1>\n<p>So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference.</p>\n<p>If it is an <a href=\"https://docs.python.org/3/reference/datamodel.html#objects-values-and-types\" rel=\"noreferrer\">immutable</a> object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.<br/>\nThe quick-and-dirty solution for this is a one-element list (instead of <code>self.variable</code>, pass <code>[self.variable]</code> and in the function modify <code>var[0]</code>).<br/>\nThe more <a href=\"https://www.python.org/dev/peps/pep-0020/\" rel=\"noreferrer\">pythonic</a> approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute.</p>\n", "abstract": "The key to understanding parameter passing is to stop thinking about \"variables\". There are names and objects in Python and together they\nappear like variables, but it is useful to always distinguish the three. That is all there is to it. Mutability is irrelevant to this question. Example: This binds the name a to an object of type integer that holds the value 1. This binds the name b to the same object that the name x is currently bound to.\nAfterward, the name b has nothing to do with the name x anymore. See sections 3.1 and 4.2 in the Python 3 language reference. In the code shown in the question, the statement self.Change(self.variable) binds the name var (in the scope of function Change) to the object that holds the value 'Original' and the assignment var = 'Changed' (in the body of function Change) assigns that same name again: to some other object (that happens to hold a string as well but could have been something else entirely). So if the thing you want to change is a mutable object, there is no problem, as everything is effectively passed by reference. If it is an immutable object (e.g. a bool, number, string), the way to go is to wrap it in a mutable object.\nThe quick-and-dirty solution for this is a one-element list (instead of self.variable, pass [self.variable] and in the function modify var[0]).\nThe more pythonic approach would be to introduce a trivial, one-attribute class. The function receives an instance of the class and manipulates the attribute."}, {"id": 15697476, "score": 84, "vote": 0, "content": "<p>Effbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  <a href=\"http://effbot.org/zone/call-by-object.htm\">http://effbot.org/zone/call-by-object.htm</a></p>\n<p>Objects are allocated on the heap and pointers to them can be passed around anywhere.  </p>\n<ul>\n<li><p>When you make an assignment such as <code>x = 1000</code>, a dictionary entry is created that maps the string \"x\" in the current namespace to a pointer to the integer object containing one thousand.   </p></li>\n<li><p>When you update \"x\" with <code>x = 2000</code>, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object).</p></li>\n<li><p>When you do a new assignment such as <code>y = x</code>, a new dictionary entry \"y\" is created that points to the same object as the entry for \"x\".</p></li>\n<li><p>Objects like strings and integers are <em>immutable</em>.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects.</p></li>\n<li><p>Objects like lists are <em>mutable</em>.  This means that the contents of the object can be changed by anything pointing to the object.  For example, <code>x = []; y = x; x.append(10); print y</code> will print <code>[10]</code>.  The empty list was created.  Both \"x\" and \"y\" point to the same list.  The <em>append</em> method mutates (updates) the list object (like adding a record to a database) and the result is visible to both \"x\" and \"y\" (just as a database update would be visible to every connection to that database).</p></li>\n</ul>\n<p>Hope that clarifies the issue for you. </p>\n", "abstract": "Effbot (aka Fredrik Lundh) has described Python's variable passing style as call-by-object:  http://effbot.org/zone/call-by-object.htm Objects are allocated on the heap and pointers to them can be passed around anywhere.   When you make an assignment such as x = 1000, a dictionary entry is created that maps the string \"x\" in the current namespace to a pointer to the integer object containing one thousand.    When you update \"x\" with x = 2000, a new integer object is created and the dictionary is updated to point at the new object.  The old one thousand object is unchanged (and may or may not be alive depending on whether anything else refers to the object). When you do a new assignment such as y = x, a new dictionary entry \"y\" is created that points to the same object as the entry for \"x\". Objects like strings and integers are immutable.  This simply means that there are no methods that can change the object after it has been created.  For example, once the integer object one-thousand is created, it will never change.  Math is done by creating new integer objects. Objects like lists are mutable.  This means that the contents of the object can be changed by anything pointing to the object.  For example, x = []; y = x; x.append(10); print y will print [10].  The empty list was created.  Both \"x\" and \"y\" point to the same list.  The append method mutates (updates) the list object (like adding a record to a database) and the result is visible to both \"x\" and \"y\" (just as a database update would be visible to every connection to that database). Hope that clarifies the issue for you. "}, {"id": 12440140, "score": 65, "vote": 0, "content": "<p>Technically, <strong>Python always uses pass by reference values</strong>. I am going to repeat <a href=\"https://stackoverflow.com/a/12438316/1346705\">my other answer</a> to support my statement.</p>\n<p>Python always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always.</p>\n<p>You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target.</p>\n<p>Here is the example that proves that Python uses passing by reference:</p>\n<p><img alt=\"Illustrated example of passing the argument\" src=\"https://i.stack.imgur.com/uzXcP.png\"/></p>\n<p>If the argument was passed by value, the outer <code>lst</code> could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.)</p>\n<p>You can use the <a href=\"http://docs.python.org/3.3/library/functions.html#id\" rel=\"noreferrer\"><code>id()</code></a> built-in function to learn what the reference value is (that is, the address of the target object).</p>\n<p>In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target.</p>\n<p>Reference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are.</p>\n", "abstract": "Technically, Python always uses pass by reference values. I am going to repeat my other answer to support my statement. Python always uses pass-by-reference values. There isn't any exception. Any variable assignment means copying the reference value. No exception. Any variable is the name bound to the reference value. Always. You can think about a reference value as the address of the target object. The address is automatically dereferenced when used. This way, working with the reference value, it seems you work directly with the target object. But there always is a reference in between, one step more to jump to the target. Here is the example that proves that Python uses passing by reference:  If the argument was passed by value, the outer lst could not be modified. The green are the target objects (the black is the value stored inside, the red is the object type), the yellow is the memory with the reference value inside -- drawn as the arrow. The blue solid arrow is the reference value that was passed to the function (via the dashed blue arrow path). The ugly dark yellow is the internal dictionary. (It actually could be drawn also as a green ellipse. The colour and the shape only says it is internal.) You can use the id() built-in function to learn what the reference value is (that is, the address of the target object). In compiled languages, a variable is a memory space that is able to capture the value of the type. In Python, a variable is a name (captured internally as a string) bound to the reference variable that holds the reference value to the target object. The name of the variable is the key in the internal dictionary, the value part of that dictionary item stores the reference value to the target. Reference values are hidden in Python. There isn't any explicit user type for storing the reference value. However, you can use a list element (or element in any other suitable container type) as the reference variable, because all containers do store the elements also as references to the target objects. In other words, elements are actually not contained inside the container -- only the references to elements are."}, {"id": 6963425, "score": 57, "vote": 0, "content": "<p>A simple trick I normally use is to just wrap it in a list:</p>\n<pre><code class=\"python\">def Change(self, var):\n    var[0] = 'Changed'\n\nvariable = ['Original']\nself.Change(variable)      \nprint variable[0]\n</code></pre>\n<p>(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)</p>\n", "abstract": "A simple trick I normally use is to just wrap it in a list: (Yeah I know this can be inconvenient, but sometimes it is simple enough to do this.)"}, {"id": 3127336, "score": 38, "vote": 0, "content": "<p>(edit - Blair has updated his enormously popular answer so that it is now accurate)</p>\n<p>I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them.</p>\n<p>David Cournapeau's answer points to the real answer and explains why the behavior in Blair Conrad's post seems to be correct while the definitions are not.</p>\n<p>To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a \"value\" or a \"reference\") must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it.</p>\n<p>If you want the behavior, Blair Conrad's answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau's answer.</p>\n", "abstract": "(edit - Blair has updated his enormously popular answer so that it is now accurate) I think it is important to note that the current post with the most votes (by Blair Conrad), while being correct with respect to its result, is misleading and is borderline incorrect based on its definitions.  While there are many languages (like C) that allow the user to either pass by reference or pass by value, Python is not one of them. David Cournapeau's answer points to the real answer and explains why the behavior in Blair Conrad's post seems to be correct while the definitions are not. To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a \"value\" or a \"reference\") must be sent. However, that does not mean that Python is pass by value in the sense that a C programmer would think of it. If you want the behavior, Blair Conrad's answer is fine.  But if you want to know the nuts and bolts of why Python is neither pass by value or pass by reference, read David Cournapeau's answer."}, {"id": 986335, "score": 27, "vote": 0, "content": "<p>You got some really good answers here.</p>\n<pre><code class=\"python\">x = [ 2, 4, 4, 5, 5 ]\nprint x  # 2, 4, 4, 5, 5\n\ndef go( li ) :\n  li = [ 5, 6, 7, 8 ]  # re-assigning what li POINTS TO, does not\n  # change the value of the ORIGINAL variable x\n\ngo( x ) \nprint x  # 2, 4, 4, 5, 5  [ STILL! ]\n\n\nraw_input( 'press any key to continue' )\n</code></pre>\n", "abstract": "You got some really good answers here."}, {"id": 29293411, "score": 23, "vote": 0, "content": "<p>Python\u2019s pass-by-assignment scheme isn\u2019t quite the same as C++\u2019s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:</p>\n<ul>\n<li>Immutable arguments are effectively passed \u201c<strong>by value</strong>.\u201d Objects such as integers and strings are passed by object reference instead of by copying, but because you can\u2019t change immutable objects in place anyhow, the effect is much like making a copy.</li>\n<li>Mutable arguments are effectively passed \u201c<strong>by pointer</strong>.\u201d Objects such as lists\nand dictionaries are also passed by object reference, which is similar to the way C\npasses arrays as pointers\u2014mutable objects can be changed in place in the function,\nmuch like C arrays.</li>\n</ul>\n", "abstract": "Python\u2019s pass-by-assignment scheme isn\u2019t quite the same as C++\u2019s reference parameters option, but it turns out to be very similar to the argument-passing model of the C language (and others) in practice:"}, {"id": 986044, "score": 22, "vote": 0, "content": "<p>In this case the variable titled <code>var</code> in the method <code>Change</code> is assigned a reference to <code>self.variable</code>, and you immediately assign a string to <code>var</code>. It's no longer pointing to <code>self.variable</code>. The following code snippet shows what would happen if you modify the data structure pointed to by <code>var</code> and <code>self.variable</code>, in this case a list:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class PassByReference:\n...     def __init__(self):\n...         self.variable = ['Original']\n...         self.change(self.variable)\n...         print self.variable\n...         \n...     def change(self, var):\n...         var.append('Changed')\n... \n&gt;&gt;&gt; q = PassByReference()\n['Original', 'Changed']\n&gt;&gt;&gt; \n</code></pre>\n<p>I'm sure someone else could clarify this further.</p>\n", "abstract": "In this case the variable titled var in the method Change is assigned a reference to self.variable, and you immediately assign a string to var. It's no longer pointing to self.variable. The following code snippet shows what would happen if you modify the data structure pointed to by var and self.variable, in this case a list: I'm sure someone else could clarify this further."}, {"id": 25810863, "score": 19, "vote": 0, "content": "<p>A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation <a href=\"https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python\" rel=\"noreferrer\">https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python</a> </p>\n<p>\"In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the function\u2019s body, it\u2019s assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as \u2018global\u2019.\nThough a bit surprising at first, a moment\u2019s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you\u2019d be using global all the time. You\u2019d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.\"</p>\n<p>Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function.</p>\n<pre><code class=\"python\">def test(l):\n    print \"Received\", l , id(l)\n    l = [0, 0, 0]\n    print \"Changed to\", l, id(l)  # New local object created, breaking link to global l\n\nl= [1,2,3]\nprint \"Original\", l, id(l)\ntest(l)\nprint \"After\", l, id(l)\n</code></pre>\n<p>gives:</p>\n<pre><code class=\"python\">Original [1, 2, 3] 4454645632\nReceived [1, 2, 3] 4454645632\nChanged to [0, 0, 0] 4474591928\nAfter [1, 2, 3] 4454645632\n</code></pre>\n<p>The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object.</p>\n", "abstract": "A lot of insights in answers here, but i think an additional point is not clearly mentioned here explicitly.   Quoting from python documentation https://docs.python.org/2/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python  \"In Python, variables that are only referenced inside a function are implicitly global. If a variable is assigned a new value anywhere within the function\u2019s body, it\u2019s assumed to be a local. If a variable is ever assigned a new value inside the function, the variable is implicitly local, and you need to explicitly declare it as \u2018global\u2019.\nThough a bit surprising at first, a moment\u2019s consideration explains this. On one hand, requiring global for assigned variables provides a bar against unintended side-effects. On the other hand, if global was required for all global references, you\u2019d be using global all the time. You\u2019d have to declare as global every reference to a built-in function or to a component of an imported module. This clutter would defeat the usefulness of the global declaration for identifying side-effects.\" Even when passing a mutable object to a function this still applies. And to me clearly explains the reason for the difference in behavior between assigning to the object and operating on the object in the function. gives: The assignment to an global variable that is not declared global therefore creates a new local object and breaks the link to the original object."}, {"id": 21684541, "score": 18, "vote": 0, "content": "<p>As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue!</p>\n<p><a href=\"http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python\" rel=\"noreferrer\">http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python</a></p>\n<p>example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def x(y):\n...     global z\n...     z = y\n...\n\n&gt;&gt;&gt; x\n&lt;function x at 0x00000000020E1730&gt;\n&gt;&gt;&gt; y\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'y' is not defined\n&gt;&gt;&gt; z\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'z' is not defined\n\n&gt;&gt;&gt; x(2)\n&gt;&gt;&gt; x\n&lt;function x at 0x00000000020E1730&gt;\n&gt;&gt;&gt; y\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nNameError: name 'y' is not defined\n&gt;&gt;&gt; z\n2\n</code></pre>\n", "abstract": "As you can state you need to have a mutable object, but let me suggest you to check over the global variables as they can help you or even solve this kind of issue! http://docs.python.org/3/faq/programming.html#what-are-the-rules-for-local-and-global-variables-in-python example:"}, {"id": 12686527, "score": 11, "vote": 0, "content": "<p>Here is the simple (I hope) explanation of the concept <code>pass by object</code> used in Python.<br/>\nWhenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call:</p>\n<pre><code class=\"python\">def change_me(list):\n   list = [1, 2, 3]\n\nmy_list = [0, 1]\nchange_me(my_list)\n</code></pre>\n<p>The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function <code>change_me</code> will try to do something like:</p>\n<pre><code class=\"python\">[0, 1] = [1, 2, 3]\n</code></pre>\n<p>which obviously will not change the object passed to the function. If the function looked like this:</p>\n<pre><code class=\"python\">def change_me(list):\n   list.append(2)\n</code></pre>\n<p>Then the call would result in:</p>\n<pre><code class=\"python\">[0, 1].append(2)\n</code></pre>\n<p>which obviously will change the object. <a href=\"https://stackoverflow.com/a/534509/831531\">This answer</a> explains it well.</p>\n", "abstract": "Here is the simple (I hope) explanation of the concept pass by object used in Python.\nWhenever you pass an object to the function, the object itself is passed (object in Python is actually what you'd call a value in other programming languages) not the reference to this object. In other words, when you call: The actual object - [0, 1] (which would be called a value in other programming languages) is being passed. So in fact the function change_me will try to do something like: which obviously will not change the object passed to the function. If the function looked like this: Then the call would result in: which obviously will change the object. This answer explains it well."}, {"id": 35260424, "score": 11, "vote": 0, "content": "<p>Aside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following:</p>\n<pre><code class=\"python\">class PassByReference:\n    def __init__(self):\n        self.variable = 'Original'\n        self.Change()\n        print self.variable\n\n    def Change(self):\n        self.variable = 'Changed'\n</code></pre>\n<p>In instance methods, you normally refer to <code>self</code> to access instance attributes. It is normal to set instance attributes in <code>__init__</code> and read or change them in instance methods. That is also why you pass <code>self</code> als the first argument to <code>def Change</code>.</p>\n<p>Another solution would be to create a static method like this:</p>\n<pre><code class=\"python\">class PassByReference:\n    def __init__(self):\n        self.variable = 'Original'\n        self.variable = PassByReference.Change(self.variable)\n        print self.variable\n\n    @staticmethod\n    def Change(var):\n        var = 'Changed'\n        return var\n</code></pre>\n", "abstract": "Aside from all the great explanations on how this stuff works in Python, I don't see a simple suggestion for the problem. As you seem to do create objects and instances, the pythonic way of handling instance variables and changing them is the following: In instance methods, you normally refer to self to access instance attributes. It is normal to set instance attributes in __init__ and read or change them in instance methods. That is also why you pass self als the first argument to def Change. Another solution would be to create a static method like this:"}, {"id": 38834546, "score": 9, "vote": 0, "content": "<p>I used the following method to quickly convert a couple of Fortran codes to Python.  True, it's not pass by reference as the original question was posed, but is a simple work around in some cases.</p>\n<pre><code class=\"python\">a=0\nb=0\nc=0\ndef myfunc(a,b,c):\n    a=1\n    b=2\n    c=3\n    return a,b,c\n\na,b,c = myfunc(a,b,c)\nprint a,b,c\n</code></pre>\n", "abstract": "I used the following method to quickly convert a couple of Fortran codes to Python.  True, it's not pass by reference as the original question was posed, but is a simple work around in some cases."}, {"id": 36775894, "score": 8, "vote": 0, "content": "<p>There is a little trick to pass an object by reference, even though the language doesn't make it possible. It works in Java too, it's the list with one item. ;-)</p>\n<pre><code class=\"python\">class PassByReference:\n    def __init__(self, name):\n        self.name = name\n\ndef changeRef(ref):\n    ref[0] = PassByReference('Michael')\n\nobj = PassByReference('Peter')\nprint obj.name\n\np = [obj] # A pointer to obj! ;-)\nchangeRef(p)\n\nprint p[0].name # p-&gt;name\n</code></pre>\n<p>It's an ugly hack, but it works. ;-P</p>\n", "abstract": "There is a little trick to pass an object by reference, even though the language doesn't make it possible. It works in Java too, it's the list with one item. ;-) It's an ugly hack, but it works. ;-P"}, {"id": 40345432, "score": 5, "vote": 0, "content": "<p>given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name:</p>\n<pre><code class=\"python\">class PassByReferenceIsh:\n    def __init__(self):\n        self.variable = 'Original'\n        self.change('variable')\n        print self.variable\n\n    def change(self, var):\n        self.__dict__[var] = 'Changed'\n</code></pre>\n<p>in real code you would, of course, add error checking on the dict lookup.</p>\n", "abstract": "given the way python handles values and references to them, the only way you can reference an arbitrary instance attribute is by name: in real code you would, of course, add error checking on the dict lookup."}, {"id": 46136730, "score": 4, "vote": 0, "content": "<p>Since your example happens to be object-oriented, you could make the following change to achieve a similar result:</p>\n<pre><code class=\"python\">class PassByReference:\n    def __init__(self):\n        self.variable = 'Original'\n        self.change('variable')\n        print(self.variable)\n\n    def change(self, var):\n        setattr(self, var, 'Changed')\n\n# o.variable will equal 'Changed'\no = PassByReference()\nassert o.variable == 'Changed'\n</code></pre>\n", "abstract": "Since your example happens to be object-oriented, you could make the following change to achieve a similar result:"}, {"id": 55992875, "score": 4, "vote": 0, "content": "<p>Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it.</p>\n<pre><code class=\"python\"># returns the result of adding numbers `a` and `b`\ndef AddNumbers(a, b, ref): # using a dict for reference\n    result = a + b\n    ref['multi'] = a * b # reference the multi. ref['multi'] is number\n    ref['msg'] = \"The result: \" + str(result) + \" was nice!\"\n    return result\n\nnumber1 = 5\nnumber2 = 10\nref = {} # init a dict like that so it can save all the referenced values. this is because all dictionaries are passed by reference, while strings and numbers do not.\n\nsum = AddNumbers(number1, number2, ref)\nprint(\"sum: \", sum)             # the returned value\nprint(\"multi: \", ref['multi'])  # a referenced value\nprint(\"msg: \", ref['msg'])      # a referenced value\n</code></pre>\n", "abstract": "Since dictionaries are passed by reference, you can use a dict variable to store any referenced values inside it."}, {"id": 56069248, "score": 4, "vote": 0, "content": "<p>Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an \"update\" function and pass that instead of the actual variable (or rather, \"name\"):</p>\n<pre><code class=\"python\">def need_to_modify(update):\n    update(42) # set new value 42\n    # other code\n\ndef call_it():\n    value = 21\n    def update_value(new_value):\n        nonlocal value\n        value = new_value\n    need_to_modify(update_value)\n    print(value) # prints 42\n</code></pre>\n<p>This is mostly useful for \"out-only references\" or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe).</p>\n<p>Obviously the above does not allow <em>reading</em> the value, only updating it.</p>\n", "abstract": "Since it seems to be nowhere mentioned an approach to simulate references as known from e.g. C++ is to use an \"update\" function and pass that instead of the actual variable (or rather, \"name\"): This is mostly useful for \"out-only references\" or in a situation with multiple threads / processes (by making the update function thread / multiprocessing safe). Obviously the above does not allow reading the value, only updating it."}, {"id": 39054982, "score": 3, "vote": 0, "content": "<p>While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function.</p>\n<p>The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class.</p>\n<p>One way is to use <code>global</code> (for global variables) or <code>nonlocal</code> (for local variables in a function) in a wrapper function.</p>\n<pre><code class=\"python\">def change(wrapper):\n    wrapper(7)\n\nx = 5\ndef setter(val):\n    global x\n    x = val\nprint(x)\n</code></pre>\n<p>The same idea works for reading and <code>del</code>eting a variable.</p>\n<p>For just reading there is even a shorter way of just using <code>lambda: x</code> which returns a callable that when called returns the current value of x. This is somewhat like \"call by name\" used in languages in the distant past.</p>\n<p>Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute:</p>\n<pre><code class=\"python\">class ByRef:\n    def __init__(self, r, w, d):\n        self._read = r\n        self._write = w\n        self._delete = d\n    def set(self, val):\n        self._write(val)\n    def get(self):\n        return self._read()\n    def remove(self):\n        self._delete()\n    wrapped = property(get, set, remove)\n\n# left as an exercise for the reader: define set, get, remove as local functions using global / nonlocal\nr = ByRef(get, set, remove)\nr.wrapped = 15\n</code></pre>\n<p>Pythons \"reflection\" support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope:</p>\n<pre><code class=\"python\">class ByRef:\n    def __init__(self, locs, name):\n        self._locs = locs\n        self._name = name\n    def set(self, val):\n        self._locs[self._name] = val\n    def get(self):\n        return self._locs[self._name]\n    def remove(self):\n        del self._locs[self._name]\n    wrapped = property(get, set, remove)\n\ndef change(x):\n    x.wrapped = 7\n\ndef test_me():\n    x = 6\n    print(x)\n    change(ByRef(locals(), \"x\"))\n    print(x)\n</code></pre>\n<p>Here the <code>ByRef</code> class wraps a dictionary access. So attribute access to <code>wrapped</code> is translated to a item access in the passed dictionary. By passing the result of the builtin <code>locals</code> and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me.</p>\n", "abstract": "While pass by reference is nothing that fits well into python and should be rarely used there are some workarounds that actually can work to get the object currently assigned to a local variable or even reassign a local variable from inside of a called function. The basic idea is to have a function that can do that access and can be passed as object into other functions or stored in a class. One way is to use global (for global variables) or nonlocal (for local variables in a function) in a wrapper function. The same idea works for reading and deleting a variable. For just reading there is even a shorter way of just using lambda: x which returns a callable that when called returns the current value of x. This is somewhat like \"call by name\" used in languages in the distant past. Passing 3 wrappers to access a variable is a bit unwieldy so those can be wrapped into a class that has a proxy attribute: Pythons \"reflection\" support makes it possible to get a object that is capable of reassigning a name/variable in a given scope without defining functions explicitly in that scope: Here the ByRef class wraps a dictionary access. So attribute access to wrapped is translated to a item access in the passed dictionary. By passing the result of the builtin locals and the name of a local variable this ends up accessing a local variable. The python documentation as of 3.5 advises that changing the dictionary might not work but it seems to work for me."}, {"id": 50157212, "score": 2, "vote": 0, "content": "<p>You can merely use <strong>an empty class</strong> as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example.</p>\n<pre><code class=\"python\">class RefsObj(object):\n    \"A class which helps to create references to variables.\"\n    pass\n\n...\n\n# an example of usage\ndef change_ref_var(ref_obj):\n    ref_obj.val = 24\n\nref_obj = RefsObj()\nref_obj.val = 1\nprint(ref_obj.val) # or print ref_obj.val for python2\nchange_ref_var(ref_obj)\nprint(ref_obj.val)\n</code></pre>\n", "abstract": "You can merely use an empty class as an instance to store reference objects because internally object attributes are stored in an instance dictionary. See the example."}, {"id": 54315603, "score": 2, "vote": 0, "content": "<p>Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java. </p>\n<ul>\n<li><strong>Java&amp;C#:</strong> primitive types(include string)pass by value(copy), Reference type is passed by reference(address copy) so all changes made in the parameter in the called function are visible to the caller.</li>\n<li><strong>C++:</strong> Both pass-by-reference or pass-by-value are allowed. If a parameter is passed by reference, you can either modify it or not depending upon whether the parameter was passed as const or not. However, const or not, the parameter maintains the reference to the object and reference cannot be assigned to point to a different object within the called function.</li>\n<li><strong>Python:</strong> \nPython is \u201cpass-by-object-reference\u201d, of which it is often said: \u201cObject references are passed by value.\u201d[Read here]<a href=\"https://robertheaton.com/2014/02/09/pythons-pass-by-object-reference-as-explained-by-philip-k-dick/\" rel=\"nofollow noreferrer\">1</a>. Both the caller and the function refer to the same object but the parameter in the function is a new variable which is just holding a copy of the object in the caller. Like C++, a parameter can be either modified or not in function - This depends upon the type of object passed. eg; An immutable object type cannot be modified in the called function whereas a mutable object can be either updated or re-initialized. A crucial difference between updating or re-assigning/re-initializing the mutable variable is that updated value gets reflected back in the called function whereas the reinitialized value does not. Scope of any assignment of new object to a mutable variable is local to the function in the python. Examples provided by @blair-conrad are great to understand this.</li>\n</ul>\n", "abstract": "Pass-By-Reference in Python is quite different from the concept of pass by reference in C++/Java. "}, {"id": 62970753, "score": 2, "vote": 0, "content": "<p>I am new to Python, started yesterday (though I have been programming for 45 years).</p>\n<p>I came here because I was writing a function where I wanted to have two so called out-parameters. If it would have been only one out-parameter, I wouldn't get hung up right now on checking how reference/value works in Python. I would just have used the return value of the function instead. But since I needed <em>two</em> such out-parameters I felt I needed to sort it out.</p>\n<p>In this post I am going to show how I solved my situation. Perhaps others coming here can find it valuable, even though it is not exactly an answer to the topic question. Experienced Python programmers of course already know about the solution I used, but it was new to me.</p>\n<p>From the answers here I could quickly see that Python works a bit like Javascript in this regard, and that you need to use workarounds if you want the reference functionality.</p>\n<p>But then I found something neat in Python that I don't think I have seen in other languages before, namely that you can return more than one value from a function, in a simple comma separated way, like this:</p>\n<pre><code class=\"python\">def somefunction(p):\n    a=p+1\n    b=p+2\n    c=-p\n    return a, b, c\n</code></pre>\n<p>and that you can handle that on the calling side similarly, like this</p>\n<pre><code class=\"python\">x, y, z = somefunction(w)\n</code></pre>\n<p>That was good enough for me and I was satisfied. No need to use some workaround.</p>\n<p>In other languages you can of course also return many values, but then usually in the from of an object, and you need to adjust the calling side accordingly.</p>\n<p>The Python way of doing it was nice and simple.</p>\n<p>If you want to mimic <em>by reference</em> even more, you could do as follows:</p>\n<pre><code class=\"python\">def somefunction(a, b, c):\n    a = a * 2\n    b = b + a\n    c = a * b * c\n    return a, b, c\n\nx = 3\ny = 5\nz = 10\nprint(F\"Before : {x}, {y}, {z}\")\n\nx, y, z = somefunction(x, y, z)\n\nprint(F\"After  : {x}, {y}, {z}\")\n</code></pre>\n<p>which gives this result</p>\n<pre>\nBefore : 3, 5, 10  \nAfter  : 6, 11, 660  \n</pre>\n", "abstract": "I am new to Python, started yesterday (though I have been programming for 45 years). I came here because I was writing a function where I wanted to have two so called out-parameters. If it would have been only one out-parameter, I wouldn't get hung up right now on checking how reference/value works in Python. I would just have used the return value of the function instead. But since I needed two such out-parameters I felt I needed to sort it out. In this post I am going to show how I solved my situation. Perhaps others coming here can find it valuable, even though it is not exactly an answer to the topic question. Experienced Python programmers of course already know about the solution I used, but it was new to me. From the answers here I could quickly see that Python works a bit like Javascript in this regard, and that you need to use workarounds if you want the reference functionality. But then I found something neat in Python that I don't think I have seen in other languages before, namely that you can return more than one value from a function, in a simple comma separated way, like this: and that you can handle that on the calling side similarly, like this That was good enough for me and I was satisfied. No need to use some workaround. In other languages you can of course also return many values, but then usually in the from of an object, and you need to adjust the calling side accordingly. The Python way of doing it was nice and simple. If you want to mimic by reference even more, you could do as follows: which gives this result"}, {"id": 65935869, "score": 2, "vote": 0, "content": "<p>alternatively you could use ctypes witch would look something like this</p>\n<pre><code class=\"python\">import ctypes\n\ndef f(a):\n    a.value=2398 ## resign the value in a function\n\na = ctypes.c_int(0)\nprint(\"pre f\", a)\nf(a)\nprint(\"post f\", a)\n</code></pre>\n<p>as a is a c int and not a python integer and apperently passed by reference. however you have to be carefull as strange things could happen and is therefor not advised</p>\n", "abstract": "alternatively you could use ctypes witch would look something like this as a is a c int and not a python integer and apperently passed by reference. however you have to be carefull as strange things could happen and is therefor not advised"}, {"id": 66819159, "score": 1, "vote": 0, "content": "<p>Most likely not the most reliable method but this works, keep in mind that you are overloading the built-in str function which is typically something you don't want to do:</p>\n<pre><code class=\"python\">import builtins\n\nclass sstr(str):\n    def __str__(self):\n        if hasattr(self, 'changed'):\n            return self.changed\n\n        return self\n\n    def change(self, value):\n        self.changed = value\n\nbuiltins.str = sstr\n\ndef change_the_value(val):\n    val.change('After')\n\nval = str('Before')\nprint (val)\nchange_the_value(val)\nprint (val)\n</code></pre>\n", "abstract": "Most likely not the most reliable method but this works, keep in mind that you are overloading the built-in str function which is typically something you don't want to do:"}, {"id": 68167731, "score": 0, "vote": 0, "content": "<p>What about <a href=\"https://docs.python.org/3/library/dataclasses.html\" rel=\"nofollow noreferrer\">dataclasses</a>? Also, it allows you to apply type restriction (aka \"type hint\").</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from dataclasses import dataclass\n\n@dataclass\nclass Holder:\n    obj: your_type # Need any type? Use \"obj: object\" then.\n\ndef foo(ref: Holder):\n    ref.obj = do_something()\n</code></pre>\n<p>I agree with folks that in most cases you'd better consider not to use it.</p>\n<p>And yet, when we're talking about <a href=\"https://en.wikipedia.org/wiki/State_pattern\" rel=\"nofollow noreferrer\"><em>contexts</em></a> it's worth to know that way.</p>\n<p>You can design explicit context class though. When prototyping I prefer dataclasses, just because it's easy to serialize them back and forth.</p>\n<p>Cheers!</p>\n", "abstract": "What about dataclasses? Also, it allows you to apply type restriction (aka \"type hint\"). I agree with folks that in most cases you'd better consider not to use it. And yet, when we're talking about contexts it's worth to know that way. You can design explicit context class though. When prototyping I prefer dataclasses, just because it's easy to serialize them back and forth. Cheers!"}, {"id": 71049904, "score": 0, "vote": 0, "content": "<ol>\n<li><p>Python assigns a unique identifier to each object and this identifier can be found by using Python's built-in <code>id()</code> function.\nIt is ready to verify that actual and formal arguments in a function call have the same id value, which indicates that the dummy argument and actual argument refer to the same object.</p>\n</li>\n<li><p>Note that the actual argument and the corresponding dummy argument are two names referring to the same object. If you re-bind a dummy argument to a new value/object in the function scope, this does not effect the fact that the actual argument still points to the original object because actual argument and dummy argument are two names.</p>\n</li>\n<li><p>The above two facts can be summarized as \u201carguments are passed by assignment\u201d. i.e.,</p>\n</li>\n</ol>\n<pre><code class=\"python\">dummy_argument = actual_argument\n</code></pre>\n<p>If you re-bind <code>dummy_argument</code> to a new object in the function body, the <code>actual_argument</code> still refers to the original object. If you use <code>dummy_argument[0] = some_thing</code>, then this will also modify <code>actual_argument[0]</code>. Therefore the effect of \u201cpass by reference\u201d can be achieved by modifying the components/attributes of the object reference passed in. Of course, this requires that the object passed is a mutable object.</p>\n<ol start=\"4\">\n<li>To make comparison with other languages, you can say Python passes arguments by value in the same way as C does, where when you pass \"by reference\" you are actually passing by value the reference (i.e., the pointer)</li>\n</ol>\n", "abstract": "Python assigns a unique identifier to each object and this identifier can be found by using Python's built-in id() function.\nIt is ready to verify that actual and formal arguments in a function call have the same id value, which indicates that the dummy argument and actual argument refer to the same object. Note that the actual argument and the corresponding dummy argument are two names referring to the same object. If you re-bind a dummy argument to a new value/object in the function scope, this does not effect the fact that the actual argument still points to the original object because actual argument and dummy argument are two names. The above two facts can be summarized as \u201carguments are passed by assignment\u201d. i.e., If you re-bind dummy_argument to a new object in the function body, the actual_argument still refers to the original object. If you use dummy_argument[0] = some_thing, then this will also modify actual_argument[0]. Therefore the effect of \u201cpass by reference\u201d can be achieved by modifying the components/attributes of the object reference passed in. Of course, this requires that the object passed is a mutable object."}, {"id": 71579032, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">def i_my_wstring_length(wstring_input:str = \"\", i_length:int = 0) -&gt; int:\n    i_length[0] = len(wstring_input)\n    return 0\n\nwstring_test  = \"Test message with 32 characters.\"\ni_length_test = [0]\ni_my_wstring_length(wstring_test, i_length_test)\nprint(\"The string:\\n\\\"{}\\\"\\ncontains {} character(s).\".format(wstring_test, *i_length_test))\ninput(\"\\nPress ENTER key to continue . . . \")\n</code></pre>\n", "abstract": ""}, {"id": 73913746, "score": 0, "vote": 0, "content": "<p>It can be pass with []</p>\n<p>dta=\"15252\"\nbody=[dta]</p>\n", "abstract": "It can be pass with [] dta=\"15252\"\nbody=[dta]"}, {"id": 73945173, "score": 0, "vote": 0, "content": "<p>There are already many great answers(or let's say opinions) about this and I've read them, but I want to mention a missing one. The one from <a href=\"https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference\" rel=\"nofollow noreferrer\">Python's documentation</a> in FAQ section. I don't know the date of publishing this page but this should be our true reference:</p>\n<blockquote>\n<p>Remember that arguments are <strong>passed by assignment</strong> in Python. Since\nassignment just creates references to objects, there\u2019s no alias\nbetween an argument name in the caller and callee, and so <strong>no\ncall-by-reference</strong> per se.</p>\n</blockquote>\n<p>If you have:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">a = SOMETHING\n\ndef fn(arg):\n    pass\n</code></pre>\n<p>and you call it like <code>fn(a)</code>, you're doing exactly what you do in assignment. So this happens:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">arg = a\n</code></pre>\n<p>Additional reference to <code>SOMETHING</code> is created. Variables are just symbols/names/references. They don't \"hold\" anything.</p>\n", "abstract": "There are already many great answers(or let's say opinions) about this and I've read them, but I want to mention a missing one. The one from Python's documentation in FAQ section. I don't know the date of publishing this page but this should be our true reference: Remember that arguments are passed by assignment in Python. Since\nassignment just creates references to objects, there\u2019s no alias\nbetween an argument name in the caller and callee, and so no\ncall-by-reference per se. If you have: and you call it like fn(a), you're doing exactly what you do in assignment. So this happens: Additional reference to SOMETHING is created. Variables are just symbols/names/references. They don't \"hold\" anything."}, {"id": 67891176, "score": -1, "vote": 0, "content": "<p>This might be an elegant object oriented solution without this functionality in Python.  An even more elegant solution would be to have any class you make subclass from this.  Or you could name it \"MasterClass\".  But instead of having a single variable and a single boolean, make them a collection of some kind.  I fixed the naming of your instance variables to comply with PEP 8.</p>\n<pre><code class=\"python\">class PassByReference:\n    def __init__(self, variable, pass_by_reference=True):\n        self._variable_original = 'Original'\n        self._variable = variable\n        self._pass_by_reference = pass_by_reference # False =&gt; pass_by_value\n        self.change(self.variable)\n        print(self)\n\n    def __str__(self):\n        print(self.get_variable())\n\n    def get_variable(self):\n        if pass_by_reference == True:\n            return self._variable\n        else:\n            return self._variable_original\n\n    def set_variable(self, something):\n        self._variable = something\n\n    def change(self, var):\n        self.set_variable(var)\n\ndef caller_method():\n\n    pbr = PassByReference(variable='Changed') # this will print 'Changed'\n    variable = pbr.get_variable() # this will assign value 'Changed'\n\n    pbr2 = PassByReference(variable='Changed', pass_by_reference=False) # this will print 'Original'\n    variable2 = pbr2.get_variable() # this will assign value 'Original'\n    \n</code></pre>\n", "abstract": "This might be an elegant object oriented solution without this functionality in Python.  An even more elegant solution would be to have any class you make subclass from this.  Or you could name it \"MasterClass\".  But instead of having a single variable and a single boolean, make them a collection of some kind.  I fixed the naming of your instance variables to comply with PEP 8."}, {"id": 67988352, "score": -1, "vote": 0, "content": "<p>I solved a similar requirement as follows:</p>\n<p>To implement a member function that changes a variable, dont pass the variable itself, but pass a <code>functools.partial</code> that contains <code>setattr</code> referring to the variable.\nCalling the <code>functools.partial</code> inside <code>change()</code> will execute <code>settatr</code> and change the actual referenced variable.</p>\n<p>Note that <code>setattr</code> needs the name of the variable as string.</p>\n<pre><code class=\"python\">class PassByReference(object):\n    def __init__(self):\n        self.variable = \"Original\"\n        print(self.variable)        \n        self.change(partial(setattr,self,\"variable\"))\n        print(self.variable)\n\n    def change(self, setter):\n        setter(\"Changed\")\n</code></pre>\n", "abstract": "I solved a similar requirement as follows: To implement a member function that changes a variable, dont pass the variable itself, but pass a functools.partial that contains setattr referring to the variable.\nCalling the functools.partial inside change() will execute settatr and change the actual referenced variable. Note that setattr needs the name of the variable as string."}, {"id": 69642519, "score": -1, "vote": 0, "content": "<p>Most of the time, the variable to be passed by reference is a class member.\nThe solution I suggest is to use a decorator to add both a field that is mutable and corresponding property. The field is a class wrapper around the variable.</p>\n<p>The <code>@refproperty</code> adds both <code>self._myvar</code> (mutable) and <code>self.myvar</code> property.</p>\n<pre><code class=\"python\">@refproperty('myvar')\nclass T():\n    pass\n\ndef f(x):\n   x.value=6\n\ny=T()\ny.myvar=3\nf(y._myvar)\nprint(y.myvar) \n</code></pre>\n<p>It will print 6.</p>\n<p>Compare this to:</p>\n<pre><code class=\"python\">class X:\n   pass\n\nx=X()\nx.myvar=4\n\ndef f(y):\n    y=6\n\nf(x.myvar)\nprint(x.myvar) \n</code></pre>\n<p>In this case, it won't work. It will print 4.</p>\n<p>The code is the following:</p>\n<pre><code class=\"python\">def refproperty(var,value=None):\n    def getp(self):\n        return getattr(self,'_'+var).get(self)\n\n    def setp(self,v):\n        return getattr(self,'_'+var).set(self,v)\n\n    def decorator(klass):\n        orginit=klass.__init__\n        setattr(klass,var,property(getp,setp))\n\n        def newinit(self,*args,**kw):\n            rv=RefVar(value)\n            setattr(self,'_'+var,rv)\n            orginit(self,*args,**kw)\n\n        klass.__init__=newinit\n        return klass\n    return decorator\n\nclass RefVar(object):\n    def __init__(self, value=None):\n        self.value = value\n    def get(self,*args):\n        return self.value\n    def set(self,main, value):\n        self.value = value\n</code></pre>\n", "abstract": "Most of the time, the variable to be passed by reference is a class member.\nThe solution I suggest is to use a decorator to add both a field that is mutable and corresponding property. The field is a class wrapper around the variable. The @refproperty adds both self._myvar (mutable) and self.myvar property. It will print 6. Compare this to: In this case, it won't work. It will print 4. The code is the following:"}, {"id": 70007855, "score": -1, "vote": 0, "content": "<p>Simple Answer:</p>\n<p>In python like c++, when you create an object instance and pass it as a parameter, no copies of the instance itself get made, so you are referencing the same instance from outside and inside the function and are able to modify the component datums of the same object instance,hence changes are visible to the outside.</p>\n<p>For basic types, python and c++ also behave the same to each other, in that copies of the instances are now made, so the outside sees/modifies a different instance than the inside of the function. Hence changes from the inside are not visible on the outside.</p>\n<p>Here comes the real difference between python and c++:</p>\n<p>c++ has the concept of address pointers, and c++ allows you to pass pointers instead, which bypasses the copying of basic types, so that the inside of the function can affect the same instances as those outside, so that the changes are also visible to the outside. This has no equivalent in python, so is not possible without workarounds (such as creating wrapper types).</p>\n<p>Such pointers can be useful in python, but it's not as necessary as it is in c++, because in c++, you can only return a single entity, whereas in python you can return multiple values separated by commas (ie a tuple). So in python, if you have variables a,b, and c, and want a function to modify them persistently (relative to the outside), you would do this:</p>\n<pre><code class=\"python\">a=4\nb=3\nc=8\n\na,b,c=somefunc(a,b,c)\n# a,b,c now have different values here\n</code></pre>\n<p>Such syntax is not easily possible in c++, thus in c++ you would do this instead:</p>\n<pre><code class=\"python\">int a=4\nint b=3\nint c=8\nsomefunc(&amp;a,&amp;b,&amp;c)\n// a,b,c now have different values here\n</code></pre>\n", "abstract": "Simple Answer: In python like c++, when you create an object instance and pass it as a parameter, no copies of the instance itself get made, so you are referencing the same instance from outside and inside the function and are able to modify the component datums of the same object instance,hence changes are visible to the outside. For basic types, python and c++ also behave the same to each other, in that copies of the instances are now made, so the outside sees/modifies a different instance than the inside of the function. Hence changes from the inside are not visible on the outside. Here comes the real difference between python and c++: c++ has the concept of address pointers, and c++ allows you to pass pointers instead, which bypasses the copying of basic types, so that the inside of the function can affect the same instances as those outside, so that the changes are also visible to the outside. This has no equivalent in python, so is not possible without workarounds (such as creating wrapper types). Such pointers can be useful in python, but it's not as necessary as it is in c++, because in c++, you can only return a single entity, whereas in python you can return multiple values separated by commas (ie a tuple). So in python, if you have variables a,b, and c, and want a function to modify them persistently (relative to the outside), you would do this: Such syntax is not easily possible in c++, thus in c++ you would do this instead:"}, {"id": 72357404, "score": -1, "vote": 0, "content": "<p>I share another fun way for people to comprehend this topic over a handy tool - <a href=\"https://pythontutor.com/\" rel=\"nofollow noreferrer\">VISUALIZE PYTHON CODE EXECUTION</a> based on the example of passing a mutable list from @Mark Ransom</p>\n<p>Just play it around, and then you will figure it out.</p>\n<ol>\n<li>Passing a String</li>\n</ol>\n<p><a href=\"https://i.stack.imgur.com/hBgao.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/hBgao.png\"/></a></p>\n<ol start=\"2\">\n<li>Passing a List</li>\n</ol>\n<p><a href=\"https://i.stack.imgur.com/7ofdY.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/7ofdY.png\"/></a></p>\n", "abstract": "I share another fun way for people to comprehend this topic over a handy tool - VISUALIZE PYTHON CODE EXECUTION based on the example of passing a mutable list from @Mark Ransom Just play it around, and then you will figure it out.  "}]}, {"link": "https://stackoverflow.com/questions/2612802/how-do-i-clone-a-list-so-that-it-doesnt-change-unexpectedly-after-assignment", "question": {"id": "2612802", "title": "How do I clone a list so that it doesn&#39;t change unexpectedly after assignment?", "content": "<p>While using <code>new_list = my_list</code>, any modifications to <code>new_list</code> changes <code>my_list</code> every time. Why is this, and how can I clone or copy the list to prevent it?</p>\n", "abstract": "While using new_list = my_list, any modifications to new_list changes my_list every time. Why is this, and how can I clone or copy the list to prevent it?"}, "answers": [{"id": 2612815, "score": 3898, "vote": 0, "content": "<p><code>new_list = my_list</code> doesn't actually create a second list. The assignment just copies the reference to the list, not the actual list, so both <code>new_list</code> and <code>my_list</code> refer to the same list after the assignment.</p>\n<p>To actually copy the list, you have several options:</p>\n<ul>\n<li><p>You can use the builtin <a href=\"https://docs.python.org/library/stdtypes.html#mutable-sequence-types\" rel=\"noreferrer\"><code>list.copy()</code></a> method (available since Python 3.3):</p>\n<pre><code class=\"python\">new_list = old_list.copy()\n</code></pre>\n</li>\n<li><p>You can slice it:</p>\n<pre><code class=\"python\">new_list = old_list[:]\n</code></pre>\n<p><a href=\"https://en.wikipedia.org/wiki/Alex_Martelli\" rel=\"noreferrer\">Alex Martelli</a>'s opinion (at least <a href=\"https://www.youtube.com/watch?v=g7V89K8QfgQ\" rel=\"noreferrer\">back in 2007</a>) about this is, that <em>it is a weird syntax and it does not make sense to use it ever</em>. ;) (In his opinion, the next one is more readable).</p>\n</li>\n<li><p>You can use the built in <a href=\"https://docs.python.org/library/stdtypes.html#list\" rel=\"noreferrer\"><code>list()</code></a> constructor:</p>\n<pre><code class=\"python\">new_list = list(old_list)\n</code></pre>\n</li>\n<li><p>You can use generic <a href=\"https://docs.python.org/library/copy.html#copy.copy\" rel=\"noreferrer\"><code>copy.copy()</code></a>:</p>\n<pre><code class=\"python\">import copy\nnew_list = copy.copy(old_list)\n</code></pre>\n<p>This is a little slower than <code>list()</code> because it has to find out the datatype of <code>old_list</code> first.</p>\n</li>\n<li><p>If you need to copy the elements of the list as well, use generic <a href=\"https://docs.python.org/library/copy.html#copy.deepcopy\" rel=\"noreferrer\"><code>copy.deepcopy()</code></a>:</p>\n<pre><code class=\"python\">import copy\nnew_list = copy.deepcopy(old_list)\n</code></pre>\n<p>Obviously the slowest and most memory-needing method, but sometimes unavoidable. This operates recursively; it will handle any number of levels of nested lists (or other containers).</p>\n</li>\n</ul>\n<p><strong>Example:</strong></p>\n<pre><code class=\"python\">import copy\n\nclass Foo(object):\n    def __init__(self, val):\n         self.val = val\n\n    def __repr__(self):\n        return f'Foo({self.val!r})'\n\nfoo = Foo(1)\n\na = ['foo', foo]\nb = a.copy()\nc = a[:]\nd = list(a)\ne = copy.copy(a)\nf = copy.deepcopy(a)\n\n# edit orignal list and instance \na.append('baz')\nfoo.val = 5\n\nprint(f'original: {a}\\nlist.copy(): {b}\\nslice: {c}\\nlist(): {d}\\ncopy: {e}\\ndeepcopy: {f}')\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">original: ['foo', Foo(5), 'baz']\nlist.copy(): ['foo', Foo(5)]\nslice: ['foo', Foo(5)]\nlist(): ['foo', Foo(5)]\ncopy: ['foo', Foo(5)]\ndeepcopy: ['foo', Foo(1)]\n</code></pre>\n", "abstract": "new_list = my_list doesn't actually create a second list. The assignment just copies the reference to the list, not the actual list, so both new_list and my_list refer to the same list after the assignment. To actually copy the list, you have several options: You can use the builtin list.copy() method (available since Python 3.3): You can slice it: Alex Martelli's opinion (at least back in 2007) about this is, that it is a weird syntax and it does not make sense to use it ever. ;) (In his opinion, the next one is more readable). You can use the built in list() constructor: You can use generic copy.copy(): This is a little slower than list() because it has to find out the datatype of old_list first. If you need to copy the elements of the list as well, use generic copy.deepcopy(): Obviously the slowest and most memory-needing method, but sometimes unavoidable. This operates recursively; it will handle any number of levels of nested lists (or other containers). Example: Result:"}, {"id": 2612990, "score": 735, "vote": 0, "content": "<p>Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:</p>\n<ol>\n<li>10.59 sec (105.9 \u00b5s/itn) -  <a href=\"http://docs.python.org/library/copy.html#copy.deepcopy\" rel=\"noreferrer\"><code>copy.deepcopy(old_list)</code></a></li>\n<li>10.16 sec (101.6 \u00b5s/itn) - pure Python <code>Copy()</code> method copying classes with deepcopy</li>\n<li>1.488 sec (14.88 \u00b5s/itn) - pure Python <code>Copy()</code> method not copying classes (only dicts/lists/tuples)</li>\n<li>0.325 sec (3.25 \u00b5s/itn) - <code>for item in old_list: new_list.append(item)</code></li>\n<li>0.217 sec (2.17 \u00b5s/itn) - <code>[i for i in old_list]</code> (a <a href=\"http://docs.python.org/tutorial/datastructures.html#list-comprehensions\" rel=\"noreferrer\">list comprehension</a>)</li>\n<li>0.186 sec (1.86 \u00b5s/itn) - <a href=\"http://docs.python.org/library/copy.html#copy.copy\" rel=\"noreferrer\"><code>copy.copy(old_list)</code></a></li>\n<li>0.075 sec (0.75 \u00b5s/itn) - <code>list(old_list)</code></li>\n<li>0.053 sec (0.53 \u00b5s/itn) - <code>new_list = []; new_list.extend(old_list)</code></li>\n<li>0.039 sec (0.39 \u00b5s/itn) - <code>old_list[:]</code> (<a href=\"http://docs.python.org/tutorial/introduction.html#lists\" rel=\"noreferrer\">list slicing</a>)</li>\n</ol>\n<p>So the fastest is list slicing. But be aware that <code>copy.copy()</code>, <code>list[:]</code> and <code>list(list)</code>, unlike <code>copy.deepcopy()</code> and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.</p>\n<p>(Here's the script if anyone's interested or wants to raise any issues:)</p>\n<pre><code class=\"python\">from copy import deepcopy\n\nclass old_class:\n    def __init__(self):\n        self.blah = 'blah'\n\nclass new_class(object):\n    def __init__(self):\n        self.blah = 'blah'\n\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\n\n    if t in (list, tuple):\n        if t == tuple:\n            # Convert to a list if a tuple to\n            # allow assigning to when copying\n            is_tuple = True\n            obj = list(obj)\n        else:\n            # Otherwise just do a quick slice copy\n            obj = obj[:]\n            is_tuple = False\n\n        # Copy each item recursively\n        for x in xrange(len(obj)):\n            if type(obj[x]) in dignore:\n                continue\n            obj[x] = Copy(obj[x], use_deepcopy)\n\n        if is_tuple:\n            # Convert back into a tuple again\n            obj = tuple(obj)\n\n    elif t == dict:\n        # Use the fast shallow dict copy() method and copy any\n        # values which aren't immutable (like lists, dicts etc)\n        obj = obj.copy()\n        for k in obj:\n            if type(obj[k]) in dignore:\n                continue\n            obj[k] = Copy(obj[k], use_deepcopy)\n\n    elif t in dignore:\n        # Numeric or string/unicode?\n        # It's immutable, so ignore it!\n        pass\n\n    elif use_deepcopy:\n        obj = deepcopy(obj)\n    return obj\n\nif __name__ == '__main__':\n    import copy\n    from time import time\n\n    num_times = 100000\n    L = [None, 'blah', 1, 543.4532,\n         ['foo'], ('bar',), {'blah': 'blah'},\n         old_class(), new_class()]\n\n    t = time()\n    for i in xrange(num_times):\n        Copy(L)\n    print 'Custom Copy:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        Copy(L, use_deepcopy=False)\n    print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        copy.copy(L)\n    print 'copy.copy:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        copy.deepcopy(L)\n    print 'copy.deepcopy:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        L[:]\n    print 'list slicing [:]:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        list(L)\n    print 'list(L):', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        [i for i in L]\n    print 'list expression(L):', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        a = []\n        a.extend(L)\n    print 'list extend:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        a = []\n        for y in L:\n            a.append(y)\n    print 'list append:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        a = []\n        a.extend(i for i in L)\n    print 'generator expression extend:', time()-t\n</code></pre>\n", "abstract": "Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods: So the fastest is list slicing. But be aware that copy.copy(), list[:] and list(list), unlike copy.deepcopy() and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa. (Here's the script if anyone's interested or wants to raise any issues:)"}, {"id": 17810305, "score": 179, "vote": 0, "content": "<p>I've <a href=\"http://mail.python.org/pipermail/python-ideas/2013-July/022368.html\" rel=\"noreferrer\">been told</a> that Python 3.3+ <a href=\"http://bugs.python.org/issue10516\" rel=\"noreferrer\">adds the <code>list.copy()</code></a> method, which should be as fast as slicing:</p>\n<pre><code class=\"python\">newlist = old_list.copy()\n</code></pre>\n", "abstract": "I've been told that Python 3.3+ adds the list.copy() method, which should be as fast as slicing:"}, {"id": 26562235, "score": 149, "vote": 0, "content": "<blockquote>\n<h1>What are the options to clone or copy a list in Python?</h1>\n</blockquote>\n<p>In Python 3, a shallow copy can be made with:</p>\n<pre><code class=\"python\">a_copy = a_list.copy()\n</code></pre>\n<p>In Python 2 and 3, you can get a shallow copy with a full slice of the original:</p>\n<pre><code class=\"python\">a_copy = a_list[:]\n</code></pre>\n<h2>Explanation</h2>\n<p>There are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects.</p>\n<h2>Shallow list copy</h2>\n<p>A shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists. </p>\n<p>There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3.</p>\n<h3>Python 2</h3>\n<p>In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original:</p>\n<pre><code class=\"python\">a_copy = a_list[:]\n</code></pre>\n<p>You can also accomplish the same thing by passing the list through the list constructor, </p>\n<pre><code class=\"python\">a_copy = list(a_list)\n</code></pre>\n<p>but using the constructor is less efficient:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; timeit\n&gt;&gt;&gt; l = range(20)\n&gt;&gt;&gt; min(timeit.repeat(lambda: l[:]))\n0.30504298210144043\n&gt;&gt;&gt; min(timeit.repeat(lambda: list(l)))\n0.40698814392089844\n</code></pre>\n<h3>Python 3</h3>\n<p>In Python 3, lists get the <code>list.copy</code> method:</p>\n<pre><code class=\"python\">a_copy = a_list.copy()\n</code></pre>\n<p>In Python 3.5:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; l = list(range(20))\n&gt;&gt;&gt; min(timeit.repeat(lambda: l[:]))\n0.38448613602668047\n&gt;&gt;&gt; min(timeit.repeat(lambda: list(l)))\n0.6309100328944623\n&gt;&gt;&gt; min(timeit.repeat(lambda: l.copy()))\n0.38122922903858125\n</code></pre>\n<h2>Making another pointer does <em>not</em> make a copy</h2>\n<blockquote>\n<p><strong>Using new_list = my_list then modifies new_list every time my_list changes. Why is this?</strong></p>\n</blockquote>\n<p><code>my_list</code> is just a name that points to the actual list in memory. When you say <code>new_list = my_list</code> you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists. </p>\n<pre><code class=\"python\">&gt;&gt;&gt; l = [[], [], []]\n&gt;&gt;&gt; l_copy = l[:]\n&gt;&gt;&gt; l_copy\n[[], [], []]\n&gt;&gt;&gt; l_copy[0].append('foo')\n&gt;&gt;&gt; l_copy\n[['foo'], [], []]\n&gt;&gt;&gt; l\n[['foo'], [], []]\n</code></pre>\n<p>The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy.</p>\n<h2>Deep copies</h2>\n<p>To make a <a href=\"https://docs.python.org/library/copy.html\" rel=\"noreferrer\">deep copy of a list, in Python 2 or 3, use <code>deepcopy</code> in the <code>copy</code> module</a>:</p>\n<pre><code class=\"python\">import copy\na_deep_copy = copy.deepcopy(a_list)\n</code></pre>\n<p>To demonstrate how this allows us to make new sub-lists:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import copy\n&gt;&gt;&gt; l\n[['foo'], [], []]\n&gt;&gt;&gt; l_deep_copy = copy.deepcopy(l)\n&gt;&gt;&gt; l_deep_copy[0].pop()\n'foo'\n&gt;&gt;&gt; l_deep_copy\n[[], [], []]\n&gt;&gt;&gt; l\n[['foo'], [], []]\n</code></pre>\n<p>And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function.</p>\n<h2>Don't use <code>eval</code></h2>\n<p>You may see this used as a way to deepcopy, but don't do it:</p>\n<pre><code class=\"python\">problematic_deep_copy = eval(repr(a_list))\n</code></pre>\n<ol>\n<li>It's dangerous, particularly if you're evaluating something from a source you don't trust.</li>\n<li>It's not reliable, if a subelement you're copying doesn't have a representation that can be eval'd to reproduce an equivalent element.</li>\n<li>It's also less performant. </li>\n</ol>\n<p>In 64 bit Python 2.7:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; import copy\n&gt;&gt;&gt; l = range(10)\n&gt;&gt;&gt; min(timeit.repeat(lambda: copy.deepcopy(l)))\n27.55826997756958\n&gt;&gt;&gt; min(timeit.repeat(lambda: eval(repr(l))))\n29.04534101486206\n</code></pre>\n<p>on 64 bit Python 3.5:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; import copy\n&gt;&gt;&gt; l = list(range(10))\n&gt;&gt;&gt; min(timeit.repeat(lambda: copy.deepcopy(l)))\n16.84255409205798\n&gt;&gt;&gt; min(timeit.repeat(lambda: eval(repr(l))))\n34.813894678023644\n</code></pre>\n", "abstract": "In Python 3, a shallow copy can be made with: In Python 2 and 3, you can get a shallow copy with a full slice of the original: There are two semantic ways to copy a list. A shallow copy creates a new list of the same objects, a deep copy creates a new list containing new equivalent objects. A shallow copy only copies the list itself, which is a container of references to the objects in the list. If the objects contained themselves are mutable and one is changed, the change will be reflected in both lists.  There are different ways to do this in Python 2 and 3. The Python 2 ways will also work in Python 3. In Python 2, the idiomatic way of making a shallow copy of a list is with a complete slice of the original: You can also accomplish the same thing by passing the list through the list constructor,  but using the constructor is less efficient: In Python 3, lists get the list.copy method: In Python 3.5: Using new_list = my_list then modifies new_list every time my_list changes. Why is this? my_list is just a name that points to the actual list in memory. When you say new_list = my_list you're not making a copy, you're just adding another name that points at that original list in memory. We can have similar issues when we make copies of lists.  The list is just an array of pointers to the contents, so a shallow copy just copies the pointers, and so you have two different lists, but they have the same contents. To make copies of the contents, you need a deep copy. To make a deep copy of a list, in Python 2 or 3, use deepcopy in the copy module: To demonstrate how this allows us to make new sub-lists: And so we see that the deep copied list is an entirely different list from the original. You could roll your own function - but don't. You're likely to create bugs you otherwise wouldn't have by using the standard library's deepcopy function. You may see this used as a way to deepcopy, but don't do it: In 64 bit Python 2.7: on 64 bit Python 3.5:"}, {"id": 47258728, "score": 72, "vote": 0, "content": "<p>Let's start from the beginning and explore this question.</p>\n<p>So let's suppose you have two lists:</p>\n<pre><code class=\"python\">list_1 = ['01', '98']\nlist_2 = [['01', '98']]\n</code></pre>\n<p>And we have to copy both lists, now starting from the first list:</p>\n<p>So first let's try by setting the variable <code>copy</code> to our original list, <code>list_1</code>:</p>\n<pre><code class=\"python\">copy = list_1\n</code></pre>\n<p>Now if you are thinking copy copied the <em>list_1</em>, then you are wrong. The <code>id</code> function can show us if two variables can point to the same object. Let's try this:</p>\n<pre><code class=\"python\">print(id(copy))\nprint(id(list_1))\n</code></pre>\n<p>The output is:</p>\n<pre><code class=\"python\">4329485320\n4329485320\n</code></pre>\n<p>Both variables are the exact same argument. Are you surprised?</p>\n<p>So as we know, Python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is a <code>list</code> but we created two references to that same object by two different variable names. This means that both variables are pointing to the same object, just with different names.</p>\n<p>When you do <code>copy = list_1</code>, it is actually doing:</p>\n<p><a href=\"https://i.stack.imgur.com/vNGqw.jpg\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/vNGqw.jpg\"/></a></p>\n<p>Here in the image <em>list_1</em> and <em>copy</em> are two variable names, but the object is same for both variable which is <code>list</code>.</p>\n<p>So if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list:</p>\n<pre><code class=\"python\">copy[0] = \"modify\"\n\nprint(copy)\nprint(list_1)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">['modify', '98']\n['modify', '98']\n</code></pre>\n<p>So it modified the original list:</p>\n<p>Now let's move onto a Pythonic method for copying lists.</p>\n<pre><code class=\"python\">copy_1 = list_1[:]\n</code></pre>\n<p>This method fixes the first issue we had:</p>\n<pre><code class=\"python\">print(id(copy_1))\nprint(id(list_1))\n\n4338792136\n4338791432\n</code></pre>\n<p>So as we can see our both list having different id and it means that both variables are pointing to different objects. So what actually going on here is:</p>\n<p><a href=\"https://i.stack.imgur.com/iitLk.jpg\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/iitLk.jpg\"/></a></p>\n<p>Now let's try to modify the list and let's see if we still face the previous problem:</p>\n<pre><code class=\"python\">copy_1[0] = \"modify\"\n\nprint(list_1)\nprint(copy_1)\n</code></pre>\n<p>The output is:</p>\n<pre><code class=\"python\">['01', '98']\n['modify', '98']\n</code></pre>\n<p>As you can see, it only modified the copied list. That means it worked.</p>\n<p>Do you think we're done? No. Let's try to copy our nested list.</p>\n<pre><code class=\"python\">copy_2 = list_2[:]\n</code></pre>\n<p><code>list_2</code> should reference to another object which is copy of <code>list_2</code>. Let's check:</p>\n<pre><code class=\"python\">print(id((list_2)), id(copy_2))\n</code></pre>\n<p>We get the output:</p>\n<pre><code class=\"python\">4330403592 4330403528\n</code></pre>\n<p>Now we can assume both lists are pointing different object, so now let's try to modify it and let's see it is giving what we want:</p>\n<pre><code class=\"python\">copy_2[0][1] = \"modify\"\n\nprint(list_2, copy_2)\n</code></pre>\n<p>This gives us the output:</p>\n<pre><code class=\"python\">[['01', 'modify']] [['01', 'modify']]\n</code></pre>\n<p>This may seem a little bit confusing, because the same method we previously used worked. Let's try to understand this.</p>\n<p>When you do:</p>\n<pre><code class=\"python\">copy_2 = list_2[:]\n</code></pre>\n<p>You're only copying the outer list, not the inside list. We can use the <code>id</code> function once again to check this.</p>\n<pre><code class=\"python\">print(id(copy_2[0]))\nprint(id(list_2[0]))\n</code></pre>\n<p>The output is:</p>\n<pre><code class=\"python\">4329485832\n4329485832\n</code></pre>\n<p>When we do <code>copy_2 = list_2[:]</code>, this happens:</p>\n<p><a href=\"https://i.stack.imgur.com/3hPti.jpg\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/3hPti.jpg\"/></a></p>\n<p>It creates the copy of list, but only outer list copy, not the nested list copy. The nested list is same for both variable, so if you try to modify the nested list then it will modify the original list too as the nested list object is same for both lists.</p>\n<p>What is the solution? The solution is the <code>deepcopy</code> function.</p>\n<pre><code class=\"python\">from copy import deepcopy\ndeep = deepcopy(list_2)\n</code></pre>\n<p>Let's check this:</p>\n<pre><code class=\"python\">print(id((list_2)), id(deep))\n\n4322146056 4322148040\n</code></pre>\n<p>Both outer lists have different IDs. Let's try this on the inner nested lists.</p>\n<pre><code class=\"python\">print(id(deep[0]))\nprint(id(list_2[0]))\n</code></pre>\n<p>The output is:</p>\n<pre><code class=\"python\">4322145992\n4322145800\n</code></pre>\n<p>As you can see both IDs are different, meaning we can assume that both nested lists are pointing different object now.</p>\n<p>This means when you do <code>deep = deepcopy(list_2)</code> what actually happens:</p>\n<p><a href=\"https://i.stack.imgur.com/O7yoo.jpg\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/O7yoo.jpg\"/></a></p>\n<p>Both nested lists are pointing different object and they have separate copy of nested list now.</p>\n<p>Now let's try to modify the nested list and see if it solved the previous issue or not:</p>\n<pre><code class=\"python\">deep[0][1] = \"modify\"\nprint(list_2, deep)\n</code></pre>\n<p>It outputs:</p>\n<pre><code class=\"python\">[['01', '98']] [['01', 'modify']]\n</code></pre>\n<p>As you can see, it didn't modify the original nested list, it only modified the copied list.</p>\n", "abstract": "Let's start from the beginning and explore this question. So let's suppose you have two lists: And we have to copy both lists, now starting from the first list: So first let's try by setting the variable copy to our original list, list_1: Now if you are thinking copy copied the list_1, then you are wrong. The id function can show us if two variables can point to the same object. Let's try this: The output is: Both variables are the exact same argument. Are you surprised? So as we know, Python doesn't store anything in a variable, Variables are just referencing to the object and object store the value. Here object is a list but we created two references to that same object by two different variable names. This means that both variables are pointing to the same object, just with different names. When you do copy = list_1, it is actually doing:  Here in the image list_1 and copy are two variable names, but the object is same for both variable which is list. So if you try to modify copied list then it will modify the original list too because the list is only one there, you will modify that list no matter you do from the copied list or from the original list: Output: So it modified the original list: Now let's move onto a Pythonic method for copying lists. This method fixes the first issue we had: So as we can see our both list having different id and it means that both variables are pointing to different objects. So what actually going on here is:  Now let's try to modify the list and let's see if we still face the previous problem: The output is: As you can see, it only modified the copied list. That means it worked. Do you think we're done? No. Let's try to copy our nested list. list_2 should reference to another object which is copy of list_2. Let's check: We get the output: Now we can assume both lists are pointing different object, so now let's try to modify it and let's see it is giving what we want: This gives us the output: This may seem a little bit confusing, because the same method we previously used worked. Let's try to understand this. When you do: You're only copying the outer list, not the inside list. We can use the id function once again to check this. The output is: When we do copy_2 = list_2[:], this happens:  It creates the copy of list, but only outer list copy, not the nested list copy. The nested list is same for both variable, so if you try to modify the nested list then it will modify the original list too as the nested list object is same for both lists. What is the solution? The solution is the deepcopy function. Let's check this: Both outer lists have different IDs. Let's try this on the inner nested lists. The output is: As you can see both IDs are different, meaning we can assume that both nested lists are pointing different object now. This means when you do deep = deepcopy(list_2) what actually happens:  Both nested lists are pointing different object and they have separate copy of nested list now. Now let's try to modify the nested list and see if it solved the previous issue or not: It outputs: As you can see, it didn't modify the original nested list, it only modified the copied list."}, {"id": 27091494, "score": 66, "vote": 0, "content": "<p>There are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed. </p>\n<p>Python doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by <code>my_list</code> and bound it to <code>new_list</code> as well. No matter which name you use there is still only one list, so changes made when referring to it as <code>my_list</code> will persist when referring to it as <code>new_list</code>. Each of the other answers to this question give you different ways of creating a new object to bind to <code>new_list</code>. </p>\n<p>Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before.</p>\n<pre><code class=\"python\">new_list = list(my_list)  # or my_list[:], but I prefer this syntax\n# is simply a shorter way of:\nnew_list = [element for element in my_list]\n</code></pre>\n<p>To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list. </p>\n<pre><code class=\"python\">import copy  \n# each element must have __copy__ defined for this...\nnew_list = [copy.copy(element) for element in my_list]\n</code></pre>\n<p>This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy. </p>\n<pre><code class=\"python\">import copy\n# each element must have __deepcopy__ defined for this...\nnew_list = copy.deepcopy(my_list)\n</code></pre>\n<p>See <a href=\"https://docs.python.org/3/library/copy.html\" rel=\"noreferrer\">the documentation</a> for more information about corner cases in copying.</p>\n", "abstract": "There are many answers already that tell you how to make a proper copy, but none of them say why your original 'copy' failed.  Python doesn't store values in variables; it binds names to objects. Your original assignment took the object referred to by my_list and bound it to new_list as well. No matter which name you use there is still only one list, so changes made when referring to it as my_list will persist when referring to it as new_list. Each of the other answers to this question give you different ways of creating a new object to bind to new_list.  Each element of a list acts like a name, in that each element binds non-exclusively to an object. A shallow copy creates a new list whose elements bind to the same objects as before. To take your list copy one step further, copy each object that your list refers to, and bind those element copies to a new list.  This is not yet a deep copy, because each element of a list may refer to other objects, just like the list is bound to its elements. To recursively copy every element in the list, and then each other object referred to by each element, and so on: perform a deep copy.  See the documentation for more information about corner cases in copying."}, {"id": 2612808, "score": 48, "vote": 0, "content": "<p>Use <code>thing[:]</code></p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = [1,2]\n&gt;&gt;&gt; b = a[:]\n&gt;&gt;&gt; a += [3]\n&gt;&gt;&gt; a\n[1, 2, 3]\n&gt;&gt;&gt; b\n[1, 2]\n&gt;&gt;&gt; \n</code></pre>\n", "abstract": "Use thing[:]"}, {"id": 43220129, "score": 42, "vote": 0, "content": "<h2>Python 3.6 Timings</h2>\n<p>Here are the timing results using Python 3.6.8. Keep in mind these times are relative to one another, not absolute.</p>\n<p>I stuck to only doing shallow copies, and also added some new methods that weren't possible in Python\u00a02, such as <code>list.copy()</code> (the Python\u00a03 <a href=\"https://mail.python.org/pipermail/python-ideas/2013-July/022368.html\" rel=\"noreferrer\">slice equivalent</a>) and two forms of <a href=\"https://stackoverflow.com/questions/43190992/understanding-x-lst\">list unpacking</a> (<code>*new_list, = list</code> and <code>new_list = [*list]</code>):</p>\n<pre><code class=\"python\">METHOD                TIME TAKEN\nb = [*a]               2.75180600000021\nb = a * 1              3.50215399999990\nb = a[:]               3.78278899999986  # Python 2 winner (see above)\nb = a.copy()           4.20556500000020  # Python 3 \"slice equivalent\" (see above)\nb = []; b.extend(a)    4.68069800000012\nb = a[0:len(a)]        6.84498999999959\n*b, = a                7.54031799999984\nb = list(a)            7.75815899999997\nb = [i for i in a]    18.4886440000000\nb = copy.copy(a)      18.8254879999999\nb = []\nfor item in a:\n  b.append(item)      35.4729199999997\n</code></pre>\n<p>We can see the Python 2 winner still does well, but doesn't edge out Python 3 <code>list.copy()</code> by much, especially considering the superior readability of the latter.</p>\n<p>The dark horse is the unpacking and repacking method (<code>b = [*a]</code>), which is ~25% faster than raw slicing, and more than twice as fast as the other unpacking method (<code>*b, = a</code>).</p>\n<p><code>b = a * 1</code> also does surprisingly well.</p>\n<p><strong>Note that these methods do <em>not</em> output equivalent results for any input other than lists.</strong> They all work for sliceable objects, a few work for any iterable, but only <code>copy.copy()</code> works for more general Python objects.</p>\n<hr/>\n<p>Here is the testing code for interested parties (<a href=\"https://stackoverflow.com/questions/13047895/efficient-ways-to-duplicate-array-list-in-python\">Template from here</a>):</p>\n<pre><code class=\"python\">import timeit\n\nCOUNT = 50000000\nprint(\"Array duplicating. Tests run\", COUNT, \"times\")\nsetup = 'a = [0,1,2,3,4,5,6,7,8,9]; import copy'\n\nprint(\"b = list(a)\\t\\t\", timeit.timeit(stmt='b = list(a)', setup=setup, number=COUNT))\nprint(\"b = copy.copy(a)\\t\", timeit.timeit(stmt='b = copy.copy(a)', setup=setup, number=COUNT))\nprint(\"b = a.copy()\\t\\t\", timeit.timeit(stmt='b = a.copy()', setup=setup, number=COUNT))\nprint(\"b = a[:]\\t\\t\", timeit.timeit(stmt='b = a[:]', setup=setup, number=COUNT))\nprint(\"b = a[0:len(a)]\\t\\t\", timeit.timeit(stmt='b = a[0:len(a)]', setup=setup, number=COUNT))\nprint(\"*b, = a\\t\\t\\t\", timeit.timeit(stmt='*b, = a', setup=setup, number=COUNT))\nprint(\"b = []; b.extend(a)\\t\", timeit.timeit(stmt='b = []; b.extend(a)', setup=setup, number=COUNT))\nprint(\"b = []; for item in a: b.append(item)\\t\", timeit.timeit(stmt='b = []\\nfor item in a:  b.append(item)', setup=setup, number=COUNT))\nprint(\"b = [i for i in a]\\t\", timeit.timeit(stmt='b = [i for i in a]', setup=setup, number=COUNT))\nprint(\"b = [*a]\\t\\t\", timeit.timeit(stmt='b = [*a]', setup=setup, number=COUNT))\nprint(\"b = a * 1\\t\\t\", timeit.timeit(stmt='b = a * 1', setup=setup, number=COUNT))\n</code></pre>\n", "abstract": "Here are the timing results using Python 3.6.8. Keep in mind these times are relative to one another, not absolute. I stuck to only doing shallow copies, and also added some new methods that weren't possible in Python\u00a02, such as list.copy() (the Python\u00a03 slice equivalent) and two forms of list unpacking (*new_list, = list and new_list = [*list]): We can see the Python 2 winner still does well, but doesn't edge out Python 3 list.copy() by much, especially considering the superior readability of the latter. The dark horse is the unpacking and repacking method (b = [*a]), which is ~25% faster than raw slicing, and more than twice as fast as the other unpacking method (*b, = a). b = a * 1 also does surprisingly well. Note that these methods do not output equivalent results for any input other than lists. They all work for sliceable objects, a few work for any iterable, but only copy.copy() works for more general Python objects. Here is the testing code for interested parties (Template from here):"}, {"id": 2612810, "score": 36, "vote": 0, "content": "<p>Python's idiom for doing this is <code>newList = oldList[:]</code></p>\n", "abstract": "Python's idiom for doing this is newList = oldList[:]"}, {"id": 31332158, "score": 21, "vote": 0, "content": "<p>All of the other contributors gave <strong>great</strong> answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only <code>copy.deepcopy()</code> works to clone/copy a list and not have it point to the nested <code>list</code> objects when you are working with multidimensional, nested lists (list of lists). While <a href=\"https://stackoverflow.com/users/218196/felix-kling\">Felix Kling</a> refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to <code>deepcopy</code>.</p>\n<p>While <code>new_list = old_list[:]</code>, <code>copy.copy(old_list)'</code> and for Py3k <code>old_list.copy()</code> work for single-leveled lists, they revert to pointing at the <code>list</code> objects nested within the <code>old_list</code> and the <code>new_list</code>, and changes to one of the <code>list</code> objects are perpetuated in the other.</p>\n<h1>Edit: New information brought to light</h1>\n<blockquote>\n<p>As was pointed out by both <a href=\"https://stackoverflow.com/users/541136/aaron-hall\">Aaron Hall</a> and <a href=\"https://stackoverflow.com/users/4014959/pm-2ring\">PM 2Ring</a> <strong>using <code>eval()</code> is not only a bad idea, it is also much slower than <code>copy.deepcopy()</code>.</strong></p>\n<p>This means that for multidimensional lists, the only option is <code>copy.deepcopy()</code>. With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to <code>timeit</code> using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post.</p>\n<p>It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated.</p>\n</blockquote>\n<p>As others have stated, there  <em><strong>are significant</strong></em> performance issues using the <code>copy</code> module and <code>copy.deepcopy</code> <em><strong>for multidimensional lists</strong></em>.</p>\n", "abstract": "All of the other contributors gave great answers, which work when you have a single dimension (leveled) list, however of the methods mentioned so far, only copy.deepcopy() works to clone/copy a list and not have it point to the nested list objects when you are working with multidimensional, nested lists (list of lists). While Felix Kling refers to it in his answer, there is a little bit more to the issue and possibly a workaround using built-ins that might prove a faster alternative to deepcopy. While new_list = old_list[:], copy.copy(old_list)' and for Py3k old_list.copy() work for single-leveled lists, they revert to pointing at the list objects nested within the old_list and the new_list, and changes to one of the list objects are perpetuated in the other. As was pointed out by both Aaron Hall and PM 2Ring using eval() is not only a bad idea, it is also much slower than copy.deepcopy(). This means that for multidimensional lists, the only option is copy.deepcopy(). With that being said, it really isn't an option as the performance goes way south when you try to use it on a moderately sized multidimensional array.  I tried to timeit using a 42x42 array, not unheard of or even that large for bioinformatics applications, and I gave up on waiting for a response and just started typing my edit to this post. It would seem that the only real option then is to initialize multiple lists and work on them independently. If anyone has any other suggestions, for how to handle multidimensional list copying, it would be appreciated. As others have stated, there  are significant performance issues using the copy module and copy.deepcopy for multidimensional lists."}, {"id": 48980683, "score": 16, "vote": 0, "content": "<p>It surprises me that this hasn't been mentioned yet, so for the sake of completeness...</p>\n<p>You can perform list unpacking with the \"splat operator\": <code>*</code>, which will also copy elements of your list.</p>\n<pre><code class=\"python\">old_list = [1, 2, 3]\n\nnew_list = [*old_list]\n\nnew_list.append(4)\nold_list == [1, 2, 3]\nnew_list == [1, 2, 3, 4]\n</code></pre>\n<p>The obvious downside to this method is that it is only available in Python 3.5+.</p>\n<p>Timing wise though, this appears to perform better than other common methods.</p>\n<pre><code class=\"python\">x = [random.random() for _ in range(1000)]\n\n%timeit a = list(x)\n%timeit a = x.copy()\n%timeit a = x[:]\n\n%timeit a = [*x]\n\n#: 2.47 \u00b5s \u00b1 38.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n#: 2.47 \u00b5s \u00b1 54.6 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n#: 2.39 \u00b5s \u00b1 58.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\n#: 2.22 \u00b5s \u00b1 43.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n</code></pre>\n", "abstract": "It surprises me that this hasn't been mentioned yet, so for the sake of completeness... You can perform list unpacking with the \"splat operator\": *, which will also copy elements of your list. The obvious downside to this method is that it is only available in Python 3.5+. Timing wise though, this appears to perform better than other common methods."}, {"id": 44768652, "score": 14, "vote": 0, "content": "<pre><code class=\"python\">new_list = my_list[:]\n</code></pre>\n<p><code>new_list = my_list</code></p>\n<p>Try to understand this. Let's say that <em>my_list</em> is in the heap memory at location X, i.e., <em>my_list</em> is pointing to the X. Now by assigning <code>new_list = my_list</code> you're letting <em>new_list</em> point to the X. This is known as a <em>shallow copy</em>.</p>\n<p>Now if you assign <code>new_list = my_list[:]</code>, you're simply copying each object of <em>my_list</em> to <em>new_list</em>. This is known as a <em>deep copy</em>.</p>\n<p>The <em>other</em> ways you can do this are:</p>\n<ul>\n<li>\n<pre><code class=\"python\">new_list = list(old_list)\n</code></pre>\n</li>\n<li>\n<pre><code class=\"python\">import copy\nnew_list = copy.deepcopy(old_list)\n</code></pre>\n</li>\n</ul>\n", "abstract": "new_list = my_list Try to understand this. Let's say that my_list is in the heap memory at location X, i.e., my_list is pointing to the X. Now by assigning new_list = my_list you're letting new_list point to the X. This is known as a shallow copy. Now if you assign new_list = my_list[:], you're simply copying each object of my_list to new_list. This is known as a deep copy. The other ways you can do this are:"}, {"id": 47050612, "score": 12, "vote": 0, "content": "<p>A very simple approach independent of python version was missing in already-given answers which you can use most of the time (at least I do):</p>\n<pre><code class=\"python\">new_list = my_list * 1       # Solution 1 when you are not using nested lists\n</code></pre>\n<p>However, <em>if</em> <em>my_list</em> contains other containers (for example, nested lists) you must use <em>deepcopy</em> as others suggested in the answers above from the copy library. For example:</p>\n<pre><code class=\"python\">import copy\nnew_list = copy.deepcopy(my_list)   # Solution 2 when you are using nested lists\n</code></pre>\n<p>.<strong>Bonus</strong>: If you don't want to copy elements use (AKA shallow copy):</p>\n<pre><code class=\"python\">new_list = my_list[:]\n</code></pre>\n<hr/>\n<p>Let's understand difference between solution #1 and solution #2</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = range(5)\n&gt;&gt;&gt; b = a*1\n&gt;&gt;&gt; a,b\n([0, 1, 2, 3, 4], [0, 1, 2, 3, 4])\n&gt;&gt;&gt; a[2] = 55\n&gt;&gt;&gt; a,b\n([0, 1, 55, 3, 4], [0, 1, 2, 3, 4])\n</code></pre>\n<p>As you can see, solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from copy import deepcopy\n&gt;&gt;&gt; a = [range(i,i+4) for i in range(3)]\n&gt;&gt;&gt; a\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n&gt;&gt;&gt; b = a*1\n&gt;&gt;&gt; c = deepcopy(a)\n&gt;&gt;&gt; for i in (a, b, c): print i\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]\n&gt;&gt;&gt; a[2].append('99')\n&gt;&gt;&gt; for i in (a, b, c): print i\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5, 99]]\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5, 99]]   # Solution #1 didn't work in nested list\n[[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5]]       # Solution #2 - DeepCopy worked in nested list\n</code></pre>\n", "abstract": "A very simple approach independent of python version was missing in already-given answers which you can use most of the time (at least I do): However, if my_list contains other containers (for example, nested lists) you must use deepcopy as others suggested in the answers above from the copy library. For example: .Bonus: If you don't want to copy elements use (AKA shallow copy): Let's understand difference between solution #1 and solution #2 As you can see, solution #1 worked perfectly when we were not using the nested lists. Let's check what will happen when we apply solution #1 to nested lists."}, {"id": 57838754, "score": 12, "vote": 0, "content": "<p>I wanted to post something a bit different than some of the other answers. Even though this is most likely not the most understandable, or fastest option, it provides a bit of an inside view of how deep copy works, as well as being another alternative option for deep copying. It doesn't really matter if my function has bugs, since the point of this is to show a way to copy objects like the question answers, but also to use this as a point to explain how deepcopy works at its core.</p>\n<p>At the core of any deep copy function is way to make a shallow copy. How? Simple. Any deep copy function only duplicates the containers of immutable objects. When you deepcopy a nested list, you are only duplicating the outer lists, not the mutable objects inside of the lists. You are only duplicating the containers. The same works for classes, too. When you deepcopy a class, you deepcopy all of its mutable attributes. So, how? How come you only have to copy the containers, like lists, dicts, tuples, iters, classes, and class instances?</p>\n<p>It's simple. A mutable object can't really be duplicated. It can never be changed, so it is only a single value. That means you never have to duplicate strings, numbers, bools, or any of those. But how would you duplicate the containers? Simple. You make just initialize a new container with all of the values. Deepcopy relies on recursion. It duplicates all the containers, even ones with containers inside of them, until no containers are left. A container is an immutable object.</p>\n<p>Once you know that, completely duplicating an object without any references is pretty easy. Here's a function for deepcopying basic data-types (wouldn't work for custom classes but you could always add that)</p>\n<pre><code class=\"python\">def deepcopy(x):\n  immutables = (str, int, bool, float)\n  mutables = (list, dict, tuple)\n  if isinstance(x, immutables):\n    return x\n  elif isinstance(x, mutables):\n    if isinstance(x, tuple):\n      return tuple(deepcopy(list(x)))\n    elif isinstance(x, list):\n      return [deepcopy(y) for y in x]\n    elif isinstance(x, dict):\n      values = [deepcopy(y) for y in list(x.values())]\n      keys = list(x.keys())\n      return dict(zip(keys, values))\n</code></pre>\n<p>Python's own built-in deepcopy is based around that example. The only difference is it supports other types, and also supports user-classes by duplicating the attributes into a new duplicate class, and also blocks infinite-recursion with a reference to an object it's already seen using a memo list or dictionary. And that's really it for making deep copies. At its core, making a deep copy is just making shallow copies. I hope this answer adds something to the question.</p>\n<p><strong>EXAMPLES</strong></p>\n<p>Say you have this list: <code>[1, 2, 3]</code>. The immutable numbers cannot be duplicated, but the other layer can. You can duplicate it using a list comprehension: <code>[x for x in [1, 2, 3]]</code></p>\n<p>Now, imagine you have this list: <code>[[1, 2], [3, 4], [5, 6]]</code>. This time, you want to make a function, which uses recursion to deep copy all layers of the list. Instead of the previous list comprehension:</p>\n<pre><code class=\"python\">[x for x in _list]\n</code></pre>\n<p>It uses a new one for lists:</p>\n<pre><code class=\"python\">[deepcopy_list(x) for x in _list]\n</code></pre>\n<p>And <strong>deepcopy_list</strong> looks like this:</p>\n<pre><code class=\"python\">def deepcopy_list(x):\n  if isinstance(x, (str, bool, float, int)):\n    return x\n  else:\n    return [deepcopy_list(y) for y in x]\n</code></pre>\n<p>Then now you have a function which can deepcopy any list of <strong>strs, bools, floast, ints</strong> and even <strong>lists</strong> to infinitely many layers using recursion. And there you have it, deepcopying.</p>\n<p><strong>TLDR</strong>: Deepcopy uses recursion to duplicate objects, and merely returns the same immutable objects as before, as immutable objects cannot be duplicated. However, it deepcopies the most inner layers of mutable objects until it reaches the outermost mutable layer of an object.</p>\n", "abstract": "I wanted to post something a bit different than some of the other answers. Even though this is most likely not the most understandable, or fastest option, it provides a bit of an inside view of how deep copy works, as well as being another alternative option for deep copying. It doesn't really matter if my function has bugs, since the point of this is to show a way to copy objects like the question answers, but also to use this as a point to explain how deepcopy works at its core. At the core of any deep copy function is way to make a shallow copy. How? Simple. Any deep copy function only duplicates the containers of immutable objects. When you deepcopy a nested list, you are only duplicating the outer lists, not the mutable objects inside of the lists. You are only duplicating the containers. The same works for classes, too. When you deepcopy a class, you deepcopy all of its mutable attributes. So, how? How come you only have to copy the containers, like lists, dicts, tuples, iters, classes, and class instances? It's simple. A mutable object can't really be duplicated. It can never be changed, so it is only a single value. That means you never have to duplicate strings, numbers, bools, or any of those. But how would you duplicate the containers? Simple. You make just initialize a new container with all of the values. Deepcopy relies on recursion. It duplicates all the containers, even ones with containers inside of them, until no containers are left. A container is an immutable object. Once you know that, completely duplicating an object without any references is pretty easy. Here's a function for deepcopying basic data-types (wouldn't work for custom classes but you could always add that) Python's own built-in deepcopy is based around that example. The only difference is it supports other types, and also supports user-classes by duplicating the attributes into a new duplicate class, and also blocks infinite-recursion with a reference to an object it's already seen using a memo list or dictionary. And that's really it for making deep copies. At its core, making a deep copy is just making shallow copies. I hope this answer adds something to the question. EXAMPLES Say you have this list: [1, 2, 3]. The immutable numbers cannot be duplicated, but the other layer can. You can duplicate it using a list comprehension: [x for x in [1, 2, 3]] Now, imagine you have this list: [[1, 2], [3, 4], [5, 6]]. This time, you want to make a function, which uses recursion to deep copy all layers of the list. Instead of the previous list comprehension: It uses a new one for lists: And deepcopy_list looks like this: Then now you have a function which can deepcopy any list of strs, bools, floast, ints and even lists to infinitely many layers using recursion. And there you have it, deepcopying. TLDR: Deepcopy uses recursion to duplicate objects, and merely returns the same immutable objects as before, as immutable objects cannot be duplicated. However, it deepcopies the most inner layers of mutable objects until it reaches the outermost mutable layer of an object."}, {"id": 50373643, "score": 8, "vote": 0, "content": "<p>Note that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use <code>copy.copy()</code> or <code>copy.deepcopy()</code> rather than the alternatives, for example in Python 3:</p>\n<pre><code class=\"python\">import copy\n\nclass MyList(list):\n    pass\n\nlst = MyList([1,2,3])\n\nlst.name = 'custom list'\n\nd = {\n'original': lst,\n'slicecopy' : lst[:],\n'lstcopy' : lst.copy(),\n'copycopy': copy.copy(lst),\n'deepcopy': copy.deepcopy(lst)\n}\n\n\nfor k,v in d.items():\n    print('lst: {}'.format(k), end=', ')\n    try:\n        name = v.name\n    except AttributeError:\n        name = 'NA'\n    print('name: {}'.format(name))\n</code></pre>\n<p>Outputs:</p>\n<pre><code class=\"python\">lst: original, name: custom list\nlst: slicecopy, name: NA\nlst: lstcopy, name: NA\nlst: copycopy, name: custom list\nlst: deepcopy, name: custom list\n</code></pre>\n", "abstract": "Note that there are some cases where if you have defined your own custom class and you want to keep the attributes then you should use copy.copy() or copy.deepcopy() rather than the alternatives, for example in Python 3: Outputs:"}, {"id": 60352267, "score": 5, "vote": 0, "content": "<p>Remember that in Python when you do:</p>\n<pre><code class=\"python\">    list1 = ['apples','bananas','pineapples']\n    list2 = list1\n</code></pre>\n<p>List2 isn't storing the actual list, but a reference to list1. So when you do anything to list1, list2 changes as well. use the copy module (not default, download on pip) to make an original copy of the list(<code>copy.copy()</code> for simple lists, <code>copy.deepcopy()</code> for nested ones). This makes a copy that doesn't change with the first list.</p>\n", "abstract": "Remember that in Python when you do: List2 isn't storing the actual list, but a reference to list1. So when you do anything to list1, list2 changes as well. use the copy module (not default, download on pip) to make an original copy of the list(copy.copy() for simple lists, copy.deepcopy() for nested ones). This makes a copy that doesn't change with the first list."}, {"id": 59011118, "score": 4, "vote": 0, "content": "<p>A slight practical perspective to look into memory through id and gc. </p>\n<pre><code class=\"python\">&gt;&gt;&gt; b = a = ['hell', 'word']\n&gt;&gt;&gt; c = ['hell', 'word']\n\n&gt;&gt;&gt; id(a), id(b), id(c)\n(4424020872, 4424020872, 4423979272) \n     |           |\n      -----------\n\n&gt;&gt;&gt; id(a[0]), id(b[0]), id(c[0])\n(4424018328, 4424018328, 4424018328) # all referring to same 'hell'\n     |           |           |\n      -----------------------\n\n&gt;&gt;&gt; id(a[0][0]), id(b[0][0]), id(c[0][0])\n(4422785208, 4422785208, 4422785208) # all referring to same 'h'\n     |           |           |\n      -----------------------\n\n&gt;&gt;&gt; a[0] += 'o'\n&gt;&gt;&gt; a,b,c\n(['hello', 'word'], ['hello', 'word'], ['hell', 'word'])  # b changed too\n&gt;&gt;&gt; id(a[0]), id(b[0]), id(c[0])\n(4424018384, 4424018384, 4424018328) # augmented assignment changed a[0],b[0]\n     |           |\n      -----------\n\n&gt;&gt;&gt; b = a = ['hell', 'word']\n&gt;&gt;&gt; id(a[0]), id(b[0]), id(c[0])\n(4424018328, 4424018328, 4424018328) # the same hell\n     |           |           |\n      -----------------------\n\n&gt;&gt;&gt; import gc\n&gt;&gt;&gt; gc.get_referrers(a[0]) \n[['hell', 'word'], ['hell', 'word']]  # one copy belong to a,b, the another for c\n&gt;&gt;&gt; gc.get_referrers(('hell'))\n[['hell', 'word'], ['hell', 'word'], ('hell', None)] # ('hello', None) \n</code></pre>\n", "abstract": "A slight practical perspective to look into memory through id and gc. "}, {"id": 62716254, "score": 2, "vote": 0, "content": "<p>There is another way of copying a list that was not listed until now: adding an empty list: <code>l2 = l + []</code>.</p>\n<p>I tested it with Python 3.8:</p>\n<pre><code class=\"python\">l = [1,2,3]\nl2 = l + []\nprint(l,l2)\nl[0] = 'a'\nprint(l,l2)\n</code></pre>\n<p>It is not the best answer, but it works.</p>\n", "abstract": "There is another way of copying a list that was not listed until now: adding an empty list: l2 = l + []. I tested it with Python 3.8: It is not the best answer, but it works."}, {"id": 61155939, "score": 1, "vote": 0, "content": "<p>The deepcopy option is the only method that works for me:</p>\n<pre><code class=\"python\">from copy import deepcopy\n\na = [   [ list(range(1, 3)) for i in range(3) ]   ]\nb = deepcopy(a)\nb[0][1]=[3]\nprint('Deep:')\nprint(a)\nprint(b)\nprint('-----------------------------')\na = [   [ list(range(1, 3)) for i in range(3) ]   ]\nb = a*1\nb[0][1]=[3]\nprint('*1:')\nprint(a)\nprint(b)\nprint('-----------------------------')\na = [   [ list(range(1, 3)) for i in range(3) ] ]\nb = a[:]\nb[0][1]=[3]\nprint('Vector copy:')\nprint(a)\nprint(b)\nprint('-----------------------------')\na = [   [ list(range(1, 3)) for i in range(3) ]  ]\nb = list(a)\nb[0][1]=[3]\nprint('List copy:')\nprint(a)\nprint(b)\nprint('-----------------------------')\na = [   [ list(range(1, 3)) for i in range(3) ]  ]\nb = a.copy()\nb[0][1]=[3]\nprint('.copy():')\nprint(a)\nprint(b)\nprint('-----------------------------')\na = [   [ list(range(1, 3)) for i in range(3) ]  ]\nb = a\nb[0][1]=[3]\nprint('Shallow:')\nprint(a)\nprint(b)\nprint('-----------------------------')\n</code></pre>\n<p>leads to output of:</p>\n<pre><code class=\"python\">Deep:\n[[[1, 2], [1, 2], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\n*1:\n[[[1, 2], [3], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\nVector copy:\n[[[1, 2], [3], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\nList copy:\n[[[1, 2], [3], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\n.copy():\n[[[1, 2], [3], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\nShallow:\n[[[1, 2], [3], [1, 2]]]\n[[[1, 2], [3], [1, 2]]]\n-----------------------------\n</code></pre>\n", "abstract": "The deepcopy option is the only method that works for me: leads to output of:"}, {"id": 62192645, "score": 1, "vote": 0, "content": "<p>This is because, the line <code>new_list = my_list</code> assigns a new reference to the variable <code>my_list</code> which is <code>new_list</code>\nThis is similar to the <code>C</code> code given below,</p>\n<pre><code class=\"python\">int my_list[] = [1,2,3,4];\nint *new_list;\nnew_list = my_list;\n</code></pre>\n<p>You should use the copy module to create a new list by</p>\n<pre><code class=\"python\">import copy\nnew_list = copy.deepcopy(my_list)\n</code></pre>\n", "abstract": "This is because, the line new_list = my_list assigns a new reference to the variable my_list which is new_list\nThis is similar to the C code given below, You should use the copy module to create a new list by"}, {"id": 65972710, "score": 1, "vote": 0, "content": "<p>The method to use depends on the contents of the list being copied. If the list contains nested <code>dicts</code> than deepcopy is the only method that works, otherwise most of the methods listed in the answers (slice, loop [for], copy, extend, combine, or unpack) will work and execute in similar time (except for loop and deepcopy, which preformed the worst).</p>\n<h3>Script</h3>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from random import randint\nfrom time import time\nimport copy\n\nitem_count = 100000\n\ndef copy_type(l1: list, l2: list):\n  if l1 == l2:\n    return 'shallow'\n  return 'deep'\n\ndef run_time(start, end):\n  run = end - start\n  return int(run * 1000000)\n\ndef list_combine(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = [] + l1\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'combine', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_extend(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = []\n  l2.extend(l1)\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'extend', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_unpack(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = [*l1]\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'unpack', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_deepcopy(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = copy.deepcopy(l1)\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'deepcopy', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_copy(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = list.copy(l1)\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'copy', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_slice(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = l1[:]\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'slice', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_loop(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = []\n  for i in range(len(l1)):\n    l2.append(l1[i])\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'loop', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\ndef list_list(data):\n  l1 = [data for i in range(item_count)]\n  start = time()\n  l2 = list(l1)\n  end = time()\n  if type(data) == dict:\n    l2[0]['test'].append(1)\n  elif type(data) == list:\n    l2.append(1)\n  return {'method': 'list()', 'copy_type': copy_type(l1, l2), \n          'time_\u00b5s': run_time(start, end)}\n\nif __name__ == '__main__':\n  list_type = [{'list[dict]': {'test': [1, 1]}}, \n          {'list[list]': [1, 1]}]\n  store = []\n  for data in list_type:\n    key = list(data.keys())[0]\n    store.append({key: [list_unpack(data[key]), list_extend(data[key]), \n                list_combine(data[key]), list_deepcopy(data[key]), \n                list_copy(data[key]), list_slice(data[key]),           \n                list_loop(data[key])]})\n  print(store)\n</code></pre>\n<h3>Results</h3>\n<pre class=\"lang-json prettyprint-override\"><code class=\"python\">[{\"list[dict]\": [\n  {\"method\": \"unpack\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 56149},\n  {\"method\": \"extend\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 52991},\n  {\"method\": \"combine\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 53726},\n  {\"method\": \"deepcopy\", \"copy_type\": \"deep\", \"time_\u00b5s\": 2702616},\n  {\"method\": \"copy\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 52204},\n  {\"method\": \"slice\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 52223},\n  {\"method\": \"loop\", \"copy_type\": \"shallow\", \"time_\u00b5s\": 836928}]},\n{\"list[list]\": [\n  {\"method\": \"unpack\", \"copy_type\": \"deep\", \"time_\u00b5s\": 52313},\n  {\"method\": \"extend\", \"copy_type\": \"deep\", \"time_\u00b5s\": 52550},\n  {\"method\": \"combine\", \"copy_type\": \"deep\", \"time_\u00b5s\": 53203},\n  {\"method\": \"deepcopy\", \"copy_type\": \"deep\", \"time_\u00b5s\": 2608560},\n  {\"method\": \"copy\", \"copy_type\": \"deep\", \"time_\u00b5s\": 53210},\n  {\"method\": \"slice\", \"copy_type\": \"deep\", \"time_\u00b5s\": 52937},\n  {\"method\": \"loop\", \"copy_type\": \"deep\", \"time_\u00b5s\": 834774}\n]}]\n</code></pre>\n", "abstract": "The method to use depends on the contents of the list being copied. If the list contains nested dicts than deepcopy is the only method that works, otherwise most of the methods listed in the answers (slice, loop [for], copy, extend, combine, or unpack) will work and execute in similar time (except for loop and deepcopy, which preformed the worst)."}, {"id": 73831052, "score": 0, "vote": 0, "content": "<h2>Frame challenge: do you actually need to copy, for your application?</h2>\n<p>I often see code that tries to modify a copy of the list in some iterative fashion. To construct a trivial example, suppose we had non-working (because <code>x</code> should not be modified) code like:</p>\n<pre><code class=\"python\">x = [8, 6, 7, 5, 3, 0, 9]\ny = x\nfor index, element in enumerate(y):\n    y[index] = element * 2\n# Expected result:\n# x = [8, 6, 7, 5, 3, 0, 9] &lt;-- this is where the code is wrong.\n# y = [16, 12, 14, 10, 6, 0, 18]\n</code></pre>\n<p>Naturally people will ask how to make <code>y</code> be a copy of <code>x</code>, rather than a name for the same list, so that the <code>for</code> loop will do the right thing.</p>\n<p>But this is the wrong approach. Functionally, what we <em>really</em> want to do is make a <strong>new list</strong> that is <strong>based on</strong> the original.</p>\n<p><strong>We don't need to make a copy first to do that, and we typically shouldn't.</strong></p>\n<h3>When we need to apply logic to each element</h3>\n<p>The natural tool for this is a list comprehension. This way, we write the logic that tells us how the elements in the desired result, relate to the original elements. It's simple, elegant and expressive; and we avoid the need for workarounds to modify the <code>y</code> copy in a <code>for</code> loop (since <a href=\"https://stackoverflow.com/questions/73251627\">assigning to the iteration variable doesn't affect the list</a> - <em>for the same reason that we wanted the copy in the first place!</em>).</p>\n<p>For the above example, it looks like:</p>\n<pre><code class=\"python\">x = [8, 6, 7, 5, 3, 0, 9]\ny = [element * 2 for element in x]\n</code></pre>\n<p>List comprehensions are quite powerful; we can also use them to filter out elements by a rule with an <code>if</code> clause, and we can chain <code>for</code> and <code>if</code> clauses (it works like the corresponding imperative code, with the same clauses <em>in the same order</em>; only the value that will ultimately end up in the result list, is moved to the front instead of being in the \"innermost\" part). If the plan was to iterate over the original while modifying the copy <a href=\"https://stackoverflow.com/questions/1207406/\">to avoid problems</a>, there is generally a much more pleasant way to do that with a filtering list comprehension.</p>\n<h3>When we need to reject or insert specific elements by position</h3>\n<p>Suppose instead that we had something like</p>\n<pre><code class=\"python\">x = [8, 6, 7, 5, 3, 0, 9]\ny = x\ndel y[2:-2] # oops, x was changed inappropriately\n</code></pre>\n<p>Rather than making <code>y</code> a separate copy first in order to delete the part we don't want, we can build a list by <em>putting together</em> the parts that we <em>do</em> want. Thus:</p>\n<pre><code class=\"python\">x = [8, 6, 7, 5, 3, 0, 9]\ny = x[:2] + x[-2:]\n</code></pre>\n<p>Handling insertion, replacement etc. by slicing is left as an exercise. Just reason out which subsequences you want the result to contain. A special case of this is <a href=\"https://stackoverflow.com/questions/4280691\">making a reversed copy</a> - assuming we need a new list at all (rather than just to <a href=\"https://stackoverflow.com/questions/3940128/\">iterate in reverse</a>), we can directly create it by slicing, rather than cloning and then using <code>.reverse</code>.</p>\n<hr/>\n<p>These approaches - like the list comprehension - also have the advantage that they create the desired result <em>as an expression</em>, rather than by procedurally modifying an existing object in-place (and <a href=\"https://stackoverflow.com/questions/11205254/\">returning <code>None</code></a>). This is more convenient for writing code in a \"fluent\" style.</p>\n", "abstract": "I often see code that tries to modify a copy of the list in some iterative fashion. To construct a trivial example, suppose we had non-working (because x should not be modified) code like: Naturally people will ask how to make y be a copy of x, rather than a name for the same list, so that the for loop will do the right thing. But this is the wrong approach. Functionally, what we really want to do is make a new list that is based on the original. We don't need to make a copy first to do that, and we typically shouldn't. The natural tool for this is a list comprehension. This way, we write the logic that tells us how the elements in the desired result, relate to the original elements. It's simple, elegant and expressive; and we avoid the need for workarounds to modify the y copy in a for loop (since assigning to the iteration variable doesn't affect the list - for the same reason that we wanted the copy in the first place!). For the above example, it looks like: List comprehensions are quite powerful; we can also use them to filter out elements by a rule with an if clause, and we can chain for and if clauses (it works like the corresponding imperative code, with the same clauses in the same order; only the value that will ultimately end up in the result list, is moved to the front instead of being in the \"innermost\" part). If the plan was to iterate over the original while modifying the copy to avoid problems, there is generally a much more pleasant way to do that with a filtering list comprehension. Suppose instead that we had something like Rather than making y a separate copy first in order to delete the part we don't want, we can build a list by putting together the parts that we do want. Thus: Handling insertion, replacement etc. by slicing is left as an exercise. Just reason out which subsequences you want the result to contain. A special case of this is making a reversed copy - assuming we need a new list at all (rather than just to iterate in reverse), we can directly create it by slicing, rather than cloning and then using .reverse. These approaches - like the list comprehension - also have the advantage that they create the desired result as an expression, rather than by procedurally modifying an existing object in-place (and returning None). This is more convenient for writing code in a \"fluent\" style."}]}, {"link": "https://stackoverflow.com/questions/36901/what-does-double-star-asterisk-and-star-asterisk-do-for-parameters", "question": {"id": "36901", "title": "What does ** (double star/asterisk) and * (star/asterisk) do for parameters?", "content": "<p>What do <code>*args</code> and <code>**kwargs</code> mean?</p>\n<pre><code class=\"python\">def foo(x, y, *args):\ndef bar(x, y, **kwargs):\n</code></pre>\n", "abstract": "What do *args and **kwargs mean?"}, "answers": [{"id": 36908, "score": 2992, "vote": 0, "content": "<p>The <code>*args</code> and <code>**kwargs</code> is a common idiom to allow arbitrary number of arguments to functions as described in the section <a href=\"http://docs.python.org/3/tutorial/controlflow.html#more-on-defining-functions\" rel=\"noreferrer\">more on defining functions</a> in the Python documentation.</p>\n<p>The <code>*args</code> will give you all function parameters <a href=\"https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists\" rel=\"noreferrer\">as a tuple</a>:</p>\n<pre><code class=\"python\">def foo(*args):\n    for a in args:\n        print(a)        \n\nfoo(1)\n# 1\n\nfoo(1,2,3)\n# 1\n# 2\n# 3\n</code></pre>\n<p>The <code>**kwargs</code> will give you all\n<strong>keyword arguments</strong> except for those corresponding to a formal parameter as a dictionary.</p>\n<pre><code class=\"python\">def bar(**kwargs):\n    for a in kwargs:\n        print(a, kwargs[a])  \n\nbar(name='one', age=27)\n# name one\n# age 27\n</code></pre>\n<p>Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:</p>\n<pre><code class=\"python\">def foo(kind, *args, **kwargs):\n   pass\n</code></pre>\n<p>It is also possible to use this the other way around:</p>\n<pre><code class=\"python\">def foo(a, b, c):\n    print(a, b, c)\n\nobj = {'b':10, 'c':'lee'}\n\nfoo(100,**obj)\n# 100 10 lee\n</code></pre>\n<p>Another usage of the <code>*l</code> idiom is to <strong>unpack argument lists</strong> when calling a function.</p>\n<pre><code class=\"python\">def foo(bar, lee):\n    print(bar, lee)\n\nl = [1,2]\n\nfoo(*l)\n# 1 2\n</code></pre>\n<p>In Python 3 it is possible to use <code>*l</code> on the left side of an assignment (<a href=\"http://www.python.org/dev/peps/pep-3132/\" rel=\"noreferrer\">Extended Iterable Unpacking</a>), though it gives a list instead of a tuple in this context:</p>\n<pre><code class=\"python\">first, *rest = [1,2,3,4]\nfirst, *l, last = [1,2,3,4]\n</code></pre>\n<p>Also Python 3 adds new semantic (refer <a href=\"https://www.python.org/dev/peps/pep-3102/\" rel=\"noreferrer\">PEP 3102</a>):</p>\n<pre><code class=\"python\">def func(arg1, arg2, arg3, *, kwarg1, kwarg2):\n    pass\n</code></pre>\n<p>For example the following works in python 3 but not python 2:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [1, 2]\n&gt;&gt;&gt; [*x]\n[1, 2]\n&gt;&gt;&gt; [*x, 3, 4]\n[1, 2, 3, 4]\n\n&gt;&gt;&gt; x = {1:1, 2:2}\n&gt;&gt;&gt; x\n{1: 1, 2: 2}\n&gt;&gt;&gt; {**x, 3:3, 4:4}\n{1: 1, 2: 2, 3: 3, 4: 4}\n</code></pre>\n<p>Such function accepts only 3 positional arguments, and everything after <code>*</code> can only be passed as keyword arguments.</p>\n<h3>Note:</h3>\n<ul>\n<li>A Python <code>dict</code>, semantically used for keyword argument passing, are arbitrarily ordered. However, in Python 3.6, keyword arguments are guaranteed to remember insertion order.</li>\n<li>\"The order of elements in <code>**kwargs</code> now corresponds to the order in which keyword arguments were passed to the function.\" - <a href=\"https://docs.python.org/3/whatsnew/3.6.html\" rel=\"noreferrer\">What\u2019s New In Python 3.6</a></li>\n<li>In fact, all dicts in CPython 3.6 will remember insertion order as an implementation detail, this becomes standard in Python 3.7.</li>\n</ul>\n", "abstract": "The *args and **kwargs is a common idiom to allow arbitrary number of arguments to functions as described in the section more on defining functions in the Python documentation. The *args will give you all function parameters as a tuple: The **kwargs will give you all\nkeyword arguments except for those corresponding to a formal parameter as a dictionary. Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments: It is also possible to use this the other way around: Another usage of the *l idiom is to unpack argument lists when calling a function. In Python 3 it is possible to use *l on the left side of an assignment (Extended Iterable Unpacking), though it gives a list instead of a tuple in this context: Also Python 3 adds new semantic (refer PEP 3102): For example the following works in python 3 but not python 2: Such function accepts only 3 positional arguments, and everything after * can only be passed as keyword arguments."}, {"id": 36926, "score": 780, "vote": 0, "content": "<p>It's also worth noting that you can use <code>*</code> and <code>**</code> when calling functions as well. This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary. For example, if you have the following function:</p>\n<pre><code class=\"python\">def foo(x,y,z):\n    print(\"x=\" + str(x))\n    print(\"y=\" + str(y))\n    print(\"z=\" + str(z))\n</code></pre>\n<p>You can do things like:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; mylist = [1,2,3]\n&gt;&gt;&gt; foo(*mylist)\nx=1\ny=2\nz=3\n\n&gt;&gt;&gt; mydict = {'x':1,'y':2,'z':3}\n&gt;&gt;&gt; foo(**mydict)\nx=1\ny=2\nz=3\n\n&gt;&gt;&gt; mytuple = (1, 2, 3)\n&gt;&gt;&gt; foo(*mytuple)\nx=1\ny=2\nz=3\n</code></pre>\n<p>Note: The keys in <code>mydict</code> have to be named exactly like the parameters of function <code>foo</code>. Otherwise it will throw a <code>TypeError</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; mydict = {'x':1,'y':2,'z':3,'badnews':9}\n&gt;&gt;&gt; foo(**mydict)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: foo() got an unexpected keyword argument 'badnews'\n</code></pre>\n", "abstract": "It's also worth noting that you can use * and ** when calling functions as well. This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary. For example, if you have the following function: You can do things like: Note: The keys in mydict have to be named exactly like the parameters of function foo. Otherwise it will throw a TypeError:"}, {"id": 36911, "score": 210, "vote": 0, "content": "<p>The single * means that there can be any number of extra positional arguments. <code>foo()</code> can be invoked like <code>foo(1,2,3,4,5)</code>. In the body of foo() param2 is a sequence containing 2-5.</p>\n<p>The double ** means there can be any number of extra named parameters. <code>bar()</code> can be invoked like <code>bar(1, a=2, b=3)</code>. In the body of bar() param2 is a dictionary containing {'a':2, 'b':3 }</p>\n<p>With the following code:</p>\n<pre><code class=\"python\">def foo(param1, *param2):\n    print(param1)\n    print(param2)\n\ndef bar(param1, **param2):\n    print(param1)\n    print(param2)\n\nfoo(1,2,3,4,5)\nbar(1,a=2,b=3)\n</code></pre>\n<p>the output is</p>\n<pre><code class=\"python\">1\n(2, 3, 4, 5)\n1\n{'a': 2, 'b': 3}\n</code></pre>\n", "abstract": "The single * means that there can be any number of extra positional arguments. foo() can be invoked like foo(1,2,3,4,5). In the body of foo() param2 is a sequence containing 2-5. The double ** means there can be any number of extra named parameters. bar() can be invoked like bar(1, a=2, b=3). In the body of bar() param2 is a dictionary containing {'a':2, 'b':3 } With the following code: the output is"}, {"id": 26365795, "score": 197, "vote": 0, "content": "<blockquote>\n<h1>What does <code>**</code> (double star) and <code>*</code> (star) do for parameters?</h1>\n</blockquote>\n<p>They allow for <strong>functions to be defined to accept</strong> and for <strong>users to pass</strong> any number of arguments, positional (<code>*</code>) and keyword (<code>**</code>).</p>\n<h2>Defining Functions</h2>\n<p><code>*args</code> allows for any number of optional positional arguments (parameters), which will be assigned to a tuple named <code>args</code>.</p>\n<p><code>**kwargs</code> allows for any number of optional keyword arguments (parameters), which will be in a dict named <code>kwargs</code>.</p>\n<p>You can (and should) choose any appropriate name, but if the intention is for the arguments to be of non-specific semantics, <code>args</code> and <code>kwargs</code> are standard names.</p>\n<h2>Expansion, Passing any number of arguments</h2>\n<p>You can also use <code>*args</code> and <code>**kwargs</code> to pass in parameters from lists (or any iterable) and dicts (or any mapping), respectively.</p>\n<p>The function recieving the parameters does not have to know that they are being expanded.</p>\n<p>For example, Python 2's xrange does not explicitly expect <code>*args</code>, but since it takes 3 integers as arguments:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = xrange(3) # create our *args - an iterable of 3 integers\n&gt;&gt;&gt; xrange(*x)    # expand here\nxrange(0, 2, 2)\n</code></pre>\n<p>As another example, we can use dict expansion in <code>str.format</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; foo = 'FOO'\n&gt;&gt;&gt; bar = 'BAR'\n&gt;&gt;&gt; 'this is foo, {foo} and bar, {bar}'.format(**locals())\n'this is foo, FOO and bar, BAR'\n</code></pre>\n<h2>New in Python 3: Defining functions with keyword only arguments</h2>\n<p>You can have <a href=\"https://www.python.org/dev/peps/pep-3102/\" rel=\"noreferrer\">keyword only arguments</a> after the <code>*args</code> - for example, here, <code>kwarg2</code> must be given as a keyword argument - not positionally:</p>\n<pre><code class=\"python\">def foo(arg, kwarg=None, *args, kwarg2=None, **kwargs): \n    return arg, kwarg, args, kwarg2, kwargs\n</code></pre>\n<p>Usage:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; foo(1,2,3,4,5,kwarg2='kwarg2', bar='bar', baz='baz')\n(1, 2, (3, 4, 5), 'kwarg2', {'bar': 'bar', 'baz': 'baz'})\n</code></pre>\n<p>Also, <code>*</code> can be used by itself  to indicate that keyword only arguments follow, without allowing for unlimited positional arguments.</p>\n<pre><code class=\"python\">def foo(arg, kwarg=None, *, kwarg2=None, **kwargs): \n    return arg, kwarg, kwarg2, kwargs\n</code></pre>\n<p>Here, <code>kwarg2</code> again must be an explicitly named, keyword argument:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; foo(1,2,kwarg2='kwarg2', foo='foo', bar='bar')\n(1, 2, 'kwarg2', {'foo': 'foo', 'bar': 'bar'})\n</code></pre>\n<p>And we can no longer accept unlimited positional arguments because we don't have <code>*args*</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; foo(1,2,3,4,5, kwarg2='kwarg2', foo='foo', bar='bar')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: foo() takes from 1 to 2 positional arguments \n    but 5 positional arguments (and 1 keyword-only argument) were given\n</code></pre>\n<p>Again, more simply, here we require <code>kwarg</code> to be given by name, not positionally:</p>\n<pre><code class=\"python\">def bar(*, kwarg=None): \n    return kwarg\n</code></pre>\n<p>In this example, we see that if we try to pass <code>kwarg</code> positionally, we get an error:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; bar('kwarg')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: bar() takes 0 positional arguments but 1 was given\n</code></pre>\n<p>We must explicitly pass the <code>kwarg</code> parameter as a keyword argument.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; bar(kwarg='kwarg')\n'kwarg'\n</code></pre>\n<h2>Python 2 compatible demos</h2>\n<p><code>*args</code> (typically said \"star-args\") and <code>**kwargs</code> (stars can be implied by saying \"kwargs\", but be explicit with \"double-star kwargs\") are common idioms of Python for using the <code>*</code> and <code>**</code> notation. These specific variable names aren't required (e.g. you could use <code>*foos</code> and <code>**bars</code>), but a departure from convention is likely to enrage your fellow Python coders.</p>\n<p>We typically use these when we don't know what our function is going to receive or how many arguments we may be passing, and sometimes even when naming every variable separately would get very messy and redundant (but this is a case where usually explicit is better than implicit).</p>\n<p><strong>Example 1</strong></p>\n<p>The following function describes how they can be used, and demonstrates behavior. Note the named <code>b</code> argument will be consumed by the second positional argument before :</p>\n<pre><code class=\"python\">def foo(a, b=10, *args, **kwargs):\n    '''\n    this function takes required argument a, not required keyword argument b\n    and any number of unknown positional arguments and keyword arguments after\n    '''\n    print('a is a required argument, and its value is {0}'.format(a))\n    print('b not required, its default value is 10, actual value: {0}'.format(b))\n    # we can inspect the unknown arguments we were passed:\n    #  - args:\n    print('args is of type {0} and length {1}'.format(type(args), len(args)))\n    for arg in args:\n        print('unknown arg: {0}'.format(arg))\n    #  - kwargs:\n    print('kwargs is of type {0} and length {1}'.format(type(kwargs),\n                                                        len(kwargs)))\n    for kw, arg in kwargs.items():\n        print('unknown kwarg - kw: {0}, arg: {1}'.format(kw, arg))\n    # But we don't have to know anything about them \n    # to pass them to other functions.\n    print('Args or kwargs can be passed without knowing what they are.')\n    # max can take two or more positional args: max(a, b, c...)\n    print('e.g. max(a, b, *args) \\n{0}'.format(\n      max(a, b, *args))) \n    kweg = 'dict({0})'.format( # named args same as unknown kwargs\n      ', '.join('{k}={v}'.format(k=k, v=v) \n                             for k, v in sorted(kwargs.items())))\n    print('e.g. dict(**kwargs) (same as {kweg}) returns: \\n{0}'.format(\n      dict(**kwargs), kweg=kweg))\n</code></pre>\n<p>We can check the online help for the function's signature, with <code>help(foo)</code>, which tells us</p>\n<pre><code class=\"python\">foo(a, b=10, *args, **kwargs)\n</code></pre>\n<p>Let's call this function with <code>foo(1, 2, 3, 4, e=5, f=6, g=7)</code></p>\n<p>which prints:</p>\n<pre><code class=\"python\">a is a required argument, and its value is 1\nb not required, its default value is 10, actual value: 2\nargs is of type &lt;type 'tuple'&gt; and length 2\nunknown arg: 3\nunknown arg: 4\nkwargs is of type &lt;type 'dict'&gt; and length 3\nunknown kwarg - kw: e, arg: 5\nunknown kwarg - kw: g, arg: 7\nunknown kwarg - kw: f, arg: 6\nArgs or kwargs can be passed without knowing what they are.\ne.g. max(a, b, *args) \n4\ne.g. dict(**kwargs) (same as dict(e=5, f=6, g=7)) returns: \n{'e': 5, 'g': 7, 'f': 6}\n</code></pre>\n<p><strong>Example 2</strong></p>\n<p>We can also call it using another function, into which we just provide <code>a</code>:</p>\n<pre><code class=\"python\">def bar(a):\n    b, c, d, e, f = 2, 3, 4, 5, 6\n    # dumping every local variable into foo as a keyword argument \n    # by expanding the locals dict:\n    foo(**locals()) \n</code></pre>\n<p><code>bar(100)</code> prints:</p>\n<pre><code class=\"python\">a is a required argument, and its value is 100\nb not required, its default value is 10, actual value: 2\nargs is of type &lt;type 'tuple'&gt; and length 0\nkwargs is of type &lt;type 'dict'&gt; and length 4\nunknown kwarg - kw: c, arg: 3\nunknown kwarg - kw: e, arg: 5\nunknown kwarg - kw: d, arg: 4\nunknown kwarg - kw: f, arg: 6\nArgs or kwargs can be passed without knowing what they are.\ne.g. max(a, b, *args) \n100\ne.g. dict(**kwargs) (same as dict(c=3, d=4, e=5, f=6)) returns: \n{'c': 3, 'e': 5, 'd': 4, 'f': 6}\n</code></pre>\n<p><strong>Example 3: practical usage in decorators</strong></p>\n<p>OK, so maybe we're not seeing the utility yet. So imagine you have several functions with redundant code before and/or after the differentiating code. The following named functions are just pseudo-code for illustrative purposes.</p>\n<pre><code class=\"python\">def foo(a, b, c, d=0, e=100):\n    # imagine this is much more code than a simple function call\n    preprocess() \n    differentiating_process_foo(a,b,c,d,e)\n    # imagine this is much more code than a simple function call\n    postprocess()\n\ndef bar(a, b, c=None, d=0, e=100, f=None):\n    preprocess()\n    differentiating_process_bar(a,b,c,d,e,f)\n    postprocess()\n\ndef baz(a, b, c, d, e, f):\n    ... and so on\n</code></pre>\n<p>We might be able to handle this differently, but we can certainly extract the redundancy with a decorator, and so our below example demonstrates how <code>*args</code> and <code>**kwargs</code> can be very useful:</p>\n<pre><code class=\"python\">def decorator(function):\n    '''function to wrap other functions with a pre- and postprocess'''\n    @functools.wraps(function) # applies module, name, and docstring to wrapper\n    def wrapper(*args, **kwargs):\n        # again, imagine this is complicated, but we only write it once!\n        preprocess()\n        function(*args, **kwargs)\n        postprocess()\n    return wrapper\n</code></pre>\n<p>And now every wrapped function can be written much more succinctly, as we've factored out the redundancy:</p>\n<pre><code class=\"python\">@decorator\ndef foo(a, b, c, d=0, e=100):\n    differentiating_process_foo(a,b,c,d,e)\n\n@decorator\ndef bar(a, b, c=None, d=0, e=100, f=None):\n    differentiating_process_bar(a,b,c,d,e,f)\n\n@decorator\ndef baz(a, b, c=None, d=0, e=100, f=None, g=None):\n    differentiating_process_baz(a,b,c,d,e,f, g)\n\n@decorator\ndef quux(a, b, c=None, d=0, e=100, f=None, g=None, h=None):\n    differentiating_process_quux(a,b,c,d,e,f,g,h)\n</code></pre>\n<p>And by factoring out our code, which <code>*args</code> and <code>**kwargs</code> allows us to do, we reduce lines of code, improve readability and maintainability, and have sole canonical locations for the logic in our program. If we need to change any part of this structure, we have one place in which to make each change.</p>\n", "abstract": "They allow for functions to be defined to accept and for users to pass any number of arguments, positional (*) and keyword (**). *args allows for any number of optional positional arguments (parameters), which will be assigned to a tuple named args. **kwargs allows for any number of optional keyword arguments (parameters), which will be in a dict named kwargs. You can (and should) choose any appropriate name, but if the intention is for the arguments to be of non-specific semantics, args and kwargs are standard names. You can also use *args and **kwargs to pass in parameters from lists (or any iterable) and dicts (or any mapping), respectively. The function recieving the parameters does not have to know that they are being expanded. For example, Python 2's xrange does not explicitly expect *args, but since it takes 3 integers as arguments: As another example, we can use dict expansion in str.format: You can have keyword only arguments after the *args - for example, here, kwarg2 must be given as a keyword argument - not positionally: Usage: Also, * can be used by itself  to indicate that keyword only arguments follow, without allowing for unlimited positional arguments. Here, kwarg2 again must be an explicitly named, keyword argument: And we can no longer accept unlimited positional arguments because we don't have *args*: Again, more simply, here we require kwarg to be given by name, not positionally: In this example, we see that if we try to pass kwarg positionally, we get an error: We must explicitly pass the kwarg parameter as a keyword argument. *args (typically said \"star-args\") and **kwargs (stars can be implied by saying \"kwargs\", but be explicit with \"double-star kwargs\") are common idioms of Python for using the * and ** notation. These specific variable names aren't required (e.g. you could use *foos and **bars), but a departure from convention is likely to enrage your fellow Python coders. We typically use these when we don't know what our function is going to receive or how many arguments we may be passing, and sometimes even when naming every variable separately would get very messy and redundant (but this is a case where usually explicit is better than implicit). Example 1 The following function describes how they can be used, and demonstrates behavior. Note the named b argument will be consumed by the second positional argument before : We can check the online help for the function's signature, with help(foo), which tells us Let's call this function with foo(1, 2, 3, 4, e=5, f=6, g=7) which prints: Example 2 We can also call it using another function, into which we just provide a: bar(100) prints: Example 3: practical usage in decorators OK, so maybe we're not seeing the utility yet. So imagine you have several functions with redundant code before and/or after the differentiating code. The following named functions are just pseudo-code for illustrative purposes. We might be able to handle this differently, but we can certainly extract the redundancy with a decorator, and so our below example demonstrates how *args and **kwargs can be very useful: And now every wrapped function can be written much more succinctly, as we've factored out the redundancy: And by factoring out our code, which *args and **kwargs allows us to do, we reduce lines of code, improve readability and maintainability, and have sole canonical locations for the logic in our program. If we need to change any part of this structure, we have one place in which to make each change."}, {"id": 34899056, "score": 62, "vote": 0, "content": "<p>Let us first understand what are positional arguments and keyword arguments.\nBelow is an example of function definition with <strong>Positional arguments.</strong></p>\n<pre><code class=\"python\">def test(a,b,c):\n     print(a)\n     print(b)\n     print(c)\n\ntest(1,2,3)\n#output:\n1\n2\n3\n</code></pre>\n<p>So this is a function definition with positional arguments.\nYou can call it with keyword/named arguments as well:</p>\n<pre><code class=\"python\">def test(a,b,c):\n     print(a)\n     print(b)\n     print(c)\n\ntest(a=1,b=2,c=3)\n#output:\n1\n2\n3\n</code></pre>\n<p>Now let us study an example of function definition with <strong>keyword arguments</strong>:</p>\n<pre><code class=\"python\">def test(a=0,b=0,c=0):\n     print(a)\n     print(b)\n     print(c)\n     print('-------------------------')\n\ntest(a=1,b=2,c=3)\n#output :\n1\n2\n3\n-------------------------\n</code></pre>\n<p>You can call this function with positional arguments as well:</p>\n<pre><code class=\"python\">def test(a=0,b=0,c=0):\n    print(a)\n    print(b)\n    print(c)\n    print('-------------------------')\n\ntest(1,2,3)\n# output :\n1\n2\n3\n---------------------------------\n</code></pre>\n<p>So we now know function definitions with positional as well as keyword arguments.</p>\n<p>Now let us study the '*' operator and '**' operator.</p>\n<p>Please note these operators can be used in 2 areas:</p>\n<p>a) <strong>function call</strong></p>\n<p>b) <strong>function definition</strong></p>\n<p>The use of '*' operator and '**' operator in <strong>function call.</strong> </p>\n<p>Let us get straight to an example and then discuss it.</p>\n<pre><code class=\"python\">def sum(a,b):  #receive args from function calls as sum(1,2) or sum(a=1,b=2)\n    print(a+b)\n\nmy_tuple = (1,2)\nmy_list = [1,2]\nmy_dict = {'a':1,'b':2}\n\n# Let us unpack data structure of list or tuple or dict into arguments with help of '*' operator\nsum(*my_tuple)   # becomes same as sum(1,2) after unpacking my_tuple with '*'\nsum(*my_list)    # becomes same as sum(1,2) after unpacking my_list with  '*'\nsum(**my_dict)   # becomes same as sum(a=1,b=2) after unpacking by '**' \n\n# output is 3 in all three calls to sum function.\n</code></pre>\n<p>So remember </p>\n<p>when the '*' or '**' operator is used in a <strong>function call</strong> -</p>\n<p>'*' operator unpacks data structure such as a list or tuple  into arguments needed by function definition.</p>\n<p>'**' operator unpacks a dictionary into arguments needed by function definition.</p>\n<p>Now let us study the '*' operator use in <strong>function definition</strong>.\nExample:</p>\n<pre><code class=\"python\">def sum(*args): #pack the received positional args into data structure of tuple. after applying '*' - def sum((1,2,3,4))\n    sum = 0\n    for a in args:\n        sum+=a\n    print(sum)\n\nsum(1,2,3,4)  #positional args sent to function sum\n#output:\n10\n</code></pre>\n<p>In function <strong>definition</strong> the '*' operator packs the received arguments into a tuple.</p>\n<p>Now let us see an example of '**' used in function definition:</p>\n<pre><code class=\"python\">def sum(**args): #pack keyword args into datastructure of dict after applying '**' - def sum({a:1,b:2,c:3,d:4})\n    sum=0\n    for k,v in args.items():\n        sum+=v\n    print(sum)\n\nsum(a=1,b=2,c=3,d=4) #positional args sent to function sum\n</code></pre>\n<p>In function <strong>definition</strong> The '**' operator packs the received arguments into a dictionary.</p>\n<p>So remember:</p>\n<p>In a <strong>function call</strong> the '*' <strong>unpacks</strong> data structure of tuple or list into positional or keyword arguments to be received by function definition.</p>\n<p>In a <strong>function call</strong> the '**' <strong>unpacks</strong> data structure of dictionary into positional or keyword arguments to be received by function definition.</p>\n<p>In a <strong>function definition</strong> the '*' <strong>packs</strong> positional arguments into a tuple.</p>\n<p>In a <strong>function definition</strong> the '**' <strong>packs</strong> keyword arguments into a dictionary.</p>\n", "abstract": "Let us first understand what are positional arguments and keyword arguments.\nBelow is an example of function definition with Positional arguments. So this is a function definition with positional arguments.\nYou can call it with keyword/named arguments as well: Now let us study an example of function definition with keyword arguments: You can call this function with positional arguments as well: So we now know function definitions with positional as well as keyword arguments. Now let us study the '*' operator and '**' operator. Please note these operators can be used in 2 areas: a) function call b) function definition The use of '*' operator and '**' operator in function call.  Let us get straight to an example and then discuss it. So remember  when the '*' or '**' operator is used in a function call - '*' operator unpacks data structure such as a list or tuple  into arguments needed by function definition. '**' operator unpacks a dictionary into arguments needed by function definition. Now let us study the '*' operator use in function definition.\nExample: In function definition the '*' operator packs the received arguments into a tuple. Now let us see an example of '**' used in function definition: In function definition The '**' operator packs the received arguments into a dictionary. So remember: In a function call the '*' unpacks data structure of tuple or list into positional or keyword arguments to be received by function definition. In a function call the '**' unpacks data structure of dictionary into positional or keyword arguments to be received by function definition. In a function definition the '*' packs positional arguments into a tuple. In a function definition the '**' packs keyword arguments into a dictionary."}, {"id": 47580283, "score": 46, "vote": 0, "content": "<p>This table is handy for using <code>*</code> and <code>**</code> in function <em>construction</em> and function <em>call</em>:</p>\n<pre><code class=\"python\">            In function construction         In function call\n=======================================================================\n          |  def f(*args):                 |  def f(a, b):\n*args     |      for arg in args:          |      return a + b\n          |          print(arg)            |  args = (1, 2)\n          |  f(1, 2)                       |  f(*args)\n----------|--------------------------------|---------------------------\n          |  def f(a, b):                  |  def f(a, b):\n**kwargs  |      return a + b              |      return a + b\n          |  def g(**kwargs):              |  kwargs = dict(a=1, b=2)\n          |      return f(**kwargs)        |  f(**kwargs)\n          |  g(a=1, b=2)                   |\n-----------------------------------------------------------------------\n</code></pre>\n<p>This really just serves to summarize Lorin Hochstein's <a href=\"https://stackoverflow.com/a/36926/7954504\">answer</a> but I find it helpful.</p>\n<p>Relatedly: uses for the star/splat operators have been <a href=\"https://docs.python.org/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations\" rel=\"noreferrer\">expanded</a> in Python 3</p>\n", "abstract": "This table is handy for using * and ** in function construction and function call: This really just serves to summarize Lorin Hochstein's answer but I find it helpful. Relatedly: uses for the star/splat operators have been expanded in Python 3"}, {"id": 12362812, "score": 29, "vote": 0, "content": "<p><code>*</code> and <code>**</code> have special usage in the function argument list. <code>*</code>\nimplies that the argument is a list and <code>**</code> implies that the argument\nis a dictionary. This allows functions to take arbitrary number of\narguments</p>\n", "abstract": "* and ** have special usage in the function argument list. *\nimplies that the argument is a list and ** implies that the argument\nis a dictionary. This allows functions to take arbitrary number of\narguments"}, {"id": 50461663, "score": 24, "vote": 0, "content": "<h2>For those of you who learn by examples!</h2>\n<ol>\n<li>The purpose of <code>*</code>  is to give you the ability to define a function that can take an arbitrary number of arguments provided as a list (e.g. <code>f(*myList)</code> ).</li>\n<li>The purpose of <code>**</code> is to give you the ability to feed a function's arguments by providing a dictionary (e.g. <code>f(**{'x' : 1, 'y' : 2})</code> ).</li>\n</ol>\n<p>Let us show this by defining a function that takes two normal variables <code>x</code>, <code>y</code>, and can accept more arguments as <code>myArgs</code>, and can accept even more arguments as <code>myKW</code>. Later, we will show how to feed <code>y</code> using <code>myArgDict</code>.</p>\n<pre><code class=\"python\">def f(x, y, *myArgs, **myKW):\n    print(\"# x      = {}\".format(x))\n    print(\"# y      = {}\".format(y))\n    print(\"# myArgs = {}\".format(myArgs))\n    print(\"# myKW   = {}\".format(myKW))\n    print(\"# ----------------------------------------------------------------------\")\n\n# Define a list for demonstration purposes\nmyList    = [\"Left\", \"Right\", \"Up\", \"Down\"]\n# Define a dictionary for demonstration purposes\nmyDict    = {\"Wubba\": \"lubba\", \"Dub\": \"dub\"}\n# Define a dictionary to feed y\nmyArgDict = {'y': \"Why?\", 'y0': \"Why not?\", \"q\": \"Here is a cue!\"}\n\n# The 1st elem of myList feeds y\nf(\"myEx\", *myList, **myDict)\n# x      = myEx\n# y      = Left\n# myArgs = ('Right', 'Up', 'Down')\n# myKW   = {'Wubba': 'lubba', 'Dub': 'dub'}\n# ----------------------------------------------------------------------\n\n# y is matched and fed first\n# The rest of myArgDict becomes additional arguments feeding myKW\nf(\"myEx\", **myArgDict)\n# x      = myEx\n# y      = Why?\n# myArgs = ()\n# myKW   = {'y0': 'Why not?', 'q': 'Here is a cue!'}\n# ----------------------------------------------------------------------\n\n# The rest of myArgDict becomes additional arguments feeding myArgs\nf(\"myEx\", *myArgDict)\n# x      = myEx\n# y      = y\n# myArgs = ('y0', 'q')\n# myKW   = {}\n# ----------------------------------------------------------------------\n\n# Feed extra arguments manually and append even more from my list\nf(\"myEx\", 4, 42, 420, *myList, *myDict, **myDict)\n# x      = myEx\n# y      = 4\n# myArgs = (42, 420, 'Left', 'Right', 'Up', 'Down', 'Wubba', 'Dub')\n# myKW   = {'Wubba': 'lubba', 'Dub': 'dub'}\n# ----------------------------------------------------------------------\n\n# Without the stars, the entire provided list and dict become x, and y:\nf(myList, myDict)\n# x      = ['Left', 'Right', 'Up', 'Down']\n# y      = {'Wubba': 'lubba', 'Dub': 'dub'}\n# myArgs = ()\n# myKW   = {}\n# ----------------------------------------------------------------------\n</code></pre>\n<h3>Caveats</h3>\n<ol>\n<li><code>**</code> is exclusively reserved for dictionaries.</li>\n<li>Non-optional argument assignment happens first.</li>\n<li>You cannot use a non-optional argument twice.</li>\n<li>If applicable, <code>**</code> must come after <code>*</code>, always.</li>\n</ol>\n", "abstract": "Let us show this by defining a function that takes two normal variables x, y, and can accept more arguments as myArgs, and can accept even more arguments as myKW. Later, we will show how to feed y using myArgDict."}, {"id": 59630576, "score": 24, "vote": 0, "content": "<p><strong>TL;DR</strong></p>\n<p>Below are 6 different use cases for <code>*</code> and <code>**</code> in python programming:</p>\n<ol>\n<li><strong>To accept any number of positional arguments using <code>*args</code>:</strong> <code>def foo(*args): pass</code>, here <code>foo</code> accepts any number of positional arguments, i. e., the following calls are valid <code>foo(1)</code>, <code>foo(1, 'bar')</code></li>\n<li><strong>To accept any number of keyword arguments using <code>**kwargs</code>:</strong> <code>def foo(**kwargs): pass</code>, here 'foo' accepts any number of keyword arguments, i. e., the following calls are valid <code>foo(name='Tom')</code>, <code>foo(name='Tom', age=33)</code></li>\n<li><strong>To accept any number of positional and keyword arguments using <code>*args, **kwargs</code>:</strong> <code>def foo(*args, **kwargs): pass</code>, here <code>foo</code> accepts any number of positional and keyword arguments, i. e., the following calls are valid <code>foo(1,name='Tom')</code>, <code>foo(1, 'bar', name='Tom', age=33)</code></li>\n<li><strong>To enforce keyword only arguments using <code>*</code>:</strong> <code>def foo(pos1, pos2, *, kwarg1): pass</code>, here <code>*</code> means that foo only accept keyword arguments after pos2, hence <code>foo(1, 2, 3)</code> raises TypeError but <code>foo(1, 2, kwarg1=3)</code> is ok.</li>\n<li><strong>To express no further interest in more positional arguments using <code>*_</code> (Note: this is a convention only):</strong> <code>def foo(bar, baz, *_): pass</code> means (by convention) <code>foo</code> only uses <code>bar</code> and <code>baz</code> arguments in its working and will ignore others.</li>\n<li><strong>To express no further interest in more keyword arguments using <code>\\**_</code> (Note: this is a convention only):</strong> <code>def foo(bar, baz, **_): pass</code> means (by convention) <code>foo</code> only uses <code>bar</code> and <code>baz</code> arguments in its working and will ignore others.</li>\n</ol>\n<p><strong>BONUS:</strong> From python 3.8 onward, one can use <code>/</code> in function definition to enforce  positional only parameters. In the following example, parameters a and b are <strong>positional-only</strong>, while c or d can be positional or keyword, and e or f are required to be keywords:</p>\n<pre><code class=\"python\">def f(a, b, /, c, d, *, e, f):\n    pass\n</code></pre>\n", "abstract": "TL;DR Below are 6 different use cases for * and ** in python programming: BONUS: From python 3.8 onward, one can use / in function definition to enforce  positional only parameters. In the following example, parameters a and b are positional-only, while c or d can be positional or keyword, and e or f are required to be keywords:"}, {"id": 36902, "score": 20, "vote": 0, "content": "<p>From the Python documentation:</p>\n<blockquote>\n<p>If there are more positional arguments than there are formal parameter slots, a TypeError exception is raised, unless a formal parameter using the syntax \"*identifier\" is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments). </p>\n<p>If any keyword argument does not correspond to a formal parameter name, a TypeError exception is raised, unless a formal parameter using the syntax \"**identifier\" is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments. </p>\n</blockquote>\n", "abstract": "From the Python documentation: If there are more positional arguments than there are formal parameter slots, a TypeError exception is raised, unless a formal parameter using the syntax \"*identifier\" is present; in this case, that formal parameter receives a tuple containing the excess positional arguments (or an empty tuple if there were no excess positional arguments).  If any keyword argument does not correspond to a formal parameter name, a TypeError exception is raised, unless a formal parameter using the syntax \"**identifier\" is present; in this case, that formal parameter receives a dictionary containing the excess keyword arguments (using the keywords as keys and the argument values as corresponding values), or a (new) empty dictionary if there were no excess keyword arguments. "}, {"id": 51733267, "score": 17, "vote": 0, "content": "<p><code>*</code> means receive variable arguments as tuple</p>\n<p><code>**</code> means receive variable arguments as dictionary</p>\n<p>Used like the following:</p>\n<p><strong>1) single *</strong></p>\n<pre><code class=\"python\">def foo(*args):\n    for arg in args:\n        print(arg)\n\nfoo(\"two\", 3)\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"python\">two\n3\n</code></pre>\n<p><strong>2) Now <code>**</code></strong></p>\n<pre><code class=\"python\">def bar(**kwargs):\n    for key in kwargs:\n        print(key, kwargs[key])\n\nbar(dic1=\"two\", dic2=3)\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"python\">dic1 two\ndic2 3\n</code></pre>\n", "abstract": "* means receive variable arguments as tuple ** means receive variable arguments as dictionary Used like the following: 1) single * Output: 2) Now ** Output:"}, {"id": 34166505, "score": 13, "vote": 0, "content": "<p>In Python 3.5, you can also use this syntax in <code>list</code>, <code>dict</code>, <code>tuple</code>, and <code>set</code> displays (also sometimes called literals). See <a href=\"http://legacy.python.org/dev/peps/pep-0448/\" rel=\"noreferrer\">PEP 488: Additional Unpacking Generalizations</a>.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; (0, *range(1, 4), 5, *range(6, 8))\n(0, 1, 2, 3, 5, 6, 7)\n&gt;&gt;&gt; [0, *range(1, 4), 5, *range(6, 8)]\n[0, 1, 2, 3, 5, 6, 7]\n&gt;&gt;&gt; {0, *range(1, 4), 5, *range(6, 8)}\n{0, 1, 2, 3, 5, 6, 7}\n&gt;&gt;&gt; d = {'one': 1, 'two': 2, 'three': 3}\n&gt;&gt;&gt; e = {'six': 6, 'seven': 7}\n&gt;&gt;&gt; {'zero': 0, **d, 'five': 5, **e}\n{'five': 5, 'seven': 7, 'two': 2, 'one': 1, 'three': 3, 'six': 6, 'zero': 0}\n</code></pre>\n<p>It also allows multiple iterables to be unpacked in a single function call.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; range(*[1, 10], *[2])\nrange(1, 10, 2)\n</code></pre>\n<p>(Thanks to mgilson for the PEP link.)</p>\n", "abstract": "In Python 3.5, you can also use this syntax in list, dict, tuple, and set displays (also sometimes called literals). See PEP 488: Additional Unpacking Generalizations. It also allows multiple iterables to be unpacked in a single function call. (Thanks to mgilson for the PEP link.)"}, {"id": 40492308, "score": 10, "vote": 0, "content": "<p>I want to give an example which others haven't  mentioned</p>\n<p>* can also unpack a <strong>generator</strong></p>\n<p>An example from Python3 Document</p>\n<pre><code class=\"python\">x = [1, 2, 3]\ny = [4, 5, 6]\n\nunzip_x, unzip_y = zip(*zip(x, y))\n</code></pre>\n<p>unzip_x will be [1, 2, 3], unzip_y will be [4, 5, 6]</p>\n<p>The zip() receives multiple iretable args, and return a generator. </p>\n<pre><code class=\"python\">zip(*zip(x,y)) -&gt; zip((1, 4), (2, 5), (3, 6))\n</code></pre>\n", "abstract": "I want to give an example which others haven't  mentioned * can also unpack a generator An example from Python3 Document unzip_x will be [1, 2, 3], unzip_y will be [4, 5, 6] The zip() receives multiple iretable args, and return a generator. "}, {"id": 55475113, "score": 10, "vote": 0, "content": "<h2>TL;DR</h2>\n<p>It packs arguments passed to the function into <code>list</code> and <code>dict</code> respectively inside the function body. When you define a function signature like this:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def func(*args, **kwds):\n    # do stuff\n</code></pre>\n<p>it can be called with any number of arguments and keyword arguments. The non-keyword arguments get packed into a list called <code>args</code> inside the function body and the keyword arguments get packed into a dict called <code>kwds</code> inside the function body.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">func(\"this\", \"is a list of\", \"non-keyowrd\", \"arguments\", keyword=\"ligma\", options=[1,2,3])\n</code></pre>\n<p>now inside the function body, when the function is called, there are two local variables, <code>args</code> which is a list having value <code>[\"this\", \"is a list of\", \"non-keyword\", \"arguments\"]</code> and <code>kwds</code> which is a <code>dict</code> having value <code>{\"keyword\" : \"ligma\", \"options\" : [1,2,3]}</code></p>\n<hr/>\n<p>This also works in reverse, i.e. from the caller side. for example if you have a function defined as:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def f(a, b, c, d=1, e=10):\n    # do stuff\n</code></pre>\n<p>you can call it with by unpacking iterables or mappings you have in the calling scope:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">iterable = [1, 20, 500]\nmapping = {\"d\" : 100, \"e\": 3}\nf(*iterable, **mapping)\n# That call is equivalent to\nf(1, 20, 500, d=100, e=3)\n</code></pre>\n", "abstract": "It packs arguments passed to the function into list and dict respectively inside the function body. When you define a function signature like this: it can be called with any number of arguments and keyword arguments. The non-keyword arguments get packed into a list called args inside the function body and the keyword arguments get packed into a dict called kwds inside the function body. now inside the function body, when the function is called, there are two local variables, args which is a list having value [\"this\", \"is a list of\", \"non-keyword\", \"arguments\"] and kwds which is a dict having value {\"keyword\" : \"ligma\", \"options\" : [1,2,3]} This also works in reverse, i.e. from the caller side. for example if you have a function defined as: you can call it with by unpacking iterables or mappings you have in the calling scope:"}, {"id": 56962836, "score": 8, "vote": 0, "content": "<p>Building on nickd's <a href=\"https://stackoverflow.com/a/36911/8588359\">answer</a>...</p>\n<pre><code class=\"python\">def foo(param1, *param2):\n    print(param1)\n    print(param2)\n\n\ndef bar(param1, **param2):\n    print(param1)\n    print(param2)\n\n\ndef three_params(param1, *param2, **param3):\n    print(param1)\n    print(param2)\n    print(param3)\n\n\nfoo(1, 2, 3, 4, 5)\nprint(\"\\n\")\nbar(1, a=2, b=3)\nprint(\"\\n\")\nthree_params(1, 2, 3, 4, s=5)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">1\n(2, 3, 4, 5)\n\n1\n{'a': 2, 'b': 3}\n\n1\n(2, 3, 4)\n{'s': 5}\n</code></pre>\n<p>Basically, any number of <strong>positional arguments</strong> can use *args and any <strong>named arguments</strong> (or kwargs aka keyword arguments) can use **kwargs.</p>\n", "abstract": "Building on nickd's answer... Output: Basically, any number of positional arguments can use *args and any named arguments (or kwargs aka keyword arguments) can use **kwargs."}, {"id": 32031804, "score": 7, "vote": 0, "content": "<p>In addition to function calls, *args and **kwargs are useful in class hierarchies and also avoid having to write <code>__init__</code> method in Python. Similar usage can seen in frameworks like Django code.</p>\n<p>For example,</p>\n<pre><code class=\"python\">def __init__(self, *args, **kwargs):\n    for attribute_name, value in zip(self._expected_attributes, args):\n        setattr(self, attribute_name, value)\n        if kwargs.has_key(attribute_name):\n            kwargs.pop(attribute_name)\n\n    for attribute_name in kwargs.viewkeys():\n        setattr(self, attribute_name, kwargs[attribute_name])\n</code></pre>\n<p>A subclass can then be</p>\n<pre><code class=\"python\">class RetailItem(Item):\n    _expected_attributes = Item._expected_attributes + ['name', 'price', 'category', 'country_of_origin']\n\nclass FoodItem(RetailItem):\n    _expected_attributes = RetailItem._expected_attributes +  ['expiry_date']\n</code></pre>\n<p>The subclass then be instantiated as </p>\n<pre><code class=\"python\">food_item = FoodItem(name = 'Jam', \n                     price = 12.0, \n                     category = 'Foods', \n                     country_of_origin = 'US', \n                     expiry_date = datetime.datetime.now())\n</code></pre>\n<p>Also, a subclass with a new attribute which makes sense only to that subclass instance can call the Base class <code>__init__</code> to offload the attributes setting.\nThis is done through *args and **kwargs. kwargs mainly used so that code is readable using named arguments. For example,</p>\n<pre><code class=\"python\">class ElectronicAccessories(RetailItem):\n    _expected_attributes = RetailItem._expected_attributes +  ['specifications']\n    # Depend on args and kwargs to populate the data as needed.\n    def __init__(self, specifications = None, *args, **kwargs):\n        self.specifications = specifications  # Rest of attributes will make sense to parent class.\n        super(ElectronicAccessories, self).__init__(*args, **kwargs)\n</code></pre>\n<p>which can be instatiated as</p>\n<pre><code class=\"python\">usb_key = ElectronicAccessories(name = 'Sandisk', \n                                price = '$6.00', \n                                category = 'Electronics',\n                                country_of_origin = 'CN',\n                                specifications = '4GB USB 2.0/USB 3.0')\n</code></pre>\n<p>The complete code is <a href=\"http://harisankar-krishnaswamy.blogspot.sg/2015/08/using-args-and-kwargs-python-code-post.html\" rel=\"nofollow noreferrer\">here</a></p>\n", "abstract": "In addition to function calls, *args and **kwargs are useful in class hierarchies and also avoid having to write __init__ method in Python. Similar usage can seen in frameworks like Django code. For example, A subclass can then be The subclass then be instantiated as  Also, a subclass with a new attribute which makes sense only to that subclass instance can call the Base class __init__ to offload the attributes setting.\nThis is done through *args and **kwargs. kwargs mainly used so that code is readable using named arguments. For example, which can be instatiated as The complete code is here"}, {"id": 50116852, "score": 4, "vote": 0, "content": "<p><code>*args</code> and <code>**kwargs</code>: allow you to pass a variable number of arguments to a function. </p>\n<p><code>*args</code>: is used to send a non-keyworded variable length argument list to the function:</p>\n<pre><code class=\"python\">def args(normal_arg, *argv):\n    print(\"normal argument:\", normal_arg)\n\n    for arg in argv:\n        print(\"Argument in list of arguments from *argv:\", arg)\n\nargs('animals', 'fish', 'duck', 'bird')\n</code></pre>\n<p>Will produce:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">normal argument: animals\nArgument in list of arguments from *argv: fish\nArgument in list of arguments from *argv: duck\nArgument in list of arguments from *argv: bird\n</code></pre>\n<p><code>**kwargs*</code></p>\n<p><code>**kwargs</code> allows you to pass keyworded variable length of arguments to a function. You should use <code>**kwargs</code> if you want to handle named arguments in a function. </p>\n<pre><code class=\"python\">def who(**kwargs):\n    if kwargs is not None:\n        for key, value in kwargs.items():\n            print(\"Your %s is %s.\" % (key, value))\n\nwho(name=\"Nikola\", last_name=\"Tesla\", birthday=\"7.10.1856\", birthplace=\"Croatia\")  \n</code></pre>\n<p>Will produce:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">Your name is Nikola.\nYour last_name is Tesla.\nYour birthday is 7.10.1856.\nYour birthplace is Croatia.\n</code></pre>\n", "abstract": "*args and **kwargs: allow you to pass a variable number of arguments to a function.  *args: is used to send a non-keyworded variable length argument list to the function: Will produce: **kwargs* **kwargs allows you to pass keyworded variable length of arguments to a function. You should use **kwargs if you want to handle named arguments in a function.  Will produce:"}, {"id": 62442187, "score": 4, "vote": 0, "content": "<p>Given a function that has 3 items as argument</p>\n<pre><code class=\"python\">sum = lambda x, y, z: x + y + z\nsum(1,2,3) # sum 3 items\n\nsum([1,2,3]) # error, needs 3 items, not 1 list\n\nx = [1,2,3][0]\ny = [1,2,3][1]\nz = [1,2,3][2]\nsum(x,y,z) # ok\n\nsum(*[1,2,3]) # ok, 1 list becomes 3 items\n</code></pre>\n<p>Imagine this toy with a bag of a triangle, a circle and a rectangle item. That bag does not directly fit. You need to unpack the bag to take those 3 items and now they fit. The Python * operator does this unpack process.</p>\n<p><a href=\"https://i.stack.imgur.com/9gf2j.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/9gf2j.jpg\"/></a></p>\n", "abstract": "Given a function that has 3 items as argument Imagine this toy with a bag of a triangle, a circle and a rectangle item. That bag does not directly fit. You need to unpack the bag to take those 3 items and now they fit. The Python * operator does this unpack process. "}, {"id": 40262722, "score": 3, "vote": 0, "content": "<p>A good example of using both in a function is:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def foo(*arg,**kwargs):\n...     print arg\n...     print kwargs\n&gt;&gt;&gt;\n&gt;&gt;&gt; a = (1, 2, 3)\n&gt;&gt;&gt; b = {'aa': 11, 'bb': 22}\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; foo(*a,**b)\n(1, 2, 3)\n{'aa': 11, 'bb': 22}\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; foo(a,**b) \n((1, 2, 3),)\n{'aa': 11, 'bb': 22}\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; foo(a,b) \n((1, 2, 3), {'aa': 11, 'bb': 22})\n{}\n&gt;&gt;&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; foo(a,*b)\n((1, 2, 3), 'aa', 'bb')\n{}\n</code></pre>\n", "abstract": "A good example of using both in a function is:"}, {"id": 40823181, "score": 3, "vote": 0, "content": "<p>This example would help you remember <code>*args</code>, <code>**kwargs</code> and even <code>super</code> and inheritance in Python at once.</p>\n<pre><code class=\"python\">class base(object):\n    def __init__(self, base_param):\n        self.base_param = base_param\n\n\nclass child1(base): # inherited from base class\n    def __init__(self, child_param, *args) # *args for non-keyword args\n        self.child_param = child_param\n        super(child1, self).__init__(*args) # call __init__ of the base class and initialize it with a NON-KEYWORD arg\n\nclass child2(base):\n    def __init__(self, child_param, **kwargs):\n        self.child_param = child_param\n        super(child2, self).__init__(**kwargs) # call __init__ of the base class and initialize it with a KEYWORD arg\n\nc1 = child1(1,0)\nc2 = child2(1,base_param=0)\nprint c1.base_param # 0\nprint c1.child_param # 1\nprint c2.base_param # 0\nprint c2.child_param # 1\n</code></pre>\n", "abstract": "This example would help you remember *args, **kwargs and even super and inheritance in Python at once."}, {"id": 59217020, "score": 2, "vote": 0, "content": "<h2>Context</h2>\n<ul>\n<li>python 3.x</li>\n<li>unpacking with <code>**</code></li>\n<li>use with string formatting</li>\n</ul>\n<h2>Use with string formatting</h2>\n<p>In addition to the answers in this thread, here is another detail that was not mentioned elsewhere. This expands on the <a href=\"https://stackoverflow.com/a/47580283/42223\">answer by Brad Solomon</a></p>\n<p>Unpacking with <code>**</code> is also useful when using python <code>str.format</code>.  </p>\n<p>This is somewhat similar to what you can do with python <code>f-strings</code> <a href=\"https://stackoverflow.com/questions/tagged/f-string\">f-string</a> but with the added overhead of declaring a dict to hold the variables (f-string does not require a dict).</p>\n<h2>Quick Example</h2>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">  ## init vars\n  ddvars = dict()\n  ddcalc = dict()\n  pass\n  ddvars['fname']     = 'Huomer'\n  ddvars['lname']     = 'Huimpson'\n  ddvars['motto']     = 'I love donuts!'\n  ddvars['age']       = 33\n  pass\n  ddcalc['ydiff']     = 5\n  ddcalc['ycalc']     = ddvars['age'] + ddcalc['ydiff']\n  pass\n  vdemo = []\n\n  ## ********************\n  ## single unpack supported in py 2.7\n  vdemo.append('''\n  Hello {fname} {lname}!\n\n  Today you are {age} years old!\n\n  We love your motto \"{motto}\" and we agree with you!\n  '''.format(**ddvars)) \n  pass\n\n  ## ********************\n  ## multiple unpack supported in py 3.x\n  vdemo.append('''\n  Hello {fname} {lname}!\n\n  In {ydiff} years you will be {ycalc} years old!\n  '''.format(**ddvars,**ddcalc)) \n  pass\n\n  ## ********************\n  print(vdemo[-1])\n\n</code></pre>\n", "abstract": "In addition to the answers in this thread, here is another detail that was not mentioned elsewhere. This expands on the answer by Brad Solomon Unpacking with ** is also useful when using python str.format.   This is somewhat similar to what you can do with python f-strings f-string but with the added overhead of declaring a dict to hold the variables (f-string does not require a dict)."}, {"id": 66705594, "score": 2, "vote": 0, "content": "<p>*args ( or *any ) means every parameters</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def any_param(*param):\n    pass\n\nany_param(1)\nany_param(1,1)\nany_param(1,1,1)\nany_param(1,...)\n</code></pre>\n<p><em>NOTICE</em> : you can don't pass parameters to *args</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def any_param(*param):\n    pass\n\nany_param() # will work correct\n</code></pre>\n<p>The *args is in type tuple</p>\n<pre><code class=\"python\">def any_param(*param):\n    return type(param)\n\nany_param(1) #tuple\nany_param() # tuple\n</code></pre>\n<p>for access to elements don't use of *</p>\n<pre><code class=\"python\">def any(*param):\n    param[0] # correct\n\ndef any(*param):\n    *param[0] # incorrect\n</code></pre>\n<p>The **kwd</p>\n<p>**kwd or **any\nThis is a dict type</p>\n<pre><code class=\"python\">def func(**any):\n    return type(any) # dict\n\ndef func(**any):\n    return any\n\nfunc(width=\"10\",height=\"20\") # {width=\"10\",height=\"20\")\n\n\n</code></pre>\n", "abstract": "*args ( or *any ) means every parameters NOTICE : you can don't pass parameters to *args The *args is in type tuple for access to elements don't use of * The **kwd **kwd or **any\nThis is a dict type"}, {"id": 52134172, "score": 0, "vote": 0, "content": "<ul>\n<li><code>def foo(param1, *param2):</code> is a method can accept arbitrary number of values for <code>*param2</code>,</li>\n<li><code>def bar(param1, **param2):</code> is a method can accept arbitrary number of values with keys for <code>*param2</code></li>\n<li><code>param1</code> is a simple parameter.</li>\n</ul>\n<p>For example, the syntax for implementing <strong>varargs</strong> in Java as follows:</p>\n<pre><code class=\"python\">accessModifier methodName(datatype\u2026 arg) {\n    // method body\n}\n</code></pre>\n", "abstract": "For example, the syntax for implementing varargs in Java as follows:"}, {"id": 73178373, "score": 0, "vote": 0, "content": "<h3>\"Infinite\" Args with *args and **kwargs</h3>\n<p><code>*args</code> and <code>**kwargs</code> are just some way to input unlimited characters to functions, like:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">\ndef print_all(*args, **kwargs):\n    print(args) # print any number of arguments like: \"print_all(\"foo\", \"bar\")\"\n    print(kwargs.get(\"to_print\")) # print the value of the keyworded argument \"to_print\"\n\n\n# example:\nprint_all(\"Hello\", \"World\", to_print=\"!\")\n# will print:\n\"\"\"\n('Hello', 'World')\n!\n\"\"\"\n</code></pre>\n", "abstract": "*args and **kwargs are just some way to input unlimited characters to functions, like:"}]}, {"link": "https://stackoverflow.com/questions/510348/how-do-i-make-a-time-delay", "question": {"id": "510348", "title": "How do I make a time delay?", "content": "<p>How do I put a time delay in a Python script?</p>\n", "abstract": "How do I put a time delay in a Python script?"}, "answers": [{"id": 510351, "score": 3340, "vote": 0, "content": "<p>This delays for 2.5 seconds:</p>\n<pre><code class=\"python\">import time\ntime.sleep(2.5)\n</code></pre>\n<hr/>\n<p>Here is another example where something is run approximately once a minute:</p>\n<pre><code class=\"python\">import time\nwhile True:\n    print(\"This prints once a minute.\")\n    time.sleep(60) # Delay for 1 minute (60 seconds).\n</code></pre>\n", "abstract": "This delays for 2.5 seconds: Here is another example where something is run approximately once a minute:"}, {"id": 64486, "score": 854, "vote": 0, "content": "<p>Use <a href=\"https://docs.python.org/library/time.html#time.sleep\" rel=\"noreferrer\"><code>sleep()</code></a> from the <code>time</code> module. It can take a float argument for sub-second resolution.</p>\n<pre><code class=\"python\">from time import sleep\nsleep(0.1)  # Time in seconds\n</code></pre>\n", "abstract": "Use sleep() from the time module. It can take a float argument for sub-second resolution."}, {"id": 44666336, "score": 108, "vote": 0, "content": "<blockquote>\n<h1>How can I make a time delay in Python?</h1>\n</blockquote>\n<p>In a single thread I suggest the <a href=\"https://docs.python.org/3/library/time.html#time.sleep\" rel=\"noreferrer\">sleep function</a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from time import sleep\n\n&gt;&gt;&gt; sleep(4)\n</code></pre>\n<p>This function actually suspends the processing of the thread in which it is called by the operating system, allowing other threads and processes to execute while it sleeps.</p>\n<p>Use it for that purpose, or simply to delay a function from executing. For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; def party_time():\n...     print('hooray!')\n...\n&gt;&gt;&gt; sleep(3); party_time()\nhooray!\n</code></pre>\n<p>\"hooray!\" is printed 3 seconds after I hit <kbd>Enter</kbd>.</p>\n<h3>Example using <code>sleep</code> with multiple threads and processes</h3>\n<p>Again, <code>sleep</code> suspends your thread - it uses next to zero processing power.</p>\n<p>To demonstrate, create a script like this (I first attempted this in an interactive Python 3.5 shell, but sub-processes can't find the <code>party_later</code> function for some reason):</p>\n<pre><code class=\"python\">from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed\nfrom time import sleep, time\n\ndef party_later(kind='', n=''):\n    sleep(3)\n    return kind + n + ' party time!: ' + __name__\n\ndef main():\n    with ProcessPoolExecutor() as proc_executor:\n        with ThreadPoolExecutor() as thread_executor:\n            start_time = time()\n            proc_future1 = proc_executor.submit(party_later, kind='proc', n='1')\n            proc_future2 = proc_executor.submit(party_later, kind='proc', n='2')\n            thread_future1 = thread_executor.submit(party_later, kind='thread', n='1')\n            thread_future2 = thread_executor.submit(party_later, kind='thread', n='2')\n            for f in as_completed([\n              proc_future1, proc_future2, thread_future1, thread_future2,]):\n                print(f.result())\n            end_time = time()\n    print('total time to execute four 3-sec functions:', end_time - start_time)\n\nif __name__ == '__main__':\n    main()\n</code></pre>\n<p>Example output from this script:</p>\n<pre><code class=\"python\">thread1 party time!: __main__\nthread2 party time!: __main__\nproc1 party time!: __mp_main__\nproc2 party time!: __mp_main__\ntotal time to execute four 3-sec functions: 3.4519670009613037\n</code></pre>\n<h2>Multithreading</h2>\n<p>You can trigger a function to be called at a later time in a separate thread with the <code>Timer</code> <a href=\"https://docs.python.org/3/library/threading.html\" rel=\"noreferrer\">threading</a> object:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from threading import Timer\n&gt;&gt;&gt; t = Timer(3, party_time, args=None, kwargs=None)\n&gt;&gt;&gt; t.start()\n&gt;&gt;&gt;\n&gt;&gt;&gt; hooray!\n\n&gt;&gt;&gt;\n</code></pre>\n<p>The blank line illustrates that the function printed to my standard output, and I had to hit <kbd>Enter</kbd> to ensure I was on a prompt.</p>\n<p>The upside of this method is that while the <code>Timer</code> thread was waiting, I was able to do other things, in this case, hitting <kbd>Enter</kbd> one time - before the function executed (see the first empty prompt).</p>\n<p>There isn't a respective object in the <a href=\"https://docs.python.org/3/library/multiprocessing.html\" rel=\"noreferrer\">multiprocessing library</a>. You can create one, but it probably doesn't exist for a reason. A sub-thread makes a lot more sense for a simple timer than a whole new subprocess.</p>\n", "abstract": "In a single thread I suggest the sleep function: This function actually suspends the processing of the thread in which it is called by the operating system, allowing other threads and processes to execute while it sleeps. Use it for that purpose, or simply to delay a function from executing. For example: \"hooray!\" is printed 3 seconds after I hit Enter. Again, sleep suspends your thread - it uses next to zero processing power. To demonstrate, create a script like this (I first attempted this in an interactive Python 3.5 shell, but sub-processes can't find the party_later function for some reason): Example output from this script: You can trigger a function to be called at a later time in a separate thread with the Timer threading object: The blank line illustrates that the function printed to my standard output, and I had to hit Enter to ensure I was on a prompt. The upside of this method is that while the Timer thread was waiting, I was able to do other things, in this case, hitting Enter one time - before the function executed (see the first empty prompt). There isn't a respective object in the multiprocessing library. You can create one, but it probably doesn't exist for a reason. A sub-thread makes a lot more sense for a simple timer than a whole new subprocess."}, {"id": 48111882, "score": 79, "vote": 0, "content": "<p>Delays can be also implemented by using the following methods.</p>\n<p>The first method:</p>\n<pre><code class=\"python\">import time\ntime.sleep(5) # Delay for 5 seconds.\n</code></pre>\n<p>The second method to delay would be using the implicit wait method:</p>\n<pre><code class=\"python\"> driver.implicitly_wait(5)\n</code></pre>\n<p>The third method is more useful when you have to wait until a particular action is completed or until an element is found:</p>\n<pre><code class=\"python\">self.wait.until(EC.presence_of_element_located((By.ID, 'UserName'))\n</code></pre>\n", "abstract": "Delays can be also implemented by using the following methods. The first method: The second method to delay would be using the implicit wait method: The third method is more useful when you have to wait until a particular action is completed or until an element is found:"}, {"id": 51199666, "score": 63, "vote": 0, "content": "<p>There are five methods which I know: <code>time.sleep()</code>, <code>pygame.time.wait()</code>, matplotlib's <code>pyplot.pause()</code>, <code>.after()</code>, and <code>asyncio.sleep()</code>.</p>\n<hr/>\n<p><code>time.sleep()</code> example (do not use if using tkinter):</p>\n<pre><code class=\"python\">import time\nprint('Hello')\ntime.sleep(5) # Number of seconds\nprint('Bye')\n</code></pre>\n<hr/>\n<p><code>pygame.time.wait()</code> example (not recommended if you are not using the pygame window, but you could exit the window instantly):</p>\n<pre><code class=\"python\">import pygame\n# If you are going to use the time module\n# don't do \"from pygame import *\"\npygame.init()\nprint('Hello')\npygame.time.wait(5000) # Milliseconds\nprint('Bye')\n</code></pre>\n<hr/>\n<p>matplotlib's function <code>pyplot.pause()</code> example (not recommended if you are not using the graph, but you could exit the graph instantly):</p>\n<pre><code class=\"python\">import matplotlib\nprint('Hello')\nmatplotlib.pyplot.pause(5) # Seconds\nprint('Bye')\n</code></pre>\n<hr/>\n<p>The <code>.after()</code> method (best with Tkinter):</p>\n<pre><code class=\"python\">import tkinter as tk # Tkinter for Python&amp;nbsp;2\nroot = tk.Tk()\nprint('Hello')\ndef ohhi():\n    print('Oh, hi!')\nroot.after(5000, ohhi) # Milliseconds and then a function\nprint('Bye')\n</code></pre>\n<hr/>\n<p>Finally, the <code>asyncio.sleep()</code> method (has to be in an async loop):</p>\n<pre><code class=\"python\">await asyncio.sleep(5)\n</code></pre>\n", "abstract": "There are five methods which I know: time.sleep(), pygame.time.wait(), matplotlib's pyplot.pause(), .after(), and asyncio.sleep(). time.sleep() example (do not use if using tkinter): pygame.time.wait() example (not recommended if you are not using the pygame window, but you could exit the window instantly): matplotlib's function pyplot.pause() example (not recommended if you are not using the graph, but you could exit the graph instantly): The .after() method (best with Tkinter): Finally, the asyncio.sleep() method (has to be in an async loop):"}, {"id": 23665492, "score": 54, "vote": 0, "content": "<p>A bit of fun with a sleepy <a href=\"https://wiki.python.org/moin/Generators\" rel=\"noreferrer\">generator</a>.</p>\n<p>The question is about time delay. It can be fixed time, but in some cases we might need a delay measured since last time. Here is one possible solution:</p>\n<h1>Delay measured since last time (waking up regularly)</h1>\n<p>The situation can be, we want to do something as regularly as possible and we do not want to bother with all the <code>last_time</code>, <code>next_time</code> stuff all around our code.</p>\n<h2>Buzzer generator</h2>\n<p>The following code (<strong>sleepy.py</strong>) defines a <code>buzzergen</code> generator:</p>\n<pre><code class=\"python\">import time\nfrom itertools import count\n\ndef buzzergen(period):\n    nexttime = time.time() + period\n    for i in count():\n        now = time.time()\n        tosleep = nexttime - now\n        if tosleep &gt; 0:\n            time.sleep(tosleep)\n            nexttime += period\n        else:\n            nexttime = now + period\n        yield i, nexttime\n</code></pre>\n<h2>Invoking regular buzzergen</h2>\n<pre><code class=\"python\">from sleepy import buzzergen\nimport time\nbuzzer = buzzergen(3) # Planning to wake up each 3 seconds\nprint time.time()\nbuzzer.next()\nprint time.time()\ntime.sleep(2)\nbuzzer.next()\nprint time.time()\ntime.sleep(5) # Sleeping a bit longer than usually\nbuzzer.next()\nprint time.time()\nbuzzer.next()\nprint time.time()\n</code></pre>\n<p>And running it we see:</p>\n<pre><code class=\"python\">1400102636.46\n1400102639.46\n1400102642.46\n1400102647.47\n1400102650.47\n</code></pre>\n<p>We can also use it directly in a loop:</p>\n<pre><code class=\"python\">import random\nfor ring in buzzergen(3):\n    print \"now\", time.time()\n    print \"ring\", ring\n    time.sleep(random.choice([0, 2, 4, 6]))\n</code></pre>\n<p>And running it we might see:</p>\n<pre><code class=\"python\">now 1400102751.46\nring (0, 1400102754.461676)\nnow 1400102754.46\nring (1, 1400102757.461676)\nnow 1400102757.46\nring (2, 1400102760.461676)\nnow 1400102760.46\nring (3, 1400102763.461676)\nnow 1400102766.47\nring (4, 1400102769.47115)\nnow 1400102769.47\nring (5, 1400102772.47115)\nnow 1400102772.47\nring (6, 1400102775.47115)\nnow 1400102775.47\nring (7, 1400102778.47115)\n</code></pre>\n<p>As we see, this buzzer is not too rigid and allow us to catch up with regular sleepy intervals even if we oversleep and get out of regular schedule.</p>\n", "abstract": "A bit of fun with a sleepy generator. The question is about time delay. It can be fixed time, but in some cases we might need a delay measured since last time. Here is one possible solution: The situation can be, we want to do something as regularly as possible and we do not want to bother with all the last_time, next_time stuff all around our code. The following code (sleepy.py) defines a buzzergen generator: And running it we see: We can also use it directly in a loop: And running it we might see: As we see, this buzzer is not too rigid and allow us to catch up with regular sleepy intervals even if we oversleep and get out of regular schedule."}, {"id": 42517469, "score": 34, "vote": 0, "content": "<p>The <a href=\"http://en.wikipedia.org/wiki/Tkinter\" rel=\"noreferrer\">Tkinter</a> library in the Python standard library is an interactive tool which you can import. Basically, you can create buttons and boxes and popups and stuff that appear as windows which you manipulate with code.</p>\n<p>If you use Tkinter, <strong><em>do not use <code>time.sleep()</code></em></strong>, because it will muck up your program. This happened to me. Instead, use <code>root.after()</code> and replace the values for however many seconds, with a milliseconds. For example, <code>time.sleep(1)</code> is equivalent to <code>root.after(1000)</code> in Tkinter.</p>\n<p>Otherwise, <code>time.sleep()</code>, which many answers have pointed out, which is the way to go.</p>\n", "abstract": "The Tkinter library in the Python standard library is an interactive tool which you can import. Basically, you can create buttons and boxes and popups and stuff that appear as windows which you manipulate with code. If you use Tkinter, do not use time.sleep(), because it will muck up your program. This happened to me. Instead, use root.after() and replace the values for however many seconds, with a milliseconds. For example, time.sleep(1) is equivalent to root.after(1000) in Tkinter. Otherwise, time.sleep(), which many answers have pointed out, which is the way to go."}, {"id": 44529622, "score": 26, "vote": 0, "content": "<p>Delays are done with the <a href=\"https://docs.python.org/2/library/time.html\" rel=\"nofollow noreferrer\">time library</a>, specifically the <a href=\"https://docs.python.org/2/library/time.html#time.sleep\" rel=\"nofollow noreferrer\"><code>time.sleep()</code></a> function.</p>\n<p>To just make it wait for a second:</p>\n<pre><code class=\"python\">from time import sleep\nsleep(1)\n</code></pre>\n<p>This works because by doing:</p>\n<pre><code class=\"python\">from time import sleep\n</code></pre>\n<p>You extract the <a href=\"https://docs.python.org/2/library/time.html#time.sleep\" rel=\"nofollow noreferrer\">sleep function</a> <strong>only</strong> from the <a href=\"https://docs.python.org/2/library/time.html\" rel=\"nofollow noreferrer\">time library</a>, which means you can just call it with:</p>\n<pre><code class=\"python\">sleep(seconds)\n</code></pre>\n<p>Rather than having to type out</p>\n<pre><code class=\"python\">time.sleep()\n</code></pre>\n<p>Which is awkwardly long to type.</p>\n<p>With this method, you wouldn't get access to the other features of the <a href=\"https://docs.python.org/2/library/time.html\" rel=\"nofollow noreferrer\">time library</a> and you can't have a variable called <code>sleep</code>. But you could create a variable called <code>time</code>.</p>\n<p>Doing <a href=\"https://docs.python.org/2/tutorial/modules.html#more-on-modules\" rel=\"nofollow noreferrer\"><code>from [library] import [function] (, [function2])</code></a> is great if you just want certain parts of a module.</p>\n<p>You could equally do it as:</p>\n<pre><code class=\"python\">import time\ntime.sleep(1)\n</code></pre>\n<p>and you would have access to the other features of the <a href=\"https://docs.python.org/2/library/time.html\" rel=\"nofollow noreferrer\">time library</a> like <a href=\"https://docs.python.org/2/library/time.html#time.clock\" rel=\"nofollow noreferrer\"><code>time.clock()</code></a> as long as you type <code>time.[function]()</code>, but you couldn't create the variable time because it would overwrite the import. A solution to this to do</p>\n<pre><code class=\"python\">import time as t\n</code></pre>\n<p>which would allow you to reference the <a href=\"https://docs.python.org/2/library/time.html\" rel=\"nofollow noreferrer\">time library</a> as <code>t</code>, allowing you to do:</p>\n<pre><code class=\"python\">t.sleep()\n</code></pre>\n<p>This works on any library.</p>\n", "abstract": "Delays are done with the time library, specifically the time.sleep() function. To just make it wait for a second: This works because by doing: You extract the sleep function only from the time library, which means you can just call it with: Rather than having to type out Which is awkwardly long to type. With this method, you wouldn't get access to the other features of the time library and you can't have a variable called sleep. But you could create a variable called time. Doing from [library] import [function] (, [function2]) is great if you just want certain parts of a module. You could equally do it as: and you would have access to the other features of the time library like time.clock() as long as you type time.[function](), but you couldn't create the variable time because it would overwrite the import. A solution to this to do which would allow you to reference the time library as t, allowing you to do: This works on any library."}, {"id": 54128477, "score": 14, "vote": 0, "content": "<h3>If you would like to put a time delay in a Python script:</h3>\n<p>Use <strong><code>time.sleep</code></strong> or <strong><code>Event().wait</code></strong> like this:</p>\n<pre><code class=\"python\">from threading import Event\nfrom time import sleep\n\ndelay_in_sec = 2\n\n# Use time.sleep like this\nsleep(delay_in_sec)         # Returns None\nprint(f'slept for {delay_in_sec} seconds')\n\n# Or use Event().wait like this\nEvent().wait(delay_in_sec)  # Returns False\nprint(f'waited for {delay_in_sec} seconds')\n</code></pre>\n<h1>However, if you want to delay the execution of a function do this:</h1>\n<p>Use <a href=\"https://docs.python.org/2.7/library/threading.html?highlight=timer#threading.Timer\" rel=\"noreferrer\"><strong><code>threading.Timer</code></strong></a> like this:</p>\n<pre><code class=\"python\">from threading import Timer\n\ndelay_in_sec = 2\n\ndef hello(delay_in_sec):\n    print(f'function called after {delay_in_sec} seconds')\n\nt = Timer(delay_in_sec, hello, [delay_in_sec])  # Hello function will be called 2 seconds later with [delay_in_sec] as the *args parameter\nt.start()  # Returns None\nprint(\"Started\")\n</code></pre>\n<p>Outputs:</p>\n<pre><code class=\"python\">Started\nfunction called after 2 seconds\n</code></pre>\n<h3>Why use the later approach?</h3>\n<ul>\n<li>It does <strong>not</strong> stop execution of the whole script (except for the function you pass it).</li>\n<li>After starting the timer you can also stop it by doing <code>timer_obj.cancel()</code>.</li>\n</ul>\n", "abstract": "Use time.sleep or Event().wait like this: Use threading.Timer like this: Outputs:"}, {"id": 53600344, "score": 11, "vote": 0, "content": "<h2>asyncio.sleep</h2>\n<p>Notice in recent Python versions (Python\u00a03.4 or higher) you can use <code>asyncio.sleep</code>. It's related to asynchronous programming and asyncio. Check out next example:</p>\n<pre><code class=\"python\">import asyncio\nfrom datetime import datetime\n\n@asyncio.coroutine\ndef countdown(iteration_name, countdown_sec):\n    \"\"\"\n    Just count for some countdown_sec seconds and do nothing else\n    \"\"\"\n    while countdown_sec &gt; 0:\n       print(f'{iteration_name} iterates: {countdown_sec} seconds')\n       yield from asyncio.sleep(1)\n       countdown_sec -= 1\n\nloop = asyncio.get_event_loop()\ntasks = [asyncio.ensure_future(countdown('First Count', 2)),\n         asyncio.ensure_future(countdown('Second Count', 3))]\n\nstart_time = datetime.utcnow()\n\n# Run both methods. How much time will both run...?\nloop.run_until_complete(asyncio.wait(tasks))\n\nloop.close()\n\nprint(f'total running time: {datetime.utcnow() - start_time}')\n</code></pre>\n<p>We may think it will \"sleep\" for 2 seconds for first method and then 3 seconds in the second method, a total of 5 seconds running time of this code. But it will print:</p>\n<pre><code class=\"python\">total_running_time: 0:00:03.01286\n</code></pre>\n<p>It is recommended to read <a href=\"https://docs.python.org/3/library/asyncio.html\" rel=\"nofollow noreferrer\">asyncio official documentation</a> for more details.</p>\n", "abstract": "Notice in recent Python versions (Python\u00a03.4 or higher) you can use asyncio.sleep. It's related to asynchronous programming and asyncio. Check out next example: We may think it will \"sleep\" for 2 seconds for first method and then 3 seconds in the second method, a total of 5 seconds running time of this code. But it will print: It is recommended to read asyncio official documentation for more details."}, {"id": 50694125, "score": 7, "vote": 0, "content": "<p>While everyone else has suggested the de facto <code>time</code> module, I thought I'd share a different method using <code>matplotlib</code>'s <code>pyplot</code> function, <a href=\"https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pause.html\" rel=\"noreferrer\"><code>pause</code></a>.</p>\n<h3>An example</h3>\n<pre><code class=\"python\">from matplotlib import pyplot as plt\nplt.pause(5)    # Pauses the program for 5 seconds\n</code></pre>\n<p>Typically this is used to prevent the plot from disappearing as soon as it is plotted or to make crude animations.</p>\n<p>This would save you an <code>import</code> if you already have <code>matplotlib</code> imported.</p>\n", "abstract": "While everyone else has suggested the de facto time module, I thought I'd share a different method using matplotlib's pyplot function, pause. Typically this is used to prevent the plot from disappearing as soon as it is plotted or to make crude animations. This would save you an import if you already have matplotlib imported."}, {"id": 52352252, "score": 6, "vote": 0, "content": "<p>This is an easy example of a time delay:</p>\n<pre><code class=\"python\">import time\n\ndef delay(period='5'):\n    # If the user enters nothing, it'll wait 5 seconds\n    try:\n        # If the user not enters a int, I'll just return ''\n        time.sleep(period)\n    except:\n        return ''\n</code></pre>\n<p>Another, in <a href=\"http://en.wikipedia.org/wiki/Tkinter\" rel=\"nofollow noreferrer\">Tkinter</a>:</p>\n<pre><code class=\"python\">import tkinter\n\ndef tick():\n    pass\n\nroot = Tk()\ndelay = 100 # Time in milliseconds\nroot.after(delay, tick)\nroot.mainloop()\n</code></pre>\n", "abstract": "This is an easy example of a time delay: Another, in Tkinter:"}, {"id": 55662588, "score": -1, "vote": 0, "content": "<p>You also can try this:</p>\n<pre><code class=\"python\">import time\n# The time now\nstart = time.time() \nwhile time.time() - start &lt; 10: # Run 1- seconds\n    pass\n# Do the job\n</code></pre>\n<p>Now the shell will not crash or not react.</p>\n", "abstract": "You also can try this: Now the shell will not crash or not react."}]}, {"link": "https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend", "question": {"id": "252703", "title": "What is the difference between Python&#39;s list methods append and extend?", "content": "<p>What's the difference between the list methods <code>append()</code> and <code>extend()</code>?</p>\n", "abstract": "What's the difference between the list methods append() and extend()?"}, "answers": [{"id": 252711, "score": 5769, "vote": 0, "content": "<p><a href=\"https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types\" rel=\"noreferrer\"><code>append</code></a> appends a specified object at the end of the list:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [1, 2, 3]\n&gt;&gt;&gt; x.append([4, 5])\n&gt;&gt;&gt; print(x)\n[1, 2, 3, [4, 5]]\n</code></pre>\n<p><a href=\"https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types\" rel=\"noreferrer\"><code>extend</code></a> extends the list by appending elements from the specified iterable:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [1, 2, 3]\n&gt;&gt;&gt; x.extend([4, 5])\n&gt;&gt;&gt; print(x)\n[1, 2, 3, 4, 5]\n</code></pre>\n", "abstract": "append appends a specified object at the end of the list: extend extends the list by appending elements from the specified iterable:"}, {"id": 252705, "score": 720, "vote": 0, "content": "<p><code>append</code> adds an element to a list. <code>extend</code> concatenates the first list with another list/iterable.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; xs = ['A', 'B']\n&gt;&gt;&gt; xs\n['A', 'B']\n\n&gt;&gt;&gt; xs.append(\"D\")\n&gt;&gt;&gt; xs\n['A', 'B', 'D']\n\n&gt;&gt;&gt; xs.append([\"E\", \"F\"])\n&gt;&gt;&gt; xs\n['A', 'B', 'D', ['E', 'F']]\n\n&gt;&gt;&gt; xs.insert(2, \"C\")\n&gt;&gt;&gt; xs\n['A', 'B', 'C', 'D', ['E', 'F']]\n\n&gt;&gt;&gt; xs.extend([\"G\", \"H\"])\n&gt;&gt;&gt; xs\n['A', 'B', 'C', 'D', ['E', 'F'], 'G', 'H']\n</code></pre>\n", "abstract": "append adds an element to a list. extend concatenates the first list with another list/iterable."}, {"id": 28119966, "score": 633, "vote": 0, "content": "<blockquote>\n<h2>What is the difference between the list methods append and extend?</h2>\n</blockquote>\n<ul>\n<li><code>append</code> adds its argument as a single element to the end of a list. The length of the list itself will increase by one.</li>\n<li><code>extend</code> iterates over its argument adding each element to the list, extending the list. The length of the list will increase by however many elements were in the iterable argument.</li>\n</ul>\n<h2><code>append</code></h2>\n<p>The <code>list.append</code> method appends an object to the end of the list.</p>\n<pre><code class=\"python\">my_list.append(object) \n</code></pre>\n<p>Whatever the object is, whether a number, a string, another list, or something else, it gets added onto the end of <code>my_list</code> as a single entry on the list.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; my_list\n['foo', 'bar']\n&gt;&gt;&gt; my_list.append('baz')\n&gt;&gt;&gt; my_list\n['foo', 'bar', 'baz']\n</code></pre>\n<p>So keep in mind that a list is an object. If you append another list onto a list, the first list will be a single object at the end of the list (which may not be what you want):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; another_list = [1, 2, 3]\n&gt;&gt;&gt; my_list.append(another_list)\n&gt;&gt;&gt; my_list\n['foo', 'bar', 'baz', [1, 2, 3]]\n                     #^^^^^^^^^--- single item at the end of the list.\n</code></pre>\n<h2><code>extend</code></h2>\n<p>The <code>list.extend</code> method extends a list by appending elements from an iterable:</p>\n<pre><code class=\"python\">my_list.extend(iterable)\n</code></pre>\n<p>So with extend, each element of the iterable gets appended onto the list. For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; my_list\n['foo', 'bar']\n&gt;&gt;&gt; another_list = [1, 2, 3]\n&gt;&gt;&gt; my_list.extend(another_list)\n&gt;&gt;&gt; my_list\n['foo', 'bar', 1, 2, 3]\n</code></pre>\n<p>Keep in mind that a string is an iterable, so if you extend a list with a string, you'll append each character as you iterate over the string (which may not be what you want):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; my_list.extend('baz')\n&gt;&gt;&gt; my_list\n['foo', 'bar', 1, 2, 3, 'b', 'a', 'z']\n</code></pre>\n<h2>Operator Overload, <code>__add__</code> (<code>+</code>) and <code>__iadd__</code> (<code>+=</code>)</h2>\n<p>Both <code>+</code> and <code>+=</code> operators are defined for <code>list</code>. They are semantically similar to extend.</p>\n<p><code>my_list + another_list</code> creates a third list in memory, so you can return the result of it, but it requires that the second iterable be a list.</p>\n<p><code>my_list += another_list</code> modifies the list in-place (it <em>is</em> the in-place operator, and lists are mutable objects, as we've seen) so it does not create a new list. It also works like extend, in that the second iterable can be any kind of iterable.</p>\n<p>Don't get confused - <code>my_list = my_list + another_list</code> is not equivalent to <code>+=</code> - it gives you a brand new list assigned to my_list.</p>\n<h2>Time Complexity</h2>\n<p>Append has (<a href=\"https://stackoverflow.com/a/33045038/541136\">amortized</a>) <a href=\"https://wiki.python.org/moin/TimeComplexity\" rel=\"noreferrer\">constant time complexity</a>, O(1).</p>\n<p>Extend has time complexity, O(k).</p>\n<p>Iterating through the multiple calls to <code>append</code> adds to the complexity, making it equivalent to that of extend, and since extend's iteration is implemented in C, it will always be faster if you intend to append successive items from an iterable onto a list.</p>\n<p>Regarding \"amortized\" - from the <a href=\"https://github.com/python/cpython/blob/3.9/Objects/listobject.c#L52\" rel=\"noreferrer\">list object implementation source</a>:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">    /* This over-allocates proportional to the list size, making room\n     * for additional growth.  The over-allocation is mild, but is\n     * enough to give linear-time amortized behavior over a long\n     * sequence of appends() in the presence of a poorly-performing\n     * system realloc().\n</code></pre>\n<p>This means that we get the benefits of a larger than needed memory reallocation up front, but we may pay for it on the next marginal reallocation with an even larger one. Total time for all appends is linear at O(n), and that time allocated per append, becomes O(1).</p>\n<h2>Performance</h2>\n<p>You may wonder what is more performant, since append can be used to achieve the same outcome as extend. The following functions do the same thing:</p>\n<pre><code class=\"python\">def append(alist, iterable):\n    for item in iterable:\n        alist.append(item)\n        \ndef extend(alist, iterable):\n    alist.extend(iterable)\n</code></pre>\n<p>So let's time them:</p>\n<pre><code class=\"python\">import timeit\n\n&gt;&gt;&gt; min(timeit.repeat(lambda: append([], \"abcdefghijklmnopqrstuvwxyz\")))\n2.867846965789795\n&gt;&gt;&gt; min(timeit.repeat(lambda: extend([], \"abcdefghijklmnopqrstuvwxyz\")))\n0.8060121536254883\n</code></pre>\n<h3>Addressing a comment on timings</h3>\n<p>A commenter said:</p>\n<blockquote>\n<p>Perfect answer, I just miss the timing of comparing adding only one element</p>\n</blockquote>\n<p>Do the semantically correct thing. If you want to append all elements in an iterable, use <code>extend</code>. If you're just adding one element, use <code>append</code>.</p>\n<p>Ok, so let's create an experiment to see how this works out in time:</p>\n<pre><code class=\"python\">def append_one(a_list, element):\n    a_list.append(element)\n\ndef extend_one(a_list, element):\n    \"\"\"creating a new list is semantically the most direct\n    way to create an iterable to give to extend\"\"\"\n    a_list.extend([element])\n\nimport timeit\n</code></pre>\n<p>And we see that going out of our way to create an iterable just to use extend is a (minor) waste of time:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; min(timeit.repeat(lambda: append_one([], 0)))\n0.2082819009956438\n&gt;&gt;&gt; min(timeit.repeat(lambda: extend_one([], 0)))\n0.2397019260097295\n</code></pre>\n<p>We learn from this that there's nothing gained from using <code>extend</code> when we have only <em>one</em> element to append.</p>\n<p>Also, these timings are not that important. I am just showing them to make the point that, in Python, doing the semantically correct thing is doing things the <em>Right</em> Way\u2122.</p>\n<p>It's conceivable that you might test timings on two comparable operations and get an ambiguous or inverse result. Just focus on doing the semantically correct thing.</p>\n<h2>Conclusion</h2>\n<p>We see that <code>extend</code> is semantically clearer, and that it can run much faster than <code>append</code>, <em>when you intend to append each element in an iterable to a list.</em></p>\n<p>If you only have a single element (not in an iterable) to add to the list, use <code>append</code>.</p>\n", "abstract": "The list.append method appends an object to the end of the list. Whatever the object is, whether a number, a string, another list, or something else, it gets added onto the end of my_list as a single entry on the list. So keep in mind that a list is an object. If you append another list onto a list, the first list will be a single object at the end of the list (which may not be what you want): The list.extend method extends a list by appending elements from an iterable: So with extend, each element of the iterable gets appended onto the list. For example: Keep in mind that a string is an iterable, so if you extend a list with a string, you'll append each character as you iterate over the string (which may not be what you want): Both + and += operators are defined for list. They are semantically similar to extend. my_list + another_list creates a third list in memory, so you can return the result of it, but it requires that the second iterable be a list. my_list += another_list modifies the list in-place (it is the in-place operator, and lists are mutable objects, as we've seen) so it does not create a new list. It also works like extend, in that the second iterable can be any kind of iterable. Don't get confused - my_list = my_list + another_list is not equivalent to += - it gives you a brand new list assigned to my_list. Append has (amortized) constant time complexity, O(1). Extend has time complexity, O(k). Iterating through the multiple calls to append adds to the complexity, making it equivalent to that of extend, and since extend's iteration is implemented in C, it will always be faster if you intend to append successive items from an iterable onto a list. Regarding \"amortized\" - from the list object implementation source: This means that we get the benefits of a larger than needed memory reallocation up front, but we may pay for it on the next marginal reallocation with an even larger one. Total time for all appends is linear at O(n), and that time allocated per append, becomes O(1). You may wonder what is more performant, since append can be used to achieve the same outcome as extend. The following functions do the same thing: So let's time them: A commenter said: Perfect answer, I just miss the timing of comparing adding only one element Do the semantically correct thing. If you want to append all elements in an iterable, use extend. If you're just adding one element, use append. Ok, so let's create an experiment to see how this works out in time: And we see that going out of our way to create an iterable just to use extend is a (minor) waste of time: We learn from this that there's nothing gained from using extend when we have only one element to append. Also, these timings are not that important. I am just showing them to make the point that, in Python, doing the semantically correct thing is doing things the Right Way\u2122. It's conceivable that you might test timings on two comparable operations and get an ambiguous or inverse result. Just focus on doing the semantically correct thing. We see that extend is semantically clearer, and that it can run much faster than append, when you intend to append each element in an iterable to a list. If you only have a single element (not in an iterable) to add to the list, use append."}, {"id": 252704, "score": 134, "vote": 0, "content": "<p><code>append</code> appends a single element. <code>extend</code> appends a list of elements.</p>\n<p>Note that if you pass a list to append, it still adds one element:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; a.append([4, 5, 6])\n&gt;&gt;&gt; a\n[1, 2, 3, [4, 5, 6]]\n</code></pre>\n", "abstract": "append appends a single element. extend appends a list of elements. Note that if you pass a list to append, it still adds one element:"}, {"id": 46804939, "score": 88, "vote": 0, "content": "<h1> Append vs Extend</h1>\n<h2><a href=\"https://i.stack.imgur.com/KH5jB.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/KH5jB.png\"/></a></h2>\n<p>With append you can append a single element that will extend the list:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = [1,2]\n&gt;&gt;&gt; a.append(3)\n&gt;&gt;&gt; a\n[1,2,3]\n</code></pre>\n<p>If you want to extend more than one element you should use extend, because you can only append one elment or one list of element:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a.append([4,5])\n&gt;&gt;&gt; a\n&gt;&gt;&gt; [1,2,3,[4,5]]\n</code></pre>\n<p>So that you get a nested list</p>\n<p>Instead with extend, you can extend a single element like this</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = [1,2]\n&gt;&gt;&gt; a.extend([3])\n&gt;&gt;&gt; a\n[1,2,3]\n</code></pre>\n<p>Or, differently, from append, extend more elements in one time without nesting the list into the original one (that's the reason of the name extend)</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a.extend([4,5,6])\n&gt;&gt;&gt; a\n[1,2,3,4,5,6]\n</code></pre>\n<h1> Adding one element with both methods</h1>\n<h2><a href=\"https://i.stack.imgur.com/lGF2k.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/lGF2k.png\"/></a></h2>\n<p>Both append and extend can add one element to the end of the list, though append is simpler.</p>\n<h2> append 1 element </h2>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [1,2]\n&gt;&gt;&gt; x.append(3)\n&gt;&gt;&gt; x\n[1,2,3]\n</code></pre>\n<h2> extend one element </h2>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [1,2]\n&gt;&gt;&gt; x.extend([3])\n&gt;&gt;&gt; x\n[1,2,3]\n</code></pre>\n<h1> Adding more elements... with different results </h1>\n<p>If you use append for more than one element, you have to pass a list of elements as arguments and you will obtain a NESTED list!</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [1,2]\n&gt;&gt;&gt; x.append([3,4])\n&gt;&gt;&gt; x\n[1,2,[3,4]]\n</code></pre>\n<p>With extend, instead, you pass a list as an argument, but you will obtain a list with the new element that is not nested in the old one.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; z = [1,2] \n&gt;&gt;&gt; z.extend([3,4])\n&gt;&gt;&gt; z\n[1,2,3,4]\n</code></pre>\n<p>So, with more elements, you will use extend to get a list with more items.\nHowever, appending a list will not add more elements to the list, but one element that is a nested list as you can clearly see in the output of the code.</p>\n<p><a href=\"https://i.stack.imgur.com/lJK1M.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/lJK1M.png\"/></a></p>\n<p><a href=\"https://i.stack.imgur.com/KC2Ji.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/KC2Ji.png\"/></a></p>\n", "abstract": "With append you can append a single element that will extend the list: If you want to extend more than one element you should use extend, because you can only append one elment or one list of element: So that you get a nested list Instead with extend, you can extend a single element like this Or, differently, from append, extend more elements in one time without nesting the list into the original one (that's the reason of the name extend) Both append and extend can add one element to the end of the list, though append is simpler. If you use append for more than one element, you have to pass a list of elements as arguments and you will obtain a NESTED list! With extend, instead, you pass a list as an argument, but you will obtain a list with the new element that is not nested in the old one. So, with more elements, you will use extend to get a list with more items.\nHowever, appending a list will not add more elements to the list, but one element that is a nested list as you can clearly see in the output of the code.  "}, {"id": 12045242, "score": 67, "vote": 0, "content": "<p>The following two snippets are semantically equivalent:</p>\n<pre><code class=\"python\">for item in iterator:\n    a_list.append(item)\n</code></pre>\n<p>and</p>\n<pre><code class=\"python\">a_list.extend(iterator)\n</code></pre>\n<p>The latter may be faster as the loop is implemented in C.</p>\n", "abstract": "The following two snippets are semantically equivalent: and The latter may be faster as the loop is implemented in C."}, {"id": 19707477, "score": 47, "vote": 0, "content": "<p>The <code>append()</code> method adds a single item to the end of the list.</p>\n<pre><code class=\"python\">x = [1, 2, 3]\nx.append([4, 5])\nx.append('abc')\nprint(x)\n# gives you\n[1, 2, 3, [4, 5], 'abc']\n</code></pre>\n<p>The <code>extend()</code> method takes one argument, a list, and appends each of the items of the argument to the original list. (Lists are implemented as classes. \u201cCreating\u201d a list is really instantiating a class. As such, a list has methods that operate on it.)</p>\n<pre><code class=\"python\">x = [1, 2, 3]\nx.extend([4, 5])\nx.extend('abc')\nprint(x)\n# gives you\n[1, 2, 3, 4, 5, 'a', 'b', 'c']\n</code></pre>\n<p>From <em><a href=\"https://rads.stackoverflow.com/amzn/click/com/1430224150\" rel=\"nofollow noreferrer\">Dive Into Python</a></em>.</p>\n", "abstract": "The append() method adds a single item to the end of the list. The extend() method takes one argument, a list, and appends each of the items of the argument to the original list. (Lists are implemented as classes. \u201cCreating\u201d a list is really instantiating a class. As such, a list has methods that operate on it.) From Dive Into Python."}, {"id": 18442908, "score": 41, "vote": 0, "content": "<p>You can use \"+\" for returning extend, instead of extending in place.</p>\n<pre><code class=\"python\">l1=range(10)\n\nl1+[11]\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n\nl2=range(10,1,-1)\n\nl1+l2\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n</code></pre>\n<p>Similarly <code>+=</code> for in place behavior, but with slight differences from <code>append</code> &amp; <code>extend</code>. One of the biggest differences of <code>+=</code> from <code>append</code> and <code>extend</code> is when it is used in function scopes, see <a href=\"https://www.toptal.com/python/top-10-mistakes-that-python-programmers-make?utm_medium=referral&amp;utm_source=zeef.com&amp;utm_campaign=ZEEF\" rel=\"noreferrer\">this blog post</a>.</p>\n", "abstract": "You can use \"+\" for returning extend, instead of extending in place. Similarly += for in place behavior, but with slight differences from append & extend. One of the biggest differences of += from append and extend is when it is used in function scopes, see this blog post."}, {"id": 16511403, "score": 25, "vote": 0, "content": "<p><code>append(object)</code> updates the list by adding the object to the list.</p>\n<pre><code class=\"python\">x = [20]\n# List passed to the append(object) method is treated as a single object.\nx.append([21, 22, 23])\n# Hence the resultant list length will be 2\nprint(x)\n--&gt; [20, [21, 22, 23]]\n</code></pre>\n<p><code>extend(list)</code> concatenates the two lists essentially.</p>\n<pre><code class=\"python\">x = [20]\n# The parameter passed to extend(list) method is treated as a list.\n# Eventually it is two lists being concatenated.\nx.extend([21, 22, 23])\n# Here the resultant list's length is 4\nprint(x)\n--&gt; [20, 21, 22, 23]\n</code></pre>\n", "abstract": "append(object) updates the list by adding the object to the list. extend(list) concatenates the two lists essentially."}, {"id": 16510635, "score": 23, "vote": 0, "content": "<p><code>extend()</code> can be used with an iterator argument. Here is an example. You wish to make a list out of a list of lists this way:</p>\n<p>From</p>\n<pre><code class=\"python\">list2d = [[1,2,3],[4,5,6], [7], [8,9]]\n</code></pre>\n<p>you want</p>\n<pre><code class=\"python\">&gt;&gt;&gt;\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n<p>You may use <code>itertools.chain.from_iterable()</code> to do so. This method's output is an iterator. Its implementation is equivalent to</p>\n<pre><code class=\"python\">def from_iterable(iterables):\n    # chain.from_iterable(['ABC', 'DEF']) --&gt; A B C D E F\n    for it in iterables:\n        for element in it:\n            yield element\n</code></pre>\n<p>Back to our example, we can do</p>\n<pre><code class=\"python\">import itertools\nlist2d = [[1,2,3],[4,5,6], [7], [8,9]]\nmerged = list(itertools.chain.from_iterable(list2d))\n</code></pre>\n<p>and get the wanted list.</p>\n<p>Here is how equivalently <code>extend()</code> can be used with an iterator argument:</p>\n<pre><code class=\"python\">merged = []\nmerged.extend(itertools.chain.from_iterable(list2d))\nprint(merged)\n&gt;&gt;&gt;\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>\n", "abstract": "extend() can be used with an iterator argument. Here is an example. You wish to make a list out of a list of lists this way: From you want You may use itertools.chain.from_iterable() to do so. This method's output is an iterator. Its implementation is equivalent to Back to our example, we can do and get the wanted list. Here is how equivalently extend() can be used with an iterator argument:"}, {"id": 24632188, "score": 23, "vote": 0, "content": "<p>This is the equivalent of <code>append</code> and <code>extend</code> using the <code>+</code> operator:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [1,2,3]\n&gt;&gt;&gt; x\n[1, 2, 3]\n&gt;&gt;&gt; x = x + [4,5,6] # Extend\n&gt;&gt;&gt; x\n[1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; x = x + [[7,8]] # Append\n&gt;&gt;&gt; x\n[1, 2, 3, 4, 5, 6, [7, 8]]\n</code></pre>\n", "abstract": "This is the equivalent of append and extend using the + operator:"}, {"id": 37787163, "score": 18, "vote": 0, "content": "<p><strong><em>append()</em></strong>: It is basically used in Python to add one element.</p>\n<blockquote>\n<p>Example 1:</p>\n</blockquote>\n<pre><code class=\"python\">&gt;&gt; a = [1, 2, 3, 4]\n&gt;&gt; a.append(5)\n&gt;&gt; print(a)\n&gt;&gt; a = [1, 2, 3, 4, 5]\n</code></pre>\n<blockquote>\n<p>Example 2:</p>\n</blockquote>\n<pre><code class=\"python\">&gt;&gt; a = [1, 2, 3, 4]\n&gt;&gt; a.append([5, 6])\n&gt;&gt; print(a)\n&gt;&gt; a = [1, 2, 3, 4, [5, 6]]\n</code></pre>\n<p><strong><em>extend()</em></strong>: Where extend(), is used to merge two lists or insert multiple elements in one list.</p>\n<blockquote>\n<p>Example 1:</p>\n</blockquote>\n<pre><code class=\"python\">&gt;&gt; a = [1, 2, 3, 4]\n&gt;&gt; b = [5, 6, 7, 8]\n&gt;&gt; a.extend(b)\n&gt;&gt; print(a)\n&gt;&gt; a = [1, 2, 3, 4, 5, 6, 7, 8]\n</code></pre>\n<blockquote>\n<p>Example 2:</p>\n</blockquote>\n<pre><code class=\"python\">&gt;&gt; a = [1, 2, 3, 4]\n&gt;&gt; a.extend([5, 6])\n&gt;&gt; print(a)\n&gt;&gt; a = [1, 2, 3, 4, 5, 6]\n</code></pre>\n", "abstract": "append(): It is basically used in Python to add one element. Example 1: Example 2: extend(): Where extend(), is used to merge two lists or insert multiple elements in one list. Example 1: Example 2:"}, {"id": 25144368, "score": 15, "vote": 0, "content": "<p>An interesting point that has been hinted, but not explained, is that extend is faster than append. For any loop that has append inside should be considered to be replaced by list.extend(processed_elements).</p>\n<p>Bear in mind that apprending new elements might result in the realloaction of the whole list to a better location in memory. If this is done several times because we are appending 1 element at a time, overall performance suffers. In this sense, list.extend is analogous to \"\".join(stringlist).</p>\n", "abstract": "An interesting point that has been hinted, but not explained, is that extend is faster than append. For any loop that has append inside should be considered to be replaced by list.extend(processed_elements). Bear in mind that apprending new elements might result in the realloaction of the whole list to a better location in memory. If this is done several times because we are appending 1 element at a time, overall performance suffers. In this sense, list.extend is analogous to \"\".join(stringlist)."}, {"id": 26397913, "score": 15, "vote": 0, "content": "<p>Append adds the entire data at once. The whole data will be added to the newly created index. On the other hand, <code>extend</code>, as it name suggests, extends the current array. </p>\n<p>For example</p>\n<pre><code class=\"python\">list1 = [123, 456, 678]\nlist2 = [111, 222]\n</code></pre>\n<p>With <code>append</code> we get:</p>\n<pre><code class=\"python\">result = [123, 456, 678, [111, 222]]\n</code></pre>\n<p>While on <code>extend</code> we get:</p>\n<pre><code class=\"python\">result = [123, 456, 678, 111, 222]\n</code></pre>\n", "abstract": "Append adds the entire data at once. The whole data will be added to the newly created index. On the other hand, extend, as it name suggests, extends the current array.  For example With append we get: While on extend we get:"}, {"id": 48036819, "score": 11, "vote": 0, "content": "<p>An English dictionary defines the words <code>append</code> and <code>extend</code> as:</p>\n<p><strong>append</strong>: add (something) to the end of a written document. <br/>\n<strong>extend</strong>: make larger. Enlarge or expand</p>\n<hr/>\n<p>With that knowledge, now let's understand</p>\n<p>1) <strong>The difference between <code>append</code> and <code>extend</code></strong></p>\n<p><strong><code>append</code></strong>:</p>\n<ul>\n<li>Appends <em>any Python object as-is</em> to the end of the list (i.e. as a\nthe last element in the list).</li>\n<li>The resulting list may be nested and contain heterogeneous elements (i.e. list, string, tuple, dictionary, set, etc.)</li>\n</ul>\n<p><strong><code>extend</code></strong>:</p>\n<ul>\n<li>Accepts any <em>iterable</em> as its argument and makes the list <em>larger</em>.</li>\n<li>The resulting list is always one-dimensional list (i.e. no nesting) and it may contain heterogeneous elements in it (e.g. characters, integers, float) as a result of applying <code>list(iterable)</code>.</li>\n</ul>\n<p>2) <strong>Similarity between <code>append</code> and <code>extend</code></strong></p>\n<ul>\n<li>Both take exactly one argument.</li>\n<li>Both modify the list <em>in-place</em>.</li>\n<li>As a result, both returns <code>None</code>.</li>\n</ul>\n<hr/>\n<p><strong>Example</strong></p>\n<pre><code class=\"python\">lis = [1, 2, 3]\n\n# 'extend' is equivalent to this\nlis = lis + list(iterable)\n\n# 'append' simply appends its argument as the last element to the list\n# as long as the argument is a valid Python object\nlist.append(object)\n</code></pre>\n", "abstract": "An English dictionary defines the words append and extend as: append: add (something) to the end of a written document. \nextend: make larger. Enlarge or expand With that knowledge, now let's understand 1) The difference between append and extend append: extend: 2) Similarity between append and extend Example"}, {"id": 42171373, "score": 7, "vote": 0, "content": "<p>I hope I can make a useful supplement to this question. If your list stores a specific type object, for example <code>Info</code>, here is a situation that <code>extend</code> method is not suitable: In a <code>for</code> loop and and generating an <code>Info</code> object every time and using <code>extend</code> to store it into your list, it will fail. The exception is like below:</p>\n<blockquote>\n<p>TypeError: 'Info' object is not iterable</p>\n</blockquote>\n<p>But if you use the <code>append</code> method, the result is OK. Because every time using the <code>extend</code> method, it will always treat it as a list or any other collection type, iterate it, and place it after the previous list. A specific object can not be iterated, obviously.</p>\n", "abstract": "I hope I can make a useful supplement to this question. If your list stores a specific type object, for example Info, here is a situation that extend method is not suitable: In a for loop and and generating an Info object every time and using extend to store it into your list, it will fail. The exception is like below: TypeError: 'Info' object is not iterable But if you use the append method, the result is OK. Because every time using the extend method, it will always treat it as a list or any other collection type, iterate it, and place it after the previous list. A specific object can not be iterated, obviously."}, {"id": 47631056, "score": 5, "vote": 0, "content": "<p>To distinguish them intuitively</p>\n<pre><code class=\"python\">l1 = ['a', 'b', 'c']\nl2 = ['d', 'e', 'f']\nl1.append(l2)\nl1\n['a', 'b', 'c', ['d', 'e', 'f']]\n</code></pre>\n<p>It's like <code>l1</code> reproduce a body inside her body(nested).</p>\n<pre><code class=\"python\"># Reset l1 = ['a', 'b', 'c']\nl1.extend(l2)\nl1\n['a', 'b', 'c', 'd', 'e', 'f']\n</code></pre>\n<p>It's like that two separated individuals get married and construct an united family.</p>\n<p>Besides I make an exhaustive cheatsheet of all list's methods for your reference.</p>\n<pre><code class=\"python\">list_methods = {'Add': {'extend', 'append', 'insert'},\n                'Remove': {'pop', 'remove', 'clear'}\n                'Sort': {'reverse', 'sort'},\n                'Search': {'count', 'index'},\n                'Copy': {'copy'},\n                }\n</code></pre>\n", "abstract": "To distinguish them intuitively It's like l1 reproduce a body inside her body(nested). It's like that two separated individuals get married and construct an united family. Besides I make an exhaustive cheatsheet of all list's methods for your reference."}, {"id": 39256397, "score": 3, "vote": 0, "content": "<p><code>extend(L)</code> extends the list by appending all the items in the given list <code>L</code>.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a\n[1, 2, 3]\na.extend([4])  #is eqivalent of a[len(a):] = [4]\n&gt;&gt;&gt; a\n[1, 2, 3, 4]\na = [1, 2, 3]\n&gt;&gt;&gt; a\n[1, 2, 3]\n&gt;&gt;&gt; a[len(a):] = [4]\n&gt;&gt;&gt; a\n[1, 2, 3, 4]\n</code></pre>\n", "abstract": "extend(L) extends the list by appending all the items in the given list L."}, {"id": 49591233, "score": 0, "vote": 0, "content": "<p><code>append</code> \"extends\" the list (in place) by <strong>only one item</strong>, the single object passed (as argument).</p>\n<p><code>extend</code> \"extends\" the list (in place) by <strong>as many items as</strong> the object passed (as argument) contains.</p>\n<p>This may be slightly confusing for <code>str</code> objects.</p>\n<ol>\n<li>If you pass a string as argument:\n<code>append</code> will add a single string item at the end but\n<code>extend</code> will add as many \"single\" 'str' items as the length of that string.</li>\n<li>If you pass a list of strings as argument:\n<code>append</code> will still add a single 'list' item at the end and\n<code>extend</code> will add as many 'list' items as the length of the passed list.</li>\n</ol>\n<blockquote>\n<pre><code class=\"python\">def append_o(a_list, element):\n    a_list.append(element)\n    print('append:', end = ' ')\n    for item in a_list:\n        print(item, end = ',')\n    print()\n\ndef extend_o(a_list, element):\n    a_list.extend(element)\n    print('extend:', end = ' ')\n    for item in a_list:\n        print(item, end = ',')\n    print()\nappend_o(['ab'],'cd')\n\nextend_o(['ab'],'cd')\nappend_o(['ab'],['cd', 'ef'])\nextend_o(['ab'],['cd', 'ef'])\nappend_o(['ab'],['cd'])\nextend_o(['ab'],['cd'])\n</code></pre>\n</blockquote>\n<p>produces:</p>\n<pre><code class=\"python\">append: ab,cd,\nextend: ab,c,d,\nappend: ab,['cd', 'ef'],\nextend: ab,cd,ef,\nappend: ab,['cd'],\nextend: ab,cd,\n</code></pre>\n", "abstract": "append \"extends\" the list (in place) by only one item, the single object passed (as argument). extend \"extends\" the list (in place) by as many items as the object passed (as argument) contains. This may be slightly confusing for str objects. produces:"}, {"id": 51375427, "score": 0, "vote": 0, "content": "<p>Append and extend are one of the extensibility mechanisms in python. </p>\n<p>Append: Adds an element to the end of the list. </p>\n<pre><code class=\"python\">my_list = [1,2,3,4]\n</code></pre>\n<p>To add a new element to the list, we can use append method in the following way.</p>\n<pre><code class=\"python\">my_list.append(5)\n</code></pre>\n<p>The default location that the new element will be added is always in the (length+1) position. </p>\n<p>Insert: The insert method was used to overcome the limitations of append. With insert, we can explicitly define the exact position we want our new element to be inserted at. </p>\n<p>Method descriptor of insert(index, object). It takes two arguments, first being the index we want to insert our element and second the element itself. </p>\n<pre><code class=\"python\">Example: my_list = [1,2,3,4]\nmy_list[4, 'a']\nmy_list\n[1,2,3,4,'a']\n</code></pre>\n<p>Extend: This is very useful when we want to join two or more lists into a single list. Without extend, if we want to join two lists, the resulting object will contain a list of lists. </p>\n<pre><code class=\"python\">a = [1,2]\nb = [3]\na.append(b)\nprint (a)\n[1,2,[3]]\n</code></pre>\n<p>If we try to access the element at pos 2, we get a list ([3]), instead of the element. To join two lists, we'll have to use append. </p>\n<pre><code class=\"python\">a = [1,2]\nb = [3]\na.extend(b)\nprint (a)\n[1,2,3]\n</code></pre>\n<p>To join multiple lists</p>\n<pre><code class=\"python\">a = [1]\nb = [2]\nc = [3]\na.extend(b+c)\nprint (a)\n[1,2,3]\n</code></pre>\n", "abstract": "Append and extend are one of the extensibility mechanisms in python.  Append: Adds an element to the end of the list.  To add a new element to the list, we can use append method in the following way. The default location that the new element will be added is always in the (length+1) position.  Insert: The insert method was used to overcome the limitations of append. With insert, we can explicitly define the exact position we want our new element to be inserted at.  Method descriptor of insert(index, object). It takes two arguments, first being the index we want to insert our element and second the element itself.  Extend: This is very useful when we want to join two or more lists into a single list. Without extend, if we want to join two lists, the resulting object will contain a list of lists.  If we try to access the element at pos 2, we get a list ([3]), instead of the element. To join two lists, we'll have to use append.  To join multiple lists"}]}, {"link": "https://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods", "question": {"id": "576169", "title": "Understanding Python super() with __init__() methods", "content": "<p>Why is <code>super()</code> used?</p>\n<p>Is there a difference between using <code>Base.__init__</code> and <code>super().__init__</code>?</p>\n<pre><code class=\"python\">class Base(object):\n    def __init__(self):\n        print \"Base created\"\n        \nclass ChildA(Base):\n    def __init__(self):\n        Base.__init__(self)\n        \nclass ChildB(Base):\n    def __init__(self):\n        super(ChildB, self).__init__()\n        \nChildA() \nChildB()\n</code></pre>\n", "abstract": "Why is super() used? Is there a difference between using Base.__init__ and super().__init__?"}, "answers": [{"id": 576183, "score": 2217, "vote": 0, "content": "<p><code>super()</code> lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of <a href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=236275\" rel=\"noreferrer\">fun stuff</a> can happen. See the <a href=\"https://docs.python.org/2/library/functions.html#super\" rel=\"noreferrer\">standard docs on super</a> if you haven't already.</p>\n<p>Note that <a href=\"https://docs.python.org/3/library/functions.html#super\" rel=\"noreferrer\">the syntax changed in Python 3.0</a>: you can just say <code>super().__init__()</code> instead of <code>super(ChildB, self).__init__()</code> which IMO is quite a bit nicer. The standard docs also refer to a <a href=\"https://rhettinger.wordpress.com/2011/05/26/super-considered-super/\" rel=\"noreferrer\">guide to using <code>super()</code></a> which is quite explanatory.</p>\n", "abstract": "super() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven't already. Note that the syntax changed in Python 3.0: you can just say super().__init__() instead of super(ChildB, self).__init__() which IMO is quite a bit nicer. The standard docs also refer to a guide to using super() which is quite explanatory."}, {"id": 27134600, "score": 1132, "vote": 0, "content": "<blockquote>\n<h2>I'm trying to understand <code>super()</code></h2>\n</blockquote>\n<p>The reason we use <code>super</code> is so that child classes that may be using cooperative multiple inheritance will call the correct next parent class function in the Method Resolution Order (MRO).</p>\n<p>In Python 3, we can call it like this:</p>\n<pre><code class=\"python\">class ChildB(Base):\n    def __init__(self):\n        super().__init__()\n</code></pre>\n<p>In Python 2, we were required to call <code>super</code> like this with the defining class's name and <code>self</code>, but we'll avoid this from now on because it's redundant, slower (due to the name lookups), and more verbose (so update your Python if you haven't already!):</p>\n<pre><code class=\"python\">        super(ChildB, self).__init__()\n</code></pre>\n<p>Without super, you are limited in your ability to use multiple inheritance because you hard-wire the next parent's call:</p>\n<pre><code class=\"python\">        Base.__init__(self) # Avoid this.\n</code></pre>\n<p>I further explain below.</p>\n<blockquote>\n<h2>\"What difference is there actually in this code?:\"</h2>\n</blockquote>\n<pre><code class=\"python\">class ChildA(Base):\n    def __init__(self):\n        Base.__init__(self)\n\nclass ChildB(Base):\n    def __init__(self):\n        super().__init__()\n</code></pre>\n<p>The primary difference in this code is that in <code>ChildB</code> you get a layer of indirection in the <code>__init__</code> with <code>super</code>, which uses the class in which it is defined to determine the next class's <code>__init__</code> to look up in the MRO.</p>\n<p>I illustrate this difference in an answer at the <a href=\"https://stackoverflow.com/a/33469090/541136\">canonical question, How to use 'super' in Python?</a>, which demonstrates <strong>dependency injection</strong> and <strong>cooperative multiple inheritance</strong>.</p>\n<h2>If Python didn't have <code>super</code></h2>\n<p>Here's code that's actually closely equivalent to <code>super</code> (how it's implemented in C, minus some checking and fallback behavior, and translated to Python):</p>\n<pre><code class=\"python\">class ChildB(Base):\n    def __init__(self):\n        mro = type(self).mro()\n        check_next = mro.index(ChildB) + 1 # next after *this* class.\n        while check_next &lt; len(mro):\n            next_class = mro[check_next]\n            if '__init__' in next_class.__dict__:\n                next_class.__init__(self)\n                break\n            check_next += 1\n</code></pre>\n<p>Written a little more like native Python:</p>\n<pre><code class=\"python\">class ChildB(Base):\n    def __init__(self):\n        mro = type(self).mro()\n        for next_class in mro[mro.index(ChildB) + 1:]: # slice to end\n            if hasattr(next_class, '__init__'):\n                next_class.__init__(self)\n                break\n</code></pre>\n<p>If we didn't have the <code>super</code> object, we'd have to write this manual code everywhere (or recreate it!) to ensure that we call the proper next method in the Method Resolution Order!</p>\n<p>How does super do this in Python 3 without being told explicitly which class and instance from the method it was called from?</p>\n<p>It gets the calling stack frame, and finds the class (implicitly stored as a local free variable, <code>__class__</code>, making the calling function a closure over the class) and the first argument to that function, which should be the instance or class that informs it which Method Resolution Order (MRO) to use.</p>\n<p>Since it requires that first argument for the MRO, <a href=\"https://bugs.python.org/issue31118\" rel=\"noreferrer\">using <code>super</code> with static methods is impossible as they do not have access to the MRO of the class from which they are called</a>.</p>\n<h2>Criticisms of other answers:</h2>\n<blockquote>\n<p>super() lets you avoid referring to the base class explicitly, which can be nice. . But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven't already.</p>\n</blockquote>\n<p>It's rather hand-wavey and doesn't tell us much, but the point of <code>super</code> is not to avoid writing the parent class. The point is to ensure that the next method in line in the method resolution order (MRO) is called. This becomes important in multiple inheritance.</p>\n<p>I'll explain here.</p>\n<pre><code class=\"python\">class Base(object):\n    def __init__(self):\n        print(\"Base init'ed\")\n\nclass ChildA(Base):\n    def __init__(self):\n        print(\"ChildA init'ed\")\n        Base.__init__(self)\n\nclass ChildB(Base):\n    def __init__(self):\n        print(\"ChildB init'ed\")\n        super().__init__()\n</code></pre>\n<p>And let's create a dependency that we want to be called after the Child:</p>\n<pre><code class=\"python\">class UserDependency(Base):\n    def __init__(self):\n        print(\"UserDependency init'ed\")\n        super().__init__()\n</code></pre>\n<p>Now remember, <code>ChildB</code> uses super, <code>ChildA</code> does not:</p>\n<pre><code class=\"python\">class UserA(ChildA, UserDependency):\n    def __init__(self):\n        print(\"UserA init'ed\")\n        super().__init__()\n\nclass UserB(ChildB, UserDependency):\n    def __init__(self):\n        print(\"UserB init'ed\")\n        super().__init__()\n</code></pre>\n<p>And <code>UserA</code> does not call the UserDependency method:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; UserA()\nUserA init'ed\nChildA init'ed\nBase init'ed\n&lt;__main__.UserA object at 0x0000000003403BA8&gt;\n</code></pre>\n<p>But <code>UserB</code> does in-fact call UserDependency because <code>ChildB</code> invokes <code>super</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; UserB()\nUserB init'ed\nChildB init'ed\nUserDependency init'ed\nBase init'ed\n&lt;__main__.UserB object at 0x0000000003403438&gt;\n</code></pre>\n<h3>Criticism for another answer</h3>\n<p>In no circumstance should you do the following, which another answer suggests, as you'll definitely get errors when you subclass ChildB:</p>\n<pre><code class=\"python\">super(self.__class__, self).__init__()  # DON'T DO THIS! EVER.\n</code></pre>\n<p><sub>(That answer is not clever or particularly interesting, but in spite of direct criticism in the comments and over 17 downvotes, the answerer persisted in suggesting it until a kind editor fixed his problem.)</sub></p>\n<p>Explanation: Using <code>self.__class__</code> as a substitute for the class name in <code>super()</code> will lead to recursion. <code>super</code> lets us look up the next parent in the MRO (see the first section of this answer) for child classes. If you tell <code>super</code> we're in the child instance's method, it will then lookup the next method in line (probably this one) resulting in recursion, probably causing a logical failure (in the answerer's example, it does) or a <code>RuntimeError</code> when the recursion depth is exceeded.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; class Polygon(object):\n...     def __init__(self, id):\n...         self.id = id\n...\n&gt;&gt;&gt; class Rectangle(Polygon):\n...     def __init__(self, id, width, height):\n...         super(self.__class__, self).__init__(id)\n...         self.shape = (width, height)\n...\n&gt;&gt;&gt; class Square(Rectangle):\n...     pass\n...\n&gt;&gt;&gt; Square('a', 10, 10)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 3, in __init__\nTypeError: __init__() missing 2 required positional arguments: 'width' and 'height'\n</code></pre>\n<p>Python 3's new <code>super()</code> calling method with no arguments fortunately allows us to sidestep this issue.</p>\n", "abstract": "The reason we use super is so that child classes that may be using cooperative multiple inheritance will call the correct next parent class function in the Method Resolution Order (MRO). In Python 3, we can call it like this: In Python 2, we were required to call super like this with the defining class's name and self, but we'll avoid this from now on because it's redundant, slower (due to the name lookups), and more verbose (so update your Python if you haven't already!): Without super, you are limited in your ability to use multiple inheritance because you hard-wire the next parent's call: I further explain below. The primary difference in this code is that in ChildB you get a layer of indirection in the __init__ with super, which uses the class in which it is defined to determine the next class's __init__ to look up in the MRO. I illustrate this difference in an answer at the canonical question, How to use 'super' in Python?, which demonstrates dependency injection and cooperative multiple inheritance. Here's code that's actually closely equivalent to super (how it's implemented in C, minus some checking and fallback behavior, and translated to Python): Written a little more like native Python: If we didn't have the super object, we'd have to write this manual code everywhere (or recreate it!) to ensure that we call the proper next method in the Method Resolution Order! How does super do this in Python 3 without being told explicitly which class and instance from the method it was called from? It gets the calling stack frame, and finds the class (implicitly stored as a local free variable, __class__, making the calling function a closure over the class) and the first argument to that function, which should be the instance or class that informs it which Method Resolution Order (MRO) to use. Since it requires that first argument for the MRO, using super with static methods is impossible as they do not have access to the MRO of the class from which they are called. super() lets you avoid referring to the base class explicitly, which can be nice. . But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven't already. It's rather hand-wavey and doesn't tell us much, but the point of super is not to avoid writing the parent class. The point is to ensure that the next method in line in the method resolution order (MRO) is called. This becomes important in multiple inheritance. I'll explain here. And let's create a dependency that we want to be called after the Child: Now remember, ChildB uses super, ChildA does not: And UserA does not call the UserDependency method: But UserB does in-fact call UserDependency because ChildB invokes super: In no circumstance should you do the following, which another answer suggests, as you'll definitely get errors when you subclass ChildB: (That answer is not clever or particularly interesting, but in spite of direct criticism in the comments and over 17 downvotes, the answerer persisted in suggesting it until a kind editor fixed his problem.) Explanation: Using self.__class__ as a substitute for the class name in super() will lead to recursion. super lets us look up the next parent in the MRO (see the first section of this answer) for child classes. If you tell super we're in the child instance's method, it will then lookup the next method in line (probably this one) resulting in recursion, probably causing a logical failure (in the answerer's example, it does) or a RuntimeError when the recursion depth is exceeded. Python 3's new super() calling method with no arguments fortunately allows us to sidestep this issue."}, {"id": 19257335, "score": 275, "vote": 0, "content": "<p>It's been noted that in Python 3.0+ you can use</p>\n<pre><code class=\"python\">super().__init__()\n</code></pre>\n<p>to make your call, which is concise and does not require you to reference the parent OR class names explicitly, which can be handy. I just want to add that for Python 2.7 or under, some people implement a name-insensitive behaviour by writing <code>self.__class__</code> instead of the class name, i.e.</p>\n<pre><code class=\"python\">super(self.__class__, self).__init__()  # DON'T DO THIS!\n</code></pre>\n<p>HOWEVER, this breaks calls to <code>super</code> for any classes that inherit from your class, where <code>self.__class__</code> could return a child class. For example:</p>\n<pre><code class=\"python\">class Polygon(object):\n    def __init__(self, id):\n        self.id = id\n\nclass Rectangle(Polygon):\n    def __init__(self, id, width, height):\n        super(self.__class__, self).__init__(id)\n        self.shape = (width, height)\n\nclass Square(Rectangle):\n    pass\n</code></pre>\n<p>Here I have a class <code>Square</code>, which is a sub-class of <code>Rectangle</code>. Say I don't want to write a separate constructor for <code>Square</code> because the constructor for <code>Rectangle</code> is good enough, but for whatever reason I want to implement a Square so I can reimplement some other method.</p>\n<p>When I create a <code>Square</code> using <code>mSquare = Square('a', 10,10)</code>, Python calls the constructor for <code>Rectangle</code> because I haven't given <code>Square</code> its own constructor. However, in the constructor for <code>Rectangle</code>, the call <code>super(self.__class__,self)</code> is going to return the superclass of <code>mSquare</code>, so it calls the constructor for <code>Rectangle</code> again. This is how the infinite loop happens, as was mentioned by @S_C. In this case, when I run <code>super(...).__init__()</code> I am calling the constructor for <code>Rectangle</code> but since I give it no arguments, I will get an error.</p>\n", "abstract": "It's been noted that in Python 3.0+ you can use to make your call, which is concise and does not require you to reference the parent OR class names explicitly, which can be handy. I just want to add that for Python 2.7 or under, some people implement a name-insensitive behaviour by writing self.__class__ instead of the class name, i.e. HOWEVER, this breaks calls to super for any classes that inherit from your class, where self.__class__ could return a child class. For example: Here I have a class Square, which is a sub-class of Rectangle. Say I don't want to write a separate constructor for Square because the constructor for Rectangle is good enough, but for whatever reason I want to implement a Square so I can reimplement some other method. When I create a Square using mSquare = Square('a', 10,10), Python calls the constructor for Rectangle because I haven't given Square its own constructor. However, in the constructor for Rectangle, the call super(self.__class__,self) is going to return the superclass of mSquare, so it calls the constructor for Rectangle again. This is how the infinite loop happens, as was mentioned by @S_C. In this case, when I run super(...).__init__() I am calling the constructor for Rectangle but since I give it no arguments, I will get an error."}, {"id": 13595092, "score": 81, "vote": 0, "content": "<p>Super has no side effects</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">Base = ChildB\n\nBase()\n</code></pre>\n<p>works as expected</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">Base = ChildA\n\nBase()\n</code></pre>\n<p>gets into infinite recursion.</p>\n", "abstract": "Super has no side effects works as expected gets into infinite recursion."}, {"id": 10759155, "score": 74, "vote": 0, "content": "<p>Just a heads up... with Python 2.7, and I believe ever since <code>super()</code> was introduced in version 2.2, you can only call <a href=\"http://docs.python.org/library/functions.html#super\" rel=\"noreferrer\"><code>super()</code></a> if one of the parents inherit from a class that eventually inherits <code>object</code> (<a href=\"http://docs.python.org/glossary.html#term-new-style-class\" rel=\"noreferrer\">new-style classes</a>).</p>\n<p>Personally, as for python 2.7 code, I'm going to continue using <code>BaseClassName.__init__(self, args)</code> until I actually get the advantage of using <code>super()</code>.</p>\n", "abstract": "Just a heads up... with Python 2.7, and I believe ever since super() was introduced in version 2.2, you can only call super() if one of the parents inherit from a class that eventually inherits object (new-style classes). Personally, as for python 2.7 code, I'm going to continue using BaseClassName.__init__(self, args) until I actually get the advantage of using super()."}, {"id": 576179, "score": 57, "vote": 0, "content": "<p>There isn't, really. <code>super()</code> looks at the next class in the MRO (method resolution order, accessed with <code>cls.__mro__</code>) to call the methods. Just calling the base <code>__init__</code> calls the base <code>__init__</code>. As it happens, the MRO has exactly one item-- the base. So you're really doing the exact same thing, but in a nicer way with <code>super()</code> (particularly if you get into multiple inheritance later).</p>\n", "abstract": "There isn't, really. super() looks at the next class in the MRO (method resolution order, accessed with cls.__mro__) to call the methods. Just calling the base __init__ calls the base __init__. As it happens, the MRO has exactly one item-- the base. So you're really doing the exact same thing, but in a nicer way with super() (particularly if you get into multiple inheritance later)."}, {"id": 32688823, "score": 40, "vote": 0, "content": "<p>The main difference is that <code>ChildA.__init__</code> will unconditionally call <code>Base.__init__</code> whereas <code>ChildB.__init__</code> will call <code>__init__</code> in <strong>whatever class happens to be <code>ChildB</code> ancestor in <code>self</code>'s line of ancestors</strong>\n(which may differ from what you expect).</p>\n<p>If you add a <code>ClassC</code> that uses multiple inheritance:</p>\n<pre><code class=\"python\">class Mixin(Base):\n  def __init__(self):\n    print \"Mixin stuff\"\n    super(Mixin, self).__init__()\n\nclass ChildC(ChildB, Mixin):  # Mixin is now between ChildB and Base\n  pass\n\nChildC()\nhelp(ChildC) # shows that the Method Resolution Order is ChildC-&gt;ChildB-&gt;Mixin-&gt;Base\n</code></pre>\n<p>then <strong><code>Base</code> is no longer the parent of <code>ChildB</code></strong> for <code>ChildC</code> instances. Now <code>super(ChildB, self)</code> will point to <code>Mixin</code> if <code>self</code> is a <code>ChildC</code> instance.</p>\n<p>You have inserted <code>Mixin</code> in between <code>ChildB</code> and <code>Base</code>. And you can take advantage of it with <code>super()</code></p>\n<p>So if you are designed your classes so that they can be used in a Cooperative Multiple Inheritance scenario, you use <code>super</code> because you don't really know who is going to be the ancestor at runtime.</p>\n<p>The <a href=\"https://rhettinger.wordpress.com/2011/05/26/super-considered-super/\" rel=\"noreferrer\">super considered super post</a> and <a href=\"https://youtu.be/EiOglTERPEo\" rel=\"noreferrer\">pycon 2015 accompanying video</a> explain this pretty well.</p>\n", "abstract": "The main difference is that ChildA.__init__ will unconditionally call Base.__init__ whereas ChildB.__init__ will call __init__ in whatever class happens to be ChildB ancestor in self's line of ancestors\n(which may differ from what you expect). If you add a ClassC that uses multiple inheritance: then Base is no longer the parent of ChildB for ChildC instances. Now super(ChildB, self) will point to Mixin if self is a ChildC instance. You have inserted Mixin in between ChildB and Base. And you can take advantage of it with super() So if you are designed your classes so that they can be used in a Cooperative Multiple Inheritance scenario, you use super because you don't really know who is going to be the ancestor at runtime. The super considered super post and pycon 2015 accompanying video explain this pretty well."}]}, {"link": "https://stackoverflow.com/questions/6996603/how-do-i-delete-a-file-or-folder-in-python", "question": {"id": "6996603", "title": "How do I delete a file or folder in Python?", "content": "<p>How do I delete a file or folder?</p>\n", "abstract": "How do I delete a file or folder?"}, "answers": [{"id": 6996628, "score": 4473, "vote": 0, "content": "<ul>\n<li><p><a href=\"http://docs.python.org/library/os.html#os.remove\" rel=\"noreferrer\"><code>os.remove()</code></a> removes a file.</p></li>\n<li><p><a href=\"http://docs.python.org/library/os.html#os.rmdir\" rel=\"noreferrer\"><code>os.rmdir()</code></a> removes an empty directory.</p></li>\n<li><p><a href=\"http://docs.python.org/library/shutil.html#shutil.rmtree\" rel=\"noreferrer\"><code>shutil.rmtree()</code></a> deletes a directory and all its contents.</p></li>\n</ul>\n<hr/>\n<p><a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path\" rel=\"noreferrer\"><code>Path</code></a> objects from the Python 3.4+ <a href=\"https://docs.python.org/3/library/pathlib.html\" rel=\"noreferrer\"><code>pathlib</code></a> module also expose these instance methods:</p>\n<ul>\n<li><p><a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.unlink\" rel=\"noreferrer\"><code>pathlib.Path.unlink()</code></a> removes a file or symbolic link.</p></li>\n<li><p><a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.rmdir\" rel=\"noreferrer\"><code>pathlib.Path.rmdir()</code></a> removes an empty directory.</p></li>\n</ul>\n", "abstract": "os.remove() removes a file. os.rmdir() removes an empty directory. shutil.rmtree() deletes a directory and all its contents. Path objects from the Python 3.4+ pathlib module also expose these instance methods: pathlib.Path.unlink() removes a file or symbolic link. pathlib.Path.rmdir() removes an empty directory."}, {"id": 42641792, "score": 586, "vote": 0, "content": "<h2>Python syntax to delete a file</h2>\n<pre><code class=\"python\">import os\nos.remove(\"/tmp/&lt;file_name&gt;.txt\")\n</code></pre>\n<p>Or</p>\n<pre><code class=\"python\">import os\nos.unlink(\"/tmp/&lt;file_name&gt;.txt\")\n</code></pre>\n<p>Or</p>\n<p><strong><a href=\"https://docs.python.org/3/library/pathlib.html#module-pathlib\" rel=\"noreferrer\">pathlib</a> Library for Python version &gt;= 3.4</strong></p>\n<pre><code class=\"python\">file_to_rem = pathlib.Path(\"/tmp/&lt;file_name&gt;.txt\")\nfile_to_rem.unlink()\n</code></pre>\n<h2>Path.unlink(missing_ok=False)</h2>\n<p>Unlink method used to remove the file or the symbolik link.</p>\n<blockquote>\n<p>If missing_ok is false (the default), FileNotFoundError is raised if the path does not exist.<br/>\nIf missing_ok is true, FileNotFoundError exceptions will be ignored (same behavior as the POSIX rm -f command).<br/>\nChanged in version 3.8: The missing_ok parameter was added.</p>\n</blockquote>\n<h2>Best practice</h2>\n<ol>\n<li>First, check whether the file or folder exists or not then only delete that file. This can be achieved in two ways :<br/>\na. <code>os.path.isfile(\"/path/to/file\")</code><br/>\nb. Use <code>exception handling.</code><br/></li>\n</ol>\n<p><strong>EXAMPLE</strong> for <code>os.path.isfile</code></p>\n<pre><code class=\"python\">#!/usr/bin/python\nimport os\nmyfile=\"/tmp/foo.txt\"\n\n## If file exists, delete it ##\nif os.path.isfile(myfile):\n    os.remove(myfile)\nelse:    ## Show an error ##\n    print(\"Error: %s file not found\" % myfile)\n</code></pre>\n<h3>Exception Handling</h3>\n<pre><code class=\"python\">#!/usr/bin/python\nimport os\n\n## Get input ##\nmyfile= raw_input(\"Enter file name to delete: \")\n\n## Try to delete the file ##\ntry:\n    os.remove(myfile)\nexcept OSError as e:  ## if failed, report it back to the user ##\n    print (\"Error: %s - %s.\" % (e.filename, e.strerror))\n</code></pre>\n<h3>RESPECTIVE OUTPUT</h3>\n<pre>\nEnter file name to delete : demo.txt\nError: demo.txt - No such file or directory.\n\nEnter file name to delete : rrr.txt\nError: rrr.txt - Operation not permitted.\n\nEnter file name to delete : foo.txt\n</pre>\n<h3>Python syntax to delete a folder</h3>\n<pre><code class=\"python\">shutil.rmtree()\n</code></pre>\n<p>Example for <code>shutil.rmtree()</code></p>\n<pre><code class=\"python\">#!/usr/bin/python\nimport os\nimport sys\nimport shutil\n\n# Get directory name\nmydir= raw_input(\"Enter directory name: \")\n\n## Try to remove tree; if failed show an error using try...except on screen\ntry:\n    shutil.rmtree(mydir)\nexcept OSError as e:\n    print (\"Error: %s - %s.\" % (e.filename, e.strerror))\n</code></pre>\n", "abstract": "Or Or pathlib Library for Python version >= 3.4 Unlink method used to remove the file or the symbolik link. If missing_ok is false (the default), FileNotFoundError is raised if the path does not exist.\nIf missing_ok is true, FileNotFoundError exceptions will be ignored (same behavior as the POSIX rm -f command).\nChanged in version 3.8: The missing_ok parameter was added. EXAMPLE for os.path.isfile Example for shutil.rmtree()"}, {"id": 6996662, "score": 105, "vote": 0, "content": "<p>Use </p>\n<pre><code class=\"python\">shutil.rmtree(path[, ignore_errors[, onerror]])\n</code></pre>\n<p>(See complete documentation on <a href=\"http://docs.python.org/library/shutil.html\" rel=\"noreferrer\">shutil</a>) and/or</p>\n<pre><code class=\"python\">os.remove\n</code></pre>\n<p>and</p>\n<pre><code class=\"python\">os.rmdir\n</code></pre>\n<p>(Complete documentation on <a href=\"http://docs.python.org/library/os.html#os.remove\" rel=\"noreferrer\">os</a>.)</p>\n", "abstract": "Use  (See complete documentation on shutil) and/or and (Complete documentation on os.)"}, {"id": 41789397, "score": 77, "vote": 0, "content": "<p>Here is a robust function that uses both <code>os.remove</code> and <code>shutil.rmtree</code>:</p>\n<pre><code class=\"python\">def remove(path):\n    \"\"\" param &lt;path&gt; could either be relative or absolute. \"\"\"\n    if os.path.isfile(path) or os.path.islink(path):\n        os.remove(path)  # remove the file\n    elif os.path.isdir(path):\n        shutil.rmtree(path)  # remove dir and all contains\n    else:\n        raise ValueError(\"file {} is not a file or dir.\".format(path))\n</code></pre>\n", "abstract": "Here is a robust function that uses both os.remove and shutil.rmtree:"}, {"id": 45536168, "score": 43, "vote": 0, "content": "<p>You can use the built-in <a href=\"https://docs.python.org/library/pathlib.html#module-pathlib\" rel=\"noreferrer\"><code>pathlib</code></a> module (requires Python 3.4+, but there are backports for older versions on PyPI: <a href=\"https://pypi.python.org/pypi/pathlib/\" rel=\"noreferrer\"><code>pathlib</code></a>, <a href=\"https://pypi.python.org/pypi/pathlib2/\" rel=\"noreferrer\"><code>pathlib2</code></a>). </p>\n<p>To remove a file there is the <a href=\"https://docs.python.org/library/pathlib.html#pathlib.Path.unlink\" rel=\"noreferrer\"><code>unlink</code></a> method:</p>\n<pre><code class=\"python\">import pathlib\npath = pathlib.Path(name_of_file)\npath.unlink()\n</code></pre>\n<p>Or the <a href=\"https://docs.python.org/library/pathlib.html#pathlib.Path.rmdir\" rel=\"noreferrer\"><code>rmdir</code></a> method to remove an <strong>empty</strong> folder:</p>\n<pre><code class=\"python\">import pathlib\npath = pathlib.Path(name_of_folder)\npath.rmdir()\n</code></pre>\n", "abstract": "You can use the built-in pathlib module (requires Python 3.4+, but there are backports for older versions on PyPI: pathlib, pathlib2).  To remove a file there is the unlink method: Or the rmdir method to remove an empty folder:"}, {"id": 48738480, "score": 38, "vote": 0, "content": "<blockquote>\n<h2>How do I delete a file or folder in Python?</h2>\n</blockquote>\n<p>For Python 3, to remove the file and directory individually, use the <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.unlink\" rel=\"noreferrer\"><code>unlink</code></a> and <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.rmdir\" rel=\"noreferrer\"><code>rmdir</code></a> <code>Path</code> object methods respectively:</p>\n<pre><code class=\"python\">from pathlib import Path\ndir_path = Path.home() / 'directory' \nfile_path = dir_path / 'file'\n\nfile_path.unlink() # remove file\n\ndir_path.rmdir()   # remove directory\n</code></pre>\n<p>Note that you can also use relative paths with <code>Path</code> objects, and you can check your current working directory with <code>Path.cwd</code>.</p>\n<p>For removing individual files and directories in Python 2, see the section so labeled below.</p>\n<p>To remove a directory with contents, use <a href=\"https://docs.python.org/3/library/shutil.html#shutil.rmtree\" rel=\"noreferrer\"><code>shutil.rmtree</code></a>, and note that this is available in Python 2 and 3:</p>\n<pre><code class=\"python\">from shutil import rmtree\n\nrmtree(dir_path)\n</code></pre>\n<h2>Demonstration</h2>\n<p>New in Python 3.4 is the <code>Path</code> object. </p>\n<p>Let's use one to create a directory and file to demonstrate usage. Note that we use the <code>/</code> to join the parts of the path, this works around issues between operating systems and issues from using backslashes on Windows (where you'd need to either double up your backslashes like <code>\\\\</code> or use raw strings, like <code>r\"foo\\bar\"</code>):</p>\n<pre><code class=\"python\">from pathlib import Path\n\n# .home() is new in 3.5, otherwise use os.path.expanduser('~')\ndirectory_path = Path.home() / 'directory'\ndirectory_path.mkdir()\n\nfile_path = directory_path / 'file'\nfile_path.touch()\n</code></pre>\n<p>and now:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; file_path.is_file()\nTrue\n</code></pre>\n<p>Now let's delete them. First the file:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; file_path.unlink()     # remove file\n&gt;&gt;&gt; file_path.is_file()\nFalse\n&gt;&gt;&gt; file_path.exists()\nFalse\n</code></pre>\n<p>We can use globbing to remove multiple files - first let's create a few files for this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; (directory_path / 'foo.my').touch()\n&gt;&gt;&gt; (directory_path / 'bar.my').touch()\n</code></pre>\n<p>Then just iterate over the glob pattern:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; for each_file_path in directory_path.glob('*.my'):\n...     print(f'removing {each_file_path}')\n...     each_file_path.unlink()\n... \nremoving ~/directory/foo.my\nremoving ~/directory/bar.my\n</code></pre>\n<p>Now, demonstrating removing the directory:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; directory_path.rmdir() # remove directory\n&gt;&gt;&gt; directory_path.is_dir()\nFalse\n&gt;&gt;&gt; directory_path.exists()\nFalse\n</code></pre>\n<p>What if we want to remove a directory  and everything in it? \nFor this use-case, use <code>shutil.rmtree</code></p>\n<p>Let's recreate our directory and file:</p>\n<pre><code class=\"python\">file_path.parent.mkdir()\nfile_path.touch()\n</code></pre>\n<p>and note that <code>rmdir</code> fails unless it's empty, which is why rmtree is so convenient:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; directory_path.rmdir()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"~/anaconda3/lib/python3.6/pathlib.py\", line 1270, in rmdir\n    self._accessor.rmdir(self)\n  File \"~/anaconda3/lib/python3.6/pathlib.py\", line 387, in wrapped\n    return strfunc(str(pathobj), *args)\nOSError: [Errno 39] Directory not empty: '/home/username/directory'\n</code></pre>\n<p>Now, import rmtree and pass the directory to the funtion:</p>\n<pre><code class=\"python\">from shutil import rmtree\nrmtree(directory_path)      # remove everything \n</code></pre>\n<p>and we can see the whole thing has been removed:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; directory_path.exists()\nFalse\n</code></pre>\n<h2>Python 2</h2>\n<p>If you're on Python 2, there's a <a href=\"https://pypi.python.org/pypi/pathlib2/\" rel=\"noreferrer\">backport of the pathlib module called pathlib2</a>, which can be installed with pip:</p>\n<pre><code class=\"python\">$ pip install pathlib2\n</code></pre>\n<p>And then you can alias the library to <code>pathlib</code></p>\n<pre><code class=\"python\">import pathlib2 as pathlib\n</code></pre>\n<p>Or just directly import the <code>Path</code> object (as demonstrated here):</p>\n<pre><code class=\"python\">from pathlib2 import Path\n</code></pre>\n<p>If that's too much, you can remove files with <a href=\"https://docs.python.org/2/library/os.html#os.remove\" rel=\"noreferrer\"><code>os.remove</code> or <code>os.unlink</code></a></p>\n<pre><code class=\"python\">from os import unlink, remove\nfrom os.path import join, expanduser\n\nremove(join(expanduser('~'), 'directory/file'))\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">unlink(join(expanduser('~'), 'directory/file'))\n</code></pre>\n<p>and you can remove directories with <a href=\"https://docs.python.org/2/library/os.html#os.rmdir\" rel=\"noreferrer\"><code>os.rmdir</code></a>:</p>\n<pre><code class=\"python\">from os import rmdir\n\nrmdir(join(expanduser('~'), 'directory'))\n</code></pre>\n<p>Note that there is also a <a href=\"https://docs.python.org/2/library/os.html#os.removedirs\" rel=\"noreferrer\"><code>os.removedirs</code></a> - it only removes empty directories recursively, but it may suit your use-case.</p>\n", "abstract": "For Python 3, to remove the file and directory individually, use the unlink and rmdir Path object methods respectively: Note that you can also use relative paths with Path objects, and you can check your current working directory with Path.cwd. For removing individual files and directories in Python 2, see the section so labeled below. To remove a directory with contents, use shutil.rmtree, and note that this is available in Python 2 and 3: New in Python 3.4 is the Path object.  Let's use one to create a directory and file to demonstrate usage. Note that we use the / to join the parts of the path, this works around issues between operating systems and issues from using backslashes on Windows (where you'd need to either double up your backslashes like \\\\ or use raw strings, like r\"foo\\bar\"): and now: Now let's delete them. First the file: We can use globbing to remove multiple files - first let's create a few files for this: Then just iterate over the glob pattern: Now, demonstrating removing the directory: What if we want to remove a directory  and everything in it? \nFor this use-case, use shutil.rmtree Let's recreate our directory and file: and note that rmdir fails unless it's empty, which is why rmtree is so convenient: Now, import rmtree and pass the directory to the funtion: and we can see the whole thing has been removed: If you're on Python 2, there's a backport of the pathlib module called pathlib2, which can be installed with pip: And then you can alias the library to pathlib Or just directly import the Path object (as demonstrated here): If that's too much, you can remove files with os.remove or os.unlink or and you can remove directories with os.rmdir: Note that there is also a os.removedirs - it only removes empty directories recursively, but it may suit your use-case."}, {"id": 70075600, "score": 36, "vote": 0, "content": "<h1>Deleting a file or folder in Python</h1>\n<p><strong>There are multiple ways to Delete a File in Python but the best ways are the following:</strong></p>\n<ol>\n<li><strong>os.remove()</strong> removes a file.</li>\n<li><strong>os.unlink()</strong> removes a file. it is a Unix name of remove() method.</li>\n<li><strong>shutil.rmtree()</strong> deletes a directory and all its contents.</li>\n<li><strong>pathlib.Path.unlink()</strong> deletes a single file The pathlib module is available in Python 3.4 and above.</li>\n</ol>\n<h1>os.remove()</h1>\n<h2>Example 1: Basic Example to Remove a File Using os.remove() Method.</h2>\n<pre><code class=\"python\">import os\nos.remove(\"test_file.txt\")\nprint(\"File removed successfully\")\n</code></pre>\n<h2>Example 2: Checking if File Exists using os.path.isfile and Deleting it With os.remove</h2>\n<pre><code class=\"python\">import os\n#checking if file exist or not\nif(os.path.isfile(\"test.txt\")):\n    #os.remove() function to remove the file\n    os.remove(\"test.txt\")\n    #Printing the confirmation message of deletion\n    print(\"File Deleted successfully\")\nelse:\nprint(\"File does not exist\")\n#Showing the message instead of throwig an error\n</code></pre>\n<h2>Example 3: Python Program to Delete all files with a specific extension</h2>\n<pre><code class=\"python\">import os \nfrom os import listdir\nmy_path = 'C:\\Python Pool\\Test\\'\nfor file_name in listdir(my_path):\n    if file_name.endswith('.txt'):\n        os.remove(my_path + file_name)\n</code></pre>\n<h2>Example 4: Python Program to Delete All Files Inside a Folder</h2>\n<p>To delete all files inside a particular directory, you simply have to use the * symbol as the pattern string.\n#Importing os and glob modules\nimport os, glob\n#Loop Through the folder projects all files and deleting them one by one\nfor file in glob.glob(\"pythonpool/*\"):\nos.remove(file)\nprint(\"Deleted \" + str(file))</p>\n<h1>os.unlink()</h1>\n<p>os.unlink() is an alias or another name of os.remove() . As in the Unix OS remove is also known as unlink.\nNote: All the functionalities and syntax is the same of os.unlink() and os.remove(). Both of them are used to delete the Python file path.\nBoth are methods in the os module in Python\u2019s standard libraries which performs the deletion function.</p>\n<h1>shutil.rmtree()</h1>\n<h2>Example 1: Python Program to Delete a File Using shutil.rmtree()</h2>\n<pre><code class=\"python\">import shutil \nimport os \n# location \nlocation = \"E:/Projects/PythonPool/\"\n# directory \ndir = \"Test\"\n# path \npath = os.path.join(location, dir) \n# removing directory \nshutil.rmtree(path) \n</code></pre>\n<h2>Example 2: Python Program to Delete a File Using shutil.rmtree()</h2>\n<pre><code class=\"python\">import shutil \nimport os \nlocation = \"E:/Projects/PythonPool/\"\ndir = \"Test\"    \npath = os.path.join(location, dir) \nshutil.rmtree(path) \n</code></pre>\n<h1>pathlib.Path.rmdir() to remove Empty Directory</h1>\n<p>Pathlib module provides different ways to interact with your files. Rmdir is one of the path functions which allows you to delete an empty folder. Firstly, you need to select the Path() for the directory, and then calling rmdir() method will check the folder size. If it\u2019s empty, it\u2019ll delete it.</p>\n<p>This is a good way to deleting empty folders without any fear of losing actual data.</p>\n<pre><code class=\"python\">from pathlib import Path\nq = Path('foldername')\nq.rmdir()\n</code></pre>\n", "abstract": "There are multiple ways to Delete a File in Python but the best ways are the following: To delete all files inside a particular directory, you simply have to use the * symbol as the pattern string.\n#Importing os and glob modules\nimport os, glob\n#Loop Through the folder projects all files and deleting them one by one\nfor file in glob.glob(\"pythonpool/*\"):\nos.remove(file)\nprint(\"Deleted \" + str(file)) os.unlink() is an alias or another name of os.remove() . As in the Unix OS remove is also known as unlink.\nNote: All the functionalities and syntax is the same of os.unlink() and os.remove(). Both of them are used to delete the Python file path.\nBoth are methods in the os module in Python\u2019s standard libraries which performs the deletion function. Pathlib module provides different ways to interact with your files. Rmdir is one of the path functions which allows you to delete an empty folder. Firstly, you need to select the Path() for the directory, and then calling rmdir() method will check the folder size. If it\u2019s empty, it\u2019ll delete it. This is a good way to deleting empty folders without any fear of losing actual data."}, {"id": 49455049, "score": 7, "vote": 0, "content": "<p>shutil.rmtree is the asynchronous function, \nso if you want to check when it complete, you can use while...loop</p>\n<pre><code class=\"python\">import os\nimport shutil\n\nshutil.rmtree(path)\n\nwhile os.path.exists(path):\n  pass\n\nprint('done')\n</code></pre>\n", "abstract": "shutil.rmtree is the asynchronous function, \nso if you want to check when it complete, you can use while...loop"}, {"id": 46932928, "score": 6, "vote": 0, "content": "<pre><code class=\"python\">import os\n\nfolder = '/Path/to/yourDir/'\nfileList = os.listdir(folder)\n\nfor f in fileList:\n    filePath = folder + '/'+f\n\n    if os.path.isfile(filePath):\n        os.remove(filePath)\n\n    elif os.path.isdir(filePath):\n        newFileList = os.listdir(filePath)\n        for f1 in newFileList:\n            insideFilePath = filePath + '/' + f1\n\n            if os.path.isfile(insideFilePath):\n                os.remove(insideFilePath)\n</code></pre>\n", "abstract": ""}, {"id": 70457032, "score": 6, "vote": 0, "content": "<p>This is my function for deleting dirs. The \"path\" requires the full pathname.</p>\n<pre><code class=\"python\">import os\n\ndef rm_dir(path):\n    cwd = os.getcwd()\n    if not os.path.exists(os.path.join(cwd, path)):\n        return False\n    os.chdir(os.path.join(cwd, path))\n\n    for file in os.listdir():\n        print(\"file = \" + file)\n        os.remove(file)\n    print(cwd)\n    os.chdir(cwd)\n    os.rmdir(os.path.join(cwd, path))\n</code></pre>\n", "abstract": "This is my function for deleting dirs. The \"path\" requires the full pathname."}, {"id": 57302158, "score": 5, "vote": 0, "content": "<h2>For deleting files:</h2>\n<pre><code class=\"python\">os.unlink(path, *, dir_fd=None)\n</code></pre>\n<p>or </p>\n<pre><code class=\"python\">os.remove(path, *, dir_fd=None)\n</code></pre>\n<p>Both functions are semantically same. This functions removes (deletes) the file path. If path is not a file and it is directory, then exception is raised.</p>\n<h2>For deleting folders:</h2>\n<pre><code class=\"python\">shutil.rmtree(path, ignore_errors=False, onerror=None)\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">os.rmdir(path, *, dir_fd=None)\n</code></pre>\n<p>In order to remove whole directory trees, <code>shutil.rmtree()</code> can be used. <code>os.rmdir</code> only works when the directory is empty and exists.</p>\n<h2>For deleting folders recursively towards parent:</h2>\n<pre><code class=\"python\">os.removedirs(name)\n</code></pre>\n<p>It remove every empty parent directory with self until parent which has some content</p>\n<blockquote>\n<p>ex. os.removedirs('abc/xyz/pqr') will remove the directories by order 'abc/xyz/pqr', 'abc/xyz' and 'abc' if they are empty. </p>\n</blockquote>\n<p>For more info check official doc: <a href=\"https://docs.python.org/library/os.html#os.unlink\" rel=\"noreferrer\"><code>os.unlink</code></a> , <a href=\"https://docs.python.org/library/os.html#os.remove\" rel=\"noreferrer\"><code>os.remove</code></a>, <a href=\"https://docs.python.org/library/os.html#os.rmdir\" rel=\"noreferrer\"><code>os.rmdir</code></a> , <a href=\"https://docs.python.org/library/shutil.html#shutil.rmtree\" rel=\"noreferrer\"><code>shutil.rmtree</code></a>, <a href=\"https://docs.python.org/3/library/os.html#os.removedirs\" rel=\"noreferrer\"><code>os.removedirs</code></a></p>\n", "abstract": "or  Both functions are semantically same. This functions removes (deletes) the file path. If path is not a file and it is directory, then exception is raised. or In order to remove whole directory trees, shutil.rmtree() can be used. os.rmdir only works when the directory is empty and exists. It remove every empty parent directory with self until parent which has some content ex. os.removedirs('abc/xyz/pqr') will remove the directories by order 'abc/xyz/pqr', 'abc/xyz' and 'abc' if they are empty.  For more info check official doc: os.unlink , os.remove, os.rmdir , shutil.rmtree, os.removedirs"}, {"id": 59304670, "score": 1, "vote": 0, "content": "<p>To remove all files in folder</p>\n<pre><code class=\"python\">import os\nimport glob\n\nfiles = glob.glob(os.path.join('path/to/folder/*'))\nfiles = glob.glob(os.path.join('path/to/folder/*.csv')) // It will give all csv files in folder\nfor file in files:\n    os.remove(file)\n</code></pre>\n<p>To remove all folders in a directory</p>\n<pre><code class=\"python\">from shutil import rmtree\nimport os\n\n// os.path.join()  # current working directory.\n\nfor dirct in os.listdir(os.path.join('path/to/folder')):\n    rmtree(os.path.join('path/to/folder',dirct))\n</code></pre>\n", "abstract": "To remove all files in folder To remove all folders in a directory"}, {"id": 60127089, "score": 1, "vote": 0, "content": "<p>To avoid the <a href=\"http://en.wikipedia.org/wiki/Time_of_check_to_time_of_use\" rel=\"nofollow noreferrer\">TOCTOU</a> issue highlighted by <a href=\"https://stackoverflow.com/questions/6996603/how-to-delete-a-file-or-folder#comment99147016_42641792\">\u00c9ric Araujo's comment</a>, you can catch an exception to call the correct method:</p>\n<pre><code class=\"python\">def remove_file_or_dir(path: str) -&gt; None:\n    \"\"\" Remove a file or directory \"\"\"\n    try:\n        shutil.rmtree(path)\n    except NotADirectoryError:\n        os.remove(path)\n</code></pre>\n<p>Since <code>shutil.rmtree()</code> will only remove directories and <code>os.remove()</code> or <code>os.unlink()</code> will only remove files.</p>\n", "abstract": "To avoid the TOCTOU issue highlighted by \u00c9ric Araujo's comment, you can catch an exception to call the correct method: Since shutil.rmtree() will only remove directories and os.remove() or os.unlink() will only remove files."}, {"id": 62741631, "score": 1, "vote": 0, "content": "<p>My personal preference is to work with pathlib objects - it offers a more pythonic and less error-prone way to interact with the filesystem, especially if You develop cross-platform code.</p>\n<p>In that case, You might use pathlib3x - it offers a backport of the latest (at the date of writing this answer Python 3.10.a0) Python pathlib for Python 3.6 or newer, and a few additional functions like \"copy\", \"copy2\", \"copytree\", \"rmtree\" etc ...</p>\n<p>It also wraps <code>shutil.rmtree</code>:</p>\n<pre><code class=\"python\">$&gt; python -m pip install pathlib3x\n$&gt; python\n&gt;&gt;&gt; import pathlib3x as pathlib\n\n# delete a directory tree\n&gt;&gt;&gt; my_dir_to_delete=pathlib.Path('c:/temp/some_dir')\n&gt;&gt;&gt; my_dir_to_delete.rmtree(ignore_errors=True)\n\n# delete a file\n&gt;&gt;&gt; my_file_to_delete=pathlib.Path('c:/temp/some_file.txt')\n&gt;&gt;&gt; my_file_to_delete.unlink(missing_ok=True)\n\n</code></pre>\n<p>you can find it on <a href=\"https://github.com/bitranox/pathlib3x\" rel=\"nofollow noreferrer\">github</a> or <a href=\"https://pypi.org/project/pathlib3x\" rel=\"nofollow noreferrer\">PyPi</a></p>\n<hr/>\n<p><sup>Disclaimer: I'm the author of the pathlib3x library.</sup></p>\n", "abstract": "My personal preference is to work with pathlib objects - it offers a more pythonic and less error-prone way to interact with the filesystem, especially if You develop cross-platform code. In that case, You might use pathlib3x - it offers a backport of the latest (at the date of writing this answer Python 3.10.a0) Python pathlib for Python 3.6 or newer, and a few additional functions like \"copy\", \"copy2\", \"copytree\", \"rmtree\" etc ... It also wraps shutil.rmtree: you can find it on github or PyPi Disclaimer: I'm the author of the pathlib3x library."}, {"id": 72787465, "score": 0, "vote": 0, "content": "<p>Majorly there are 4 methods to remove file from folder</p>\n<p>Method 1</p>\n<pre><code class=\"python\">os.remove()\n</code></pre>\n<p><a href=\"https://scriptoverflow.com/incidents/python/how-to-remove-all-file-from-specific-folder-using-python.html\" rel=\"nofollow noreferrer\">Get code of other 3 methods</a></p>\n", "abstract": "Majorly there are 4 methods to remove file from folder Method 1 Get code of other 3 methods"}, {"id": 50614507, "score": -1, "vote": 0, "content": "<p>I recommend using <code>subprocess</code> if writing a beautiful and readable code is your cup of tea:</p>\n<pre><code class=\"python\">import subprocess\nsubprocess.Popen(\"rm -r my_dir\", shell=True)\n</code></pre>\n<p>And if you are not a software engineer, then maybe consider using Jupyter; you can simply type bash commands:</p>\n<pre><code class=\"python\">!rm -r my_dir\n</code></pre>\n<p>Traditionally, you use <code>shutil</code>:</p>\n<pre><code class=\"python\">import shutil\nshutil.rmtree(my_dir) \n</code></pre>\n", "abstract": "I recommend using subprocess if writing a beautiful and readable code is your cup of tea: And if you are not a software engineer, then maybe consider using Jupyter; you can simply type bash commands: Traditionally, you use shutil:"}]}, {"link": "https://stackoverflow.com/questions/739654/how-do-i-make-function-decorators-and-chain-them-together", "question": {"id": "739654", "title": "How do I make function decorators and chain them together?", "content": "<p>How do I make two decorators in Python that would do the following?</p>\n<pre><code class=\"python\">@make_bold\n@make_italic\ndef say():\n   return \"Hello\"\n</code></pre>\n<p>Calling <code>say()</code> should return:</p>\n<pre><code class=\"python\">\"&lt;b&gt;&lt;i&gt;Hello&lt;/i&gt;&lt;/b&gt;\"\n</code></pre>\n", "abstract": "How do I make two decorators in Python that would do the following? Calling say() should return:"}, "answers": [{"id": 1594484, "score": 4644, "vote": 0, "content": "<p>If you are not into long explanations, see <a href=\"https://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665\">Paolo Bergantino\u2019s answer</a>.</p>\n<h1>Decorator Basics</h1>\n<h2>Python\u2019s functions are objects</h2>\n<p>To understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let\u2019s see why with a simple example :</p>\n<pre><code class=\"python\">def shout(word=\"yes\"):\n    return word.capitalize()+\"!\"\n\nprint(shout())\n# outputs : 'Yes!'\n\n# As an object, you can assign the function to a variable like any other object \nscream = shout\n\n# Notice we don't use parentheses: we are not calling the function,\n# we are putting the function \"shout\" into the variable \"scream\".\n# It means you can then call \"shout\" from \"scream\":\n\nprint(scream())\n# outputs : 'Yes!'\n\n# More than that, it means you can remove the old name 'shout',\n#\u00a0and the function will still be accessible from 'scream'\n\ndel shout\ntry:\n    print(shout())\nexcept NameError as e:\n    print(e)\n    #outputs: \"name 'shout' is not defined\"\n\nprint(scream())\n# outputs: 'Yes!'\n</code></pre>\n<p>Keep this in mind. We\u2019ll circle back to it shortly.</p>\n<p>Another interesting property of Python functions is they can be defined inside another function!</p>\n<pre><code class=\"python\">def talk():\n\n    # You can define a function on the fly in \"talk\" ...\n    def whisper(word=\"yes\"):\n        return word.lower()+\"...\"\n\n    # ... and use it right away!\n    print(whisper())\n\n# You call \"talk\", that defines \"whisper\" EVERY TIME you call it, then\n# \"whisper\" is called in \"talk\". \ntalk()\n# outputs: \n# \"yes...\"\n\n# But \"whisper\" DOES NOT EXIST outside \"talk\":\n\ntry:\n    print(whisper())\nexcept NameError as e:\n    print(e)\n    #outputs : \"name 'whisper' is not defined\"*\n    #Python's functions are objects\n</code></pre>\n<h2>Functions references</h2>\n<p>Okay, still here? Now the fun part...</p>\n<p>You\u2019ve seen that functions are objects. Therefore, functions:</p>\n<ul>\n<li>can be assigned to a variable</li>\n<li>can be defined in another function</li>\n</ul>\n<p>That means that <strong>a function can <code>return</code> another function</strong>.</p>\n<pre><code class=\"python\">def getTalk(kind=\"shout\"):\n\n    # We define functions on the fly\n    def shout(word=\"yes\"):\n        return word.capitalize()+\"!\"\n\n    def whisper(word=\"yes\") :\n        return word.lower()+\"...\"\n\n    # Then we return one of them\n    if kind == \"shout\":\n        # We don't use \"()\", we are not calling the function,\n        # we are returning the function object\n        return shout  \n    else:\n        return whisper\n\n# How do you use this strange beast?\n\n# Get the function and assign it to a variable\ntalk = getTalk()      \n\n# You can see that \"talk\" is here a function object:\nprint(talk)\n#outputs : &lt;function shout at 0xb7ea817c&gt;\n\n# The object is the one returned by the function:\nprint(talk())\n#outputs : Yes!\n\n# And you can even use it directly if you feel wild:\nprint(getTalk(\"whisper\")())\n#outputs : yes...\n</code></pre>\n<p>There\u2019s more!</p>\n<p>If you can <code>return</code> a function, you can pass one as a parameter:</p>\n<pre><code class=\"python\">def doSomethingBefore(func): \n    print(\"I do something before then I call the function you gave me\")\n    print(func())\n\ndoSomethingBefore(scream)\n#outputs: \n#I do something before then I call the function you gave me\n#Yes!\n</code></pre>\n<p>Well, you just have everything needed to understand decorators. You see, decorators are \u201cwrappers\u201d, which means that <strong>they let you execute code before and after the function they decorate</strong> without modifying the function itself.</p>\n<h2>Handcrafted decorators</h2>\n<p>How you\u2019d do it manually:</p>\n<pre><code class=\"python\"># A decorator is a function that expects ANOTHER function as parameter\ndef my_shiny_new_decorator(a_function_to_decorate):\n\n    # Inside, the decorator defines a function on the fly: the wrapper.\n    # This function is going to be wrapped around the original function\n    # so it can execute code before and after it.\n    def the_wrapper_around_the_original_function():\n\n        # Put here the code you want to be executed BEFORE the original function is called\n        print(\"Before the function runs\")\n\n        # Call the function here (using parentheses)\n        a_function_to_decorate()\n\n        # Put here the code you want to be executed AFTER the original function is called\n        print(\"After the function runs\")\n\n    # At this point, \"a_function_to_decorate\" HAS NEVER BEEN EXECUTED.\n    # We return the wrapper function we have just created.\n    # The wrapper contains the function and the code to execute before and after. It\u2019s ready to use!\n    return the_wrapper_around_the_original_function\n\n# Now imagine you create a function you don't want to ever touch again.\ndef a_stand_alone_function():\n    print(\"I am a stand alone function, don't you dare modify me\")\n\na_stand_alone_function() \n#outputs: I am a stand alone function, don't you dare modify me\n\n# Well, you can decorate it to extend its behavior.\n# Just pass it to the decorator, it will wrap it dynamically in \n# any code you want and return you a new function ready to be used:\n\na_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)\na_stand_alone_function_decorated()\n#outputs:\n#Before the function runs\n#I am a stand alone function, don't you dare modify me\n#After the function runs\n</code></pre>\n<p>Now, you probably want that every time you call <code>a_stand_alone_function</code>, <code>a_stand_alone_function_decorated</code> is called instead. That\u2019s easy, just overwrite <code>a_stand_alone_function</code> with the function returned by <code>my_shiny_new_decorator</code>:</p>\n<pre><code class=\"python\">a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)\na_stand_alone_function()\n#outputs:\n#Before the function runs\n#I am a stand alone function, don't you dare modify me\n#After the function runs\n\n# That\u2019s EXACTLY what decorators do!\n</code></pre>\n<h2>Decorators demystified</h2>\n<p>The previous example, using the decorator syntax:</p>\n<pre><code class=\"python\">@my_shiny_new_decorator\ndef another_stand_alone_function():\n    print(\"Leave me alone\")\n\nanother_stand_alone_function()  \n#outputs:  \n#Before the function runs\n#Leave me alone\n#After the function runs\n</code></pre>\n<p>Yes, that\u2019s all, it\u2019s that simple. <code>@decorator</code> is just a shortcut to:</p>\n<pre><code class=\"python\">another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)\n</code></pre>\n<p>Decorators are just a pythonic variant of the <a href=\"http://en.wikipedia.org/wiki/Decorator_pattern\" rel=\"noreferrer\">decorator design pattern</a>. There are several classic design patterns embedded in Python to ease development (like iterators).</p>\n<p>Of course, you can accumulate decorators:</p>\n<pre><code class=\"python\">def bread(func):\n    def wrapper():\n        print(\"&lt;/''''''\\&gt;\")\n        func()\n        print(\"&lt;\\______/&gt;\")\n    return wrapper\n\ndef ingredients(func):\n    def wrapper():\n        print(\"#tomatoes#\")\n        func()\n        print(\"~salad~\")\n    return wrapper\n\ndef sandwich(food=\"--ham--\"):\n    print(food)\n\nsandwich()\n#outputs: --ham--\nsandwich = bread(ingredients(sandwich))\nsandwich()\n#outputs:\n#&lt;/''''''\\&gt;\n# #tomatoes#\n# --ham--\n# ~salad~\n#&lt;\\______/&gt;\n</code></pre>\n<p>Using the Python decorator syntax:</p>\n<pre><code class=\"python\">@bread\n@ingredients\ndef sandwich(food=\"--ham--\"):\n    print(food)\n\nsandwich()\n#outputs:\n#&lt;/''''''\\&gt;\n# #tomatoes#\n# --ham--\n# ~salad~\n#&lt;\\______/&gt;\n</code></pre>\n<p>The order you set the decorators MATTERS:</p>\n<pre><code class=\"python\">@ingredients\n@bread\ndef strange_sandwich(food=\"--ham--\"):\n    print(food)\n\nstrange_sandwich()\n#outputs:\n##tomatoes#\n#&lt;/''''''\\&gt;\n# --ham--\n#&lt;\\______/&gt;\n# ~salad~\n</code></pre>\n<hr/>\n<h1>Now: to answer the question...</h1>\n<p>As a conclusion, you can easily see how to answer the question:</p>\n<pre><code class=\"python\"># The decorator to make it bold\ndef makebold(fn):\n    # The new function the decorator returns\n    def wrapper():\n        # Insertion of some code before and after\n        return \"&lt;b&gt;\" + fn() + \"&lt;/b&gt;\"\n    return wrapper\n\n# The decorator to make it italic\ndef makeitalic(fn):\n    # The new function the decorator returns\n    def wrapper():\n        # Insertion of some code before and after\n        return \"&lt;i&gt;\" + fn() + \"&lt;/i&gt;\"\n    return wrapper\n\n@makebold\n@makeitalic\ndef say():\n    return \"hello\"\n\nprint(say())\n#outputs: &lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;\n\n# This is the exact equivalent to \ndef say():\n    return \"hello\"\nsay = makebold(makeitalic(say))\n\nprint(say())\n#outputs: &lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;\n</code></pre>\n<p>You can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators.</p>\n<hr/>\n<h1>Taking decorators to the next level</h1>\n<h2>Passing arguments to the decorated function</h2>\n<pre><code class=\"python\"># It\u2019s not black magic, you just have to let the wrapper \n# pass the argument:\n\ndef a_decorator_passing_arguments(function_to_decorate):\n    def a_wrapper_accepting_arguments(arg1, arg2):\n        print(\"I got args! Look: {0}, {1}\".format(arg1, arg2))\n        function_to_decorate(arg1, arg2)\n    return a_wrapper_accepting_arguments\n\n# Since when you are calling the function returned by the decorator, you are\n# calling the wrapper, passing arguments to the wrapper will let it pass them to \n# the decorated function\n\n@a_decorator_passing_arguments\ndef print_full_name(first_name, last_name):\n    print(\"My name is {0} {1}\".format(first_name, last_name))\n    \nprint_full_name(\"Peter\", \"Venkman\")\n# outputs:\n#I got args! Look: Peter Venkman\n#My name is Peter Venkman\n</code></pre>\n<h2>Decorating methods</h2>\n<p>One nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (<code>self</code>).</p>\n<p>That means you can build a decorator for methods the same way! Just remember to take <code>self</code> into consideration:</p>\n<pre><code class=\"python\">def method_friendly_decorator(method_to_decorate):\n    def wrapper(self, lie):\n        lie = lie - 3 # very friendly, decrease age even more :-)\n        return method_to_decorate(self, lie)\n    return wrapper\n    \n    \nclass Lucy(object):\n    \n    def __init__(self):\n        self.age = 32\n    \n    @method_friendly_decorator\n    def sayYourAge(self, lie):\n        print(\"I am {0}, what did you think?\".format(self.age + lie))\n        \nl = Lucy()\nl.sayYourAge(-3)\n#outputs: I am 26, what did you think?\n</code></pre>\n<p>If you\u2019re making general-purpose decorator--one you\u2019ll apply to any function or method, no matter its arguments--then just use <code>*args, **kwargs</code>:</p>\n<pre><code class=\"python\">def a_decorator_passing_arbitrary_arguments(function_to_decorate):\n    # The wrapper accepts any arguments\n    def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs):\n        print(\"Do I have args?:\")\n        print(args)\n        print(kwargs)\n        # Then you unpack the arguments, here *args, **kwargs\n        # If you are not familiar with unpacking, check:\n        # http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/\n        function_to_decorate(*args, **kwargs)\n    return a_wrapper_accepting_arbitrary_arguments\n\n@a_decorator_passing_arbitrary_arguments\ndef function_with_no_argument():\n    print(\"Python is cool, no argument here.\")\n\nfunction_with_no_argument()\n#outputs\n#Do I have args?:\n#()\n#{}\n#Python is cool, no argument here.\n\n@a_decorator_passing_arbitrary_arguments\ndef function_with_arguments(a, b, c):\n    print(a, b, c)\n    \nfunction_with_arguments(1,2,3)\n#outputs\n#Do I have args?:\n#(1, 2, 3)\n#{}\n#1 2 3 \n \n@a_decorator_passing_arbitrary_arguments\ndef function_with_named_arguments(a, b, c, platypus=\"Why not ?\"):\n    print(\"Do {0}, {1} and {2} like platypus? {3}\".format(a, b, c, platypus))\n\nfunction_with_named_arguments(\"Bill\", \"Linus\", \"Steve\", platypus=\"Indeed!\")\n#outputs\n#Do I have args ? :\n#('Bill', 'Linus', 'Steve')\n#{'platypus': 'Indeed!'}\n#Do Bill, Linus and Steve like platypus? Indeed!\n\nclass Mary(object):\n    \n    def __init__(self):\n        self.age = 31\n    \n    @a_decorator_passing_arbitrary_arguments\n    def sayYourAge(self, lie=-3): # You can now add a default value\n        print(\"I am {0}, what did you think?\".format(self.age + lie))\n\nm = Mary()\nm.sayYourAge()\n#outputs\n# Do I have args?:\n#(&lt;__main__.Mary object at 0xb7d303ac&gt;,)\n#{}\n#I am 28, what did you think?\n</code></pre>\n<h2>Passing arguments to the decorator</h2>\n<p>Great, now what would you say about passing arguments to the decorator itself?</p>\n<p>This can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function\u2019s arguments directly to the decorator.</p>\n<p>Before rushing to the solution, let\u2019s write a little reminder:</p>\n<pre><code class=\"python\"># Decorators are ORDINARY functions\ndef my_decorator(func):\n    print(\"I am an ordinary function\")\n    def wrapper():\n        print(\"I am function returned by the decorator\")\n        func()\n    return wrapper\n\n# Therefore, you can call it without any \"@\"\n\ndef lazy_function():\n    print(\"zzzzzzzz\")\n\ndecorated_function = my_decorator(lazy_function)\n#outputs: I am an ordinary function\n            \n# It outputs \"I am an ordinary function\", because that\u2019s just what you do:\n# calling a function. Nothing magic.\n\n@my_decorator\ndef lazy_function():\n    print(\"zzzzzzzz\")\n    \n#outputs: I am an ordinary function\n</code></pre>\n<p>It\u2019s exactly the same. \"<code>my_decorator</code>\" is called. So when you <code>@my_decorator</code>, you are telling Python to call the function 'labelled by the variable \"<code>my_decorator</code>\"'.</p>\n<p>This is important! The label you give can point directly to the decorator\u2014<strong>or not</strong>.</p>\n<p>Let\u2019s get evil. \u263a</p>\n<pre><code class=\"python\">def decorator_maker():\n    \n    print(\"I make decorators! I am executed only once: \"\n          \"when you make me create a decorator.\")\n            \n    def my_decorator(func):\n        \n        print(\"I am a decorator! I am executed only when you decorate a function.\")\n               \n        def wrapped():\n            print(\"I am the wrapper around the decorated function. \"\n                  \"I am called when you call the decorated function. \"\n                  \"As the wrapper, I return the RESULT of the decorated function.\")\n            return func()\n        \n        print(\"As the decorator, I return the wrapped function.\")\n        \n        return wrapped\n    \n    print(\"As a decorator maker, I return a decorator\")\n    return my_decorator\n            \n# Let\u2019s create a decorator. It\u2019s just a new function after all.\nnew_decorator = decorator_maker()       \n#outputs:\n#I make decorators! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n\n# Then we decorate the function\n            \ndef decorated_function():\n    print(\"I am the decorated function.\")\n   \ndecorated_function = new_decorator(decorated_function)\n#outputs:\n#I am a decorator! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function\n     \n# Let\u2019s call the function:\ndecorated_function()\n#outputs:\n#I am the wrapper around the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n</code></pre>\n<p>No surprise here.</p>\n<p>Let\u2019s do EXACTLY the same thing, but skip all the pesky intermediate variables:</p>\n<pre><code class=\"python\">def decorated_function():\n    print(\"I am the decorated function.\")\ndecorated_function = decorator_maker()(decorated_function)\n#outputs:\n#I make decorators! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n#I am a decorator! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function.\n\n# Finally:\ndecorated_function()    \n#outputs:\n#I am the wrapper around the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n</code></pre>\n<p>Let\u2019s make it <em>even shorter</em>:</p>\n<pre><code class=\"python\">@decorator_maker()\ndef decorated_function():\n    print(\"I am the decorated function.\")\n#outputs:\n#I make decorators! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n#I am a decorator! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function.\n\n#Eventually: \ndecorated_function()    \n#outputs:\n#I am the wrapper around the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n</code></pre>\n<p>Hey, did you see that? We used a function call with the \"<code>@</code>\" syntax! :-)</p>\n<p>So, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right?</p>\n<pre><code class=\"python\">def decorator_maker_with_arguments(decorator_arg1, decorator_arg2):\n    \n    print(\"I make decorators! And I accept arguments: {0}, {1}\".format(decorator_arg1, decorator_arg2))\n            \n    def my_decorator(func):\n        # The ability to pass arguments here is a gift from closures.\n        # If you are not comfortable with closures, you can assume it\u2019s ok,\n        # or read: https://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python\n        print(\"I am the decorator. Somehow you passed me arguments: {0}, {1}\".format(decorator_arg1, decorator_arg2))\n               \n        # Don't confuse decorator arguments and function arguments!\n        def wrapped(function_arg1, function_arg2) :\n            print(\"I am the wrapper around the decorated function.\\n\"\n                  \"I can access all the variables\\n\"\n                  \"\\t- from the decorator: {0} {1}\\n\"\n                  \"\\t- from the function call: {2} {3}\\n\"\n                  \"Then I can pass them to the decorated function\"\n                  .format(decorator_arg1, decorator_arg2,\n                          function_arg1, function_arg2))\n            return func(function_arg1, function_arg2)\n        \n        return wrapped\n    \n    return my_decorator\n\n@decorator_maker_with_arguments(\"Leonard\", \"Sheldon\")\ndef decorated_function_with_arguments(function_arg1, function_arg2):\n    print(\"I am the decorated function and only knows about my arguments: {0}\"\n           \" {1}\".format(function_arg1, function_arg2))\n          \ndecorated_function_with_arguments(\"Rajesh\", \"Howard\")\n#outputs:\n#I make decorators! And I accept arguments: Leonard Sheldon\n#I am the decorator. Somehow you passed me arguments: Leonard Sheldon\n#I am the wrapper around the decorated function. \n#I can access all the variables \n#   - from the decorator: Leonard Sheldon \n#   - from the function call: Rajesh Howard \n#Then I can pass them to the decorated function\n#I am the decorated function and only knows about my arguments: Rajesh Howard\n</code></pre>\n<p>Here it is: a decorator with arguments. Arguments can be set as variable:</p>\n<pre><code class=\"python\">c1 = \"Penny\"\nc2 = \"Leslie\"\n\n@decorator_maker_with_arguments(\"Leonard\", c1)\ndef decorated_function_with_arguments(function_arg1, function_arg2):\n    print(\"I am the decorated function and only knows about my arguments:\"\n           \" {0} {1}\".format(function_arg1, function_arg2))\n\ndecorated_function_with_arguments(c2, \"Howard\")\n#outputs:\n#I make decorators! And I accept arguments: Leonard Penny\n#I am the decorator. Somehow you passed me arguments: Leonard Penny\n#I am the wrapper around the decorated function. \n#I can access all the variables \n#   - from the decorator: Leonard Penny \n#   - from the function call: Leslie Howard \n#Then I can pass them to the decorated function\n#I am the decorated function and only know about my arguments: Leslie Howard\n</code></pre>\n<p>As you can see, you can pass arguments to the decorator like any function using this trick. You can even use <code>*args, **kwargs</code> if you wish. But remember decorators are called <strong>only once</strong>. Just when Python imports the script. You can't dynamically set the arguments afterwards. When you do \"import x\", <strong>the function is already decorated</strong>, so you can't\nchange anything.</p>\n<hr/>\n<h1>Let\u2019s practice: decorating a decorator</h1>\n<p>Okay, as a bonus, I'll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function.</p>\n<p>We wrapped the decorator.</p>\n<p>Anything else we saw recently that wrapped function?</p>\n<p>Oh yes, decorators!</p>\n<p>Let\u2019s have some fun and write a decorator for the decorators:</p>\n<pre><code class=\"python\">def decorator_with_args(decorator_to_enhance):\n    \"\"\" \n    This function is supposed to be used as a decorator.\n    It must decorate an other function, that is intended to be used as a decorator.\n    Take a cup of coffee.\n    It will allow any decorator to accept an arbitrary number of arguments,\n    saving you the headache to remember how to do that every time.\n    \"\"\"\n    \n    # We use the same trick we did to pass arguments\n    def decorator_maker(*args, **kwargs):\n       \n        # We create on the fly a decorator that accepts only a function\n        # but keeps the passed arguments from the maker.\n        def decorator_wrapper(func):\n       \n            # We return the result of the original decorator, which, after all, \n            # IS JUST AN ORDINARY FUNCTION (which returns a function).\n            # Only pitfall: the decorator must have this specific signature or it won't work:\n            return decorator_to_enhance(func, *args, **kwargs)\n        \n        return decorator_wrapper\n    \n    return decorator_maker\n       \n</code></pre>\n<p>It can be used as follows:</p>\n<pre><code class=\"python\"># You create the function you will use as a decorator. And stick a decorator on it :-)\n# Don't forget, the signature is \"decorator(func, *args, **kwargs)\"\n@decorator_with_args \ndef decorated_decorator(func, *args, **kwargs): \n    def wrapper(function_arg1, function_arg2):\n        print(\"Decorated with {0} {1}\".format(args, kwargs))\n        return func(function_arg1, function_arg2)\n    return wrapper\n    \n# Then you decorate the functions you wish with your brand new decorated decorator.\n\n@decorated_decorator(42, 404, 1024)\ndef decorated_function(function_arg1, function_arg2):\n    print(\"Hello {0} {1}\".format(function_arg1, function_arg2))\n\ndecorated_function(\"Universe and\", \"everything\")\n#outputs:\n#Decorated with (42, 404, 1024) {}\n#Hello Universe and everything\n\n# Whoooot!\n</code></pre>\n<p>I know, the last time you had this feeling, it was after listening a guy saying: \"before understanding recursion, you must first understand recursion\". But now, don't you feel good about mastering this?</p>\n<hr/>\n<h1>Best practices: decorators</h1>\n<ul>\n<li>Decorators were introduced in Python 2.4, so be sure your code will be run on &gt;= 2.4.</li>\n<li>Decorators slow down the function call. Keep that in mind.</li>\n<li><strong>You cannot un-decorate a function.</strong> (There <em>are</em> hacks to create decorators that can be removed, but nobody uses them.) So once a function is decorated, it\u2019s decorated <em>for all the code</em>.</li>\n<li>Decorators wrap functions, which can make them hard to debug.  (This gets better from Python &gt;= 2.5; see below.)</li>\n</ul>\n<p>The <code>functools</code> module was introduced in Python 2.5. It includes the function <code>functools.wraps()</code>, which copies the name, module, and docstring of the decorated function to its wrapper.</p>\n<p>(Fun fact: <code>functools.wraps()</code> is a decorator! \u263a)</p>\n<pre><code class=\"python\"># For debugging, the stacktrace prints you the function __name__\ndef foo():\n    print(\"foo\")\n    \nprint(foo.__name__)\n#outputs: foo\n    \n# With a decorator, it gets messy    \ndef bar(func):\n    def wrapper():\n        print(\"bar\")\n        return func()\n    return wrapper\n\n@bar\ndef foo():\n    print(\"foo\")\n\nprint(foo.__name__)\n#outputs: wrapper\n\n# \"functools\" can help for that\n\nimport functools\n\ndef bar(func):\n    # We say that \"wrapper\", is wrapping \"func\"\n    # and the magic begins\n    @functools.wraps(func)\n    def wrapper():\n        print(\"bar\")\n        return func()\n    return wrapper\n\n@bar\ndef foo():\n    print(\"foo\")\n\nprint(foo.__name__)\n#outputs: foo\n</code></pre>\n<hr/>\n<h1>How can the decorators be useful?</h1>\n<p><strong>Now the big question:</strong> What can I use decorators for?</p>\n<p>Seem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can't modify it), or for debugging (you don't want to modify it because it\u2019s temporary).</p>\n<p>You can use them to extend several functions in a DRY\u2019s way, like so:</p>\n<pre><code class=\"python\">def benchmark(func):\n    \"\"\"\n    A decorator that prints the time a function takes\n    to execute.\n    \"\"\"\n    import time\n    def wrapper(*args, **kwargs):\n        t = time.clock()\n        res = func(*args, **kwargs)\n        print(\"{0} {1}\".format(func.__name__, time.clock()-t))\n        return res\n    return wrapper\n\n\ndef logging(func):\n    \"\"\"\n    A decorator that logs the activity of the script.\n    (it actually just prints it, but it could be logging!)\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        res = func(*args, **kwargs)\n        print(\"{0} {1} {2}\".format(func.__name__, args, kwargs))\n        return res\n    return wrapper\n\n\ndef counter(func):\n    \"\"\"\n    A decorator that counts and prints the number of times a function has been executed\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        wrapper.count = wrapper.count + 1\n        res = func(*args, **kwargs)\n        print(\"{0} has been used: {1}x\".format(func.__name__, wrapper.count))\n        return res\n    wrapper.count = 0\n    return wrapper\n\n@counter\n@benchmark\n@logging\ndef reverse_string(string):\n    return str(reversed(string))\n\nprint(reverse_string(\"Able was I ere I saw Elba\"))\nprint(reverse_string(\"A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!\"))\n\n#outputs:\n#reverse_string ('Able was I ere I saw Elba',) {}\n#wrapper 0.0\n#wrapper has been used: 1x \n#ablE was I ere I saw elbA\n#reverse_string ('A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!',) {}\n#wrapper 0.0\n#wrapper has been used: 2x\n#!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A\n</code></pre>\n<p>Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:</p>\n<pre><code class=\"python\">@counter\n@benchmark\n@logging\ndef get_random_futurama_quote():\n    from urllib import urlopen\n    result = urlopen(\"http://subfusion.net/cgi-bin/quote.pl?quote=futurama\").read()\n    try:\n        value = result.split(\"&lt;br&gt;&lt;b&gt;&lt;hr&gt;&lt;br&gt;\")[1].split(\"&lt;br&gt;&lt;br&gt;&lt;hr&gt;\")[0]\n        return value.strip()\n    except:\n        return \"No, I'm ... doesn't!\"\n\n    \nprint(get_random_futurama_quote())\nprint(get_random_futurama_quote())\n\n#outputs:\n#get_random_futurama_quote () {}\n#wrapper 0.02\n#wrapper has been used: 1x\n#The laws of science be a harsh mistress.\n#get_random_futurama_quote () {}\n#wrapper 0.01\n#wrapper has been used: 2x\n#Curse you, merciful Poseidon!\n</code></pre>\n<p>Python itself provides several decorators: <code>property</code>, <code>staticmethod</code>, etc.</p>\n<ul>\n<li>Django uses decorators to manage caching and view permissions.</li>\n<li>Twisted to fake inlining asynchronous functions calls.</li>\n</ul>\n<p>This really is a large playground.</p>\n", "abstract": "If you are not into long explanations, see Paolo Bergantino\u2019s answer. To understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let\u2019s see why with a simple example : Keep this in mind. We\u2019ll circle back to it shortly. Another interesting property of Python functions is they can be defined inside another function! Okay, still here? Now the fun part... You\u2019ve seen that functions are objects. Therefore, functions: That means that a function can return another function. There\u2019s more! If you can return a function, you can pass one as a parameter: Well, you just have everything needed to understand decorators. You see, decorators are \u201cwrappers\u201d, which means that they let you execute code before and after the function they decorate without modifying the function itself. How you\u2019d do it manually: Now, you probably want that every time you call a_stand_alone_function, a_stand_alone_function_decorated is called instead. That\u2019s easy, just overwrite a_stand_alone_function with the function returned by my_shiny_new_decorator: The previous example, using the decorator syntax: Yes, that\u2019s all, it\u2019s that simple. @decorator is just a shortcut to: Decorators are just a pythonic variant of the decorator design pattern. There are several classic design patterns embedded in Python to ease development (like iterators). Of course, you can accumulate decorators: Using the Python decorator syntax: The order you set the decorators MATTERS: As a conclusion, you can easily see how to answer the question: You can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators. One nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (self). That means you can build a decorator for methods the same way! Just remember to take self into consideration: If you\u2019re making general-purpose decorator--one you\u2019ll apply to any function or method, no matter its arguments--then just use *args, **kwargs: Great, now what would you say about passing arguments to the decorator itself? This can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function\u2019s arguments directly to the decorator. Before rushing to the solution, let\u2019s write a little reminder: It\u2019s exactly the same. \"my_decorator\" is called. So when you @my_decorator, you are telling Python to call the function 'labelled by the variable \"my_decorator\"'. This is important! The label you give can point directly to the decorator\u2014or not. Let\u2019s get evil. \u263a No surprise here. Let\u2019s do EXACTLY the same thing, but skip all the pesky intermediate variables: Let\u2019s make it even shorter: Hey, did you see that? We used a function call with the \"@\" syntax! :-) So, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right? Here it is: a decorator with arguments. Arguments can be set as variable: As you can see, you can pass arguments to the decorator like any function using this trick. You can even use *args, **kwargs if you wish. But remember decorators are called only once. Just when Python imports the script. You can't dynamically set the arguments afterwards. When you do \"import x\", the function is already decorated, so you can't\nchange anything. Okay, as a bonus, I'll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function. We wrapped the decorator. Anything else we saw recently that wrapped function? Oh yes, decorators! Let\u2019s have some fun and write a decorator for the decorators: It can be used as follows: I know, the last time you had this feeling, it was after listening a guy saying: \"before understanding recursion, you must first understand recursion\". But now, don't you feel good about mastering this? The functools module was introduced in Python 2.5. It includes the function functools.wraps(), which copies the name, module, and docstring of the decorated function to its wrapper. (Fun fact: functools.wraps() is a decorator! \u263a) Now the big question: What can I use decorators for? Seem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can't modify it), or for debugging (you don't want to modify it because it\u2019s temporary). You can use them to extend several functions in a DRY\u2019s way, like so: Of course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said: Python itself provides several decorators: property, staticmethod, etc. This really is a large playground."}, {"id": 739665, "score": 3058, "vote": 0, "content": "<p>Check out <a href=\"http://docs.python.org/reference/compound_stmts.html#function\" rel=\"noreferrer\">the documentation</a> to see how decorators work. Here is what you asked for:</p>\n<pre><code class=\"python\">from functools import wraps\n\ndef makebold(fn):\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        return \"&lt;b&gt;\" + fn(*args, **kwargs) + \"&lt;/b&gt;\"\n    return wrapper\n\ndef makeitalic(fn):\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        return \"&lt;i&gt;\" + fn(*args, **kwargs) + \"&lt;/i&gt;\"\n    return wrapper\n\n@makebold\n@makeitalic\ndef hello():\n    return \"hello world\"\n\n@makebold\n@makeitalic\ndef log(s):\n    return s\n\nprint hello()        # returns \"&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;\"\nprint hello.__name__ # with functools.wraps() this returns \"hello\"\nprint log('hello')   # returns \"&lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;\"\n</code></pre>\n", "abstract": "Check out the documentation to see how decorators work. Here is what you asked for:"}, {"id": 739679, "score": 154, "vote": 0, "content": "<p>Alternatively, you could write a factory function which return a decorator which wraps the return value of the decorated function in a tag passed to the factory function. For example:</p>\n<pre><code class=\"python\">from functools import wraps\n\ndef wrap_in_tag(tag):\n    def factory(func):\n        @wraps(func)\n        def decorator():\n            return '&lt;%(tag)s&gt;%(rv)s&lt;/%(tag)s&gt;' % (\n                {'tag': tag, 'rv': func()})\n        return decorator\n    return factory\n</code></pre>\n<p>This enables you to write:</p>\n<pre><code class=\"python\">@wrap_in_tag('b')\n@wrap_in_tag('i')\ndef say():\n    return 'hello'\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">makebold = wrap_in_tag('b')\nmakeitalic = wrap_in_tag('i')\n\n@makebold\n@makeitalic\ndef say():\n    return 'hello'\n</code></pre>\n<p>Personally I would have written the decorator somewhat differently:</p>\n<pre><code class=\"python\">from functools import wraps\n\ndef wrap_in_tag(tag):\n    def factory(func):\n        @wraps(func)\n        def decorator(val):\n            return func('&lt;%(tag)s&gt;%(val)s&lt;/%(tag)s&gt;' %\n                        {'tag': tag, 'val': val})\n        return decorator\n    return factory\n</code></pre>\n<p>which would yield:</p>\n<pre><code class=\"python\">@wrap_in_tag('b')\n@wrap_in_tag('i')\ndef say(val):\n    return val\nsay('hello')\n</code></pre>\n<p>Don't forget the construction for which decorator syntax is a shorthand:</p>\n<pre><code class=\"python\">say = wrap_in_tag('b')(wrap_in_tag('i')(say)))\n</code></pre>\n", "abstract": "Alternatively, you could write a factory function which return a decorator which wraps the return value of the decorated function in a tag passed to the factory function. For example: This enables you to write: or Personally I would have written the decorator somewhat differently: which would yield: Don't forget the construction for which decorator syntax is a shorthand:"}, {"id": 739721, "score": 139, "vote": 0, "content": "<p>Decorators are just syntactical sugar.</p>\n<p>This</p>\n<pre><code class=\"python\">@decorator\ndef func():\n    ...\n</code></pre>\n<p>expands to</p>\n<pre><code class=\"python\">def func():\n    ...\nfunc = decorator(func)\n</code></pre>\n", "abstract": "Decorators are just syntactical sugar. This expands to"}, {"id": 4012213, "score": 74, "vote": 0, "content": "<p>And of course you can return lambdas as well from a decorator function:</p>\n<pre><code class=\"python\">def makebold(f): \n    return lambda: \"&lt;b&gt;\" + f() + \"&lt;/b&gt;\"\ndef makeitalic(f): \n    return lambda: \"&lt;i&gt;\" + f() + \"&lt;/i&gt;\"\n\n@makebold\n@makeitalic\ndef say():\n    return \"Hello\"\n\nprint say()\n</code></pre>\n", "abstract": "And of course you can return lambdas as well from a decorator function:"}, {"id": 739667, "score": 66, "vote": 0, "content": "<p>Python decorators add extra functionality to another function</p>\n<p>An italics decorator could be like</p>\n<pre><code class=\"python\">def makeitalic(fn):\n    def newFunc():\n        return \"&lt;i&gt;\" + fn() + \"&lt;/i&gt;\"\n    return newFunc\n</code></pre>\n<p>Note that a function is defined inside a function.\nWhat it basically does is replace a function with the newly defined one. For example, I have this class</p>\n<pre><code class=\"python\">class foo:\n    def bar(self):\n        print \"hi\"\n    def foobar(self):\n        print \"hi again\"\n</code></pre>\n<p>Now say, I want both functions to print \"---\" after and before they are done.\nI could add a print \"---\" before and after each print statement.\nBut because I don't like repeating myself, I will make a decorator</p>\n<pre><code class=\"python\">def addDashes(fn): # notice it takes a function as an argument\n    def newFunction(self): # define a new function\n        print \"---\"\n        fn(self) # call the original function\n        print \"---\"\n    return newFunction\n    # Return the newly defined function - it will \"replace\" the original\n</code></pre>\n<p>So now I can change my class to </p>\n<pre><code class=\"python\">class foo:\n    @addDashes\n    def bar(self):\n        print \"hi\"\n\n    @addDashes\n    def foobar(self):\n        print \"hi again\"\n</code></pre>\n<p>For more on decorators, check\n<a href=\"http://www.ibm.com/developerworks/linux/library/l-cpdecor.html\" rel=\"noreferrer\">http://www.ibm.com/developerworks/linux/library/l-cpdecor.html</a></p>\n", "abstract": "Python decorators add extra functionality to another function An italics decorator could be like Note that a function is defined inside a function.\nWhat it basically does is replace a function with the newly defined one. For example, I have this class Now say, I want both functions to print \"---\" after and before they are done.\nI could add a print \"---\" before and after each print statement.\nBut because I don't like repeating myself, I will make a decorator So now I can change my class to  For more on decorators, check\nhttp://www.ibm.com/developerworks/linux/library/l-cpdecor.html"}, {"id": 30283056, "score": 44, "vote": 0, "content": "<p>You <em>could</em> make two separate decorators that do what you want as illustrated directly below. Note the use of <code>*args, **kwargs</code> in the declaration of the <code>wrapped()</code> function which supports the decorated function having multiple arguments (which isn't really necessary for the example <code>say()</code> function, but is included for generality).</p>\n<p>For similar reasons, the <code>functools.wraps</code> decorator is used to change the meta attributes of the wrapped function to be those of the one being decorated. This makes error messages and embedded function documentation (<code>func.__doc__</code>) be those of the decorated function instead of <code>wrapped()</code>'s.</p>\n<pre><code class=\"python\">from functools import wraps\n\ndef makebold(fn):\n    @wraps(fn)\n    def wrapped(*args, **kwargs):\n        return \"&lt;b&gt;\" + fn(*args, **kwargs) + \"&lt;/b&gt;\"\n    return wrapped\n\ndef makeitalic(fn):\n    @wraps(fn)\n    def wrapped(*args, **kwargs):\n        return \"&lt;i&gt;\" + fn(*args, **kwargs) + \"&lt;/i&gt;\"\n    return wrapped\n\n@makebold\n@makeitalic\ndef say():\n    return 'Hello'\n\nprint(say())  # -&gt; &lt;b&gt;&lt;i&gt;Hello&lt;/i&gt;&lt;/b&gt;\n</code></pre>\n<h2>Refinements</h2>\n<p>As you can see there's a lot of duplicate code in these two decorators. Given this similarity it would be better for you to instead make a generic one that was actually a <em>decorator factory</em>\u2014in other words, a decorator function that makes other decorators. That way there would be less code repetition\u2014and allow the <a href=\"https://en.wikipedia.org/wiki/Don't_repeat_yourself\" rel=\"noreferrer\">DRY</a> principle to be followed.</p>\n<pre><code class=\"python\">def html_deco(tag):\n    def decorator(fn):\n        @wraps(fn)\n        def wrapped(*args, **kwargs):\n            return '&lt;%s&gt;' % tag + fn(*args, **kwargs) + '&lt;/%s&gt;' % tag\n        return wrapped\n    return decorator\n\n@html_deco('b')\n@html_deco('i')\ndef greet(whom=''):\n    return 'Hello' + (' ' + whom) if whom else ''\n\nprint(greet('world'))  # -&gt; &lt;b&gt;&lt;i&gt;Hello world&lt;/i&gt;&lt;/b&gt;\n</code></pre>\n<p>To make the code more readable, you can assign a more descriptive name to the factory-generated decorators:</p>\n<pre><code class=\"python\">makebold = html_deco('b')\nmakeitalic = html_deco('i')\n\n@makebold\n@makeitalic\ndef greet(whom=''):\n    return 'Hello' + (' ' + whom) if whom else ''\n\nprint(greet('world'))  # -&gt; &lt;b&gt;&lt;i&gt;Hello world&lt;/i&gt;&lt;/b&gt;\n</code></pre>\n<p>or even combine them like this:</p>\n<pre><code class=\"python\">makebolditalic = lambda fn: makebold(makeitalic(fn))\n\n@makebolditalic\ndef greet(whom=''):\n    return 'Hello' + (' ' + whom) if whom else ''\n\nprint(greet('world'))  # -&gt; &lt;b&gt;&lt;i&gt;Hello world&lt;/i&gt;&lt;/b&gt;\n</code></pre>\n<h3>Efficiency</h3>\n<p>While the above examples do all work, the code generated involves a fair amount of overhead in the form of extraneous function calls when multiple decorators are applied at once. This may not matter, depending the exact usage (which might be I/O-bound, for instance).</p>\n<p>If speed of the decorated function is important, the overhead can be kept to a single extra function call by writing a slightly different decorator factory-function which implements adding all the tags at once, so it can generate code that avoids the addtional function calls incurred by using separate decorators for each tag.</p>\n<p>This requires more code in the decorator itself, but this only runs when it's being applied to function definitions, not later when they themselves are called. This also applies when creating more readable names by using <code>lambda</code> functions as previously illustrated. Sample:</p>\n<pre><code class=\"python\">def multi_html_deco(*tags):\n    start_tags, end_tags = [], []\n    for tag in tags:\n        start_tags.append('&lt;%s&gt;' % tag)\n        end_tags.append('&lt;/%s&gt;' % tag)\n    start_tags = ''.join(start_tags)\n    end_tags = ''.join(reversed(end_tags))\n\n    def decorator(fn):\n        @wraps(fn)\n        def wrapped(*args, **kwargs):\n            return start_tags + fn(*args, **kwargs) + end_tags\n        return wrapped\n    return decorator\n\nmakebolditalic = multi_html_deco('b', 'i')\n\n@makebolditalic\ndef greet(whom=''):\n    return 'Hello' + (' ' + whom) if whom else ''\n\nprint(greet('world'))  # -&gt; &lt;b&gt;&lt;i&gt;Hello world&lt;/i&gt;&lt;/b&gt;\n</code></pre>\n", "abstract": "You could make two separate decorators that do what you want as illustrated directly below. Note the use of *args, **kwargs in the declaration of the wrapped() function which supports the decorated function having multiple arguments (which isn't really necessary for the example say() function, but is included for generality). For similar reasons, the functools.wraps decorator is used to change the meta attributes of the wrapped function to be those of the one being decorated. This makes error messages and embedded function documentation (func.__doc__) be those of the decorated function instead of wrapped()'s. As you can see there's a lot of duplicate code in these two decorators. Given this similarity it would be better for you to instead make a generic one that was actually a decorator factory\u2014in other words, a decorator function that makes other decorators. That way there would be less code repetition\u2014and allow the DRY principle to be followed. To make the code more readable, you can assign a more descriptive name to the factory-generated decorators: or even combine them like this: While the above examples do all work, the code generated involves a fair amount of overhead in the form of extraneous function calls when multiple decorators are applied at once. This may not matter, depending the exact usage (which might be I/O-bound, for instance). If speed of the decorated function is important, the overhead can be kept to a single extra function call by writing a slightly different decorator factory-function which implements adding all the tags at once, so it can generate code that avoids the addtional function calls incurred by using separate decorators for each tag. This requires more code in the decorator itself, but this only runs when it's being applied to function definitions, not later when they themselves are called. This also applies when creating more readable names by using lambda functions as previously illustrated. Sample:"}, {"id": 8633375, "score": 23, "vote": 0, "content": "<p>Another way of doing the same thing:</p>\n<pre><code class=\"python\">class bol(object):\n  def __init__(self, f):\n    self.f = f\n  def __call__(self):\n    return \"&lt;b&gt;{}&lt;/b&gt;\".format(self.f())\n\nclass ita(object):\n  def __init__(self, f):\n    self.f = f\n  def __call__(self):\n    return \"&lt;i&gt;{}&lt;/i&gt;\".format(self.f())\n\n@bol\n@ita\ndef sayhi():\n  return 'hi'\n</code></pre>\n<p>Or, more flexibly:</p>\n<pre><code class=\"python\">class sty(object):\n  def __init__(self, tag):\n    self.tag = tag\n  def __call__(self, f):\n    def newf():\n      return \"&lt;{tag}&gt;{res}&lt;/{tag}&gt;\".format(res=f(), tag=self.tag)\n    return newf\n\n@sty('b')\n@sty('i')\ndef sayhi():\n  return 'hi'\n</code></pre>\n", "abstract": "Another way of doing the same thing: Or, more flexibly:"}, {"id": 34073212, "score": 22, "vote": 0, "content": "<blockquote>\n<h1>How can I make two decorators in Python that would do the following?</h1>\n</blockquote>\n<p>You want the following function, when called:</p>\n<blockquote>\n<pre><code class=\"python\">@makebold\n@makeitalic\ndef say():\n    return \"Hello\"\n</code></pre>\n</blockquote>\n<p>To return:</p>\n<blockquote>\n<pre><code class=\"python\">&lt;b&gt;&lt;i&gt;Hello&lt;/i&gt;&lt;/b&gt;\n</code></pre>\n</blockquote>\n<h2>Simple solution</h2>\n<p>To most simply do this, make decorators that return lambdas (anonymous functions) that close over the function (closures) and call it:</p>\n<pre><code class=\"python\">def makeitalic(fn):\n    return lambda: '&lt;i&gt;' + fn() + '&lt;/i&gt;'\n\ndef makebold(fn):\n    return lambda: '&lt;b&gt;' + fn() + '&lt;/b&gt;'\n</code></pre>\n<p>Now use them as desired:</p>\n<pre><code class=\"python\">@makebold\n@makeitalic\ndef say():\n    return 'Hello'\n</code></pre>\n<p>and now:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; say()\n'&lt;b&gt;&lt;i&gt;Hello&lt;/i&gt;&lt;/b&gt;'\n</code></pre>\n<h2>Problems with the simple solution</h2>\n<p>But we seem to have nearly lost the original function. </p>\n<pre><code class=\"python\">&gt;&gt;&gt; say\n&lt;function &lt;lambda&gt; at 0x4ACFA070&gt;\n</code></pre>\n<p>To find it, we'd need to dig into the closure of each lambda, one of which is buried in the other:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; say.__closure__[0].cell_contents\n&lt;function &lt;lambda&gt; at 0x4ACFA030&gt;\n&gt;&gt;&gt; say.__closure__[0].cell_contents.__closure__[0].cell_contents\n&lt;function say at 0x4ACFA730&gt;\n</code></pre>\n<p>So if we put documentation on this function, or wanted to be able to decorate functions that take more than one argument, or we just wanted to know what function we were looking at in a debugging session, we need to do a bit more with our wrapper.</p>\n<h2>Full featured solution - overcoming most of these problems</h2>\n<p>We have the decorator <code>wraps</code> from the <code>functools</code> module in the standard library! </p>\n<pre><code class=\"python\">from functools import wraps\n\ndef makeitalic(fn):\n    # must assign/update attributes from wrapped function to wrapper\n    # __module__, __name__, __doc__, and __dict__ by default\n    @wraps(fn) # explicitly give function whose attributes it is applying\n    def wrapped(*args, **kwargs):\n        return '&lt;i&gt;' + fn(*args, **kwargs) + '&lt;/i&gt;'\n    return wrapped\n\ndef makebold(fn):\n    @wraps(fn)\n    def wrapped(*args, **kwargs):\n        return '&lt;b&gt;' + fn(*args, **kwargs) + '&lt;/b&gt;'\n    return wrapped\n</code></pre>\n<p>It is unfortunate that there's still some boilerplate, but this is about as simple as we can make it. </p>\n<p>In Python 3, you also get <code>__qualname__</code> and <code>__annotations__</code> assigned by default.</p>\n<p>So now:</p>\n<pre><code class=\"python\">@makebold\n@makeitalic\ndef say():\n    \"\"\"This function returns a bolded, italicized 'hello'\"\"\"\n    return 'Hello'\n</code></pre>\n<p>And now:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; say\n&lt;function say at 0x14BB8F70&gt;\n&gt;&gt;&gt; help(say)\nHelp on function say in module __main__:\n\nsay(*args, **kwargs)\n    This function returns a bolded, italicized 'hello'\n</code></pre>\n<h2>Conclusion</h2>\n<p>So we see that <code>wraps</code> makes the wrapping function do almost everything except tell us exactly what the function takes as arguments. </p>\n<p>There are other modules that may attempt to tackle the problem, but the solution is not yet in the standard library.</p>\n", "abstract": "You want the following function, when called: To return: To most simply do this, make decorators that return lambdas (anonymous functions) that close over the function (closures) and call it: Now use them as desired: and now: But we seem to have nearly lost the original function.  To find it, we'd need to dig into the closure of each lambda, one of which is buried in the other: So if we put documentation on this function, or wanted to be able to decorate functions that take more than one argument, or we just wanted to know what function we were looking at in a debugging session, we need to do a bit more with our wrapper. We have the decorator wraps from the functools module in the standard library!  It is unfortunate that there's still some boilerplate, but this is about as simple as we can make it.  In Python 3, you also get __qualname__ and __annotations__ assigned by default. So now: And now: So we see that wraps makes the wrapping function do almost everything except tell us exactly what the function takes as arguments.  There are other modules that may attempt to tackle the problem, but the solution is not yet in the standard library."}, {"id": 11673539, "score": 15, "vote": 0, "content": "<p>A decorator takes the function definition and creates a new function that executes this function and transforms the result.</p>\n<pre><code class=\"python\">@deco\ndef do():\n    ...\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code class=\"python\">do = deco(do)\n</code></pre>\n<h2>Example:</h2>\n<pre><code class=\"python\">def deco(func):\n    def inner(letter):\n        return func(letter).upper()  #upper\n    return inner\n</code></pre>\n<p>This</p>\n<pre><code class=\"python\">@deco\ndef do(number):\n    return chr(number)  # number to letter\n</code></pre>\n<p>is equivalent to this</p>\n<pre><code class=\"python\">def do2(number):\n    return chr(number)\n\ndo2 = deco(do2)\n</code></pre>\n<p>65 &lt;=&gt; 'a'</p>\n<pre><code class=\"python\">print(do(65))\nprint(do2(65))\n&gt;&gt;&gt; B\n&gt;&gt;&gt; B\n</code></pre>\n<p>To understand the decorator, it is important to notice, that decorator created a new function do which is inner that executes function and transforms the result.</p>\n", "abstract": "A decorator takes the function definition and creates a new function that executes this function and transforms the result. is equivalent to: This is equivalent to this 65 <=> 'a' To understand the decorator, it is important to notice, that decorator created a new function do which is inner that executes function and transforms the result."}, {"id": 53176726, "score": 11, "vote": 0, "content": "<p>This answer has long been answered, but I thought I would share my Decorator class which makes writing new decorators easy and compact.</p>\n<pre><code class=\"python\">from abc import ABCMeta, abstractclassmethod\n\nclass Decorator(metaclass=ABCMeta):\n    \"\"\" Acts as a base class for all decorators \"\"\"\n\n    def __init__(self):\n        self.method = None\n\n    def __call__(self, method):\n        self.method = method\n        return self.call\n\n    @abstractclassmethod\n    def call(self, *args, **kwargs):\n        return self.method(*args, **kwargs)\n</code></pre>\n<p>For one I think this makes the behavior of decorators very clear, but it also makes it easy to define new decorators very concisely. For the example listed above, you could then solve it as:</p>\n<pre><code class=\"python\">class MakeBold(Decorator):\n    def call():\n        return \"&lt;b&gt;\" + self.method() + \"&lt;/b&gt;\"\n\nclass MakeItalic(Decorator):\n    def call():\n        return \"&lt;i&gt;\" + self.method() + \"&lt;/i&gt;\"\n\n@MakeBold()\n@MakeItalic()\ndef say():\n   return \"Hello\"\n</code></pre>\n<p>You could also use it to do more complex tasks, like for instance a decorator which automatically makes the function get applied recursively to all arguments in an iterator:</p>\n<pre><code class=\"python\">class ApplyRecursive(Decorator):\n    def __init__(self, *types):\n        super().__init__()\n        if not len(types):\n            types = (dict, list, tuple, set)\n        self._types = types\n\n    def call(self, arg):\n        if dict in self._types and isinstance(arg, dict):\n            return {key: self.call(value) for key, value in arg.items()}\n\n        if set in self._types and isinstance(arg, set):\n            return set(self.call(value) for value in arg)\n\n        if tuple in self._types and isinstance(arg, tuple):\n            return tuple(self.call(value) for value in arg)\n\n        if list in self._types and isinstance(arg, list):\n            return list(self.call(value) for value in arg)\n\n        return self.method(arg)\n\n\n@ApplyRecursive(tuple, set, dict)\ndef double(arg):\n    return 2*arg\n\nprint(double(1))\nprint(double({'a': 1, 'b': 2}))\nprint(double({1, 2, 3}))\nprint(double((1, 2, 3, 4)))\nprint(double([1, 2, 3, 4, 5]))\n</code></pre>\n<p>Which prints:</p>\n<pre><code class=\"python\">2\n{'a': 2, 'b': 4}\n{2, 4, 6}\n(2, 4, 6, 8)\n[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n</code></pre>\n<p>Notice that this example didn't include the <code>list</code> type in the instantiation of the decorator, so in the final print statement the method gets applied to the list itself, not the elements of the list.</p>\n", "abstract": "This answer has long been answered, but I thought I would share my Decorator class which makes writing new decorators easy and compact. For one I think this makes the behavior of decorators very clear, but it also makes it easy to define new decorators very concisely. For the example listed above, you could then solve it as: You could also use it to do more complex tasks, like for instance a decorator which automatically makes the function get applied recursively to all arguments in an iterator: Which prints: Notice that this example didn't include the list type in the instantiation of the decorator, so in the final print statement the method gets applied to the list itself, not the elements of the list."}, {"id": 22833714, "score": 10, "vote": 0, "content": "<pre><code class=\"python\">#decorator.py\ndef makeHtmlTag(tag, *args, **kwds):\n    def real_decorator(fn):\n        css_class = \" class='{0}'\".format(kwds[\"css_class\"]) \\\n                                 if \"css_class\" in kwds else \"\"\n        def wrapped(*args, **kwds):\n            return \"&lt;\"+tag+css_class+\"&gt;\" + fn(*args, **kwds) + \"&lt;/\"+tag+\"&gt;\"\n        return wrapped\n    # return decorator dont call it\n    return real_decorator\n\n@makeHtmlTag(tag=\"b\", css_class=\"bold_css\")\n@makeHtmlTag(tag=\"i\", css_class=\"italic_css\")\ndef hello():\n    return \"hello world\"\n\nprint hello()\n</code></pre>\n<p>You can also write decorator in Class</p>\n<pre><code class=\"python\">#class.py\nclass makeHtmlTagClass(object):\n    def __init__(self, tag, css_class=\"\"):\n        self._tag = tag\n        self._css_class = \" class='{0}'\".format(css_class) \\\n                                       if css_class != \"\" else \"\"\n\n    def __call__(self, fn):\n        def wrapped(*args, **kwargs):\n            return \"&lt;\" + self._tag + self._css_class+\"&gt;\"  \\\n                       + fn(*args, **kwargs) + \"&lt;/\" + self._tag + \"&gt;\"\n        return wrapped\n\n@makeHtmlTagClass(tag=\"b\", css_class=\"bold_css\")\n@makeHtmlTagClass(tag=\"i\", css_class=\"italic_css\")\ndef hello(name):\n    return \"Hello, {}\".format(name)\n\nprint hello(\"Your name\")\n</code></pre>\n", "abstract": "You can also write decorator in Class"}, {"id": 17140530, "score": 8, "vote": 0, "content": "<p>Here is a simple example of chaining decorators.  Note the last line - it shows what is going on under the covers.</p>\n<pre><code class=\"python\">############################################################\n#\n#    decorators\n#\n############################################################\n\ndef bold(fn):\n    def decorate():\n        # surround with bold tags before calling original function\n        return \"&lt;b&gt;\" + fn() + \"&lt;/b&gt;\"\n    return decorate\n\n\ndef uk(fn):\n    def decorate():\n        # swap month and day\n        fields = fn().split('/')\n        date = fields[1] + \"/\" + fields[0] + \"/\" + fields[2]\n        return date\n    return decorate\n\nimport datetime\ndef getDate():\n    now = datetime.datetime.now()\n    return \"%d/%d/%d\" % (now.day, now.month, now.year)\n\n@bold\ndef getBoldDate(): \n    return getDate()\n\n@uk\ndef getUkDate():\n    return getDate()\n\n@bold\n@uk\ndef getBoldUkDate():\n    return getDate()\n\n\nprint getDate()\nprint getBoldDate()\nprint getUkDate()\nprint getBoldUkDate()\n# what is happening under the covers\nprint bold(uk(getDate))()\n</code></pre>\n<p>The output looks like:</p>\n<pre><code class=\"python\">17/6/2013\n&lt;b&gt;17/6/2013&lt;/b&gt;\n6/17/2013\n&lt;b&gt;6/17/2013&lt;/b&gt;\n&lt;b&gt;6/17/2013&lt;/b&gt;\n</code></pre>\n", "abstract": "Here is a simple example of chaining decorators.  Note the last line - it shows what is going on under the covers. The output looks like:"}, {"id": 9540819, "score": 7, "vote": 0, "content": "<p>Speaking of the counter example - as given above, the counter will be shared between all functions that use the decorator:</p>\n<pre><code class=\"python\">def counter(func):\n    def wrapped(*args, **kws):\n        print 'Called #%i' % wrapped.count\n        wrapped.count += 1\n        return func(*args, **kws)\n    wrapped.count = 0\n    return wrapped\n</code></pre>\n<p>That way, your decorator can be reused for different functions (or used to decorate the same function multiple times: <code>func_counter1 = counter(func); func_counter2 = counter(func)</code>), and the counter variable will remain private to each. </p>\n", "abstract": "Speaking of the counter example - as given above, the counter will be shared between all functions that use the decorator: That way, your decorator can be reused for different functions (or used to decorate the same function multiple times: func_counter1 = counter(func); func_counter2 = counter(func)), and the counter variable will remain private to each. "}, {"id": 15840821, "score": 7, "vote": 0, "content": "<h1>Decorate functions with different number of arguments:</h1>\n<pre><code class=\"python\">def frame_tests(fn):\n    def wrapper(*args):\n        print \"\\nStart: %s\" %(fn.__name__)\n        fn(*args)\n        print \"End: %s\\n\" %(fn.__name__)\n    return wrapper\n\n@frame_tests\ndef test_fn1():\n    print \"This is only a test!\"\n\n@frame_tests\ndef test_fn2(s1):\n    print \"This is only a test! %s\" %(s1)\n\n@frame_tests\ndef test_fn3(s1, s2):\n    print \"This is only a test! %s %s\" %(s1, s2)\n\nif __name__ == \"__main__\":\n    test_fn1()\n    test_fn2('OK!')\n    test_fn3('OK!', 'Just a test!')\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">Start: test_fn1  \nThis is only a test!  \nEnd: test_fn1  \n  \n  \nStart: test_fn2  \nThis is only a test! OK!  \nEnd: test_fn2  \n  \n  \nStart: test_fn3  \nThis is only a test! OK! Just a test!  \nEnd: test_fn3  \n</code></pre>\n", "abstract": "Result:"}, {"id": 55105198, "score": 7, "vote": 0, "content": "<p><a href=\"https://stackoverflow.com/a/739665/7262247\">Paolo Bergantino's answer</a> has the great advantage of only using the stdlib, and works for this simple example where there are no <em>decorator</em> arguments nor <em>decorated function</em> arguments. </p>\n<p>However it has 3 major limitations if you want to tackle more general cases:</p>\n<ul>\n<li>as already noted in several answers, you can not easily modify the code to <strong>add optional decorator arguments</strong>. For example creating a <code>makestyle(style='bold')</code> decorator is non-trivial.</li>\n<li>besides, wrappers created with <code>@functools.wraps</code> <strong>do not preserve the signature</strong>, so if bad arguments are provided they will start executing, and might raise a different kind of error than the usual <code>TypeError</code>.</li>\n<li>finally, it is quite difficult in wrappers created with <code>@functools.wraps</code> to <strong>access an argument based on its name</strong>. Indeed the argument can appear in <code>*args</code>, in <code>**kwargs</code>, or may not appear at all (if it is optional).</li>\n</ul>\n<p>I wrote <a href=\"https://smarie.github.io/python-decopatch/\" rel=\"noreferrer\"><code>decopatch</code></a> to solve the first issue, and wrote <a href=\"https://smarie.github.io/python-makefun/#signature-preserving-function-wrappers\" rel=\"noreferrer\"><code>makefun.wraps</code></a> to solve the other two. Note that <code>makefun</code> leverages the same trick than the famous <a href=\"https://github.com/micheles/decorator\" rel=\"noreferrer\"><code>decorator</code></a> lib.</p>\n<p>This is how you would create a decorator with arguments, returning truly signature-preserving wrappers:</p>\n<pre><code class=\"python\">from decopatch import function_decorator, DECORATED\nfrom makefun import wraps\n\n@function_decorator\ndef makestyle(st='b', fn=DECORATED):\n    open_tag = \"&lt;%s&gt;\" % st\n    close_tag = \"&lt;/%s&gt;\" % st\n\n    @wraps(fn)\n    def wrapped(*args, **kwargs):\n        return open_tag + fn(*args, **kwargs) + close_tag\n\n    return wrapped\n</code></pre>\n<p><code>decopatch</code> provides you with two other development styles that hide or show the various python concepts, depending on your preferences. The most compact style is the following:</p>\n<pre><code class=\"python\">from decopatch import function_decorator, WRAPPED, F_ARGS, F_KWARGS\n\n@function_decorator\ndef makestyle(st='b', fn=WRAPPED, f_args=F_ARGS, f_kwargs=F_KWARGS):\n    open_tag = \"&lt;%s&gt;\" % st\n    close_tag = \"&lt;/%s&gt;\" % st\n    return open_tag + fn(*f_args, **f_kwargs) + close_tag\n</code></pre>\n<p>In both cases you can check that the decorator works as expected:</p>\n<pre><code class=\"python\">@makestyle\n@makestyle('i')\ndef hello(who):\n    return \"hello %s\" % who\n\nassert hello('world') == '&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;'    \n</code></pre>\n<p>Please refer to the <a href=\"https://smarie.github.io/python-decopatch/\" rel=\"noreferrer\">documentation</a> for details.</p>\n", "abstract": "Paolo Bergantino's answer has the great advantage of only using the stdlib, and works for this simple example where there are no decorator arguments nor decorated function arguments.  However it has 3 major limitations if you want to tackle more general cases: I wrote decopatch to solve the first issue, and wrote makefun.wraps to solve the other two. Note that makefun leverages the same trick than the famous decorator lib. This is how you would create a decorator with arguments, returning truly signature-preserving wrappers: decopatch provides you with two other development styles that hide or show the various python concepts, depending on your preferences. The most compact style is the following: In both cases you can check that the decorator works as expected: Please refer to the documentation for details."}, {"id": 67247689, "score": 0, "vote": 0, "content": "<p>I add a case when you need to add custom parameters in decorator, pass it to final function and then work it with.</p>\n<p>the very decorators:</p>\n<pre><code class=\"python\">def jwt_or_redirect(fn):\n  @wraps(fn)\n  def decorator(*args, **kwargs):\n    ...\n    return fn(*args, **kwargs)\n  return decorator\n\ndef jwt_refresh(fn):\n  @wraps(fn)\n  def decorator(*args, **kwargs):\n    ...\n    new_kwargs = {'refreshed_jwt': 'xxxxx-xxxxxx'}\n    new_kwargs.update(kwargs)\n    return fn(*args, **new_kwargs)\n  return decorator\n</code></pre>\n<p>and the final function:</p>\n<pre><code class=\"python\">@app.route('/')\n@jwt_or_redirect\n@jwt_refresh\ndef home_page(*args, **kwargs):\n  return kwargs['refreched_jwt']\n</code></pre>\n", "abstract": "I add a case when you need to add custom parameters in decorator, pass it to final function and then work it with. the very decorators: and the final function:"}, {"id": 71546227, "score": 0, "vote": 0, "content": "<p>Yet another example of nested decorators for plotting an image:</p>\n<pre><code class=\"python\">import matplotlib.pylab as plt\n\ndef remove_axis(func):\n    def inner(img, alpha):\n        plt.axis('off')\n        func(img, alpha)\n    return inner\n\ndef plot_gray(func):\n    def inner(img, alpha):\n        plt.gray()\n        func(img, alpha)\n    return inner\n\n@remove_axis\n@plot_gray\ndef plot_image(img, alpha):\n    plt.imshow(img, alpha=alpha)\n    plt.show()\n</code></pre>\n<p>Now, let's show a color image first without axis labels using the nested decorators:</p>\n<pre><code class=\"python\">plot_image(plt.imread('lena_color.jpg'), 0.4)\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/n6Pbn.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/n6Pbn.png\"/></a></p>\n<p>Next, let's show a gray scale image without axis labels using the nested decorators <code>remove_axis</code> and <code>plot_gray</code> (we need to <code>cmap='gray'</code>, otherwise the default colormap is <code>viridis</code>, so a grayscale image is by default not displayed in black and white shades, unless explicitly specified)</p>\n<pre><code class=\"python\">plot_image(plt.imread('lena_bw.jpg'), 0.8)\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/JAhvK.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/JAhvK.png\"/></a></p>\n<p>The above function call reduces down to the following nested call</p>\n<pre><code class=\"python\">remove_axis(plot_gray(plot_image))(img, alpha)\n</code></pre>\n", "abstract": "Yet another example of nested decorators for plotting an image: Now, let's show a color image first without axis labels using the nested decorators:  Next, let's show a gray scale image without axis labels using the nested decorators remove_axis and plot_gray (we need to cmap='gray', otherwise the default colormap is viridis, so a grayscale image is by default not displayed in black and white shades, unless explicitly specified)  The above function call reduces down to the following nested call"}]}, {"link": "https://stackoverflow.com/questions/332289/how-do-i-change-the-size-of-figures-drawn-with-matplotlib", "question": {"id": "332289", "title": "How do I change the size of figures drawn with Matplotlib?", "content": "<p>How do I change the size of figure drawn with Matplotlib?</p>\n", "abstract": "How do I change the size of figure drawn with Matplotlib?"}, "answers": [{"id": 638443, "score": 1716, "vote": 0, "content": "<p><a href=\"https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.figure.html\" rel=\"noreferrer\"><code>figure</code></a> tells you the call signature:</p>\n<pre><code class=\"python\">from matplotlib.pyplot import figure\n\nfigure(figsize=(8, 6), dpi=80)\n</code></pre>\n<p><code>figure(figsize=(1,1))</code> would create an inch-by-inch image, which would be 80-by-80 pixels unless you also give a different dpi argument.</p>\n", "abstract": "figure tells you the call signature: figure(figsize=(1,1)) would create an inch-by-inch image, which would be 80-by-80 pixels unless you also give a different dpi argument."}, {"id": 4306340, "score": 1061, "vote": 0, "content": "<p>If you've already got the figure created, you can use <a href=\"https://matplotlib.org/stable/api/figure_api.html#matplotlib.figure.Figure.set_size_inches\" rel=\"noreferrer\"><code>figure.set_size_inches</code></a> to adjust the figure size:</p>\n<pre><code class=\"python\">fig = matplotlib.pyplot.gcf()\nfig.set_size_inches(18.5, 10.5)\nfig.savefig('test2png.png', dpi=100)\n</code></pre>\n<p>To propagate the size change to an existing GUI window, add <code>forward=True</code>:</p>\n<pre><code class=\"python\">fig.set_size_inches(18.5, 10.5, forward=True)\n</code></pre>\n<p>Additionally as <a href=\"https://stackoverflow.com/questions/332289/how-do-you-change-the-size-of-figures-drawn-with-matplotlib#comment46810702_4306340\">Erik Shilts mentioned in the comments</a> you can also use <a href=\"https://matplotlib.org/stable/api/figure_api.html#matplotlib.figure.Figure.set_dpi\" rel=\"noreferrer\"><code>figure.set_dpi</code></a> to \"[s]et the resolution of the figure in dots-per-inch\"</p>\n<pre><code class=\"python\">fig.set_dpi(100)\n</code></pre>\n", "abstract": "If you've already got the figure created, you can use figure.set_size_inches to adjust the figure size: To propagate the size change to an existing GUI window, add forward=True: Additionally as Erik Shilts mentioned in the comments you can also use figure.set_dpi to \"[s]et the resolution of the figure in dots-per-inch\""}, {"id": 41717533, "score": 674, "vote": 0, "content": "<h3>Using plt.rcParams</h3>\n<p>There is also this workaround in case you want to change the size without using the figure environment. So in case you are using <a href=\"https://matplotlib.org/api/_as_gen/matplotlib.pyplot.figure.html\" rel=\"noreferrer\"><code>plt.plot()</code></a> for example, you can set a tuple with width and height.</p>\n<pre><code class=\"python\">import matplotlib.pyplot as plt\nplt.rcParams[\"figure.figsize\"] = (20,3)\n</code></pre>\n<p>This is very useful when you plot inline (e.g., with <a href=\"https://en.wikipedia.org/wiki/IPython#Notebook\" rel=\"noreferrer\">IPython Notebook</a>). As <a href=\"https://stackoverflow.com/questions/332289/how-do-you-change-the-size-of-figures-drawn-with-matplotlib#comment87590438_41717533\">asmaier noticed</a>, it is preferable to not put this statement in the same cell of the imports statements.</p>\n<p>To reset the global figure size back to default for subsequent plots:</p>\n<pre><code class=\"python\">plt.rcParams[\"figure.figsize\"] = plt.rcParamsDefault[\"figure.figsize\"]\n</code></pre>\n<h3>Conversion to cm</h3>\n<p>The <code>figsize</code> tuple accepts inches, so if you want to set it in centimetres you have to divide them by 2.54. Have a look at <a href=\"https://stackoverflow.com/questions/14708695/specify-figure-size-in-centimeter-in-matplotlib\">this question</a>.</p>\n", "abstract": "There is also this workaround in case you want to change the size without using the figure environment. So in case you are using plt.plot() for example, you can set a tuple with width and height. This is very useful when you plot inline (e.g., with IPython Notebook). As asmaier noticed, it is preferable to not put this statement in the same cell of the imports statements. To reset the global figure size back to default for subsequent plots: The figsize tuple accepts inches, so if you want to set it in centimetres you have to divide them by 2.54. Have a look at this question."}, {"id": 24073700, "score": 431, "vote": 0, "content": "<p>Please try a simple code as following:</p>\n<pre><code class=\"python\">from matplotlib import pyplot as plt\nplt.figure(figsize=(1,1))\nx = [1,2,3]\nplt.plot(x, x)\nplt.show()\n</code></pre>\n<p>You need to set the figure size before you plot.</p>\n", "abstract": "Please try a simple code as following: You need to set the figure size before you plot."}, {"id": 332311, "score": 424, "vote": 0, "content": "<blockquote>\n<p><strong>Deprecation note:</strong><br/>\n  As per the <a href=\"https://matplotlib.org/faq/usage_faq.html#matplotlib-pyplot-and-pylab-how-are-they-related\" rel=\"noreferrer\">official Matplotlib guide</a>, usage of the <code>pylab</code> module is no longer recommended. Please consider using the <code>matplotlib.pyplot</code> module instead, as described by <a href=\"https://stackoverflow.com/a/41717533\">this other answer</a>.</p>\n</blockquote>\n<p>The following seems to work:</p>\n<pre><code class=\"python\">from pylab import rcParams\nrcParams['figure.figsize'] = 5, 10\n</code></pre>\n<p>This makes the figure's width 5 inches, and its height 10 <b>inches</b>. </p>\n<p>The Figure class then uses this as the default value for one of its arguments.</p>\n", "abstract": "Deprecation note:\n  As per the official Matplotlib guide, usage of the pylab module is no longer recommended. Please consider using the matplotlib.pyplot module instead, as described by this other answer. The following seems to work: This makes the figure's width 5 inches, and its height 10 inches.  The Figure class then uses this as the default value for one of its arguments."}, {"id": 39770939, "score": 181, "vote": 0, "content": "<p>In case you're looking for a way to change the figure size in <strong>Pandas</strong>, you could do:</p>\n<pre><code class=\"python\">df['some_column'].plot(figsize=(10, 5))\n</code></pre>\n<p>where <code>df</code> is a Pandas dataframe. Or, to use an existing figure or axes:</p>\n<pre><code class=\"python\">fig, ax = plt.subplots(figsize=(10, 5))\ndf['some_column'].plot(ax=ax)\n</code></pre>\n<p>If you want to change the default settings, you could do the following:</p>\n<pre><code class=\"python\">import matplotlib\n\nmatplotlib.rc('figure', figsize=(10, 5))\n</code></pre>\n<p>For more details, check out the docs: <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html\" rel=\"noreferrer\"><code>pd.DataFrame.plot</code></a>.</p>\n", "abstract": "In case you're looking for a way to change the figure size in Pandas, you could do: where df is a Pandas dataframe. Or, to use an existing figure or axes: If you want to change the default settings, you could do the following: For more details, check out the docs: pd.DataFrame.plot."}, {"id": 56941236, "score": 91, "vote": 0, "content": "<pre><code class=\"python\">import matplotlib.pyplot as plt\nplt.figure(figsize=(20,10))\nplt.plot(x,y) ## This is your plot\nplt.show()\n</code></pre>\n<p>You can also use:</p>\n<pre><code class=\"python\">fig, ax = plt.subplots(figsize=(20, 10))\n</code></pre>\n", "abstract": "You can also use:"}, {"id": 334462, "score": 84, "vote": 0, "content": "<p>The first link in Google for <code>'matplotlib figure size'</code> is <a href=\"http://www.scipy.org/Cookbook/Matplotlib/AdjustingImageSize\" rel=\"noreferrer\">AdjustingImageSize</a> (<a href=\"https://webcache.googleusercontent.com/search?q=cache:5oqjjm8c8UMJ:https://scipy.github.io/old-wiki/pages/Cookbook/Matplotlib/AdjustingImageSize.html+&amp;cd=2&amp;hl=en&amp;ct=clnk&amp;gl=fr\" rel=\"noreferrer\">Google cache of the page</a>).</p>\n<p>Here's a test script from the above page. It creates <code>test[1-3].png</code> files of different sizes of the same image:</p>\n<pre><code class=\"python\">#!/usr/bin/env python\n\"\"\"\nThis is a small demo file that helps teach how to adjust figure sizes\nfor matplotlib\n\n\"\"\"\n\nimport matplotlib\nprint \"using MPL version:\", matplotlib.__version__\nmatplotlib.use(\"WXAgg\") # do this before pylab so you don'tget the default back end.\n\nimport pylab\nimport numpy as np\n\n# Generate and plot some simple data:\nx = np.arange(0, 2*np.pi, 0.1)\ny = np.sin(x)\n\npylab.plot(x,y)\nF = pylab.gcf()\n\n# Now check everything with the defaults:\nDPI = F.get_dpi()\nprint \"DPI:\", DPI\nDefaultSize = F.get_size_inches()\nprint \"Default size in Inches\", DefaultSize\nprint \"Which should result in a %i x %i Image\"%(DPI*DefaultSize[0], DPI*DefaultSize[1])\n# the default is 100dpi for savefig:\nF.savefig(\"test1.png\")\n# this gives me a 797 x 566 pixel image, which is about 100 DPI\n\n# Now make the image twice as big, while keeping the fonts and all the\n# same size\nF.set_size_inches( (DefaultSize[0]*2, DefaultSize[1]*2) )\nSize = F.get_size_inches()\nprint \"Size in Inches\", Size\nF.savefig(\"test2.png\")\n# this results in a 1595x1132 image\n\n# Now make the image twice as big, making all the fonts and lines\n# bigger too.\n\nF.set_size_inches( DefaultSize )# resetthe size\nSize = F.get_size_inches()\nprint \"Size in Inches\", Size\nF.savefig(\"test3.png\", dpi = (200)) # change the dpi\n# this also results in a 1595x1132 image, but the fonts are larger.\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">using MPL version: 0.98.1\nDPI: 80\nDefault size in Inches [ 8.  6.]\nWhich should result in a 640 x 480 Image\nSize in Inches [ 16.  12.]\nSize in Inches [ 16.  12.]\n</code></pre>\n<p>Two notes:</p>\n<ol>\n<li><p>The module comments and the actual output differ.</p></li>\n<li><p><a href=\"https://stackoverflow.com/questions/335896/how-to-complete-this-python-function-to-save-in-the-same-folder#336001\">This answer</a> allows easily to combine all three images in one image file to see the difference in sizes.</p></li>\n</ol>\n", "abstract": "The first link in Google for 'matplotlib figure size' is AdjustingImageSize (Google cache of the page). Here's a test script from the above page. It creates test[1-3].png files of different sizes of the same image: Output: Two notes: The module comments and the actual output differ. This answer allows easily to combine all three images in one image file to see the difference in sizes."}, {"id": 47018826, "score": 59, "vote": 0, "content": "<p>You can simply use (from <a href=\"https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html\" rel=\"noreferrer\">matplotlib.figure.Figure</a>):</p>\n<pre><code class=\"python\">fig.set_size_inches(width,height)\n</code></pre>\n<p>As of Matplotlib 2.0.0, changes to your canvas will be visible immediately, as the <code>forward</code> keyword <a href=\"https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html?highlight=set%20size%20inches#matplotlib.figure.Figure.set_size_inches\" rel=\"noreferrer\">defaults to <code>True</code></a>.</p>\n<p>If you want to just <a href=\"https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html?highlight=set%20size%20inches#matplotlib.figure.Figure.set_figheight\" rel=\"noreferrer\">change the width <strong>or</strong> height</a> instead of both, you can use </p>\n<p><code>fig.set_figwidth(val)</code> or <code>fig.set_figheight(val)</code></p>\n<p>These will also immediately update your canvas, but only in Matplotlib 2.2.0 and newer.</p>\n<h3>For Older Versions</h3>\n<p>You need to specify <code>forward=True</code> explicitly in order to live-update your canvas in versions older than what is specified above. Note that the <code>set_figwidth</code> and <code>set_figheight</code> functions don\u2019t support the <code>forward</code> parameter in versions older than Matplotlib 1.5.0.</p>\n", "abstract": "You can simply use (from matplotlib.figure.Figure): As of Matplotlib 2.0.0, changes to your canvas will be visible immediately, as the forward keyword defaults to True. If you want to just change the width or height instead of both, you can use  fig.set_figwidth(val) or fig.set_figheight(val) These will also immediately update your canvas, but only in Matplotlib 2.2.0 and newer. You need to specify forward=True explicitly in order to live-update your canvas in versions older than what is specified above. Note that the set_figwidth and set_figheight functions don\u2019t support the forward parameter in versions older than Matplotlib 1.5.0."}, {"id": 22399608, "score": 49, "vote": 0, "content": "<p>Try commenting out the <code>fig = ...</code> line</p>\n<pre><code class=\"python\">%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nN = 50\nx = np.random.rand(N)\ny = np.random.rand(N)\narea = np.pi * (15 * np.random.rand(N))**2\n\nfig = plt.figure(figsize=(18, 18))\nplt.scatter(x, y, s=area, alpha=0.5)\nplt.show()\n</code></pre>\n", "abstract": "Try commenting out the fig = ... line"}, {"id": 23903662, "score": 41, "vote": 0, "content": "<p>This works well for me:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from matplotlib import pyplot as plt\n\nF = plt.gcf()\nSize = F.get_size_inches()\nF.set_size_inches(Size[0]*2, Size[1]*2, forward=True) # Set forward to True to resize window along with plot in figure.\nplt.show() # Or plt.imshow(z_array) if using an animation, where z_array is a matrix or NumPy array\n</code></pre>\n<p>This forum post might also help: <em><a href=\"http://matplotlib.1069221.n5.nabble.com/Resizing-figure-windows-td11424.html\" rel=\"nofollow noreferrer\">Resizing figure windows</a></em></p>\n", "abstract": "This works well for me: This forum post might also help: Resizing figure windows"}, {"id": 64767170, "score": 31, "vote": 0, "content": "<p><strong>Comparison of different approaches to set exact image sizes in pixels</strong></p>\n<p>This answer will focus on:</p>\n<ul>\n<li><code>savefig</code>: how to save to a file, not just show on screen</li>\n<li>setting the size in pixels</li>\n</ul>\n<p>Here is a quick comparison of some of the approaches I've tried with images showing what the give.</p>\n<p>Summary of current status: things are messy, not sure if it is a fundamental limitation, or if the use case just didn't get enough attention from devs, I couldn't easily find an upstream discussion about this.</p>\n<p><strong>Baseline example without trying to set the image dimensions</strong></p>\n<p>Just to have a comparison point:</p>\n<p>base.py</p>\n<pre><code class=\"python\">#!/usr/bin/env python3\n\nimport sys\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nfig, ax = plt.subplots()\nprint('fig.dpi = {}'.format(fig.dpi))\nprint('fig.get_size_inches() = ' + str(fig.get_size_inches())\nt = np.arange(-10., 10., 1.)\nplt.plot(t, t, '.')\nplt.plot(t, t**2, '.')\nax.text(0., 60., 'Hello', fontdict=dict(size=25))\nplt.savefig('base.png', format='png')\n</code></pre>\n<p>run:</p>\n<pre><code class=\"python\">./base.py\nidentify base.png\n</code></pre>\n<p>outputs:</p>\n<pre><code class=\"python\">fig.dpi = 100.0\nfig.get_size_inches() = [6.4 4.8]\nbase.png PNG 640x480 640x480+0+0 8-bit sRGB 13064B 0.000u 0:00.000\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/jtD8D.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/jtD8D.png\"/></a></p>\n<p><strong>My best approach so far: <code>plt.savefig(dpi=h/fig.get_size_inches()[1]</code> height-only control</strong></p>\n<p>I think this is what I'll go with most of the time, as it is simple and scales:</p>\n<p>get_size.py</p>\n<pre><code class=\"python\">#!/usr/bin/env python3\n\nimport sys\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nheight = int(sys.argv[1])\nfig, ax = plt.subplots()\nt = np.arange(-10., 10., 1.)\nplt.plot(t, t, '.')\nplt.plot(t, t**2, '.')\nax.text(0., 60., 'Hello', fontdict=dict(size=25))\nplt.savefig(\n    'get_size.png',\n    format='png',\n    dpi=height/fig.get_size_inches()[1]\n)\n</code></pre>\n<p>run:</p>\n<pre><code class=\"python\">./get_size.py 431\n</code></pre>\n<p>outputs:</p>\n<pre><code class=\"python\">get_size.png PNG 574x431 574x431+0+0 8-bit sRGB 10058B 0.000u 0:00.000\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/KdCdo.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/KdCdo.png\"/></a></p>\n<p>and</p>\n<pre><code class=\"python\">./get_size.py 1293\n</code></pre>\n<p>outputs:</p>\n<pre><code class=\"python\">main.png PNG 1724x1293 1724x1293+0+0 8-bit sRGB 46709B 0.000u 0:00.000\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/sitTs.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/sitTs.png\"/></a></p>\n<p>I tend to set just the height because I'm usually most concerned about how much vertical space the image is going to take up in the middle of my text.</p>\n<p><strong><code>plt.savefig(bbox_inches='tight'</code> changes image size</strong></p>\n<p>I always feel that there is too much white space around images, and tended to add <code>bbox_inches='tight'</code> from:\n<a href=\"https://stackoverflow.com/questions/11837979/removing-white-space-around-a-saved-image-in-matplotlib\">Removing white space around a saved image</a></p>\n<p>However, that works by cropping the image, and you won't get the desired sizes with it.</p>\n<p>Instead, this other approach proposed in the same question seems to work well:</p>\n<pre><code class=\"python\">plt.tight_layout(pad=1)\nplt.savefig(...\n</code></pre>\n<p>which gives the exact desired height for height equals 431:</p>\n<p><a href=\"https://i.stack.imgur.com/tX75f.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/tX75f.png\"/></a></p>\n<p><strong>Fixed height, <code>set_aspect</code>, automatically sized width and small margins</strong></p>\n<p>Ermmm, <code>set_aspect</code> messes things up again and prevents <code>plt.tight_layout</code> from actually removing the margins... this is an important use case that I don't have a great solution for yet.</p>\n<p>Asked at: <a href=\"https://stackoverflow.com/questions/64642855/how-to-obtain-a-fixed-height-in-pixels-fixed-data-x-y-aspect-ratio-and-automati\">How to obtain a fixed height in pixels, fixed data x/y aspect ratio and automatically remove remove horizontal whitespace margin in Matplotlib?</a></p>\n<p><strong><code>plt.savefig(dpi=h/fig.get_size_inches()[1]</code> + width control</strong></p>\n<p>If you really need a specific width in addition to height, this seems to work OK:</p>\n<p>width.py</p>\n<pre><code class=\"python\">#!/usr/bin/env python3\n\nimport sys\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nh = int(sys.argv[1])\nw = int(sys.argv[2])\nfig, ax = plt.subplots()\nwi, hi = fig.get_size_inches()\nfig.set_size_inches(hi*(w/h), hi)\nt = np.arange(-10., 10., 1.)\nplt.plot(t, t, '.')\nplt.plot(t, t**2, '.')\nax.text(0., 60., 'Hello', fontdict=dict(size=25))\nplt.savefig(\n    'width.png',\n    format='png',\n    dpi=h/hi\n)\n</code></pre>\n<p>run:</p>\n<pre><code class=\"python\">./width.py 431 869\n</code></pre>\n<p>output:</p>\n<pre><code class=\"python\">width.png PNG 869x431 869x431+0+0 8-bit sRGB 10965B 0.000u 0:00.000\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/udybG.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/udybG.png\"/></a></p>\n<p>and for a small width:</p>\n<pre><code class=\"python\">./width.py 431 869\n</code></pre>\n<p>output:</p>\n<pre><code class=\"python\">width.png PNG 211x431 211x431+0+0 8-bit sRGB 6949B 0.000u 0:00.000\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/Xbq1g.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Xbq1g.png\"/></a></p>\n<p>So it does seem that fonts are scaling correctly, we just get some trouble for very small widths with labels getting cut off, e.g. the <code>100</code> on the top left.</p>\n<p>I managed to work around those with <a href=\"https://stackoverflow.com/questions/11837979/removing-white-space-around-a-saved-image-in-matplotlib/57498238#57498238\">Removing white space around a saved image</a></p>\n<pre><code class=\"python\">plt.tight_layout(pad=1)\n</code></pre>\n<p>which gives:</p>\n<pre><code class=\"python\">width.png PNG 211x431 211x431+0+0 8-bit sRGB 7134B 0.000u 0:00.000\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/D3Adb.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/D3Adb.png\"/></a></p>\n<p>From this, we also see that <code>tight_layout</code> removes a lot of the empty space at the top of the image, so I just generally always use it.</p>\n<p><strong>Fixed magic base height, <code>dpi</code> on <code>fig.set_size_inches</code> and <code>plt.savefig(dpi=</code> scaling</strong></p>\n<p>I believe that this is equivalent to the approach mentioned at: <a href=\"https://stackoverflow.com/a/13714720/895245\">https://stackoverflow.com/a/13714720/895245</a></p>\n<p>magic.py</p>\n<pre><code class=\"python\">#!/usr/bin/env python3\n\nimport sys\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nmagic_height = 300\nw = int(sys.argv[1])\nh = int(sys.argv[2])\ndpi = 80\nfig, ax = plt.subplots(dpi=dpi)\nfig.set_size_inches(magic_height*w/(h*dpi), magic_height/dpi)\nt = np.arange(-10., 10., 1.)\nplt.plot(t, t, '.')\nplt.plot(t, t**2, '.')\nax.text(0., 60., 'Hello', fontdict=dict(size=25))\nplt.savefig(\n    'magic.png',\n    format='png',\n    dpi=h/magic_height*dpi,\n)\n</code></pre>\n<p>run:</p>\n<pre><code class=\"python\">./magic.py 431 231\n</code></pre>\n<p>outputs:</p>\n<pre><code class=\"python\">magic.png PNG 431x231 431x231+0+0 8-bit sRGB 7923B 0.000u 0:00.000\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/cnTUV.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/cnTUV.png\"/></a></p>\n<p>And to see if it scales nicely:</p>\n<pre><code class=\"python\">./magic.py 1291 693\n</code></pre>\n<p>outputs:</p>\n<pre><code class=\"python\">magic.png PNG 1291x693 1291x693+0+0 8-bit sRGB 25013B 0.000u 0:00.000\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/I5xN6.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/I5xN6.png\"/></a></p>\n<p>So we see that this approach also does work well. The only problem I have with it is that you have to set that <code>magic_height</code> parameter or equivalent.</p>\n<p><strong>Fixed DPI + <code>set_size_inches</code></strong></p>\n<p>This approach gave a slightly wrong pixel size, and it makes it is hard to scale everything seamlessly.</p>\n<p>set_size_inches.py</p>\n<pre><code class=\"python\">#!/usr/bin/env python3\n\nimport sys\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nw = int(sys.argv[1])\nh = int(sys.argv[2])\nfig, ax = plt.subplots()\nfig.set_size_inches(w/fig.dpi, h/fig.dpi)\nt = np.arange(-10., 10., 1.)\nplt.plot(t, t, '.')\nplt.plot(t, t**2, '.')\nax.text(\n    0,\n    60.,\n    'Hello',\n    # Keep font size fixed independently of DPI.\n    # https://stackoverflow.com/questions/39395616/matplotlib-change-figsize-but-keep-fontsize-constant\n    fontdict=dict(size=10*h/fig.dpi),\n)\nplt.savefig(\n    'set_size_inches.png',\n    format='png',\n)\n</code></pre>\n<p>run:</p>\n<pre><code class=\"python\">./set_size_inches.py 431 231\n</code></pre>\n<p>outputs:</p>\n<pre><code class=\"python\">set_size_inches.png PNG 430x231 430x231+0+0 8-bit sRGB 8078B 0.000u 0:00.000\n</code></pre>\n<p>so the height is slightly off, and the image:</p>\n<p><a href=\"https://i.stack.imgur.com/2rC6e.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/2rC6e.png\"/></a></p>\n<p>The pixel sizes are also correct if I make it 3 times larger:</p>\n<pre><code class=\"python\">./set_size_inches.py 1291 693\n</code></pre>\n<p>outputs:</p>\n<pre><code class=\"python\">set_size_inches.png PNG 1291x693 1291x693+0+0 8-bit sRGB 19798B 0.000u 0:00.000\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/dWsRG.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/dWsRG.png\"/></a></p>\n<p>We understand from this however that for this approach to scale nicely, you need to make every DPI-dependant setting proportional to the size in inches.</p>\n<p>In the previous example, we only made the \"Hello\" text proportional, and it did retain its height between 60 and 80 as we'd expect. But everything for which we didn't do that, looks tiny, including:</p>\n<ul>\n<li>line width of axes</li>\n<li>tick labels</li>\n<li>point markers</li>\n</ul>\n<p><strong>SVG</strong></p>\n<p>I could not find how to set it for SVG images, my approaches only worked for PNG e.g.:</p>\n<p>get_size_svg.py</p>\n<pre><code class=\"python\">#!/usr/bin/env python3\n\nimport sys\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\nheight = int(sys.argv[1])\nfig, ax = plt.subplots()\nt = np.arange(-10., 10., 1.)\nplt.plot(t, t, '.')\nplt.plot(t, t**2, '.')\nax.text(0., 60., 'Hello', fontdict=dict(size=25))\nplt.savefig(\n    'get_size_svg.svg',\n    format='svg',\n    dpi=height/fig.get_size_inches()[1]\n)\n</code></pre>\n<p>run:</p>\n<pre><code class=\"python\">./get_size_svg.py 431\n</code></pre>\n<p>and the generated output contains:</p>\n<pre><code class=\"python\">&lt;svg height=\"345.6pt\" version=\"1.1\" viewBox=\"0 0 460.8 345.6\" width=\"460.8pt\"\n</code></pre>\n<p>and identify says:</p>\n<pre><code class=\"python\">get_size_svg.svg SVG 614x461 614x461+0+0 8-bit sRGB 17094B 0.000u 0:00.000\n</code></pre>\n<p>and if I open it in Chromium 86 the browser debug tools mouse image hover confirm that height as 460.79.</p>\n<p>But of course, since SVG is a vector format, everything should in theory scale, so you can just convert to any fixed sized format without loss of resolution, e.g.:</p>\n<pre><code class=\"python\">inkscape -h 431 get_size_svg.svg -b FFF -e get_size_svg.png\n</code></pre>\n<p>gives the exact height:</p>\n<p><a href=\"https://i.stack.imgur.com/i4kHL.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/i4kHL.png\"/></a></p>\n<p>I use Inkscape instead of Imagemagick's <code>convert</code> here because you need to mess with <code>-density</code> as well to get sharp SVG resizes with ImageMagick:</p>\n<ul>\n<li><a href=\"https://superuser.com/questions/598849/imagemagick-convert-how-to-produce-sharp-resized-png-files-from-svg-files/1602059#1602059\">https://superuser.com/questions/598849/imagemagick-convert-how-to-produce-sharp-resized-png-files-from-svg-files/1602059#1602059</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9853325/how-to-convert-a-svg-to-a-png-with-imagemagick\">How to convert a SVG to a PNG with ImageMagick?</a></li>\n</ul>\n<p>And setting <code>&lt;img height=\"\"</code> on the HTML should also just work for the browser.</p>\n<p>Tested on matplotlib==3.2.2.</p>\n", "abstract": "Comparison of different approaches to set exact image sizes in pixels This answer will focus on: Here is a quick comparison of some of the approaches I've tried with images showing what the give. Summary of current status: things are messy, not sure if it is a fundamental limitation, or if the use case just didn't get enough attention from devs, I couldn't easily find an upstream discussion about this. Baseline example without trying to set the image dimensions Just to have a comparison point: base.py run: outputs:  My best approach so far: plt.savefig(dpi=h/fig.get_size_inches()[1] height-only control I think this is what I'll go with most of the time, as it is simple and scales: get_size.py run: outputs:  and outputs:  I tend to set just the height because I'm usually most concerned about how much vertical space the image is going to take up in the middle of my text. plt.savefig(bbox_inches='tight' changes image size I always feel that there is too much white space around images, and tended to add bbox_inches='tight' from:\nRemoving white space around a saved image However, that works by cropping the image, and you won't get the desired sizes with it. Instead, this other approach proposed in the same question seems to work well: which gives the exact desired height for height equals 431:  Fixed height, set_aspect, automatically sized width and small margins Ermmm, set_aspect messes things up again and prevents plt.tight_layout from actually removing the margins... this is an important use case that I don't have a great solution for yet. Asked at: How to obtain a fixed height in pixels, fixed data x/y aspect ratio and automatically remove remove horizontal whitespace margin in Matplotlib? plt.savefig(dpi=h/fig.get_size_inches()[1] + width control If you really need a specific width in addition to height, this seems to work OK: width.py run: output:  and for a small width: output:  So it does seem that fonts are scaling correctly, we just get some trouble for very small widths with labels getting cut off, e.g. the 100 on the top left. I managed to work around those with Removing white space around a saved image which gives:  From this, we also see that tight_layout removes a lot of the empty space at the top of the image, so I just generally always use it. Fixed magic base height, dpi on fig.set_size_inches and plt.savefig(dpi= scaling I believe that this is equivalent to the approach mentioned at: https://stackoverflow.com/a/13714720/895245 magic.py run: outputs:  And to see if it scales nicely: outputs:  So we see that this approach also does work well. The only problem I have with it is that you have to set that magic_height parameter or equivalent. Fixed DPI + set_size_inches This approach gave a slightly wrong pixel size, and it makes it is hard to scale everything seamlessly. set_size_inches.py run: outputs: so the height is slightly off, and the image:  The pixel sizes are also correct if I make it 3 times larger: outputs:  We understand from this however that for this approach to scale nicely, you need to make every DPI-dependant setting proportional to the size in inches. In the previous example, we only made the \"Hello\" text proportional, and it did retain its height between 60 and 80 as we'd expect. But everything for which we didn't do that, looks tiny, including: SVG I could not find how to set it for SVG images, my approaches only worked for PNG e.g.: get_size_svg.py run: and the generated output contains: and identify says: and if I open it in Chromium 86 the browser debug tools mouse image hover confirm that height as 460.79. But of course, since SVG is a vector format, everything should in theory scale, so you can just convert to any fixed sized format without loss of resolution, e.g.: gives the exact height:  I use Inkscape instead of Imagemagick's convert here because you need to mess with -density as well to get sharp SVG resizes with ImageMagick: And setting <img height=\"\" on the HTML should also just work for the browser. Tested on matplotlib==3.2.2."}, {"id": 26650785, "score": 20, "vote": 0, "content": "<p>To increase the size of your figure N times, you need to insert this just before your <em>pl.show()</em>:</p>\n<pre><code class=\"python\">N = 2\nparams = pl.gcf()\nplSize = params.get_size_inches()\nparams.set_size_inches((plSize[0]*N, plSize[1]*N))\n</code></pre>\n<p>It also works well with an <a href=\"https://en.wikipedia.org/wiki/IPython\" rel=\"nofollow noreferrer\">IPython</a> notebook.</p>\n", "abstract": "To increase the size of your figure N times, you need to insert this just before your pl.show(): It also works well with an IPython notebook."}, {"id": 66638878, "score": 16, "vote": 0, "content": "<p>The following will surely work, but <strong>make sure you add the line <code>plt.figure(figsize=(20,10))</code> above <code>plt.plot(x,y)</code>, <code>plt.pie()</code></strong>, etc.</p>\n<pre><code class=\"python\">import matplotlib.pyplot as plt\nplt.figure(figsize=(20,10))\nplt.plot(x,y) ## This is your plot\nplt.show()\n</code></pre>\n<p>The code is copied <a href=\"https://stackoverflow.com/questions/332289/how-do-you-change-the-size-of-figures-drawn-with-matplotlib/56941236#56941236\">from amalik2205</a>.</p>\n", "abstract": "The following will surely work, but make sure you add the line plt.figure(figsize=(20,10)) above plt.plot(x,y), plt.pie(), etc. The code is copied from amalik2205."}, {"id": 59108174, "score": 15, "vote": 0, "content": "<p>Generalizing and simplifying <a href=\"https://stackoverflow.com/questions/332289/how-do-you-change-the-size-of-figures-drawn-with-matplotlib/26650785#26650785\">psihodelia's answer</a>:</p>\n<p>If you want to change the current size of the figure by a factor <code>sizefactor</code>:</p>\n<pre><code class=\"python\">import matplotlib.pyplot as plt\n\n# Here goes your code\n\nfig_size = plt.gcf().get_size_inches() # Get current size\nsizefactor = 0.8 # Set a zoom factor\n# Modify the current size by the factor\nplt.gcf().set_size_inches(sizefactor * fig_size) \n</code></pre>\n<p>After changing the current size, it might occur that you have to fine tune the <em>subplot layout</em>. You can do that in the figure window GUI, or by means of the command <a href=\"https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.subplots_adjust.html\" rel=\"nofollow noreferrer\">subplots_adjust</a></p>\n<p>For example,</p>\n<pre><code class=\"python\">plt.subplots_adjust(left=0.16, bottom=0.19, top=0.82)\n</code></pre>\n", "abstract": "Generalizing and simplifying psihodelia's answer: If you want to change the current size of the figure by a factor sizefactor: After changing the current size, it might occur that you have to fine tune the subplot layout. You can do that in the figure window GUI, or by means of the command subplots_adjust For example,"}, {"id": 38750738, "score": 14, "vote": 0, "content": "<p>Since Matplotlib <a href=\"https://github.com/matplotlib/matplotlib/issues/1369\" rel=\"noreferrer\">isn't able</a> to use the metric system natively, if you want to specify the size of your figure in a reasonable unit of length such as centimeters, you can do the following (code from <a href=\"https://stackoverflow.com/a/22787457/395857\">gns-ank</a>):</p>\n<pre><code class=\"python\">def cm2inch(*tupl):\n    inch = 2.54\n    if isinstance(tupl[0], tuple):\n        return tuple(i/inch for i in tupl[0])\n    else:\n        return tuple(i/inch for i in tupl)\n</code></pre>\n<p>Then you can use:</p>\n<pre><code class=\"python\">plt.figure(figsize=cm2inch(21, 29.7))\n</code></pre>\n", "abstract": "Since Matplotlib isn't able to use the metric system natively, if you want to specify the size of your figure in a reasonable unit of length such as centimeters, you can do the following (code from gns-ank): Then you can use:"}, {"id": 66315574, "score": 14, "vote": 0, "content": "<p>Use this:</p>\n<pre><code class=\"python\">plt.figure(figsize=(width,height))\n</code></pre>\n<p>The <code>width</code> and <code>height</code> are in inches.\nIf not provided, it defaults to <code>rcParams[\"figure.figsize\"] = [6.4, 4.8]</code>. See more <a href=\"https://matplotlib.org/3.1.0/api/_as_gen/matplotlib.pyplot.figure.html\" rel=\"noreferrer\">here</a>.</p>\n", "abstract": "Use this: The width and height are in inches.\nIf not provided, it defaults to rcParams[\"figure.figsize\"] = [6.4, 4.8]. See more here."}, {"id": 26601247, "score": 12, "vote": 0, "content": "<p>This resizes the figure immediately even after the figure has been drawn (at least using Qt4Agg/TkAgg - but not Mac\u00a0OS\u00a0X - with Matplotlib 1.4.0):</p>\n<pre><code class=\"python\">matplotlib.pyplot.get_current_fig_manager().resize(width_px, height_px)\n</code></pre>\n", "abstract": "This resizes the figure immediately even after the figure has been drawn (at least using Qt4Agg/TkAgg - but not Mac\u00a0OS\u00a0X - with Matplotlib 1.4.0):"}, {"id": 56333222, "score": 9, "vote": 0, "content": "<p>Another option is to use the rc() function in Matplotlib (the unit is inch):</p>\n<pre><code class=\"python\">import matplotlib\nmatplotlib.rc('figure', figsize=[10,5])\n</code></pre>\n", "abstract": "Another option is to use the rc() function in Matplotlib (the unit is inch):"}, {"id": 68002660, "score": 9, "vote": 0, "content": "<p>This is How  I printed my Custom Graph with Custom Size</p>\n<pre><code class=\"python\">import matplotlib.pyplot as plt\nfrom matplotlib.pyplot import figure\n\nfigure(figsize=(16, 8), dpi=80)\nplt.plot(x_test, color = 'red', label = 'Predicted Price')\nplt.plot(y_test, color = 'blue', label = 'Actual Price')\nplt.title('Dollar to PKR Prediction')\nplt.xlabel('Predicted Price')\nplt.ylabel('Actual Dollar Price')\nplt.legend()\nplt.show()\n           \n</code></pre>\n", "abstract": "This is How  I printed my Custom Graph with Custom Size"}, {"id": 67180265, "score": 7, "vote": 0, "content": "<p>When <strong>creating a new figure</strong>, you can specify the size (in inches) with the <a href=\"https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.figure.html\" rel=\"noreferrer\"><code>figsize</code></a> argument:</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import matplotlib.pyplot as plt\nfig = plt.figure(figsize=(w,h))\n</code></pre>\n</blockquote>\n<p>If you want to <strong>modify an existing figure</strong>, use the <a href=\"https://matplotlib.org/stable/api/figure_api.html#matplotlib.figure.Figure.set_size_inches\" rel=\"noreferrer\"><code>set_size_inches()</code></a> method:</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">fig.set_size_inches(w,h)\n</code></pre>\n</blockquote>\n<p>If you want to <strong>change the default</strong> figure size (6.4\" x 4.8\"), use <a href=\"https://stackoverflow.com/questions/37728087/what-does-rc-in-matplotlibs-rcparams-stand-for#comment93050965_37728087\">\"run commands\"</a> <a href=\"https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.rc.html\" rel=\"noreferrer\"><code>rc</code></a>:</p>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">plt.rc('figure', figsize=(w,h))\n</code></pre>\n</blockquote>\n", "abstract": "When creating a new figure, you can specify the size (in inches) with the figsize argument: If you want to modify an existing figure, use the set_size_inches() method: If you want to change the default figure size (6.4\" x 4.8\"), use \"run commands\" rc:"}, {"id": 71933465, "score": 6, "vote": 0, "content": "<p>You could also try to initialize this:</p>\n<pre><code class=\"python\">import matplotlib as mpl\nimport matplotlib.pyplot as plt\nmpl.rcParams['figure.figsize'] = (8, 6)\nmpl.rcParams['axes.grid'] = False\n</code></pre>\n", "abstract": "You could also try to initialize this:"}, {"id": 70539176, "score": 5, "vote": 0, "content": "<pre><code class=\"python\">import random\nimport math\nimport matplotlib.pyplot as plt\nstart=-20\nend=20\nx=[v for v in range(start,end)]\n#sigmoid function\ndef sigmoid(x):\n    return 1/(1+math.exp(x))\nplt.figure(figsize=(8,5))#setting the figure size\nplt.scatter([abs(v) for v in x],[sigmoid(v) for v in x])\nplt.scatter(x,[sigmoid(sigmoid(v)) for v in x])\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/3ONu6.png\" rel=\"noreferrer\"><img alt=\"sigmoid image\" src=\"https://i.stack.imgur.com/3ONu6.png\"/></a></p>\n", "abstract": ""}, {"id": 69768472, "score": 3, "vote": 0, "content": "<p>Here is an example from my own.</p>\n<p>Below I've given you your answer, and I've expanded for you to experiment with.</p>\n<p>Also note fig size values are measured in <em><strong>inches</strong></em></p>\n<pre><code class=\"python\">import matplotlib.pyplot as plt\n\ndata = [2,5,8,10,15] # Random data, can use existing data frame column\n\nfig, axs = plt.subplots(figsize = (20,6)) # This is your answer to resize the figure\n\n# The below will help you expand on your question and resize individual elements within your figure. Experiement with the below parameters.\naxs.set_title(\"Data\", fontsize = 17.5)\naxs.tick_params(axis = 'x', labelsize = 14)\naxs.set_xlabel('X Label Here', size = 15)\naxs.tick_params(axis = 'y', labelsize =14)\naxs.set_ylabel('Y Label Here', size = 15)\n\nplt.plot(data)\n</code></pre>\n<p>Output:\n<a href=\"https://i.stack.imgur.com/1qXSP.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/1qXSP.png\"/></a></p>\n", "abstract": "Here is an example from my own. Below I've given you your answer, and I've expanded for you to experiment with. Also note fig size values are measured in inches Output:\n"}, {"id": 64490245, "score": 1, "vote": 0, "content": "<p>I always use the following pattern:</p>\n<pre><code class=\"python\">x_inches = 150*(1/25.4)     # [mm]*constant\ny_inches = x_inches*(0.8)\ndpi = 96\n\nfig = plt.figure(1, figsize = (x_inches,y_inches), dpi = dpi, constrained_layout = True)\n</code></pre>\n<p>With this example you are able to set figure dimensions in inches or in millimetres. When setting <code>constrained_layout</code> to <code>True</code>, plots fill your figure without borders.</p>\n", "abstract": "I always use the following pattern: With this example you are able to set figure dimensions in inches or in millimetres. When setting constrained_layout to True, plots fill your figure without borders."}]}, {"link": "https://stackoverflow.com/questions/2052390/manually-raising-throwing-an-exception-in-python", "question": {"id": "2052390", "title": "Manually raising (throwing) an exception in Python", "content": "<p>How do I raise an exception in Python so that it can later be caught via an <code>except</code> block?</p>\n", "abstract": "How do I raise an exception in Python so that it can later be caught via an except block?"}, "answers": [{"id": 24065533, "score": 3892, "vote": 0, "content": "<blockquote>\n<h2>How do I manually throw/raise an exception in Python?</h2>\n</blockquote>\n<p><a href=\"https://docs.python.org/3/library/exceptions.html#exception-hierarchy\" rel=\"noreferrer\">Use the most specific Exception constructor that semantically fits your issue</a>.</p>\n<p>Be specific in your message, e.g.:</p>\n<pre><code class=\"python\">raise ValueError('A very specific bad thing happened.')\n</code></pre>\n<h2>Don't raise generic exceptions</h2>\n<p>Avoid raising a generic <code>Exception</code>. To catch it, you'll have to catch all other more specific exceptions that subclass it.</p>\n<h3>Problem 1: Hiding bugs</h3>\n<pre><code class=\"python\">raise Exception('I know Python!') # Don't! If you catch, likely to hide bugs.\n</code></pre>\n<p>For example:</p>\n<pre><code class=\"python\">def demo_bad_catch():\n    try:\n        raise ValueError('Represents a hidden bug, do not catch this')\n        raise Exception('This is the exception you expect to handle')\n    except Exception as error:\n        print('Caught this error: ' + repr(error))\n\n&gt;&gt;&gt; demo_bad_catch()\nCaught this error: ValueError('Represents a hidden bug, do not catch this',)\n</code></pre>\n<h3>Problem 2: Won't catch</h3>\n<p>And more specific catches won't catch the general exception:</p>\n<pre><code class=\"python\">def demo_no_catch():\n    try:\n        raise Exception('general exceptions not caught by specific handling')\n    except ValueError as e:\n        print('we will not catch exception: Exception')\n \n\n&gt;&gt;&gt; demo_no_catch()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 3, in demo_no_catch\nException: general exceptions not caught by specific handling\n</code></pre>\n<h2>Best Practices: <code>raise</code> statement</h2>\n<p><a href=\"https://docs.python.org/3/library/exceptions.html#exception-hierarchy\" rel=\"noreferrer\">Instead, use the most specific Exception constructor that semantically fits your issue</a>.</p>\n<pre><code class=\"python\">raise ValueError('A very specific bad thing happened')\n</code></pre>\n<p>which also handily allows an arbitrary number of arguments to be passed to the constructor:</p>\n<pre><code class=\"python\">raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz') \n</code></pre>\n<p>These arguments are accessed by the <code>args</code> attribute on the <code>Exception</code> object. For example:</p>\n<pre><code class=\"python\">try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    print(err.args)\n</code></pre>\n<p>prints</p>\n<pre><code class=\"python\">('message', 'foo', 'bar', 'baz')    \n</code></pre>\n<p>In Python 2.5, an actual <code>message</code> attribute was added to <code>BaseException</code> in favor of encouraging users to subclass Exceptions and stop using <code>args</code>, but <a href=\"http://www.python.org/dev/peps/pep-0352/#retracted-ideas\" rel=\"noreferrer\">the introduction of <code>message</code> and the original deprecation of args has been retracted</a>.</p>\n<h2>Best Practices: <code>except</code> clause</h2>\n<p>When inside an except clause, you might want to, for example, log that a specific type of error happened, and then re-raise. The best way to do this while preserving the stack trace is to use a bare raise statement. For example:</p>\n<pre><code class=\"python\">logger = logging.getLogger(__name__)\n\ntry:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)\n    raise                 # just this!\n    # raise AppError      # Don't do this, you'll lose the stack trace!\n</code></pre>\n<h3>Don't modify your errors... but if you insist.</h3>\n<p>You can preserve the stacktrace (and error value) with <code>sys.exc_info()</code>, but <strong>this is way more error prone</strong> and <strong>has compatibility problems between Python 2 and 3</strong>, prefer to use a bare <code>raise</code> to re-raise.</p>\n<p>To explain - the <code>sys.exc_info()</code> returns the type, value, and traceback.</p>\n<pre><code class=\"python\">type, value, traceback = sys.exc_info()\n</code></pre>\n<p>This is the syntax in Python 2 - note this is not compatible with Python 3:</p>\n<pre><code class=\"python\">raise AppError, error, sys.exc_info()[2] # avoid this.\n# Equivalently, as error *is* the second object:\nraise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]\n</code></pre>\n<p>If you want to, you can modify what happens with your new raise - e.g. setting new <code>args</code> for the instance:</p>\n<pre><code class=\"python\">def error():\n    raise ValueError('oops!')\n\ndef catch_error_modify_message():\n    try:\n        error()\n    except ValueError:\n        error_type, error_instance, traceback = sys.exc_info()\n        error_instance.args = (error_instance.args[0] + ' &lt;modification&gt;',)\n        raise error_type, error_instance, traceback\n</code></pre>\n<p>And we have preserved the whole traceback while modifying the args. Note that this is <strong>not a best practice</strong> and it is <strong>invalid syntax</strong> in Python 3 (making keeping compatibility much harder to work around).</p>\n<pre><code class=\"python\">&gt;&gt;&gt; catch_error_modify_message()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 3, in catch_error_modify_message\n  File \"&lt;stdin&gt;\", line 2, in error\nValueError: oops! &lt;modification&gt;\n</code></pre>\n<p>In <a href=\"https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement\" rel=\"noreferrer\">Python 3</a>:</p>\n<pre><code class=\"python\">raise error.with_traceback(sys.exc_info()[2])\n</code></pre>\n<p>Again: avoid manually manipulating tracebacks. It's <a href=\"https://docs.python.org/2/reference/simple_stmts.html#the-raise-statement\" rel=\"noreferrer\">less efficient</a> and more error prone. And if you're using threading and <code>sys.exc_info</code> you may even get the wrong traceback (especially if you're using exception handling for control flow - which I'd personally tend to avoid.)</p>\n<h3>Python 3, Exception chaining</h3>\n<p>In Python 3, you can chain Exceptions, which preserve tracebacks:</p>\n<pre><code class=\"python\">raise RuntimeError('specific message') from error\n</code></pre>\n<p>Be aware:</p>\n<ul>\n<li>this <em>does</em> allow changing the error type raised, and</li>\n<li>this is <em>not</em> compatible with Python 2.</li>\n</ul>\n<h3>Deprecated Methods:</h3>\n<p>These can easily hide and even get into production code. You want to raise an exception, and doing them will raise an exception, <strong>but not the one intended!</strong></p>\n<p><a href=\"http://www.python.org/dev/peps/pep-3109/\" rel=\"noreferrer\">Valid in Python 2, but not in Python 3</a> is the following:</p>\n<pre><code class=\"python\">raise ValueError, 'message' # Don't do this, it's deprecated!\n</code></pre>\n<p>Only <a href=\"https://docs.python.org/2/whatsnew/2.5.html#pep-352-exceptions-as-new-style-classes\" rel=\"noreferrer\">valid in much older versions of Python</a> (2.4 and lower), you may still see people raising strings:</p>\n<pre><code class=\"python\">raise 'message' # really really wrong. don't do this.\n</code></pre>\n<p>In all modern versions, this will actually raise a <code>TypeError</code>, because you're not raising a <code>BaseException</code> type. If you're not checking for the right exception and don't have a reviewer that's aware of the issue, it could get into production.</p>\n<h2>Example Usage</h2>\n<p>I raise Exceptions to warn consumers of my API if they're using it incorrectly:</p>\n<pre><code class=\"python\">def api_func(foo):\n    '''foo should be either 'baz' or 'bar'. returns something very useful.'''\n    if foo not in _ALLOWED_ARGS:\n        raise ValueError('{foo} wrong, use \"baz\" or \"bar\"'.format(foo=repr(foo)))\n</code></pre>\n<h2>Create your own error types when apropos</h2>\n<blockquote>\n<p><strong>\"I want to make an error on purpose, so that it would go into the except\"</strong></p>\n</blockquote>\n<p>You can create your own error types, if you want to indicate something specific is wrong with your application, just subclass the appropriate point in the exception hierarchy:</p>\n<pre><code class=\"python\">class MyAppLookupError(LookupError):\n    '''raise this when there's a lookup error for my app'''\n</code></pre>\n<p>and usage:</p>\n<pre><code class=\"python\">if important_key not in resource_dict and not ok_to_be_missing:\n    raise MyAppLookupError('resource is missing, and that is not ok.')\n</code></pre>\n", "abstract": "Use the most specific Exception constructor that semantically fits your issue. Be specific in your message, e.g.: Avoid raising a generic Exception. To catch it, you'll have to catch all other more specific exceptions that subclass it. For example: And more specific catches won't catch the general exception: Instead, use the most specific Exception constructor that semantically fits your issue. which also handily allows an arbitrary number of arguments to be passed to the constructor: These arguments are accessed by the args attribute on the Exception object. For example: prints In Python 2.5, an actual message attribute was added to BaseException in favor of encouraging users to subclass Exceptions and stop using args, but the introduction of message and the original deprecation of args has been retracted. When inside an except clause, you might want to, for example, log that a specific type of error happened, and then re-raise. The best way to do this while preserving the stack trace is to use a bare raise statement. For example: You can preserve the stacktrace (and error value) with sys.exc_info(), but this is way more error prone and has compatibility problems between Python 2 and 3, prefer to use a bare raise to re-raise. To explain - the sys.exc_info() returns the type, value, and traceback. This is the syntax in Python 2 - note this is not compatible with Python 3: If you want to, you can modify what happens with your new raise - e.g. setting new args for the instance: And we have preserved the whole traceback while modifying the args. Note that this is not a best practice and it is invalid syntax in Python 3 (making keeping compatibility much harder to work around). In Python 3: Again: avoid manually manipulating tracebacks. It's less efficient and more error prone. And if you're using threading and sys.exc_info you may even get the wrong traceback (especially if you're using exception handling for control flow - which I'd personally tend to avoid.) In Python 3, you can chain Exceptions, which preserve tracebacks: Be aware: These can easily hide and even get into production code. You want to raise an exception, and doing them will raise an exception, but not the one intended! Valid in Python 2, but not in Python 3 is the following: Only valid in much older versions of Python (2.4 and lower), you may still see people raising strings: In all modern versions, this will actually raise a TypeError, because you're not raising a BaseException type. If you're not checking for the right exception and don't have a reviewer that's aware of the issue, it could get into production. I raise Exceptions to warn consumers of my API if they're using it incorrectly: \"I want to make an error on purpose, so that it would go into the except\" You can create your own error types, if you want to indicate something specific is wrong with your application, just subclass the appropriate point in the exception hierarchy: and usage:"}, {"id": 2052396, "score": 567, "vote": 0, "content": "<blockquote>\n<p><em><strong>Don't do this</strong></em>. Raising a bare <code>Exception</code> is absolutely <strong>not</strong> the right thing to do; see <a href=\"https://stackoverflow.com/a/24065533\">Aaron Hall's excellent answer</a> instead.</p>\n</blockquote>\n<p>It can't get much more Pythonic than this:</p>\n<pre><code class=\"python\">raise Exception(\"I know Python!\")\n</code></pre>\n<p>Replace <code>Exception</code> with the specific type of exception you want to throw.</p>\n<p>See <a href=\"http://docs.python.org/reference/simple_stmts.html#the-raise-statement\" rel=\"noreferrer\">the raise statement documentation</a> for Python if you'd like more information.</p>\n", "abstract": "Don't do this. Raising a bare Exception is absolutely not the right thing to do; see Aaron Hall's excellent answer instead. It can't get much more Pythonic than this: Replace Exception with the specific type of exception you want to throw. See the raise statement documentation for Python if you'd like more information."}, {"id": 40493467, "score": 83, "vote": 0, "content": "<p>In Python 3 there are four different syntaxes for raising exceptions:</p>\n<ol>\n<li>raise exception</li>\n<li>raise exception (args)</li>\n<li>raise</li>\n<li>raise exception (args) from original_exception</li>\n</ol>\n<h3>1. Raise exception vs. 2. raise exception (args)</h3>\n<p>If you use <code>raise exception (args)</code> to raise an exception then the <code>args</code> will be printed when you print the exception object - as shown in the example below.</p>\n<pre><code class=\"python\">  # Raise exception (args)\n    try:\n        raise ValueError(\"I have raised an Exception\")\n    except ValueError as exp:\n          print (\"Error\", exp)     # Output -&gt; Error I have raised an Exception\n\n\n  # Raise exception\n    try:\n        raise ValueError\n    except ValueError as exp:\n          print (\"Error\", exp)     # Output -&gt; Error\n</code></pre>\n<h3>3. Statement <em>raise</em></h3>\n<p>The <code>raise</code> statement without any arguments re-raises the last exception.</p>\n<p>This is useful if you need to perform some actions after catching the exception and then want to re-raise it. But if there wasn't any exception before, the <code>raise</code> statement raises  a <code>TypeError</code> Exception.</p>\n<pre><code class=\"python\">def somefunction():\n    print(\"some cleaning\")\n\na=10\nb=0\nresult=None\n\ntry:\n    result=a/b\n    print(result)\n\nexcept Exception:            # Output -&gt;\n    somefunction()           # Some cleaning\n    raise                    # Traceback (most recent call last):\n                             # File \"python\", line 8, in &lt;module&gt;\n                             # ZeroDivisionError: division by zero\n</code></pre>\n<h3>4. Raise exception (args) from original_exception</h3>\n<p>This statement is used to create exception chaining in which an exception that is raised in response to another exception can contain the details of the original exception - as shown in the example below.</p>\n<pre><code class=\"python\">class MyCustomException(Exception):\npass\n\na=10\nb=0\nreuslt=None\ntry:\n    try:\n        result=a/b\n\n    except ZeroDivisionError as exp:\n        print(\"ZeroDivisionError -- \",exp)\n        raise MyCustomException(\"Zero Division \") from exp\n\nexcept MyCustomException as exp:\n        print(\"MyException\",exp)\n        print(exp.__cause__)\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"python\">ZeroDivisionError --  division by zero\nMyException Zero Division\ndivision by zero\n</code></pre>\n", "abstract": "In Python 3 there are four different syntaxes for raising exceptions: If you use raise exception (args) to raise an exception then the args will be printed when you print the exception object - as shown in the example below. The raise statement without any arguments re-raises the last exception. This is useful if you need to perform some actions after catching the exception and then want to re-raise it. But if there wasn't any exception before, the raise statement raises  a TypeError Exception. This statement is used to create exception chaining in which an exception that is raised in response to another exception can contain the details of the original exception - as shown in the example below. Output:"}, {"id": 30317038, "score": 42, "vote": 0, "content": "<p>For the common case where you need to throw an exception in response to some unexpected conditions, and that you never intend to catch, but simply to fail fast to enable you to debug from there if it ever happens \u2014 the most logical one seems to be <code>AssertionError</code>:</p>\n<pre><code class=\"python\">if 0 &lt; distance &lt;= RADIUS:\n    #Do something.\nelif RADIUS &lt; distance:\n    #Do something.\nelse:\n    raise AssertionError(\"Unexpected value of 'distance'!\", distance)\n</code></pre>\n", "abstract": "For the common case where you need to throw an exception in response to some unexpected conditions, and that you never intend to catch, but simply to fail fast to enable you to debug from there if it ever happens \u2014 the most logical one seems to be AssertionError:"}, {"id": 43092920, "score": 20, "vote": 0, "content": "<p><em>Read the existing answers first, this is just an addendum.</em></p>\n<p>Notice that you can raise exceptions with or without arguments.</p>\n<p>Example:</p>\n<pre><code class=\"python\">raise SystemExit\n</code></pre>\n<p>exits the program, but you might want to know what happened. So you can use this.</p>\n<pre><code class=\"python\">raise SystemExit(\"program exited\")\n</code></pre>\n<p>This will print \"program exited\" to standard error before closing the program.</p>\n", "abstract": "Read the existing answers first, this is just an addendum. Notice that you can raise exceptions with or without arguments. Example: exits the program, but you might want to know what happened. So you can use this. This will print \"program exited\" to standard error before closing the program."}, {"id": 53597619, "score": 5, "vote": 0, "content": "<p>Just to note: there are times when you <em>do</em> want to handle generic exceptions. If you're processing a bunch of files and logging your errors, you might want to catch any error that occurs for a file, log it, and continue processing the rest of the files. In that case, a</p>\n<pre><code class=\"python\">try:\n    foo()\nexcept Exception as e:\n    print(e) # Print out handled error\n</code></pre>\n<p>block is a good way to do it. You'll still want to <code>raise</code> specific exceptions so you know what they mean, though.</p>\n", "abstract": "Just to note: there are times when you do want to handle generic exceptions. If you're processing a bunch of files and logging your errors, you might want to catch any error that occurs for a file, log it, and continue processing the rest of the files. In that case, a block is a good way to do it. You'll still want to raise specific exceptions so you know what they mean, though."}, {"id": 54902334, "score": 4, "vote": 0, "content": "<p>Another way to throw an exception is using <a href=\"https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement\" rel=\"nofollow noreferrer\"><code>assert</code></a>. You can use <em>assert</em> to verify a condition is being fulfilled. If not, then it will raise <code>AssertionError</code>. For more details have a look <a href=\"https://www.programiz.com/python-programming/assert-statement\" rel=\"nofollow noreferrer\">here</a>.</p>\n<pre><code class=\"python\">def avg(marks):\n    assert len(marks) != 0, \"List is empty.\"\n    return sum(marks)/len(marks)\n\nmark2 = [55,88,78,90,79]\nprint(\"Average of mark2:\", avg(mark2))\n\nmark1 = []\nprint(\"Average of mark1:\", avg(mark1))\n</code></pre>\n", "abstract": "Another way to throw an exception is using assert. You can use assert to verify a condition is being fulfilled. If not, then it will raise AssertionError. For more details have a look here."}, {"id": 60946432, "score": 2, "vote": 0, "content": "<p>You should learn the <em>raise</em> statement of Python for that.</p>\n<p>It should be kept inside the try block.</p>\n<p>Example -</p>\n<pre><code class=\"python\">try:\n    raise TypeError            # Replace TypeError by any other error if you want\nexcept TypeError:\n    print('TypeError raised')\n</code></pre>\n", "abstract": "You should learn the raise statement of Python for that. It should be kept inside the try block. Example -"}, {"id": 67890877, "score": 2, "vote": 0, "content": "<p>You might also want to raise <strong>custom exceptions</strong>. For example, if you're writing a library, it's a very good practice to make a base exception class for your module, and then have custom sub-exceptions to be more specific.</p>\n<p>You can achieve that like this:</p>\n<pre><code class=\"python\">class MyModuleBaseClass(Exception):\n    pass\n\nclass MoreSpecificException(MyModuleBaseClass):\n    pass\n\n\n# To raise custom exceptions, you can just\n# use the raise keyword\nraise MoreSpecificException\nraise MoreSpecificException('message')\n</code></pre>\n<p>If you're not interested in having a custom base class, you can just inherit your custom exception classes from an ordinary exception class like <code>Exception</code>, <code>TypeError</code>, <code>ValueError</code>, etc.</p>\n", "abstract": "You might also want to raise custom exceptions. For example, if you're writing a library, it's a very good practice to make a base exception class for your module, and then have custom sub-exceptions to be more specific. You can achieve that like this: If you're not interested in having a custom base class, you can just inherit your custom exception classes from an ordinary exception class like Exception, TypeError, ValueError, etc."}, {"id": 69147909, "score": 1, "vote": 0, "content": "<p>If you don't care about <em>which</em> error to raise, you could use <code>assert</code> to raise an <code>AssertionError</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; assert False, \"Manually raised error\"\nTraceback (most recent call last):\n  File \"&lt;pyshell#24&gt;\", line 1, in &lt;module&gt;\n    assert False, \"Manually raised error\"\nAssertionError: Manually raised error\n&gt;&gt;&gt; \n</code></pre>\n<p>The <code>assert</code> keyword raises an <code>AssertionError</code> if the condition is <code>False</code>. In this case, we specified <code>False</code> directly, so it raises the error, but to have it have a text we want it to raise to, we add a comma and specify the error text we want. In this case, I wrote <code>Manually raised error</code> and this raises it with that text.</p>\n", "abstract": "If you don't care about which error to raise, you could use assert to raise an AssertionError: The assert keyword raises an AssertionError if the condition is False. In this case, we specified False directly, so it raises the error, but to have it have a text we want it to raise to, we add a comma and specify the error text we want. In this case, I wrote Manually raised error and this raises it with that text."}, {"id": 70278544, "score": -4, "vote": 0, "content": "<p>If you don\u2019t care about the raised exception, do:</p>\n<pre><code class=\"python\">def crash(): return 0/0\n</code></pre>\n<p>The good old division by 0.</p>\n", "abstract": "If you don\u2019t care about the raised exception, do: The good old division by 0."}]}, {"link": "https://stackoverflow.com/questions/312443/how-do-i-split-a-list-into-equally-sized-chunks", "question": {"id": "312443", "title": "How do I split a list into equally-sized chunks?", "content": "<p>How do I split a list of arbitrary length into equal sized chunks?</p>\n<hr/>\n<p><sub>See <a href=\"https://stackoverflow.com/q/434287\">How to iterate over a list in chunks</a> if the data result will be used directly for a loop, and does not need to be stored.</sub></p>\n<p><sub>For the same question with a string input, see <a href=\"https://stackoverflow.com/questions/9475241\">Split string every nth character?</a>. The same techniques generally apply, though there are some variations.</sub></p>\n", "abstract": "How do I split a list of arbitrary length into equal sized chunks? See How to iterate over a list in chunks if the data result will be used directly for a loop, and does not need to be stored. For the same question with a string input, see Split string every nth character?. The same techniques generally apply, though there are some variations."}, "answers": [{"id": 312464, "score": 4173, "vote": 0, "content": "<p>Here's a generator that yields evenly-sized chunks:</p>\n<pre><code class=\"python\">def chunks(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in range(0, len(lst), n):\n        yield lst[i:i + n]\n</code></pre>\n<pre><code class=\"python\">import pprint\npprint.pprint(list(chunks(range(10, 75), 10)))\n[[10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\n [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],\n [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\n [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],\n [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],\n [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n [70, 71, 72, 73, 74]]\n</code></pre>\n<p>For Python 2, using <code>xrange</code> instead of <code>range</code>:</p>\n<pre><code class=\"python\">def chunks(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in xrange(0, len(lst), n):\n        yield lst[i:i + n]\n</code></pre>\n<hr/>\n<p>Below is a list comprehension one-liner. The method above is preferable, though, since using named functions makes code easier to understand. For Python 3:</p>\n<pre><code class=\"python\">[lst[i:i + n] for i in range(0, len(lst), n)]\n</code></pre>\n<p>For Python 2:</p>\n<pre><code class=\"python\">[lst[i:i + n] for i in xrange(0, len(lst), n)]\n</code></pre>\n", "abstract": "Here's a generator that yields evenly-sized chunks: For Python 2, using xrange instead of range: Below is a list comprehension one-liner. The method above is preferable, though, since using named functions makes code easier to understand. For Python 3: For Python 2:"}, {"id": 1751478, "score": 643, "vote": 0, "content": "<p>Something super simple:</p>\n<pre><code class=\"python\">def chunks(xs, n):\n    n = max(1, n)\n    return (xs[i:i+n] for i in range(0, len(xs), n))\n</code></pre>\n<p>For Python 2, use <code>xrange()</code> instead of <code>range()</code>.</p>\n", "abstract": "Something super simple: For Python 2, use xrange() instead of range()."}, {"id": 16935535, "score": 383, "vote": 0, "content": "<p>I know this is kind of old but nobody yet mentioned <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.array_split.html\" rel=\"noreferrer\"><code>numpy.array_split</code></a>:</p>\n<pre><code class=\"python\">import numpy as np\n\nlst = range(50)\nnp.array_split(lst, 5)\n</code></pre>\n<p>Result:</p>\n<pre><code class=\"python\">[array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),\n array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19]),\n array([20, 21, 22, 23, 24, 25, 26, 27, 28, 29]),\n array([30, 31, 32, 33, 34, 35, 36, 37, 38, 39]),\n array([40, 41, 42, 43, 44, 45, 46, 47, 48, 49])]\n</code></pre>\n", "abstract": "I know this is kind of old but nobody yet mentioned numpy.array_split: Result:"}, {"id": 312644, "score": 340, "vote": 0, "content": "<p>Directly from the (old) Python documentation (recipes for itertools):</p>\n<pre><code class=\"python\">from itertools import izip, chain, repeat\n\ndef grouper(n, iterable, padvalue=None):\n    \"grouper(3, 'abcdefg', 'x') --&gt; ('a','b','c'), ('d','e','f'), ('g','x','x')\"\n    return izip(*[chain(iterable, repeat(padvalue, n-1))]*n)\n</code></pre>\n<p>The current version, as suggested by J.F.Sebastian:</p>\n<pre><code class=\"python\">#from itertools import izip_longest as zip_longest # for Python 2.x\nfrom itertools import zip_longest # for Python 3.x\n#from six.moves import zip_longest # for both (uses the six compat library)\n\ndef grouper(n, iterable, padvalue=None):\n    \"grouper(3, 'abcdefg', 'x') --&gt; ('a','b','c'), ('d','e','f'), ('g','x','x')\"\n    return zip_longest(*[iter(iterable)]*n, fillvalue=padvalue)\n</code></pre>\n<p>I guess Guido's time machine works\u2014worked\u2014will work\u2014will have worked\u2014was working again.</p>\n<p>These solutions work because <code>[iter(iterable)]*n</code> (or the equivalent in the earlier version) creates <em>one</em> iterator, repeated <code>n</code> times in the list. <code>izip_longest</code> then effectively performs a round-robin of \"each\" iterator; because this is the same iterator, it is advanced by each such call, resulting in each such zip-roundrobin generating one tuple of <code>n</code> items.</p>\n", "abstract": "Directly from the (old) Python documentation (recipes for itertools): The current version, as suggested by J.F.Sebastian: I guess Guido's time machine works\u2014worked\u2014will work\u2014will have worked\u2014was working again. These solutions work because [iter(iterable)]*n (or the equivalent in the earlier version) creates one iterator, repeated n times in the list. izip_longest then effectively performs a round-robin of \"each\" iterator; because this is the same iterator, it is advanced by each such call, resulting in each such zip-roundrobin generating one tuple of n items."}, {"id": 22045226, "score": 279, "vote": 0, "content": "<p>I'm surprised nobody has thought of using <code>iter</code>'s <a href=\"http://docs.python.org/2/library/functions.html#iter\" rel=\"noreferrer\">two-argument form</a>:</p>\n<pre><code class=\"python\">from itertools import islice\n\ndef chunk(it, size):\n    it = iter(it)\n    return iter(lambda: tuple(islice(it, size)), ())\n</code></pre>\n<p>Demo:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(chunk(range(14), 3))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13)]\n</code></pre>\n<p>This works with any iterable and produces output lazily. It returns tuples rather than iterators, but I think it has a certain elegance nonetheless. It also doesn't pad; if you want padding, a simple variation on the above will suffice:</p>\n<pre><code class=\"python\">from itertools import islice, chain, repeat\n\ndef chunk_pad(it, size, padval=None):\n    it = chain(iter(it), repeat(padval))\n    return iter(lambda: tuple(islice(it, size)), (padval,) * size)\n</code></pre>\n<p>Demo:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(chunk_pad(range(14), 3))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13, None)]\n&gt;&gt;&gt; list(chunk_pad(range(14), 3, 'a'))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13, 'a')]\n</code></pre>\n<p>Like the <code>izip_longest</code>-based solutions, the above <em>always</em> pads. As far as I know, there's no one- or two-line itertools recipe for a function that <em>optionally</em> pads. By combining the above two approaches, this one comes pretty close:</p>\n<pre><code class=\"python\">_no_padding = object()\n\ndef chunk(it, size, padval=_no_padding):\n    if padval == _no_padding:\n        it = iter(it)\n        sentinel = ()\n    else:\n        it = chain(iter(it), repeat(padval))\n        sentinel = (padval,) * size\n    return iter(lambda: tuple(islice(it, size)), sentinel)\n</code></pre>\n<p>Demo:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(chunk(range(14), 3))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13)]\n&gt;&gt;&gt; list(chunk(range(14), 3, None))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13, None)]\n&gt;&gt;&gt; list(chunk(range(14), 3, 'a'))\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11), (12, 13, 'a')]\n</code></pre>\n<p>I believe this is the shortest chunker proposed that offers optional padding.</p>\n<p>As Tomasz Gandor <a href=\"https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/22045226?noredirect=1#comment93566337_22045226\">observed</a>, the two padding chunkers will stop unexpectedly if they encounter a long sequence of pad values. Here's a final variation that works around that problem in a reasonable way:</p>\n<pre><code class=\"python\">_no_padding = object()\ndef chunk(it, size, padval=_no_padding):\n    it = iter(it)\n    chunker = iter(lambda: tuple(islice(it, size)), ())\n    if padval == _no_padding:\n        yield from chunker\n    else:\n        for ch in chunker:\n            yield ch if len(ch) == size else ch + (padval,) * (size - len(ch))\n</code></pre>\n<p>Demo:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; list(chunk([1, 2, (), (), 5], 2))\n[(1, 2), ((), ()), (5,)]\n&gt;&gt;&gt; list(chunk([1, 2, None, None, 5], 2, None))\n[(1, 2), (None, None), (5, None)]\n</code></pre>\n", "abstract": "I'm surprised nobody has thought of using iter's two-argument form: Demo: This works with any iterable and produces output lazily. It returns tuples rather than iterators, but I think it has a certain elegance nonetheless. It also doesn't pad; if you want padding, a simple variation on the above will suffice: Demo: Like the izip_longest-based solutions, the above always pads. As far as I know, there's no one- or two-line itertools recipe for a function that optionally pads. By combining the above two approaches, this one comes pretty close: Demo: I believe this is the shortest chunker proposed that offers optional padding. As Tomasz Gandor observed, the two padding chunkers will stop unexpectedly if they encounter a long sequence of pad values. Here's a final variation that works around that problem in a reasonable way: Demo:"}, {"id": 312467, "score": 118, "vote": 0, "content": "<p>Here is a generator that work on arbitrary iterables:</p>\n<pre><code class=\"python\">def split_seq(iterable, size):\n    it = iter(iterable)\n    item = list(itertools.islice(it, size))\n    while item:\n        yield item\n        item = list(itertools.islice(it, size))\n</code></pre>\n<p>Example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; pprint.pprint(list(split_seq(xrange(75), 10)))\n[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\n [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],\n [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\n [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],\n [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],\n [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n [70, 71, 72, 73, 74]]\n</code></pre>\n", "abstract": "Here is a generator that work on arbitrary iterables: Example:"}, {"id": 3226719, "score": 82, "vote": 0, "content": "<p>Simple yet elegant</p>\n<pre><code class=\"python\">L = range(1, 1000)\nprint [L[x:x+10] for x in xrange(0, len(L), 10)]\n</code></pre>\n<p>or if you prefer:</p>\n<pre><code class=\"python\">def chunks(L, n): return [L[x: x+n] for x in xrange(0, len(L), n)]\nchunks(L, 10)\n</code></pre>\n", "abstract": "Simple yet elegant or if you prefer:"}, {"id": 3125186, "score": 63, "vote": 0, "content": "<pre><code class=\"python\">def chunk(input, size):\n    return map(None, *([iter(input)] * size))\n</code></pre>\n", "abstract": ""}, {"id": 21767522, "score": 59, "vote": 0, "content": "<h2>How do you split a list into evenly sized chunks?</h2>\n<p>\"Evenly sized chunks\", to me, implies that they are all the same length, or barring that option, at <strong>minimal variance</strong> in length. E.g. 5 baskets for 21 items could have the following results:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import statistics\n&gt;&gt;&gt; statistics.variance([5,5,5,5,1]) \n3.2\n&gt;&gt;&gt; statistics.variance([5,4,4,4,4]) \n0.19999999999999998\n</code></pre>\n<p>A practical reason to prefer the latter result: if you were using these functions to distribute work, you've built-in the prospect of one likely finishing well before the others, so it would sit around doing nothing while the others continued working hard.</p>\n<h3>Critique of other answers here</h3>\n<p>When I originally wrote this answer, none of the other answers were evenly sized chunks - they all leave a runt chunk at the end, so they're not well balanced, and have a higher than necessary variance of lengths.</p>\n<p>For example, the current top answer ends with:</p>\n<pre><code class=\"python\">[60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n[70, 71, 72, 73, 74]]\n</code></pre>\n<p>Others, like <code>list(grouper(3, range(7)))</code>, and <code>chunk(range(7), 3)</code> both return: <code>[(0, 1, 2), (3, 4, 5), (6, None, None)]</code>. The <code>None</code>'s are just padding, and rather inelegant in my opinion. They are NOT evenly chunking the iterables.</p>\n<p>Why can't we divide these better?</p>\n<h3>Cycle Solution</h3>\n<p>A high-level balanced solution using <code>itertools.cycle</code>, which is the way I might do it today. Here's the setup:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from itertools import cycle\nitems = range(10, 75)\nnumber_of_baskets = 10\n</code></pre>\n<p>Now we need our lists into which to populate the elements:</p>\n<pre><code class=\"python\">baskets = [[] for _ in range(number_of_baskets)]\n</code></pre>\n<p>Finally, we zip the elements we're going to allocate together with a cycle of the baskets until we run out of elements, which, semantically, it exactly what we want:</p>\n<pre><code class=\"python\">for element, basket in zip(items, cycle(baskets)):\n    basket.append(element)\n</code></pre>\n<p>Here's the result:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; pprint(baskets)\n[[10, 20, 30, 40, 50, 60, 70],\n [11, 21, 31, 41, 51, 61, 71],\n [12, 22, 32, 42, 52, 62, 72],\n [13, 23, 33, 43, 53, 63, 73],\n [14, 24, 34, 44, 54, 64, 74],\n [15, 25, 35, 45, 55, 65],\n [16, 26, 36, 46, 56, 66],\n [17, 27, 37, 47, 57, 67],\n [18, 28, 38, 48, 58, 68],\n [19, 29, 39, 49, 59, 69]]\n</code></pre>\n<p>To productionize this solution, we write a function, and provide the type annotations:</p>\n<pre><code class=\"python\">from itertools import cycle\nfrom typing import List, Any\n\ndef cycle_baskets(items: List[Any], maxbaskets: int) -&gt; List[List[Any]]:\n    baskets = [[] for _ in range(min(maxbaskets, len(items)))]\n    for item, basket in zip(items, cycle(baskets)):\n        basket.append(item)\n    return baskets\n</code></pre>\n<p>In the above, we take our list of items, and the max number of baskets. We create a list of empty lists, in which to append each element, in a round-robin style.</p>\n<h3>Slices</h3>\n<p>Another elegant solution is to use slices - specifically the less-commonly used <strong>step</strong> argument to slices. i.e.:</p>\n<pre><code class=\"python\">start = 0\nstop = None\nstep = number_of_baskets\n\nfirst_basket = items[start:stop:step]\n</code></pre>\n<p>This is especially elegant in that slices don't care how long the data are - the result, our first basket, is only as long as it needs to be. We'll only need to increment the starting point for each basket.</p>\n<p>In fact this could be a one-liner, but we'll go multiline for readability and to avoid an overlong line of code:</p>\n<pre><code class=\"python\">from typing import List, Any\n\ndef slice_baskets(items: List[Any], maxbaskets: int) -&gt; List[List[Any]]:\n    n_baskets = min(maxbaskets, len(items))\n    return [items[i::n_baskets] for i in range(n_baskets)]\n</code></pre>\n<p>And <code>islice</code> from the itertools module will provide a lazily iterating approach, like that which was originally asked for in the question.</p>\n<p>I don't expect most use-cases to benefit very much, as the original data is already fully materialized in a list, but for large datasets, it could save nearly half the memory usage.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from itertools import islice\nfrom typing import List, Any, Generator\n    \ndef yield_islice_baskets(items: List[Any], maxbaskets: int) -&gt; Generator[List[Any], None, None]:\n    n_baskets = min(maxbaskets, len(items))\n    for i in range(n_baskets):\n        yield islice(items, i, None, n_baskets)\n</code></pre>\n<p>View results with:</p>\n<pre><code class=\"python\">from pprint import pprint\n\nitems = list(range(10, 75))\npprint(cycle_baskets(items, 10))\npprint(slice_baskets(items, 10))\npprint([list(s) for s in yield_islice_baskets(items, 10)])\n</code></pre>\n<h3>Updated prior solutions</h3>\n<p>Here's another balanced solution, adapted from a function I've used in production in the past, that uses the modulo operator:</p>\n<pre><code class=\"python\">def baskets_from(items, maxbaskets=25):\n    baskets = [[] for _ in range(maxbaskets)]\n    for i, item in enumerate(items):\n        baskets[i % maxbaskets].append(item)\n    return filter(None, baskets) \n</code></pre>\n<p>And I created a generator that does the same if you put it into a list:</p>\n<pre><code class=\"python\">def iter_baskets_from(items, maxbaskets=3):\n    '''generates evenly balanced baskets from indexable iterable'''\n    item_count = len(items)\n    baskets = min(item_count, maxbaskets)\n    for x_i in range(baskets):\n        yield [items[y_i] for y_i in range(x_i, item_count, baskets)]\n    \n</code></pre>\n<p>And finally, since I see that all of the above functions return elements in a contiguous order (as they were given):</p>\n<pre><code class=\"python\">def iter_baskets_contiguous(items, maxbaskets=3, item_count=None):\n    '''\n    generates balanced baskets from iterable, contiguous contents\n    provide item_count if providing a iterator that doesn't support len()\n    '''\n    item_count = item_count or len(items)\n    baskets = min(item_count, maxbaskets)\n    items = iter(items)\n    floor = item_count // baskets \n    ceiling = floor + 1\n    stepdown = item_count % baskets\n    for x_i in range(baskets):\n        length = ceiling if x_i &lt; stepdown else floor\n        yield [items.next() for _ in range(length)]\n</code></pre>\n<h2>Output</h2>\n<p>To test them out:</p>\n<pre><code class=\"python\">print(baskets_from(range(6), 8))\nprint(list(iter_baskets_from(range(6), 8)))\nprint(list(iter_baskets_contiguous(range(6), 8)))\nprint(baskets_from(range(22), 8))\nprint(list(iter_baskets_from(range(22), 8)))\nprint(list(iter_baskets_contiguous(range(22), 8)))\nprint(baskets_from('ABCDEFG', 3))\nprint(list(iter_baskets_from('ABCDEFG', 3)))\nprint(list(iter_baskets_contiguous('ABCDEFG', 3)))\nprint(baskets_from(range(26), 5))\nprint(list(iter_baskets_from(range(26), 5)))\nprint(list(iter_baskets_contiguous(range(26), 5)))\n</code></pre>\n<p>Which prints out:</p>\n<pre><code class=\"python\">[[0], [1], [2], [3], [4], [5]]\n[[0], [1], [2], [3], [4], [5]]\n[[0], [1], [2], [3], [4], [5]]\n[[0, 8, 16], [1, 9, 17], [2, 10, 18], [3, 11, 19], [4, 12, 20], [5, 13, 21], [6, 14], [7, 15]]\n[[0, 8, 16], [1, 9, 17], [2, 10, 18], [3, 11, 19], [4, 12, 20], [5, 13, 21], [6, 14], [7, 15]]\n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11], [12, 13, 14], [15, 16, 17], [18, 19], [20, 21]]\n[['A', 'D', 'G'], ['B', 'E'], ['C', 'F']]\n[['A', 'D', 'G'], ['B', 'E'], ['C', 'F']]\n[['A', 'B', 'C'], ['D', 'E'], ['F', 'G']]\n[[0, 5, 10, 15, 20, 25], [1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24]]\n[[0, 5, 10, 15, 20, 25], [1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24]]\n[[0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]\n</code></pre>\n<p>Notice that the contiguous generator provide chunks in the same length patterns as the other two, but the items are all in order, and they are as evenly divided as one may divide a list of discrete elements.</p>\n", "abstract": "\"Evenly sized chunks\", to me, implies that they are all the same length, or barring that option, at minimal variance in length. E.g. 5 baskets for 21 items could have the following results: A practical reason to prefer the latter result: if you were using these functions to distribute work, you've built-in the prospect of one likely finishing well before the others, so it would sit around doing nothing while the others continued working hard. When I originally wrote this answer, none of the other answers were evenly sized chunks - they all leave a runt chunk at the end, so they're not well balanced, and have a higher than necessary variance of lengths. For example, the current top answer ends with: Others, like list(grouper(3, range(7))), and chunk(range(7), 3) both return: [(0, 1, 2), (3, 4, 5), (6, None, None)]. The None's are just padding, and rather inelegant in my opinion. They are NOT evenly chunking the iterables. Why can't we divide these better? A high-level balanced solution using itertools.cycle, which is the way I might do it today. Here's the setup: Now we need our lists into which to populate the elements: Finally, we zip the elements we're going to allocate together with a cycle of the baskets until we run out of elements, which, semantically, it exactly what we want: Here's the result: To productionize this solution, we write a function, and provide the type annotations: In the above, we take our list of items, and the max number of baskets. We create a list of empty lists, in which to append each element, in a round-robin style. Another elegant solution is to use slices - specifically the less-commonly used step argument to slices. i.e.: This is especially elegant in that slices don't care how long the data are - the result, our first basket, is only as long as it needs to be. We'll only need to increment the starting point for each basket. In fact this could be a one-liner, but we'll go multiline for readability and to avoid an overlong line of code: And islice from the itertools module will provide a lazily iterating approach, like that which was originally asked for in the question. I don't expect most use-cases to benefit very much, as the original data is already fully materialized in a list, but for large datasets, it could save nearly half the memory usage. View results with: Here's another balanced solution, adapted from a function I've used in production in the past, that uses the modulo operator: And I created a generator that does the same if you put it into a list: And finally, since I see that all of the above functions return elements in a contiguous order (as they were given): To test them out: Which prints out: Notice that the contiguous generator provide chunks in the same length patterns as the other two, but the items are all in order, and they are as evenly divided as one may divide a list of discrete elements."}, {"id": 312466, "score": 54, "vote": 0, "content": "<p>If you know list size:</p>\n<pre><code class=\"python\">def SplitList(mylist, chunk_size):\n    return [mylist[offs:offs+chunk_size] for offs in range(0, len(mylist), chunk_size)]\n</code></pre>\n<p>If you don't (an iterator):</p>\n<pre><code class=\"python\">def IterChunks(sequence, chunk_size):\n    res = []\n    for item in sequence:\n        res.append(item)\n        if len(res) &gt;= chunk_size:\n            yield res\n            res = []\n    if res:\n        yield res  # yield the last, incomplete, portion\n</code></pre>\n<p>In the latter case, it can be rephrased in a more beautiful way if you can be sure that the sequence always contains a whole number of chunks of given size (i.e. there is no incomplete last chunk).</p>\n", "abstract": "If you know list size: If you don't (an iterator): In the latter case, it can be rephrased in a more beautiful way if you can be sure that the sequence always contains a whole number of chunks of given size (i.e. there is no incomplete last chunk)."}, {"id": 52022535, "score": 51, "vote": 0, "content": "<p><strong>Don't reinvent the wheel.</strong></p>\n<p><strong>Given</strong></p>\n<pre><code class=\"python\">import itertools as it\nimport collections as ct\n\nimport more_itertools as mit\n\n\niterable = range(11)\nn = 3\n</code></pre>\n<p><strong>Code</strong></p>\n<p><a href=\"https://github.com/more-itertools/more-itertools\" rel=\"noreferrer\"><em><code>more_itertools</code></em></a><sup>+</sup></p>\n<pre><code class=\"python\">list(mit.chunked(iterable, n))\n# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]\n\nlist(mit.sliced(iterable, n))\n# [range(0, 3), range(3, 6), range(6, 9), range(9, 11)]\n\nlist(mit.grouper(n, iterable))\n# [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, None)]\n\nlist(mit.windowed(iterable, len(iterable)//n, step=n))\n# [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, None)]\n\nlist(mit.chunked_even(iterable, n))\n# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]\n</code></pre>\n<p>(or DIY, if you want)</p>\n<p><em>The Standard Library</em></p>\n<pre><code class=\"python\">list(it.zip_longest(*[iter(iterable)] * n))\n# [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, None)]\n</code></pre>\n<pre><code class=\"python\">d = {}\nfor i, x in enumerate(iterable):\n    d.setdefault(i//n, []).append(x)\n    \n\nlist(d.values())\n# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]\n</code></pre>\n<pre><code class=\"python\">dd = ct.defaultdict(list)\nfor i, x in enumerate(iterable):\n    dd[i//n].append(x)\n    \n\nlist(dd.values())\n# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]\n</code></pre>\n<p><strong>References</strong></p>\n<ul>\n<li><a href=\"https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.chunked\" rel=\"noreferrer\"><code>more_itertools.chunked</code></a> (<a href=\"https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/16315158#16315158\">related posted</a>)</li>\n<li><a href=\"https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.sliced\" rel=\"noreferrer\"><code>more_itertools.sliced</code></a></li>\n<li><a href=\"https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.grouper\" rel=\"noreferrer\"><code>more_itertools.grouper</code></a> (<a href=\"https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/312644#312644\">related post</a>)</li>\n<li><a href=\"https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.windowed\" rel=\"noreferrer\"><code>more_itertools.windowed</code></a> (see also <a href=\"https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.stagger\" rel=\"noreferrer\"><code>stagger</code></a>, <a href=\"https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.zip_offset\" rel=\"noreferrer\"><code>zip_offset</code></a>)</li>\n<li><a href=\"https://more-itertools.readthedocs.io/en/latest/api.html#more_itertools.chunked_even\" rel=\"noreferrer\"><code>more_itertools.chunked_even</code></a></li>\n<li><a href=\"https://docs.python.org/3/library/itertools.html#itertools.zip_longest\" rel=\"noreferrer\"><code>zip_longest</code></a> (<a href=\"https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/3125186#3125186\">related post</a>, <a href=\"https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks/29009933#29009933\">related post</a>)</li>\n<li><a href=\"https://docs.python.org/3/library/stdtypes.html#dict.setdefault\" rel=\"noreferrer\"><code>setdefault</code></a> (ordered results requires Python 3.6+)</li>\n<li><a href=\"https://docs.python.org/3/library/collections.html#collections.defaultdict\" rel=\"noreferrer\"><code>collections.defaultdict</code></a>  (ordered results requires Python 3.6+)</li>\n</ul>\n<p><sub><sup>+</sup> A third-party library that implements <a href=\"https://docs.python.org/3/library/itertools.html#itertools-recipes\" rel=\"noreferrer\">itertools recipes</a> and more. <code>&gt; pip install more_itertools</code> </sub></p>\n", "abstract": "Don't reinvent the wheel. Given Code more_itertools+ (or DIY, if you want) The Standard Library References + A third-party library that implements itertools recipes and more. > pip install more_itertools "}, {"id": 29009933, "score": 50, "vote": 0, "content": "<p>I saw the most awesome Python-ish answer in a <a href=\"https://stackoverflow.com/questions/23286254/convert-list-to-a-list-of-tuples-python\">duplicate</a> of this question:</p>\n<pre><code class=\"python\">from itertools import zip_longest\n\na = range(1, 16)\ni = iter(a)\nr = list(zip_longest(i, i, i))\n&gt;&gt;&gt; print(r)\n[(1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12), (13, 14, 15)]\n</code></pre>\n<p>You can create n-tuple for any n. If <code>a = range(1, 15)</code>, then the result will be:</p>\n<pre><code class=\"python\">[(1, 2, 3), (4, 5, 6), (7, 8, 9), (10, 11, 12), (13, 14, None)]\n</code></pre>\n<p>If the list is divided evenly, then you can replace <code>zip_longest</code> with <code>zip</code>, otherwise the triplet <code>(13, 14, None)</code> would be lost. Python 3 is used above. For Python 2, use <code>izip_longest</code>.</p>\n", "abstract": "I saw the most awesome Python-ish answer in a duplicate of this question: You can create n-tuple for any n. If a = range(1, 15), then the result will be: If the list is divided evenly, then you can replace zip_longest with zip, otherwise the triplet (13, 14, None) would be lost. Python 3 is used above. For Python 2, use izip_longest."}, {"id": 34322647, "score": 39, "vote": 0, "content": "<pre><code class=\"python\">[AA[i:i+SS] for i in range(len(AA))[::SS]]\n</code></pre>\n<p>Where AA is array, SS is chunk size. For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; AA=range(10,21);SS=3\n&gt;&gt;&gt; [AA[i:i+SS] for i in range(len(AA))[::SS]]\n[[10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20]]\n# or [range(10, 13), range(13, 16), range(16, 19), range(19, 21)] in py3\n</code></pre>\n<p>To expand the ranges in py3 do</p>\n<pre><code class=\"python\">(py3) &gt;&gt;&gt; [list(AA[i:i+SS]) for i in range(len(AA))[::SS]]\n[[10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20]]\n</code></pre>\n", "abstract": "Where AA is array, SS is chunk size. For example: To expand the ranges in py3 do"}, {"id": 5711993, "score": 26, "vote": 0, "content": "<p>If you had a chunk size of 3 for example, you could do:</p>\n<pre><code class=\"python\">zip(*[iterable[i::3] for i in range(3)]) \n</code></pre>\n<p>source:\n<a href=\"http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/\">http://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/</a></p>\n<p>I would use this when my chunk size is fixed number I can type, e.g. '3', and would never change.</p>\n", "abstract": "If you had a chunk size of 3 for example, you could do: source:\nhttp://code.activestate.com/recipes/303060-group-a-list-into-sequential-n-tuples/ I would use this when my chunk size is fixed number I can type, e.g. '3', and would never change."}, {"id": 20106816, "score": 25, "vote": 0, "content": "<p>The <a href=\"https://github.com/pytoolz/toolz\">toolz</a> library has the <code>partition</code> function for this:</p>\n<pre><code class=\"python\">from toolz.itertoolz.core import partition\n\nlist(partition(2, [1, 2, 3, 4]))\n[(1, 2), (3, 4)]\n</code></pre>\n", "abstract": "The toolz library has the partition function for this:"}, {"id": 59266741, "score": 25, "vote": 0, "content": "<p>With <a href=\"https://www.python.org/dev/peps/pep-0572/\" rel=\"noreferrer\">Assignment Expressions</a> in Python 3.8 it becomes quite nice:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import itertools\n\ndef batch(iterable, size):\n    it = iter(iterable)\n    while item := list(itertools.islice(it, size)):\n        yield item\n</code></pre>\n<p>This works on an arbitrary iterable, not just a list.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; pprint.pprint(list(batch(range(75), 10)))\n[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\n [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],\n [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\n [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],\n [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],\n [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n [70, 71, 72, 73, 74]]\n</code></pre>\n", "abstract": "With Assignment Expressions in Python 3.8 it becomes quite nice: This works on an arbitrary iterable, not just a list."}, {"id": 48135727, "score": 21, "vote": 0, "content": "<p>I was curious about the performance of different approaches and here it is:</p>\n<p>Tested on Python 3.5.1</p>\n<pre><code class=\"python\">import time\nbatch_size = 7\narr_len = 298937\n\n#---------slice-------------\n\nprint(\"\\r\\nslice\")\nstart = time.time()\narr = [i for i in range(0, arr_len)]\nwhile True:\n    if not arr:\n        break\n\n    tmp = arr[0:batch_size]\n    arr = arr[batch_size:-1]\nprint(time.time() - start)\n\n#-----------index-----------\n\nprint(\"\\r\\nindex\")\narr = [i for i in range(0, arr_len)]\nstart = time.time()\nfor i in range(0, round(len(arr) / batch_size + 1)):\n    tmp = arr[batch_size * i : batch_size * (i + 1)]\nprint(time.time() - start)\n\n#----------batches 1------------\n\ndef batch(iterable, n=1):\n    l = len(iterable)\n    for ndx in range(0, l, n):\n        yield iterable[ndx:min(ndx + n, l)]\n\nprint(\"\\r\\nbatches 1\")\narr = [i for i in range(0, arr_len)]\nstart = time.time()\nfor x in batch(arr, batch_size):\n    tmp = x\nprint(time.time() - start)\n\n#----------batches 2------------\n\nfrom itertools import islice, chain\n\ndef batch(iterable, size):\n    sourceiter = iter(iterable)\n    while True:\n        batchiter = islice(sourceiter, size)\n        yield chain([next(batchiter)], batchiter)\n\n\nprint(\"\\r\\nbatches 2\")\narr = [i for i in range(0, arr_len)]\nstart = time.time()\nfor x in batch(arr, batch_size):\n    tmp = x\nprint(time.time() - start)\n\n#---------chunks-------------\ndef chunks(l, n):\n    \"\"\"Yield successive n-sized chunks from l.\"\"\"\n    for i in range(0, len(l), n):\n        yield l[i:i + n]\nprint(\"\\r\\nchunks\")\narr = [i for i in range(0, arr_len)]\nstart = time.time()\nfor x in chunks(arr, batch_size):\n    tmp = x\nprint(time.time() - start)\n\n#-----------grouper-----------\n\nfrom itertools import zip_longest # for Python 3.x\n#from six.moves import zip_longest # for both (uses the six compat library)\n\ndef grouper(iterable, n, padvalue=None):\n    \"grouper(3, 'abcdefg', 'x') --&gt; ('a','b','c'), ('d','e','f'), ('g','x','x')\"\n    return zip_longest(*[iter(iterable)]*n, fillvalue=padvalue)\n\narr = [i for i in range(0, arr_len)]\nprint(\"\\r\\ngrouper\")\nstart = time.time()\nfor x in grouper(arr, batch_size):\n    tmp = x\nprint(time.time() - start)\n</code></pre>\n<p><strong>Results:</strong></p>\n<pre><code class=\"python\">slice\n31.18285083770752\n\nindex\n0.02184295654296875\n\nbatches 1\n0.03503894805908203\n\nbatches 2\n0.22681021690368652\n\nchunks\n0.019841909408569336\n\ngrouper\n0.006506919860839844\n</code></pre>\n", "abstract": "I was curious about the performance of different approaches and here it is: Tested on Python 3.5.1 Results:"}, {"id": 19264525, "score": 19, "vote": 0, "content": "<p>I like the Python doc's version proposed by tzot and J.F.Sebastian a lot,\n but it has two shortcomings:</p>\n<ul>\n<li>it is not very explicit</li>\n<li>I usually don't want a fill value in the last chunk</li>\n</ul>\n<p>I'm using this one a lot in my code:</p>\n<pre><code class=\"python\">from itertools import islice\n\ndef chunks(n, iterable):\n    iterable = iter(iterable)\n    while True:\n        yield tuple(islice(iterable, n)) or iterable.next()\n</code></pre>\n<p>UPDATE: A lazy chunks version:</p>\n<pre><code class=\"python\">from itertools import chain, islice\n\ndef chunks(n, iterable):\n   iterable = iter(iterable)\n   while True:\n       yield chain([next(iterable)], islice(iterable, n-1))\n</code></pre>\n", "abstract": "I like the Python doc's version proposed by tzot and J.F.Sebastian a lot,\n but it has two shortcomings: I'm using this one a lot in my code: UPDATE: A lazy chunks version:"}, {"id": 41904532, "score": 18, "vote": 0, "content": "<p>You may also use <a href=\"http://utilspie.readthedocs.io/en/latest/#get-chunks\" rel=\"noreferrer\"><code>get_chunks</code></a> function of <a href=\"http://utilspie.readthedocs.io\" rel=\"noreferrer\"><code>utilspie</code></a> library as:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from utilspie import iterutils\n&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n&gt;&gt;&gt; list(iterutils.get_chunks(a, 5))\n[[1, 2, 3, 4, 5], [6, 7, 8, 9]]\n</code></pre>\n<p>You can install <a href=\"https://pypi.python.org/pypi/utilspie\" rel=\"noreferrer\"><code>utilspie</code></a> via pip:</p>\n<pre><code class=\"python\">sudo pip install utilspie\n</code></pre>\n<p><em>Disclaimer: I am the creator of <a href=\"https://github.com/moin18/utilspie\" rel=\"noreferrer\">utilspie</a> library</em>.</p>\n", "abstract": "You may also use get_chunks function of utilspie library as: You can install utilspie via pip: Disclaimer: I am the creator of utilspie library."}, {"id": 31178232, "score": 16, "vote": 0, "content": "<p>code:</p>\n<pre><code class=\"python\">def split_list(the_list, chunk_size):\n    result_list = []\n    while the_list:\n        result_list.append(the_list[:chunk_size])\n        the_list = the_list[chunk_size:]\n    return result_list\n\na_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nprint split_list(a_list, 3)\n</code></pre>\n<p>result:</p>\n<pre><code class=\"python\">[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n</code></pre>\n", "abstract": "code: result:"}, {"id": 33510840, "score": 13, "vote": 0, "content": "<p>At this point, I think we need a <strong>recursive generator</strong>, just in case...</p>\n<p>In python 2:</p>\n<pre><code class=\"python\">def chunks(li, n):\n    if li == []:\n        return\n    yield li[:n]\n    for e in chunks(li[n:], n):\n        yield e\n</code></pre>\n<p>In python 3:</p>\n<pre><code class=\"python\">def chunks(li, n):\n    if li == []:\n        return\n    yield li[:n]\n    yield from chunks(li[n:], n)\n</code></pre>\n<p>Also, in case of massive Alien invasion, a <strong>decorated recursive generator</strong> might become handy:</p>\n<pre><code class=\"python\">def dec(gen):\n    def new_gen(li, n):\n        for e in gen(li, n):\n            if e == []:\n                return\n            yield e\n    return new_gen\n\n@dec\ndef chunks(li, n):\n    yield li[:n]\n    for e in chunks(li[n:], n):\n        yield e\n</code></pre>\n", "abstract": "At this point, I think we need a recursive generator, just in case... In python 2: In python 3: Also, in case of massive Alien invasion, a decorated recursive generator might become handy:"}, {"id": 312472, "score": 12, "vote": 0, "content": "<p>heh, one line version</p>\n<pre><code class=\"python\">In [48]: chunk = lambda ulist, step:  map(lambda i: ulist[i:i+step],  xrange(0, len(ulist), step))\n\nIn [49]: chunk(range(1,100), 10)\nOut[49]: \n[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n [21, 22, 23, 24, 25, 26, 27, 28, 29, 30],\n [31, 32, 33, 34, 35, 36, 37, 38, 39, 40],\n [41, 42, 43, 44, 45, 46, 47, 48, 49, 50],\n [51, 52, 53, 54, 55, 56, 57, 58, 59, 60],\n [61, 62, 63, 64, 65, 66, 67, 68, 69, 70],\n [71, 72, 73, 74, 75, 76, 77, 78, 79, 80],\n [81, 82, 83, 84, 85, 86, 87, 88, 89, 90],\n [91, 92, 93, 94, 95, 96, 97, 98, 99]]\n</code></pre>\n", "abstract": "heh, one line version"}, {"id": 314771, "score": 11, "vote": 0, "content": "<pre><code class=\"python\">def split_seq(seq, num_pieces):\n    start = 0\n    for i in xrange(num_pieces):\n        stop = start + len(seq[i::num_pieces])\n        yield seq[start:stop]\n        start = stop\n</code></pre>\n<p>usage:</p>\n<pre><code class=\"python\">seq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nfor seq in split_seq(seq, 3):\n    print seq\n</code></pre>\n", "abstract": "usage:"}, {"id": 2270932, "score": 11, "vote": 0, "content": "<p>Without calling len() which is good for large lists:</p>\n<pre><code class=\"python\">def splitter(l, n):\n    i = 0\n    chunk = l[:n]\n    while chunk:\n        yield chunk\n        i += n\n        chunk = l[i:i+n]\n</code></pre>\n<p>And this is for iterables:</p>\n<pre><code class=\"python\">def isplitter(l, n):\n    l = iter(l)\n    chunk = list(islice(l, n))\n    while chunk:\n        yield chunk\n        chunk = list(islice(l, n))\n</code></pre>\n<p>The functional flavour of the above:</p>\n<pre><code class=\"python\">def isplitter2(l, n):\n    return takewhile(bool,\n                     (tuple(islice(start, n))\n                            for start in repeat(iter(l))))\n</code></pre>\n<p>OR:</p>\n<pre><code class=\"python\">def chunks_gen_sentinel(n, seq):\n    continuous_slices = imap(islice, repeat(iter(seq)), repeat(0), repeat(n))\n    return iter(imap(tuple, continuous_slices).next,())\n</code></pre>\n<p>OR:</p>\n<pre><code class=\"python\">def chunks_gen_filter(n, seq):\n    continuous_slices = imap(islice, repeat(iter(seq)), repeat(0), repeat(n))\n    return takewhile(bool,imap(tuple, continuous_slices))\n</code></pre>\n", "abstract": "Without calling len() which is good for large lists: And this is for iterables: The functional flavour of the above: OR: OR:"}, {"id": 28786255, "score": 11, "vote": 0, "content": "<p>Another more explicit version.</p>\n<pre><code class=\"python\">def chunkList(initialList, chunkSize):\n    \"\"\"\n    This function chunks a list into sub lists \n    that have a length equals to chunkSize.\n\n    Example:\n    lst = [3, 4, 9, 7, 1, 1, 2, 3]\n    print(chunkList(lst, 3)) \n    returns\n    [[3, 4, 9], [7, 1, 1], [2, 3]]\n    \"\"\"\n    finalList = []\n    for i in range(0, len(initialList), chunkSize):\n        finalList.append(initialList[i:i+chunkSize])\n    return finalList\n</code></pre>\n", "abstract": "Another more explicit version."}, {"id": 14937534, "score": 10, "vote": 0, "content": "<p>See <a href=\"http://docs.python.org/3.3/library/functions.html?highlight=zip#zip\" rel=\"noreferrer\">this reference</a></p>\n<pre><code class=\"python\">&gt;&gt;&gt; orange = range(1, 1001)\n&gt;&gt;&gt; otuples = list( zip(*[iter(orange)]*10))\n&gt;&gt;&gt; print(otuples)\n[(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), ... (991, 992, 993, 994, 995, 996, 997, 998, 999, 1000)]\n&gt;&gt;&gt; olist = [list(i) for i in otuples]\n&gt;&gt;&gt; print(olist)\n[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], ..., [991, 992, 993, 994, 995, 996, 997, 998, 999, 1000]]\n&gt;&gt;&gt; \n</code></pre>\n<p>Python3</p>\n", "abstract": "See this reference Python3"}, {"id": 9255750, "score": 8, "vote": 0, "content": "<pre><code class=\"python\">def chunks(iterable,n):\n    \"\"\"assumes n is an integer&gt;0\n    \"\"\"\n    iterable=iter(iterable)\n    while True:\n        result=[]\n        for i in range(n):\n            try:\n                a=next(iterable)\n            except StopIteration:\n                break\n            else:\n                result.append(a)\n        if result:\n            yield result\n        else:\n            break\n\ng1=(i*i for i in range(10))\ng2=chunks(g1,3)\nprint g2\n'&lt;generator object chunks at 0x0337B9B8&gt;'\nprint list(g2)\n'[[0, 1, 4], [9, 16, 25], [36, 49, 64], [81]]'\n</code></pre>\n", "abstract": ""}, {"id": 40409475, "score": 8, "vote": 0, "content": "<p>Since everybody here talking about iterators. <a href=\"https://boltons.readthedocs.io/\" rel=\"noreferrer\"><code>boltons</code></a> has perfect method for that, called <a href=\"https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked_iter\" rel=\"noreferrer\"><code>iterutils.chunked_iter</code></a>.</p>\n<pre><code class=\"python\">from boltons import iterutils\n\nlist(iterutils.chunked_iter(list(range(50)), 11))\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],\n [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32],\n [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43],\n [44, 45, 46, 47, 48, 49]]\n</code></pre>\n<p>But if you don't want to be mercy on memory, you can use old-way and store the full <code>list</code> in the first place with <a href=\"https://boltons.readthedocs.io/en/latest/iterutils.html#boltons.iterutils.chunked\" rel=\"noreferrer\"><code>iterutils.chunked</code></a>.</p>\n", "abstract": "Since everybody here talking about iterators. boltons has perfect method for that, called iterutils.chunked_iter. Output: But if you don't want to be mercy on memory, you can use old-way and store the full list in the first place with iterutils.chunked."}, {"id": 5872632, "score": 7, "vote": 0, "content": "<p>Consider using <a href=\"http://matplotlib.sourceforge.net/\" rel=\"noreferrer\">matplotlib.cbook</a> pieces</p>\n<p>for example:</p>\n<pre><code class=\"python\">import matplotlib.cbook as cbook\nsegments = cbook.pieces(np.arange(20), 3)\nfor s in segments:\n     print s\n</code></pre>\n", "abstract": "Consider using matplotlib.cbook pieces for example:"}, {"id": 31442939, "score": 6, "vote": 0, "content": "<pre><code class=\"python\">a = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nCHUNK = 4\n[a[i*CHUNK:(i+1)*CHUNK] for i in xrange((len(a) + CHUNK - 1) / CHUNK )]\n</code></pre>\n", "abstract": ""}, {"id": 43454601, "score": 6, "vote": 0, "content": "<p>One more solution</p>\n<pre><code class=\"python\">def make_chunks(data, chunk_size): \n    while data:\n        chunk, data = data[:chunk_size], data[chunk_size:]\n        yield chunk\n\n&gt;&gt;&gt; for chunk in make_chunks([1, 2, 3, 4, 5, 6, 7], 2):\n...     print chunk\n... \n[1, 2]\n[3, 4]\n[5, 6]\n[7]\n&gt;&gt;&gt; \n</code></pre>\n", "abstract": "One more solution"}, {"id": 1668586, "score": 5, "vote": 0, "content": "<pre><code class=\"python\">&gt;&gt;&gt; def f(x, n, acc=[]): return f(x[n:], n, acc+[(x[:n])]) if x else acc\n&gt;&gt;&gt; f(\"Hallo Welt\", 3)\n['Hal', 'lo ', 'Wel', 't']\n&gt;&gt;&gt; \n</code></pre>\n<p>If you are into brackets - I picked up a book on Erlang :)</p>\n", "abstract": "If you are into brackets - I picked up a book on Erlang :)"}, {"id": 12150728, "score": 5, "vote": 0, "content": "<p>I realise this question is old (stumbled over it on Google), but surely something like the following is far simpler and clearer than any of the huge complex suggestions and only uses slicing:</p>\n<pre><code class=\"python\">def chunker(iterable, chunksize):\n    for i,c in enumerate(iterable[::chunksize]):\n        yield iterable[i*chunksize:(i+1)*chunksize]\n\n&gt;&gt;&gt; for chunk in chunker(range(0,100), 10):\n...     print list(chunk)\n... \n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n[20, 21, 22, 23, 24, 25, 26, 27, 28, 29]\n... etc ...\n</code></pre>\n", "abstract": "I realise this question is old (stumbled over it on Google), but surely something like the following is far simpler and clearer than any of the huge complex suggestions and only uses slicing:"}, {"id": 38808533, "score": 5, "vote": 0, "content": "<p>As per <a href=\"https://stackoverflow.com/a/21767522/15055\">this answer</a>, the top-voted answer leaves a 'runt' at the end. Here's my solution to really get about as evenly-sized chunks as you can, with no runts. It basically tries to pick exactly the fractional spot where it should split the list, but just rounds it off to the nearest integer:</p>\n<pre><code class=\"python\">from __future__ import division  # not needed in Python 3\ndef n_even_chunks(l, n):\n    \"\"\"Yield n as even chunks as possible from l.\"\"\"\n    last = 0\n    for i in range(1, n+1):\n        cur = int(round(i * (len(l) / n)))\n        yield l[last:cur]\n        last = cur\n</code></pre>\n<p>Demonstration:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; pprint.pprint(list(n_even_chunks(list(range(100)), 9)))\n[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],\n [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32],\n [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43],\n [44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55],\n [56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66],\n [67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77],\n [78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88],\n [89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]]\n&gt;&gt;&gt; pprint.pprint(list(n_even_chunks(list(range(100)), 11)))\n[[0, 1, 2, 3, 4, 5, 6, 7, 8],\n [9, 10, 11, 12, 13, 14, 15, 16, 17],\n [18, 19, 20, 21, 22, 23, 24, 25, 26],\n [27, 28, 29, 30, 31, 32, 33, 34, 35],\n [36, 37, 38, 39, 40, 41, 42, 43, 44],\n [45, 46, 47, 48, 49, 50, 51, 52, 53, 54],\n [55, 56, 57, 58, 59, 60, 61, 62, 63],\n [64, 65, 66, 67, 68, 69, 70, 71, 72],\n [73, 74, 75, 76, 77, 78, 79, 80, 81],\n [82, 83, 84, 85, 86, 87, 88, 89, 90],\n [91, 92, 93, 94, 95, 96, 97, 98, 99]]\n</code></pre>\n<p>Compare to the top-voted <code>chunks</code> answer:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; pprint.pprint(list(chunks(list(range(100)), 100//9)))\n[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],\n [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32],\n [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43],\n [44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54],\n [55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65],\n [66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76],\n [77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87],\n [88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98],\n [99]]\n&gt;&gt;&gt; pprint.pprint(list(chunks(list(range(100)), 100//11)))\n[[0, 1, 2, 3, 4, 5, 6, 7, 8],\n [9, 10, 11, 12, 13, 14, 15, 16, 17],\n [18, 19, 20, 21, 22, 23, 24, 25, 26],\n [27, 28, 29, 30, 31, 32, 33, 34, 35],\n [36, 37, 38, 39, 40, 41, 42, 43, 44],\n [45, 46, 47, 48, 49, 50, 51, 52, 53],\n [54, 55, 56, 57, 58, 59, 60, 61, 62],\n [63, 64, 65, 66, 67, 68, 69, 70, 71],\n [72, 73, 74, 75, 76, 77, 78, 79, 80],\n [81, 82, 83, 84, 85, 86, 87, 88, 89],\n [90, 91, 92, 93, 94, 95, 96, 97, 98],\n [99]]\n</code></pre>\n", "abstract": "As per this answer, the top-voted answer leaves a 'runt' at the end. Here's my solution to really get about as evenly-sized chunks as you can, with no runts. It basically tries to pick exactly the fractional spot where it should split the list, but just rounds it off to the nearest integer: Demonstration: Compare to the top-voted chunks answer:"}, {"id": 40700737, "score": 5, "vote": 0, "content": "<p>You could use numpy's array_split function e.g., <code>np.array_split(np.array(data), 20)</code> to split into 20 nearly equal size chunks.</p>\n<p>To make sure chunks are exactly equal in size use <code>np.split</code>.</p>\n", "abstract": "You could use numpy's array_split function e.g., np.array_split(np.array(data), 20) to split into 20 nearly equal size chunks. To make sure chunks are exactly equal in size use np.split."}, {"id": 47096024, "score": 5, "vote": 0, "content": "<p>I don't think I saw this option, so just to add another one :)) :</p>\n<pre><code class=\"python\">def chunks(iterable, chunk_size):\n  i = 0;\n  while i &lt; len(iterable):\n    yield iterable[i:i+chunk_size]\n    i += chunk_size\n</code></pre>\n", "abstract": "I don't think I saw this option, so just to add another one :)) :"}, {"id": 56954384, "score": 5, "vote": 0, "content": "<p>python <code>pydash</code> package could be a good choice. </p>\n<pre><code class=\"python\">from pydash.arrays import chunk\nids = ['22', '89', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '1']\nchunk_ids = chunk(ids,5)\nprint(chunk_ids)\n# output: [['22', '89', '2', '3', '4'], ['5', '6', '7', '8', '9'], ['10', '11', '1']]\n</code></pre>\n<p>for more checkout <a href=\"https://pydash.readthedocs.io/en/latest/api.html?highlight=chunk%20list\" rel=\"noreferrer\">pydash chunk list</a></p>\n", "abstract": "python pydash package could be a good choice.  for more checkout pydash chunk list"}, {"id": 319970, "score": 4, "vote": 0, "content": "<pre><code class=\"python\">def chunk(lst):\n    out = []\n    for x in xrange(2, len(lst) + 1):\n        if not len(lst) % x:\n            factor = len(lst) / x\n            break\n    while lst:\n        out.append([lst.pop(0) for x in xrange(factor)])\n    return out\n</code></pre>\n", "abstract": ""}, {"id": 27371167, "score": 4, "vote": 0, "content": "<p>letting r be the chunk size  and L be the initial list, you can do. </p>\n<pre><code class=\"python\">chunkL = [ [i for i in L[r*k:r*(k+1)] ] for k in range(len(L)/r)] \n</code></pre>\n", "abstract": "letting r be the chunk size  and L be the initial list, you can do. "}, {"id": 28756559, "score": 4, "vote": 0, "content": "<p>Use list comprehensions:</p>\n<pre><code class=\"python\">l = [1,2,3,4,5,6,7,8,9,10,11,12]\nk = 5 #chunk size\nprint [tuple(l[x:y]) for (x, y) in [(x, x+k) for x in range(0, len(l), k)]]\n</code></pre>\n", "abstract": "Use list comprehensions:"}, {"id": 33517774, "score": 4, "vote": 0, "content": "<p>At this point, I think we need the obligatory anonymous-recursive function.</p>\n<pre><code class=\"python\">Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\nchunks = Y(lambda f: lambda n: [n[0][:n[1]]] + f((n[0][n[1]:], n[1])) if len(n[0]) &gt; 0 else [])\n</code></pre>\n", "abstract": "At this point, I think we need the obligatory anonymous-recursive function."}, {"id": 41586849, "score": 4, "vote": 0, "content": "<p>I have one solution below which does work but more important than that solution is a few comments on other approaches.  First, a good solution shouldn't require that one loop through the sub-iterators in order.  If I run</p>\n<pre><code class=\"python\">g = paged_iter(list(range(50)), 11))\ni0 = next(g)\ni1 = next(g)\nlist(i1)\nlist(i0)\n</code></pre>\n<p>The appropriate output for the last command is   </p>\n<pre><code class=\"python\"> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre>\n<p>not</p>\n<pre><code class=\"python\"> []\n</code></pre>\n<p>As most of the itertools based solutions here return.  This isn't just the usual boring restriction about accessing iterators in order.  Imagine a consumer trying to clean up poorly entered data which reversed the appropriate order of blocks of 5, i.e., the data looks like [B5, A5, D5, C5] and should look like [A5, B5, C5, D5] (where A5 is just five elements not a sublist).  This consumer would look at the claimed behavior of the grouping function and not hesitate to write a loop like</p>\n<pre><code class=\"python\">i = 0\nout = []\nfor it in paged_iter(data,5)\n    if (i % 2 == 0):\n         swapped = it\n    else: \n         out += list(it)\n         out += list(swapped)\n    i = i + 1\n</code></pre>\n<p>This will produce mysteriously wrong results if you sneakily assume that sub-iterators are always fully used in order.  It gets even worse if you want to interleave elements from the chunks. </p>\n<p>Second, a decent number of the suggested solutions implicitly rely on the fact that iterators have a deterministic order (they don't e.g. set) and while some of the solutions using islice may be ok it worries me.</p>\n<p>Third, the itertools grouper approach works but the recipe relies on internal behavior of the zip_longest (or zip) functions that isn't part of their published behavior.  In particular, the grouper function only works because in zip_longest(i0...in) the next function is always called in order next(i0), next(i1), ... next(in) before starting over.  As grouper passes n copies of the same iterator object it relies on this behavior.</p>\n<p>Finally, while the solution below can be improved if you make the assumption criticized above that sub-iterators are accessed in order and fully perused without this assumption one MUST implicitly (via call chain) or explicitly (via deques or other data structure) store elements for each subiterator somewhere.  So don't bother wasting time (as I did) assuming one could get around this with some clever trick.</p>\n<pre><code class=\"python\">def paged_iter(iterat, n):\n    itr = iter(iterat)\n    deq = None\n    try:\n        while(True):\n            deq = collections.deque(maxlen=n)\n            for q in range(n):\n                deq.append(next(itr))\n            yield (i for i in deq)\n    except StopIteration:\n        yield (i for i in deq)\n</code></pre>\n", "abstract": "I have one solution below which does work but more important than that solution is a few comments on other approaches.  First, a good solution shouldn't require that one loop through the sub-iterators in order.  If I run The appropriate output for the last command is    not As most of the itertools based solutions here return.  This isn't just the usual boring restriction about accessing iterators in order.  Imagine a consumer trying to clean up poorly entered data which reversed the appropriate order of blocks of 5, i.e., the data looks like [B5, A5, D5, C5] and should look like [A5, B5, C5, D5] (where A5 is just five elements not a sublist).  This consumer would look at the claimed behavior of the grouping function and not hesitate to write a loop like This will produce mysteriously wrong results if you sneakily assume that sub-iterators are always fully used in order.  It gets even worse if you want to interleave elements from the chunks.  Second, a decent number of the suggested solutions implicitly rely on the fact that iterators have a deterministic order (they don't e.g. set) and while some of the solutions using islice may be ok it worries me. Third, the itertools grouper approach works but the recipe relies on internal behavior of the zip_longest (or zip) functions that isn't part of their published behavior.  In particular, the grouper function only works because in zip_longest(i0...in) the next function is always called in order next(i0), next(i1), ... next(in) before starting over.  As grouper passes n copies of the same iterator object it relies on this behavior. Finally, while the solution below can be improved if you make the assumption criticized above that sub-iterators are accessed in order and fully perused without this assumption one MUST implicitly (via call chain) or explicitly (via deques or other data structure) store elements for each subiterator somewhere.  So don't bother wasting time (as I did) assuming one could get around this with some clever trick."}, {"id": 42677465, "score": 4, "vote": 0, "content": "<p>Here's an idea using itertools.groupby:</p>\n<pre><code class=\"python\">def chunks(l, n):\n    c = itertools.count()\n    return (it for _, it in itertools.groupby(l, lambda x: next(c)//n))\n</code></pre>\n<p>This returns a generator of generators. If you want a list of lists, just replace the last line with</p>\n<pre><code class=\"python\">    return [list(it) for _, it in itertools.groupby(l, lambda x: next(c)//n)]\n</code></pre>\n<p>Example returning list of lists:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; chunks('abcdefghij', 4)\n[['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j']]\n</code></pre>\n<p>(So yes, this suffers form the \"runt problem\", which may or may not be a problem in a given situation.)</p>\n", "abstract": "Here's an idea using itertools.groupby: This returns a generator of generators. If you want a list of lists, just replace the last line with Example returning list of lists: (So yes, this suffers form the \"runt problem\", which may or may not be a problem in a given situation.)"}, {"id": 62643989, "score": 4, "vote": 0, "content": "<p>An abstraction would be</p>\n<pre><code class=\"python\">l = [1,2,3,4,5,6,7,8,9]\nn = 3\noutList = []\nfor i in range(n, len(l) + n, n):\n    outList.append(l[i-n:i])\n\nprint(outList)\n</code></pre>\n<p>This will print:</p>\n<blockquote>\n<p>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</p>\n</blockquote>\n", "abstract": "An abstraction would be This will print: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"id": 22138685, "score": 3, "vote": 0, "content": "<p>I wrote a small library expressly for this purpose, available <a href=\"https://github.com/rectangletangle/iterlib\" rel=\"nofollow\">here</a>. The library's <code>chunked</code> function is particularly efficient because it's implemented as a <a href=\"https://wiki.python.org/moin/Generators\" rel=\"nofollow\">generator</a>, so a substantial amount of memory can be saved in certain situations. It also doesn't rely on the slice notation, so any arbitrary iterator can be used.</p>\n<pre><code class=\"python\">import iterlib\n\nprint list(iterlib.chunked(xrange(1, 1000), 10))\n# prints [(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), (11, 12, 13, 14, 15, 16, 17, 18, 19, 20), ...]\n</code></pre>\n", "abstract": "I wrote a small library expressly for this purpose, available here. The library's chunked function is particularly efficient because it's implemented as a generator, so a substantial amount of memory can be saved in certain situations. It also doesn't rely on the slice notation, so any arbitrary iterator can be used."}, {"id": 29707187, "score": 3, "vote": 0, "content": "<p>The answer above (by koffein) has a little problem: the list is always split into an equal number of splits, not equal number of items per partition. This is my version. The \"// chs + 1\" takes into account that the number of items may not be divideable exactly by the partition size, so the last partition will only be partially filled.</p>\n<pre><code class=\"python\"># Given 'l' is your list\n\nchs = 12 # Your chunksize\npartitioned = [ l[i*chs:(i*chs)+chs] for i in range((len(l) // chs)+1) ]\n</code></pre>\n", "abstract": "The answer above (by koffein) has a little problem: the list is always split into an equal number of splits, not equal number of items per partition. This is my version. The \"// chs + 1\" takes into account that the number of items may not be divideable exactly by the partition size, so the last partition will only be partially filled."}, {"id": 47010604, "score": 3, "vote": 0, "content": "<p>No magic, but simple and correct:</p>\n<pre><code class=\"python\">def chunks(iterable, n):\n    \"\"\"Yield successive n-sized chunks from iterable.\"\"\"\n    values = []\n    for i, item in enumerate(iterable, 1):\n        values.append(item)\n        if i % n == 0:\n            yield values\n            values = []\n    if values:\n        yield values\n</code></pre>\n", "abstract": "No magic, but simple and correct:"}, {"id": 66967457, "score": 3, "vote": 0, "content": "<h1>A <em>simple</em> solution</h1>\n<blockquote>\n<p>The OP has requested \"equal sized chunk\". I understand \"equal sized\" as \"balanced\" sizes: we are looking for groups of items of <em>approximately</em> the same sizes <em>if</em> equal sizes are not possible (e.g, 23/5).</p>\n</blockquote>\n<p>Inputs here are:</p>\n<ul>\n<li>the list of items: <code>input_list</code> (list of 23 numbers, for instance)</li>\n<li>the number of groups to split those items: <code>n_groups</code> (<code>5</code>, for instance)</li>\n</ul>\n<p>Input:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">input_list = list(range(23))\nn_groups = 5\n</code></pre>\n<h2>Groups of contiguous elements:</h2>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">approx_sizes = len(input_list)/n_groups \n\ngroups_cont = [input_list[int(i*approx_sizes):int((i+1)*approx_sizes)] \n               for i in range(n_groups)]\n</code></pre>\n<h2>Groups of \"every-Nth\" elements:</h2>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">groups_leap = [input_list[i::n_groups] \n               for i in range(n_groups)]\n</code></pre>\n<h3>Results</h3>\n<pre><code class=\"python\">print(len(input_list))\n\nprint('Contiguous elements lists:')\nprint(groups_cont)\n\nprint('Leap every \"N\" items lists:')\nprint(groups_leap)\n</code></pre>\n<blockquote>\n<p>Will output:</p>\n<pre><code class=\"python\">23\n\nContiguous elements lists:\n[[0, 1, 2, 3], [4, 5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16, 17], [18, 19, 20, 21, 22]]\n\nLeap every \"N\" items lists:\n[[0, 5, 10, 15, 20], [1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18], [4, 9, 14, 19]]\n</code></pre>\n</blockquote>\n", "abstract": "The OP has requested \"equal sized chunk\". I understand \"equal sized\" as \"balanced\" sizes: we are looking for groups of items of approximately the same sizes if equal sizes are not possible (e.g, 23/5). Inputs here are: Input: Will output:"}, {"id": 18793562, "score": 2, "vote": 0, "content": "<ul>\n<li>Works with any iterable</li>\n<li>Inner data is generator object (not a list)</li>\n<li>One liner</li>\n</ul>\n<pre>\nIn [259]: get_in_chunks = lambda itr,n: ( (v for _,v in g) for _,g in itertools.groupby(enumerate(itr),lambda (ind,_): ind/n))\n\nIn [260]: list(list(x) for x in get_in_chunks(range(30),7))\nOut[260]:\n[[0, 1, 2, 3, 4, 5, 6],\n [7, 8, 9, 10, 11, 12, 13],\n [14, 15, 16, 17, 18, 19, 20],\n [21, 22, 23, 24, 25, 26, 27],\n [28, 29]]\n</pre>\n", "abstract": ""}, {"id": 25650543, "score": 2, "vote": 0, "content": "<p>Like @AaronHall I got here looking for roughly evenly sized chunks. There are different interpretations of that. In my case, if the desired size is N, I would like each group to be of size&gt;=N.\nThus, the orphans which are created in most of the above should be redistributed to other groups.</p>\n<p>This can be done using:</p>\n<pre><code class=\"python\">def nChunks(l, n):\n    \"\"\" Yield n successive chunks from l.\n    Works for lists,  pandas dataframes, etc\n    \"\"\"\n    newn = int(1.0 * len(l) / n + 0.5)\n    for i in xrange(0, n-1):\n        yield l[i*newn:i*newn+newn]\n    yield l[n*newn-newn:]\n</code></pre>\n<p>(from <a href=\"https://stackoverflow.com/questions/2130016/splitting-a-list-of-arbitrary-size-into-only-roughly-n-equal-parts\">Splitting a list of into N parts of approximately equal length</a>) by simply calling it as nChunks(l,l/n)  or nChunks(l,floor(l/n))</p>\n", "abstract": "Like @AaronHall I got here looking for roughly evenly sized chunks. There are different interpretations of that. In my case, if the desired size is N, I would like each group to be of size>=N.\nThus, the orphans which are created in most of the above should be redistributed to other groups. This can be done using: (from Splitting a list of into N parts of approximately equal length) by simply calling it as nChunks(l,l/n)  or nChunks(l,floor(l/n))"}, {"id": 32658232, "score": 2, "vote": 0, "content": "<p>I have come up to following solution without creation temorary list object, which should work with any iterable object. Please note that this version for Python 2.x:</p>\n<pre><code class=\"python\">def chunked(iterable, size):\n    stop = []\n    it = iter(iterable)\n    def _next_chunk():\n        try:\n            for _ in xrange(size):\n                yield next(it)\n        except StopIteration:\n            stop.append(True)\n            return\n\n    while not stop:\n        yield _next_chunk()\n\nfor it in chunked(xrange(16), 4):\n   print list(it)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">[0, 1, 2, 3]\n[4, 5, 6, 7]\n[8, 9, 10, 11]\n[12, 13, 14, 15] \n[]\n</code></pre>\n<p>As you can see if len(iterable) % size == 0 then we have additional empty iterator object. But I do not think that it is big problem.</p>\n", "abstract": "I have come up to following solution without creation temorary list object, which should work with any iterable object. Please note that this version for Python 2.x: Output: As you can see if len(iterable) % size == 0 then we have additional empty iterator object. But I do not think that it is big problem."}, {"id": 44959796, "score": 2, "vote": 0, "content": "<p>This works in v2/v3, is inlineable, generator-based and uses only the standard library:</p>\n<pre><code class=\"python\">import itertools\ndef split_groups(iter_in, group_size):\n    return ((x for _, x in item) for _, item in itertools.groupby(enumerate(iter_in), key=lambda x: x[0] // group_size))\n</code></pre>\n", "abstract": "This works in v2/v3, is inlineable, generator-based and uses only the standard library:"}, {"id": 33180285, "score": 1, "vote": 0, "content": "<p>Since I had to do something like this, here's my solution given a generator and a batch size:</p>\n<pre><code class=\"python\">def pop_n_elems_from_generator(g, n):\n    elems = []\n    try:\n        for idx in xrange(0, n):\n            elems.append(g.next())\n        return elems\n    except StopIteration:\n        return elems\n</code></pre>\n", "abstract": "Since I had to do something like this, here's my solution given a generator and a batch size:"}, {"id": 57042866, "score": 1, "vote": 0, "content": "<p>This question reminds me of the Raku (formerly Perl 6) <code>.comb(n)</code> method.  It breaks up strings into <code>n</code>-sized chunks.  (There's more to it than that, but I'll leave out the details.)</p>\n<p>It's easy enough to implement a similar function in Python3 as a lambda expression:</p>\n<pre><code class=\"python\">comb = lambda s,n: (s[i:i+n] for i in range(0,len(s),n))\n</code></pre>\n<p>Then you can call it like this:</p>\n<pre><code class=\"python\">some_list = list(range(0, 20))  # creates a list of 20 elements\ngenerator = comb(some_list, 4)  # creates a generator that will generate lists of 4 elements\nfor sublist in generator:\n    print(sublist)  # prints a sublist of four elements, as it's generated\n</code></pre>\n<p>Of course, you don't have to assign the generator to a variable; you can just loop over it directly like this:</p>\n<pre><code class=\"python\">for sublist in comb(some_list, 4):\n    print(sublist)  # prints a sublist of four elements, as it's generated\n</code></pre>\n<p>As a bonus, this <code>comb()</code> function also operates on strings:</p>\n<pre><code class=\"python\">list( comb('catdogant', 3) )  # returns ['cat', 'dog', 'ant']\n</code></pre>\n", "abstract": "This question reminds me of the Raku (formerly Perl 6) .comb(n) method.  It breaks up strings into n-sized chunks.  (There's more to it than that, but I'll leave out the details.) It's easy enough to implement a similar function in Python3 as a lambda expression: Then you can call it like this: Of course, you don't have to assign the generator to a variable; you can just loop over it directly like this: As a bonus, this comb() function also operates on strings:"}, {"id": 62216571, "score": 1, "vote": 0, "content": "<p>A generic chunker for any iterable, which gives the user a choice of how to handle a partial chunk at the end.</p>\n<p>Tested on Python 3.</p>\n<p><code>chunker.py</code></p>\n<pre><code class=\"python\">from enum import Enum\n\nclass PartialChunkOptions(Enum):\n    INCLUDE = 0\n    EXCLUDE = 1\n    PAD = 2\n    ERROR = 3\n\nclass PartialChunkException(Exception):\n    pass\n\ndef chunker(iterable, n, on_partial=PartialChunkOptions.INCLUDE, pad=None):\n    \"\"\"\n    A chunker yielding n-element lists from an iterable, with various options\n    about what to do about a partial chunk at the end.\n\n    on_partial=PartialChunkOptions.INCLUDE (the default):\n                     include the partial chunk as a short (&lt;n) element list\n\n    on_partial=PartialChunkOptions.EXCLUDE\n                     do not include the partial chunk\n\n    on_partial=PartialChunkOptions.PAD\n                     pad to an n-element list \n                     (also pass pad=&lt;pad_value&gt;, default None)\n\n    on_partial=PartialChunkOptions.ERROR\n                     raise a RuntimeError if a partial chunk is encountered\n    \"\"\"\n\n    on_partial = PartialChunkOptions(on_partial)        \n\n    iterator = iter(iterable)\n    while True:\n        vals = []\n        for i in range(n):\n            try:\n                vals.append(next(iterator))\n            except StopIteration:\n                if vals:\n                    if on_partial == PartialChunkOptions.INCLUDE:\n                        yield vals\n                    elif on_partial == PartialChunkOptions.EXCLUDE:\n                        pass\n                    elif on_partial == PartialChunkOptions.PAD:\n                        yield vals + [pad] * (n - len(vals))\n                    elif on_partial == PartialChunkOptions.ERROR:\n                        raise PartialChunkException\n                    return\n                return\n        yield vals\n</code></pre>\n<p><code>test.py</code></p>\n<pre><code class=\"python\">import chunker\n\nchunk_size = 3\n\nfor it in (range(100, 107),\n          range(100, 109)):\n\n    print(\"\\nITERABLE TO CHUNK: {}\".format(it))\n    print(\"CHUNK SIZE: {}\".format(chunk_size))\n\n    for option in chunker.PartialChunkOptions.__members__.values():\n        print(\"\\noption {} used\".format(option))\n        try:\n            for chunk in chunker.chunker(it, chunk_size, on_partial=option):\n                print(chunk)\n        except chunker.PartialChunkException:\n            print(\"PartialChunkException was raised\")\n    print(\"\")\n</code></pre>\n<p>output of <code>test.py</code></p>\n<pre><code class=\"python\">\nITERABLE TO CHUNK: range(100, 107)\nCHUNK SIZE: 3\n\noption PartialChunkOptions.INCLUDE used\n[100, 101, 102]\n[103, 104, 105]\n[106]\n\noption PartialChunkOptions.EXCLUDE used\n[100, 101, 102]\n[103, 104, 105]\n\noption PartialChunkOptions.PAD used\n[100, 101, 102]\n[103, 104, 105]\n[106, None, None]\n\noption PartialChunkOptions.ERROR used\n[100, 101, 102]\n[103, 104, 105]\nPartialChunkException was raised\n\n\nITERABLE TO CHUNK: range(100, 109)\nCHUNK SIZE: 3\n\noption PartialChunkOptions.INCLUDE used\n[100, 101, 102]\n[103, 104, 105]\n[106, 107, 108]\n\noption PartialChunkOptions.EXCLUDE used\n[100, 101, 102]\n[103, 104, 105]\n[106, 107, 108]\n\noption PartialChunkOptions.PAD used\n[100, 101, 102]\n[103, 104, 105]\n[106, 107, 108]\n\noption PartialChunkOptions.ERROR used\n[100, 101, 102]\n[103, 104, 105]\n[106, 107, 108]\n\n</code></pre>\n", "abstract": "A generic chunker for any iterable, which gives the user a choice of how to handle a partial chunk at the end. Tested on Python 3. chunker.py test.py output of test.py"}, {"id": 66734805, "score": 1, "vote": 0, "content": "<p>Although there is a lot of answers I have very simple way:</p>\n<pre><code class=\"python\">\nx = list(range(10, 75))\nindices = x[0::10]\nprint(\"indices: \", indices)\nxx = [x[i-10:i] for i in indices ]\nprint(\"x= \", x)\nprint (\"xx= \",xx)\n\n</code></pre>\n<p>the result will be :</p>\n<blockquote>\n<p>indices:  [10, 20, 30, 40, 50, 60, 70] x=  [10, 11, 12, 13, 14, 15,\n16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\n33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\n67, 68, 69, 70, 71, 72, 73, 74]</p>\n<p>xx = [[10, 11, 12, 13, 14, 15, 16, 17, 18, 19],<br/>\n[20, 21, 22, 23, 24, 25,26, 27, 28, 29],<br/>\n[30, 31, 32, 33, 34, 35, 36, 37, 38, 39],<br/>\n[40, 41, 42, 43, 44, 45, 46, 47, 48, 49],<br/>\n[50, 51, 52, 53, 54, 55, 56, 57, 58, 59],<br/>\n[60, 61, 62, 63, 64, 65, 66, 67, 68, 69],<br/>\n[70, 71, 72, 73, 74]]</p>\n</blockquote>\n", "abstract": "Although there is a lot of answers I have very simple way: the result will be : indices:  [10, 20, 30, 40, 50, 60, 70] x=  [10, 11, 12, 13, 14, 15,\n16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\n33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\n50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\n67, 68, 69, 70, 71, 72, 73, 74] xx = [[10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\n[20, 21, 22, 23, 24, 25,26, 27, 28, 29],\n[30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\n[40, 41, 42, 43, 44, 45, 46, 47, 48, 49],\n[50, 51, 52, 53, 54, 55, 56, 57, 58, 59],\n[60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n[70, 71, 72, 73, 74]]"}, {"id": 70927990, "score": 1, "vote": 0, "content": "<p>Let's say the list is <code>lst</code></p>\n<pre><code class=\"python\">import math\n\n# length of the list len(lst) is ln\n# size of a chunk is size\n\nfor num in range ( math.ceil(ln/size) ):\n    start, end = num*size, min((num+1)*size, ln)\n    print(lst[start:end])\n</code></pre>\n", "abstract": "Let's say the list is lst"}, {"id": 72960641, "score": 1, "vote": 0, "content": "<p>User @tzot's <a href=\"https://stackoverflow.com/a/312644/7758804\">solution</a> <code>zip_longest(*[iter(lst)]*n, fillvalue=padvalue)</code> is very elegant but if the length of <code>lst</code> is not divisible by <code>n</code>, it pads the last sublist to keep its length match that of the other sublists. However, if that's not desirable, then simply using <code>zip()</code> to produce similar round-robin zips and appending the remaining elements of <code>lst</code> (that cannot make a \"whole\" sublist) to the output should do the trick.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">list(map(list, zip(*[iter(lst)]*n))) + ([rest] if (rest:=lst[len(lst)//n*n : ]) else [])\n</code></pre>\n<p>The above one-liner is perhaps more readable wrapped in a function. Unlike the other functions on here, it produces a list not a generator. Depending on the use case, that may or may not be desirable.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def chunkify(lst, chunk_size):\n    nested = list(map(list, zip(*[iter(lst)]*chunk_size)))\n    rest = lst[len(lst)//chunk_size*chunk_size: ]\n    if rest:\n        nested.append(rest)\n    return nested\n</code></pre>\n<p>It's faster than some of the most popular answers on here that produce the same output.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">my_list, n = list(range(1_000_000)), 12\n\n%timeit list(chunks(my_list, n))                                         # @Ned_Batchelder\n# 36.4 ms \u00b1 1.6 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\n%timeit [my_list[i:i+n] for i in range(0, len(my_list), n)]              # @Ned_Batchelder\n# 34.6 ms \u00b1 1.12 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\n%timeit it = iter(my_list); list(iter(lambda: list(islice(it, n)), []))  # @senderle\n# 60.6 ms \u00b1 5.36 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\n%timeit list(mit.chunked(my_list, n))                                    # @pylang\n# 59.4 ms \u00b1 4.92 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\n%timeit chunkify(my_list, n)\n# 25.8 ms \u00b1 1.84 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</code></pre>\n", "abstract": "User @tzot's solution zip_longest(*[iter(lst)]*n, fillvalue=padvalue) is very elegant but if the length of lst is not divisible by n, it pads the last sublist to keep its length match that of the other sublists. However, if that's not desirable, then simply using zip() to produce similar round-robin zips and appending the remaining elements of lst (that cannot make a \"whole\" sublist) to the output should do the trick. The above one-liner is perhaps more readable wrapped in a function. Unlike the other functions on here, it produces a list not a generator. Depending on the use case, that may or may not be desirable. It's faster than some of the most popular answers on here that produce the same output."}, {"id": 73268211, "score": 1, "vote": 0, "content": "<p>You may use <code>more_itertools.chunked_even</code> along with <code>math.ceil</code>. Likely the easiest to reason?</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from math import ceil\nimport more_itertools as mit\nfrom pprint import pprint\n\npprint([*mit.chunked_even(range(19), ceil(19 / 5))])\n# [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18]]\n\npprint([*mit.chunked_even(range(20), ceil(20 / 5))])\n# [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19]]\n\npprint([*mit.chunked_even(range(21), ceil(21 / 5))])\n# [[0, 1, 2, 3, 4],\n# [5, 6, 7, 8],\n# [9, 10, 11, 12],\n# [13, 14, 15, 16],\n# [17, 18, 19, 20]]\n\npprint([*mit.chunked_even(range(3), ceil(3 / 5))])\n# [[0], [1], [2]]\n\n\n</code></pre>\n", "abstract": "You may use more_itertools.chunked_even along with math.ceil. Likely the easiest to reason?"}, {"id": 49456217, "score": 0, "vote": 0, "content": "<p>I dislike idea of splitting elements by chunk size, e.g. script can devide 101 to 3 chunks as [50, 50, 1]. For my needs I needed spliting proportionly, and keeping order same. First I wrote my own script, which works fine, and it's very simple. But I've seen later <a href=\"https://stackoverflow.com/a/21767522/3110300\">this answer</a>, where script is better than mine, I reccomend it.\nHere's my script:</p>\n<pre><code class=\"python\">def proportional_dividing(N, n):\n    \"\"\"\n    N - length of array (bigger number)\n    n - number of chunks (smaller number)\n    output - arr, containing N numbers, diveded roundly to n chunks\n    \"\"\"\n    arr = []\n    if N == 0:\n        return arr\n    elif n == 0:\n        arr.append(N)\n        return arr\n    r = N // n\n    for i in range(n-1):\n        arr.append(r)\n    arr.append(N-r*(n-1))\n\n    last_n = arr[-1]\n    # last number always will be r &lt;= last_n &lt; 2*r\n    # when last_n == r it's ok, but when last_n &gt; r ...\n    if last_n &gt; r:\n        # ... and if difference too big (bigger than 1), then\n        if abs(r-last_n) &gt; 1:\n            #[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7] # N=29, n=12\n            # we need to give unnecessary numbers to first elements back\n            diff = last_n - r\n            for k in range(diff):\n                arr[k] += 1\n            arr[-1] = r\n            # and we receive [3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2]\n    return arr\n\ndef split_items(items, chunks):\n    arr = proportional_dividing(len(items), chunks)\n    splitted = []\n    for chunk_size in arr:\n        splitted.append(items[:chunk_size])\n        items = items[chunk_size:]\n    print(splitted)\n    return splitted\n\nitems = [1,2,3,4,5,6,7,8,9,10,11]\nchunks = 3\nsplit_items(items, chunks)\nsplit_items(['a','b','c','d','e','f','g','h','i','g','k','l', 'm'], 3)\nsplit_items(['a','b','c','d','e','f','g','h','i','g','k','l', 'm', 'n'], 3)\nsplit_items(range(100), 4)\nsplit_items(range(99), 4)\nsplit_items(range(101), 4)\n</code></pre>\n<p>and output:</p>\n<pre><code class=\"python\">[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11]]\n[['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'g', 'k', 'l', 'm']]\n[['a', 'b', 'c', 'd', 'e'], ['f', 'g', 'h', 'i', 'g'], ['k', 'l', 'm', 'n']]\n[range(0, 25), range(25, 50), range(50, 75), range(75, 100)]\n[range(0, 25), range(25, 50), range(50, 75), range(75, 99)]\n[range(0, 25), range(25, 50), range(50, 75), range(75, 101)]\n</code></pre>\n", "abstract": "I dislike idea of splitting elements by chunk size, e.g. script can devide 101 to 3 chunks as [50, 50, 1]. For my needs I needed spliting proportionly, and keeping order same. First I wrote my own script, which works fine, and it's very simple. But I've seen later this answer, where script is better than mine, I reccomend it.\nHere's my script: and output:"}, {"id": 56273344, "score": 0, "vote": 0, "content": "<p>If you don't care about the order:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">&gt; from itertools import groupby\n&gt; batch_no = 3\n&gt; data = 'abcdefgh'\n\n&gt; [\n    [x[1] for x in x[1]] \n    for x in \n    groupby(\n      sorted(\n        (x[0] % batch_no, x[1]) \n        for x in \n        enumerate(data)\n      ),\n      key=lambda x: x[0]\n    )\n  ]\n\n[['a', 'd', 'g'], ['b', 'e', 'h'], ['c', 'f']]\n\n</code></pre>\n<p>This solution doesn't generates sets of same size, but distributes values so batches are as big as possible while keeping the number of generated batches.</p>\n", "abstract": "If you don't care about the order: This solution doesn't generates sets of same size, but distributes values so batches are as big as possible while keeping the number of generated batches."}, {"id": 61212415, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">def main():\n  print(chunkify([1,2,3,4,5,6],2))\n\ndef chunkify(list, n):\n  chunks = []\n  for i in range(0, len(list), n):\n    chunks.append(list[i:i+n])\n  return chunks\n\nmain()\n</code></pre>\n<p>I think that it's simple and can give you a chunk of an array.</p>\n", "abstract": "I think that it's simple and can give you a chunk of an array."}, {"id": 64041110, "score": 0, "vote": 0, "content": "<p>I've created these two fancy one-liners which are efficient and lazy, both input and output are iterables, also they doen't depend on any module:</p>\n<p>First one-liner is totally lazy meaning that it returns iterator producing iterators (i.e. each chunk produced is iterator iterating over chunk's elements), this version is good for the case if chunks are very large or elements are produced slowly one by one and should become available immediately as they are produced:</p>\n<p><a href=\"https://tio.run/##RY/BCsIwDIbve4ocG6hg0dPAJxlDutltURdH7Q768jXpBvZQmvD9X9Llk6YXn3Lup5UfV0ohvuECTz93Nw@ULHANxgQYXhHIwgjEEHidQ/QpGGMGixZ6SogFuVsIinxpMdHzKIgTBxzAYUOtsONOSkZBoyPlQru1B22qr6q0ZC03kXjcGesK5CyROBm20DRdiXXK@ba8fVH8/7MvcpS8kwUYW8z5Bw\" rel=\"nofollow noreferrer\" title=\"Python 3 \u2013 Try It Online\">Try it online!</a></p>\n<pre><code class=\"python\">chunk_iters = lambda it, n: ((e for i, g in enumerate(((f,), cit)) for j, e in zip(range((1, n - 1)[i]), g)) for cit in (iter(it),) for f in cit)\n</code></pre>\n<p>Second one-liner returns iterator that produces lists. Each list is produced as soon as elements of whole chunk become available through input iterator or if very last element of last chunk is reached. This version should be used if input elements are produced fast or all available immediately. Other wise first more-lazy one-liner version should be used.</p>\n<p><a href=\"https://tio.run/##TY/BDoIwEETvfMV4MNmNNYHoqQlfQoipWqCxLATKwa/HVhJlb7sz8zYzvkM3yGVdH90ir5t3c5hRwpv@/jRwQUE0yKMZJng4AVW14u/qFNp0sbL0djLBEiU/ESvmzWKT3u7CvtLeCnnGEVLjhMrWlS5whktY10TLT0dZImccSjjOsgSRBJmMtJYKheLKOkOccXISSFSk/d/uCtEWyWOk4NiIa17XDw\" rel=\"nofollow noreferrer\" title=\"Python 3 \u2013 Try It Online\">Try it online!</a></p>\n<pre><code class=\"python\">chunk_lists = lambda it, n: (l for l in ([],) for i, g in enumerate((it, ((),))) for e in g for l in (l[:len(l) % n] + [e][:1 - i],) if (len(l) % n == 0) != i)\n</code></pre>\n<p>Also I provide multi-line version of first <code>chunk_iters</code> one-liner, which returns iterator producing another iterators (going through each chunk's elements):</p>\n<p><a href=\"https://tio.run/##XY/LCsIwEEX3@YpZJhDBoivBLyml9DGxgzItMV3Un4@ZtGpxVsnlnDvJtIRh5FOMPTrohpnvNQX0T03BApuLgjQdBbiC5Ck2ORJ8ZKyzot0GyiyEjx7c9@5GD2QBgRheNGnf8A01wwEKY6V65/58VB/XiZiw/w377UoJyUKu9YWF4rwVT544aLZQlm1ubIVrqnxucvvu36t/TL48j01lYnwD\" rel=\"nofollow noreferrer\" title=\"Python 3 \u2013 Try It Online\">Try it online!</a></p>\n<pre><code class=\"python\">def chunk_iters(it, n):\n    cit = iter(it)\n    def one_chunk(f):\n        yield f\n        for i, e in zip(range(n - 1), cit):\n            yield e\n    for f in cit:\n        yield one_chunk(f)\n</code></pre>\n", "abstract": "I've created these two fancy one-liners which are efficient and lazy, both input and output are iterables, also they doen't depend on any module: First one-liner is totally lazy meaning that it returns iterator producing iterators (i.e. each chunk produced is iterator iterating over chunk's elements), this version is good for the case if chunks are very large or elements are produced slowly one by one and should become available immediately as they are produced: Try it online! Second one-liner returns iterator that produces lists. Each list is produced as soon as elements of whole chunk become available through input iterator or if very last element of last chunk is reached. This version should be used if input elements are produced fast or all available immediately. Other wise first more-lazy one-liner version should be used. Try it online! Also I provide multi-line version of first chunk_iters one-liner, which returns iterator producing another iterators (going through each chunk's elements): Try it online!"}, {"id": 67181221, "score": 0, "vote": 0, "content": "<pre><code class=\"python\">from itertools import islice\nl=[1,2,3,4,5,6]\nchuncksize=input(\"Enter chunk size\")\nm=[]\nobj=iter(l)\nm.append(list(islice(l,3)))\nm.append(list(islice(l,3)))\nprint(m)\n</code></pre>\n", "abstract": ""}, {"id": 70381614, "score": 0, "vote": 0, "content": "<p>This task can be easily done using the generator in the <a href=\"http://https:/https://stackoverflow.com/a/312464/8010865\" rel=\"nofollow noreferrer\">accepted answer</a>. I'm adding class implementation that implements length methods, which may be useful to somebody. I needed to know the progress (with <code>tqdm</code>) so the generator should've returned the number of chunks.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class ChunksIterator(object):\n    def __init__(self, data, n):\n        self._data = data\n        self._l = len(data)\n        self._n = n\n\n    def __iter__(self):\n        for i in range(0, self._l, self._n):\n            yield self._data[i:i + self._n]\n\n    def __len__(self):\n        rem = 1 if self._l % self._n != 0 else 0\n        return self._l // self._n + rem\n</code></pre>\n<p>Usage:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">it = ChunksIterator([1,2,3,4,5,6,7,8,9], 2)\nprint(len(it))\nfor i in it:\n  print(i)\n</code></pre>\n", "abstract": "This task can be easily done using the generator in the accepted answer. I'm adding class implementation that implements length methods, which may be useful to somebody. I needed to know the progress (with tqdm) so the generator should've returned the number of chunks. Usage:"}, {"id": 70555495, "score": 0, "vote": 0, "content": "<p>One-liner version of <a href=\"https://stackoverflow.com/a/22045226/1022684\">senderle's answer</a>:</p>\n<pre><code class=\"python\">from itertools import islice\nfrom functools import partial\n\nseq = [1,2,3,4,5,6,7]\nsize = 3\nresult = list(iter(partial(lambda it: tuple(islice(it, size)), iter(seq)), ()))\nassert result == [(1, 2, 3), (4, 5, 6), (7,)]\n</code></pre>\n", "abstract": "One-liner version of senderle's answer:"}, {"id": 55776536, "score": -1, "vote": 0, "content": "<h3>Lazy loading version</h3>\n<blockquote>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import pprint\npprint.pprint(list(chunks(range(10, 75), 10)))\n[range(10, 20),\n range(20, 30),\n range(30, 40),\n range(40, 50),\n range(50, 60),\n range(60, 70),\n range(70, 75)]\n</code></pre>\n<p><em><sup><sub> Confer this implementation's result with the example usage result of the <a href=\"https://stackoverflow.com/a/312464/3423324\">accepted answer</a>. </sub></sup></em></p>\n</blockquote>\n<p>Many of the above functions assume that the length of the whole iterable are known up front, or at least are cheap to calculate.</p>\n<p>For some streamed objects that would mean loading the full data into memory first (e.g. to download the whole file) to get the length information.</p>\n<p>If you however don't know the the full size yet, you can use this code instead:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def chunks(iterable, size):\n    \"\"\"\n    Yield successive chunks from iterable, being `size` long.\n\n    https://stackoverflow.com/a/55776536/3423324\n    :param iterable: The object you want to split into pieces.\n    :param size: The size each of the resulting pieces should have.\n    \"\"\"\n    i = 0\n    while True:\n        sliced = iterable[i:i + size]\n        if len(sliced) == 0:\n            # to suppress stuff like `range(max, max)`.\n            break\n        # end if\n        yield sliced\n        if len(sliced) &lt; size:\n            # our slice is not the full length, so we must have passed the end of the iterator\n            break\n        # end if\n        i += size  # so we start the next chunk at the right place.\n    # end while\n# end def\n</code></pre>\n<p>This works because the slice command will return less/no elements if you passed the end of an iterable:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">\"abc\"[0:2] == 'ab'\n\"abc\"[2:4] == 'c'\n\"abc\"[4:6] == ''\n</code></pre>\n<p>We now use that result of the slice, and calculate the length of that generated chunk. If it is less than what we expect, we know we can end the iteration.</p>\n<p>That way the iterator will not be executed unless access.</p>\n", "abstract": " Confer this implementation's result with the example usage result of the accepted answer.  Many of the above functions assume that the length of the whole iterable are known up front, or at least are cheap to calculate. For some streamed objects that would mean loading the full data into memory first (e.g. to download the whole file) to get the length information. If you however don't know the the full size yet, you can use this code instead: This works because the slice command will return less/no elements if you passed the end of an iterable: We now use that result of the slice, and calculate the length of that generated chunk. If it is less than what we expect, we know we can end the iteration. That way the iterator will not be executed unless access."}, {"id": 59163343, "score": -1, "vote": 0, "content": "<p>An old school approach that does not require itertools but still works with arbitrary generators:</p>\n<pre><code class=\"python\">def chunks(g, n):\n  \"\"\"divide a generator 'g' into small chunks\n  Yields:\n    a chunk that has 'n' or less items\n  \"\"\"\n  n = max(1, n)\n  buff = []\n  for item in g:\n    buff.append(item)\n    if len(buff) == n:\n      yield buff\n      buff = []\n  if buff:\n    yield buff\n</code></pre>\n", "abstract": "An old school approach that does not require itertools but still works with arbitrary generators:"}, {"id": 63136026, "score": -1, "vote": 0, "content": "<p>Here is a bit of code written in Python3 that does the same as np.array_split.</p>\n<pre><code class=\"python\">list(map(list, map(functools.partial(filter, None), itertools.zip_longest(*iter(lambda: tuple(itertools.islice(a, n)), ())))))\n</code></pre>\n<p>It's quite a long one-liner but it does divide the items evenly amongst the resulting sublists.</p>\n", "abstract": "Here is a bit of code written in Python3 that does the same as np.array_split. It's quite a long one-liner but it does divide the items evenly amongst the resulting sublists."}, {"id": 16760646, "score": -2, "vote": 0, "content": "<p>using List Comprehensions of python</p>\n<pre><code class=\"python\">[range(t,t+10) for t in range(1,1000,10)]\n\n[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n [21, 22, 23, 24, 25, 26, 27, 28, 29, 30],....\n ....[981, 982, 983, 984, 985, 986, 987, 988, 989, 990],\n [991, 992, 993, 994, 995, 996, 997, 998, 999, 1000]]\n</code></pre>\n<p>visit <a href=\"http://docs.python.org/2/tutorial/datastructures.html#list-comprehensions\" rel=\"nofollow\">this link</a> to know about List Comprehensions</p>\n", "abstract": "using List Comprehensions of python visit this link to know about List Comprehensions"}, {"id": 20228836, "score": -2, "vote": 0, "content": "<p>Yes, it is an old question, but I had to post this one, because it is even a little shorter than the similar ones.\nYes, the result looks scrambled, but if it is just about even length...</p>\n<pre><code class=\"python\">&gt;&gt;&gt; n = 3 # number of groups\n&gt;&gt;&gt; biglist = range(30)\n&gt;&gt;&gt;\n&gt;&gt;&gt; [ biglist[i::n] for i in xrange(n) ]\n[[0, 3, 6, 9, 12, 15, 18, 21, 24, 27],\n [1, 4, 7, 10, 13, 16, 19, 22, 25, 28],\n [2, 5, 8, 11, 14, 17, 20, 23, 26, 29]]\n</code></pre>\n", "abstract": "Yes, it is an old question, but I had to post this one, because it is even a little shorter than the similar ones.\nYes, the result looks scrambled, but if it is just about even length..."}]}, {"link": "https://stackoverflow.com/questions/287871/how-do-i-print-colored-text-to-the-terminal", "question": {"id": "287871", "title": "How do I print colored text to the terminal?", "content": "<p>How do I output colored text to the terminal in Python?</p>\n", "abstract": "How do I output colored text to the terminal in Python?"}, "answers": [{"id": 287944, "score": 2573, "vote": 0, "content": "<p>This somewhat depends on what platform you are on. The most common way to do this is by printing ANSI escape sequences. For a simple example, here's some Python code from the <a href=\"https://svn.blender.org/svnroot/bf-blender/trunk/blender/build_files/scons/tools/bcolors.py\" rel=\"noreferrer\">Blender build scripts</a>:</p>\n<pre><code class=\"python\">class bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKCYAN = '\\033[96m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n</code></pre>\n<p>To use code like this, you can do something like:</p>\n<pre><code class=\"python\">print(bcolors.WARNING + \"Warning: No active frommets remain. Continue?\" + bcolors.ENDC)\n</code></pre>\n<p>Or, with Python 3.6+:</p>\n<pre><code class=\"python\">print(f\"{bcolors.WARNING}Warning: No active frommets remain. Continue?{bcolors.ENDC}\")\n</code></pre>\n<p>This will work on unixes including OS X, Linux and Windows (provided you use <a href=\"https://github.com/adoxa/ansicon\" rel=\"noreferrer\">ANSICON</a>, or in Windows 10 provided you enable <a href=\"https://msdn.microsoft.com/en-us/library/mt638032\" rel=\"noreferrer\">VT100 emulation</a>). There are ANSI codes for setting the color, moving the cursor, and more.</p>\n<p>If you are going to get complicated with this (and it sounds like you are if you are writing a game), you should look into the \"<a href=\"https://en.wikipedia.org/wiki/Curses_%28programming_library%29\" rel=\"noreferrer\">curses</a>\" module, which handles a lot of the complicated parts of this for you. The <a href=\"http://docs.python.org/howto/curses.html\" rel=\"noreferrer\" title=\"Python Curses howto\">Python Curses HowTO</a> is a good introduction.</p>\n<p>If you are not using extended ASCII (i.e., not on a PC), you are stuck with the ASCII characters below 127, and '#' or '@' is probably your best bet for a block. If you can ensure your terminal is using a IBM <a href=\"http://telecom.tbi.net/asc-ibm.html\" rel=\"noreferrer\">extended ASCII character set</a>, you have many more options. Characters 176, 177, 178 and 219 are the \"block characters\".</p>\n<p>Some modern text-based programs, such as \"Dwarf Fortress\", emulate text mode in a graphical mode, and use images of the classic PC font. You can find some of these bitmaps that you can use on the <a href=\"http://dwarffortresswiki.org/DF2014:Tilesets\" rel=\"noreferrer\">Dwarf Fortress Wiki</a> see (<a href=\"http://dwarffortresswiki.org/Tileset_repository\" rel=\"noreferrer\">user-made tilesets</a>).</p>\n<p>The <a href=\"http://en.wikipedia.org/wiki/TMDC\" rel=\"noreferrer\" title=\"text mode demo contest\">Text Mode Demo Contest</a> has more resources for doing graphics in text mode.</p>\n", "abstract": "This somewhat depends on what platform you are on. The most common way to do this is by printing ANSI escape sequences. For a simple example, here's some Python code from the Blender build scripts: To use code like this, you can do something like: Or, with Python 3.6+: This will work on unixes including OS X, Linux and Windows (provided you use ANSICON, or in Windows 10 provided you enable VT100 emulation). There are ANSI codes for setting the color, moving the cursor, and more. If you are going to get complicated with this (and it sounds like you are if you are writing a game), you should look into the \"curses\" module, which handles a lot of the complicated parts of this for you. The Python Curses HowTO is a good introduction. If you are not using extended ASCII (i.e., not on a PC), you are stuck with the ASCII characters below 127, and '#' or '@' is probably your best bet for a block. If you can ensure your terminal is using a IBM extended ASCII character set, you have many more options. Characters 176, 177, 178 and 219 are the \"block characters\". Some modern text-based programs, such as \"Dwarf Fortress\", emulate text mode in a graphical mode, and use images of the classic PC font. You can find some of these bitmaps that you can use on the Dwarf Fortress Wiki see (user-made tilesets). The Text Mode Demo Contest has more resources for doing graphics in text mode."}, {"id": 293633, "score": 1084, "vote": 0, "content": "<p>There is also the <a href=\"http://pypi.python.org/pypi/termcolor\" rel=\"noreferrer\">Python termcolor module</a>. Usage is pretty simple:</p>\n<pre><code class=\"python\">from termcolor import colored\n\nprint colored('hello', 'red'), colored('world', 'green')\n</code></pre>\n<p>Or in Python 3:</p>\n<pre><code class=\"python\">print(colored('hello', 'red'), colored('world', 'green'))\n</code></pre>\n<p>It may not be sophisticated enough, however, for game programming and the \"colored blocks\" that you want to do...</p>\n<p>To get the ANSI codes working on windows, first run</p>\n<pre><code class=\"python\">os.system('color')\n</code></pre>\n", "abstract": "There is also the Python termcolor module. Usage is pretty simple: Or in Python 3: It may not be sophisticated enough, however, for game programming and the \"colored blocks\" that you want to do... To get the ANSI codes working on windows, first run"}, {"id": 3332860, "score": 962, "vote": 0, "content": "<p>The answer is <a href=\"https://pypi.python.org/pypi/colorama\" rel=\"noreferrer\">Colorama</a> for all cross-platform coloring in Python.</p>\n<p>It supports Python 3.5+ as well as Python 2.7.</p>\n<p>And as of January 2021 it is maintained.</p>\n<p>Example Code:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from colorama import Fore\nfrom colorama import Style\n\nprint(f\"This is {Fore.GREEN}color{Style.RESET_ALL}!\")\n</code></pre>\n<p>Example Screenshot:\n<a href=\"https://i.stack.imgur.com/q3D4W.png\" rel=\"noreferrer\"><img alt=\"example screenshot\" src=\"https://i.stack.imgur.com/q3D4W.png\"/></a></p>\n", "abstract": "The answer is Colorama for all cross-platform coloring in Python. It supports Python 3.5+ as well as Python 2.7. And as of January 2021 it is maintained. Example Code: Example Screenshot:\n"}, {"id": 21786287, "score": 606, "vote": 0, "content": "<p>Print a string that starts a color/style, then the string, and then end the color/style change with <code>'\\x1b[0m'</code>:</p>\n<pre><code class=\"python\">print('\\x1b[6;30;42m' + 'Success!' + '\\x1b[0m')\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/RN3MN.png\" rel=\"noreferrer\"><img alt=\"Success with green background example\" src=\"https://i.stack.imgur.com/RN3MN.png\"/></a></p>\n<p>Get a table of format options for shell text with the following code:</p>\n<pre><code class=\"python\">def print_format_table():\n    \"\"\"\n    prints table of formatted text format options\n    \"\"\"\n    for style in range(8):\n        for fg in range(30,38):\n            s1 = ''\n            for bg in range(40,48):\n                format = ';'.join([str(style), str(fg), str(bg)])\n                s1 += '\\x1b[%sm %s \\x1b[0m' % (format, format)\n            print(s1)\n        print('\\n')\n\nprint_format_table()\n</code></pre>\n<h1>Light-on-dark example (complete)</h1>\n<p><a href=\"https://i.stack.imgur.com/6otvY.png\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/6otvY.png\"/></a></p>\n<h1>Dark-on-light example (partial)</h1>\n<p><img alt=\"Top part of output\" src=\"https://i.stack.imgur.com/lZr23.png\"/></p>\n<p>Reference: <a href=\"https://en.wikipedia.org/wiki/ANSI_escape_code#Colors\" rel=\"noreferrer\">https://en.wikipedia.org/wiki/ANSI_escape_code#Colors</a></p>\n", "abstract": "Print a string that starts a color/style, then the string, and then end the color/style change with '\\x1b[0m':  Get a table of format options for shell text with the following code:   Reference: https://en.wikipedia.org/wiki/ANSI_escape_code#Colors"}, {"id": 39452138, "score": 294, "vote": 0, "content": "<p>Define a string that starts a color and a string that ends the color. Then print your text with the start string at the front and the end string at the end.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">CRED = '\\033[91m'\nCEND = '\\033[0m'\nprint(CRED + \"Error, does not compute!\" + CEND)\n</code></pre>\n<p>This produces the following in Bash, in <code>urxvt</code> with a Zenburn-style color scheme:</p>\n<p><a href=\"https://i.stack.imgur.com/Iu3I1.png\" rel=\"noreferrer\"><img alt=\"Output colors\" src=\"https://i.stack.imgur.com/Iu3I1.png\"/></a></p>\n<p>Through experimentation, we can get more colors:</p>\n<p><a href=\"https://i.stack.imgur.com/j7e4i.gif\" rel=\"noreferrer\"><img alt=\"Color matrix\" src=\"https://i.stack.imgur.com/j7e4i.gif\"/></a></p>\n<p>Note: <code>\\33[5m</code> and <code>\\33[6m</code> are blinking.</p>\n<p>This way we can create a full color collection:</p>\n<pre><code class=\"python\">CEND      = '\\33[0m'\nCBOLD     = '\\33[1m'\nCITALIC   = '\\33[3m'\nCURL      = '\\33[4m'\nCBLINK    = '\\33[5m'\nCBLINK2   = '\\33[6m'\nCSELECTED = '\\33[7m'\n\nCBLACK  = '\\33[30m'\nCRED    = '\\33[31m'\nCGREEN  = '\\33[32m'\nCYELLOW = '\\33[33m'\nCBLUE   = '\\33[34m'\nCVIOLET = '\\33[35m'\nCBEIGE  = '\\33[36m'\nCWHITE  = '\\33[37m'\n\nCBLACKBG  = '\\33[40m'\nCREDBG    = '\\33[41m'\nCGREENBG  = '\\33[42m'\nCYELLOWBG = '\\33[43m'\nCBLUEBG   = '\\33[44m'\nCVIOLETBG = '\\33[45m'\nCBEIGEBG  = '\\33[46m'\nCWHITEBG  = '\\33[47m'\n\nCGREY    = '\\33[90m'\nCRED2    = '\\33[91m'\nCGREEN2  = '\\33[92m'\nCYELLOW2 = '\\33[93m'\nCBLUE2   = '\\33[94m'\nCVIOLET2 = '\\33[95m'\nCBEIGE2  = '\\33[96m'\nCWHITE2  = '\\33[97m'\n\nCGREYBG    = '\\33[100m'\nCREDBG2    = '\\33[101m'\nCGREENBG2  = '\\33[102m'\nCYELLOWBG2 = '\\33[103m'\nCBLUEBG2   = '\\33[104m'\nCVIOLETBG2 = '\\33[105m'\nCBEIGEBG2  = '\\33[106m'\nCWHITEBG2  = '\\33[107m'\n</code></pre>\n<p>Here is the code to generate the test:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">x = 0\nfor i in range(24):\n  colors = \"\"\n  for j in range(5):\n    code = str(x+j)\n    colors = colors + \"\\33[\" + code + \"m\\\\33[\" + code + \"m\\033[0m \"\n  print(colors)\n  x = x + 5\n</code></pre>\n", "abstract": "Define a string that starts a color and a string that ends the color. Then print your text with the start string at the front and the end string at the end. This produces the following in Bash, in urxvt with a Zenburn-style color scheme:  Through experimentation, we can get more colors:  Note: \\33[5m and \\33[6m are blinking. This way we can create a full color collection: Here is the code to generate the test:"}, {"id": 54955094, "score": 161, "vote": 0, "content": "<p>Here's a solution that works on Windows 10 natively.</p>\n<p>Using a system call, such as <code>os.system(\"\")</code>, allows colours to be printed in Command Prompt and Powershell natively:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import os\n\n# System call\nos.system(\"\")\n\n# Class of different styles\nclass style():\n    BLACK = '\\033[30m'\n    RED = '\\033[31m'\n    GREEN = '\\033[32m'\n    YELLOW = '\\033[33m'\n    BLUE = '\\033[34m'\n    MAGENTA = '\\033[35m'\n    CYAN = '\\033[36m'\n    WHITE = '\\033[37m'\n    UNDERLINE = '\\033[4m'\n    RESET = '\\033[0m'\n\nprint(style.YELLOW + \"Hello, World!\")\n</code></pre>\n<p>Note: Windows does not fully support ANSI codes, whether through system calls or modules. Not all text decoration is supported, and although the bright colours display, they are identical to the regular colours.</p>\n<p>Thanks to @j-l for finding an even shorter method.</p>\n<p><strong>tl;dr</strong>: Add <code>os.system(\"\")</code></p>\n", "abstract": "Here's a solution that works on Windows 10 natively. Using a system call, such as os.system(\"\"), allows colours to be printed in Command Prompt and Powershell natively: Note: Windows does not fully support ANSI codes, whether through system calls or modules. Not all text decoration is supported, and although the bright colours display, they are identical to the regular colours. Thanks to @j-l for finding an even shorter method. tl;dr: Add os.system(\"\")"}, {"id": 287934, "score": 112, "vote": 0, "content": "<p>You want to learn about ANSI escape sequences. Here's a brief example:</p>\n<pre><code class=\"python\">CSI = \"\\x1B[\"\nprint(CSI+\"31;40m\" + \"Colored Text\" + CSI + \"0m\")\n</code></pre>\n<p>For more information, see <em><a href=\"http://en.wikipedia.org/wiki/ANSI_escape_code\" rel=\"noreferrer\">ANSI escape code</a></em>.</p>\n<p>For a block character, try a Unicode character like \\u2588:</p>\n<pre><code class=\"python\">print(u\"\\u2588\")\n</code></pre>\n<p>Putting it all together:</p>\n<pre><code class=\"python\">print(CSI+\"31;40m\" + u\"\\u2588\" + CSI + \"0m\")\n</code></pre>\n", "abstract": "You want to learn about ANSI escape sequences. Here's a brief example: For more information, see ANSI escape code. For a block character, try a Unicode character like \\u2588: Putting it all together:"}, {"id": 48723332, "score": 104, "vote": 0, "content": "<p><a href=\"https://github.com/feluxe/sty\" rel=\"noreferrer\">sty</a> is similar to colorama, but it's less verbose, supports <a href=\"https://sty.mewo.dev/docs/coloring.html#coloring-with-8-bit-codes\" rel=\"noreferrer\">8-bit</a> and <a href=\"https://sty.mewo.dev/docs/coloring.html#coloring-with-24bit-codes\" rel=\"noreferrer\">24-bit</a> (RGB) colors, supports all <a href=\"https://sty.mewo.dev/docs/effects.html\" rel=\"noreferrer\">effects</a> (bold, underline, etc.), allows you to <a href=\"https://sty.mewo.dev/docs/customizing.html#add-custom-styles-to-a-register-object\" rel=\"noreferrer\">register your own styles</a>, is fully typed and high performant, supports <a href=\"https://sty.mewo.dev/docs/muting.html#the-mute-and-unmute-methods\" rel=\"noreferrer\">muting</a>, is not messing with globals such as <code>sys.stdout</code>, is really flexible, well <a href=\"https://sty.mewo.dev/\" rel=\"noreferrer\">documented</a> and more...</p>\n<p><strong>Examples:</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from sty import fg, bg, ef, rs\n\nfoo = fg.red + 'This is red text!' + fg.rs\nbar = bg.blue + 'This has a blue background!' + bg.rs\nbaz = ef.italic + 'This is italic text' + rs.italic\nqux = fg(201) + 'This is pink text using 8bit colors' + fg.rs\nqui = fg(255, 10, 10) + 'This is red text using 24bit colors.' + fg.rs\n\n# Add custom colors:\n\nfrom sty import Style, RgbFg\n\nfg.orange = Style(RgbFg(255, 150, 50))\n\nbuf = fg.orange + 'Yay, Im orange.' + fg.rs\n\nprint(foo, bar, baz, qux, qui, buf, sep='\\n')\n</code></pre>\n<p>prints:</p>\n<p><a href=\"https://i.stack.imgur.com/4BIdi.png\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/4BIdi.png\"/></a></p>\n<p><strong>Demo:</strong></p>\n<p><a href=\"https://i.stack.imgur.com/S8wtO.png\" rel=\"noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/S8wtO.png\"/></a></p>\n", "abstract": "sty is similar to colorama, but it's less verbose, supports 8-bit and 24-bit (RGB) colors, supports all effects (bold, underline, etc.), allows you to register your own styles, is fully typed and high performant, supports muting, is not messing with globals such as sys.stdout, is really flexible, well documented and more... Examples: prints:  Demo: "}, {"id": 65088582, "score": 83, "vote": 0, "content": "<p><a href=\"https://github.com/willmcgugan/rich\" rel=\"noreferrer\">Rich</a> is a relatively new Python library for working with color in the terminal.</p>\n<p>There are a few ways of working with color in Rich. The quickest way to get started would be the rich print method which renders a <a href=\"https://en.wikipedia.org/wiki/BBCode\" rel=\"noreferrer\">BBCode</a>-like syntax in to ANSI control codes:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from rich import print\nprint(\"[red]Color[/] in the [bold magenta]Terminal[/]!\")\n</code></pre>\n<p>There are other ways of applying color with Rich (regex, syntax) and related formatting features.</p>\n<p><a href=\"https://i.stack.imgur.com/4jJaD.png\" rel=\"noreferrer\"><img alt=\"Screenshot of Rich\" src=\"https://i.stack.imgur.com/4jJaD.png\"/></a></p>\n", "abstract": "Rich is a relatively new Python library for working with color in the terminal. There are a few ways of working with color in Rich. The quickest way to get started would be the rich print method which renders a BBCode-like syntax in to ANSI control codes: There are other ways of applying color with Rich (regex, syntax) and related formatting features. "}, {"id": 8548994, "score": 69, "vote": 0, "content": "<p>My favorite way is with the <a href=\"http://pypi.python.org/pypi/blessings/\">Blessings</a> library (full disclosure: I wrote it). For example:</p>\n<pre><code class=\"python\">from blessings import Terminal\n\nt = Terminal()\nprint t.red('This is red.')\nprint t.bold_bright_red_on_black('Bright red on black')\n</code></pre>\n<p>To print colored bricks, the most reliable way is to print spaces with background colors. I use this technique to draw the progress bar in <a href=\"http://pypi.python.org/pypi/nose-progressive/\">nose-progressive</a>:</p>\n<pre><code class=\"python\">print t.on_green(' ')\n</code></pre>\n<p>You can print in specific locations as well:</p>\n<pre><code class=\"python\">with t.location(0, 5):\n    print t.on_yellow(' ')\n</code></pre>\n<p>If you have to muck with other terminal capabilities in the course of your game, you can do that as well. You can use Python's standard string formatting to keep it readable:</p>\n<pre><code class=\"python\">print '{t.clear_eol}You just cleared a {t.bold}whole{t.normal} line!'.format(t=t)\n</code></pre>\n<p>The nice thing about Blessings is that it does its best to work on all sorts of terminals, not just the (overwhelmingly common) ANSI-color ones. It also keeps unreadable escape sequences out of your code while remaining concise to use. Have fun!</p>\n", "abstract": "My favorite way is with the Blessings library (full disclosure: I wrote it). For example: To print colored bricks, the most reliable way is to print spaces with background colors. I use this technique to draw the progress bar in nose-progressive: You can print in specific locations as well: If you have to muck with other terminal capabilities in the course of your game, you can do that as well. You can use Python's standard string formatting to keep it readable: The nice thing about Blessings is that it does its best to work on all sorts of terminals, not just the (overwhelmingly common) ANSI-color ones. It also keeps unreadable escape sequences out of your code while remaining concise to use. Have fun!"}, {"id": 26445590, "score": 64, "vote": 0, "content": "<p>I generated a class with all the colors using a <code>for</code> loop to iterate every combination of color up to 100, and then wrote a class with Python colors. Copy and paste as you will, GPLv2 by me:</p>\n<pre><code class=\"python\">class colors:\n    '''Colors class:\n    Reset all colors with colors.reset\n    Two subclasses fg for foreground and bg for background.\n    Use as colors.subclass.colorname.\n    i.e. colors.fg.red or colors.bg.green\n    Also, the generic bold, disable, underline, reverse, strikethrough,\n    and invisible work with the main class\n    i.e. colors.bold\n    '''\n    reset='\\033[0m'\n    bold='\\033[01m'\n    disable='\\033[02m'\n    underline='\\033[04m'\n    reverse='\\033[07m'\n    strikethrough='\\033[09m'\n    invisible='\\033[08m'\n    class fg:\n        black='\\033[30m'\n        red='\\033[31m'\n        green='\\033[32m'\n        orange='\\033[33m'\n        blue='\\033[34m'\n        purple='\\033[35m'\n        cyan='\\033[36m'\n        lightgrey='\\033[37m'\n        darkgrey='\\033[90m'\n        lightred='\\033[91m'\n        lightgreen='\\033[92m'\n        yellow='\\033[93m'\n        lightblue='\\033[94m'\n        pink='\\033[95m'\n        lightcyan='\\033[96m'\n    class bg:\n        black='\\033[40m'\n        red='\\033[41m'\n        green='\\033[42m'\n        orange='\\033[43m'\n        blue='\\033[44m'\n        purple='\\033[45m'\n        cyan='\\033[46m'\n        lightgrey='\\033[47m'\n</code></pre>\n", "abstract": "I generated a class with all the colors using a for loop to iterate every combination of color up to 100, and then wrote a class with Python colors. Copy and paste as you will, GPLv2 by me:"}, {"id": 61960902, "score": 60, "vote": 0, "content": "<p>This is, in my opinion, the easiest method. As long as you have the RGB values of the color you want, this should work:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def colored(r, g, b, text):\n    return f\"\\033[38;2;{r};{g};{b}m{text}\\033[0m\"\n</code></pre>\n<p>An example of printing red text:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">text = 'Hello, World!'\ncolored_text = colored(255, 0, 0, text)\nprint(colored_text)\n\n#or\n\nprint(colored(255, 0, 0, 'Hello, World!'))\n</code></pre>\n<p>Multi-colored text</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">text = colored(255, 0, 0, 'Hello, ') + colored(0, 255, 0, 'World')\nprint(text)\n</code></pre>\n", "abstract": "This is, in my opinion, the easiest method. As long as you have the RGB values of the color you want, this should work: An example of printing red text: Multi-colored text"}, {"id": 34443116, "score": 55, "vote": 0, "content": "<p>Try this simple code</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def prRed(prt):\n    print(f\"\\033[91m{prt}\\033[00m\")\n\ndef prGreen(prt):\n    print(f\"\\033[92m{prt}\\033[00m\")\n\ndef prYellow(prt):\n    print(f\"\\033[93m{prt}\\033[00m\")\n\ndef prLightPurple(prt):\n    print(f\"\\033[94m{prt}\\033[00m\")\n\ndef prPurple(prt):\n    print(f\"\\033[95m{prt}\\033[00m\")\n\ndef prCyan(prt):\n    print(f\"\\033[96m{prt}\\033[00m\")\n\ndef prLightGray(prt):\n    print(f\"\\033[97m{prt}\\033[00m\")\n\ndef prBlack(prt):\n    print(f\"\\033[98m{prt}\\033[00m\")\n\ndef prReset(prt):\n    print(f\"\\033[0m{prt}\\033[00m\")\n\nprGreen(\"Hello, Green World!\")\nprBlack(\"Hello, Black World!\")\nprCyan(\"Hello, Cyan World!\")\nprGreen(\"Hello, Green World!\")\nprLightGray(\"Hello, Light Grey World!\")\nprLightPurple(\"Hello, Light Purple World!\")\nprPurple(\"Hello, Purple World!\")\nprRed(\"Hello, Red World!\")\nprYellow(\"Hello, Yellow World!\")\nprReset(\"Hello, Reset World!\")\n</code></pre>\n<p>Python 3 Example\n<a href=\"https://i.stack.imgur.com/VsUHx.png\" rel=\"nofollow noreferrer\"><img alt=\"Python 3 Example.\" src=\"https://i.stack.imgur.com/VsUHx.png\"/></a></p>\n<pre><code class=\"python\"># python2\n    def prRed(prt): print(\"\\033[91m {}\\033[00m\" .format(prt))\n    def prGreen(prt): print(\"\\033[92m {}\\033[00m\" .format(prt))\n    def prYellow(prt): print(\"\\033[93m {}\\033[00m\" .format(prt))\n    def prLightPurple(prt): print(\"\\033[94m {}\\033[00m\" .format(prt))\n    def prPurple(prt): print(\"\\033[95m {}\\033[00m\" .format(prt))\n    def prCyan(prt): print(\"\\033[96m {}\\033[00m\" .format(prt))\n    def prLightGray(prt): print(\"\\033[97m {}\\033[00m\" .format(prt))\n    def prBlack(prt): print(\"\\033[98m {}\\033[00m\" .format(prt))\n\n    prGreen(\"Hello, World!\")\n</code></pre>\n", "abstract": "Try this simple code Python 3 Example\n"}, {"id": 50025330, "score": 43, "vote": 0, "content": "<pre><code class=\"python\"># Pure Python 3.x demo, 256 colors\n# Works with bash under Linux and MacOS\n\nfg = lambda text, color: \"\\33[38;5;\" + str(color) + \"m\" + text + \"\\33[0m\"\nbg = lambda text, color: \"\\33[48;5;\" + str(color) + \"m\" + text + \"\\33[0m\"\n\ndef print_six(row, format, end=\"\\n\"):\n    for col in range(6):\n        color = row*6 + col - 2\n        if color&gt;=0:\n            text = \"{:3d}\".format(color)\n            print (format(text,color), end=\" \")\n        else:\n            print(end=\"    \")   # four spaces\n    print(end=end)\n\nfor row in range(0, 43):\n    print_six(row, fg, \" \")\n    print_six(row, bg)\n\n# Simple usage: print(fg(\"text\", 160))\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/qqMmX.png\" rel=\"noreferrer\"><img alt=\"Text with altering foreground and background, colors 0..141\" src=\"https://i.stack.imgur.com/qqMmX.png\"/></a>\n<a href=\"https://i.stack.imgur.com/3X16v.png\" rel=\"noreferrer\"><img alt=\"Text with altering foreground and background, colors 142..255\" src=\"https://i.stack.imgur.com/3X16v.png\"/></a></p>\n<p><a href=\"https://code.labstack.com/VfphHQ14\" rel=\"noreferrer\">Try it online</a></p>\n", "abstract": "\n Try it online"}, {"id": 59582215, "score": 43, "vote": 0, "content": "<p>I have a <a href=\"https://github.com/SuperMaZingCoder/ColorIt\" rel=\"noreferrer\">library called colorit</a>. It is super simple.</p>\n<p>Here are some examples:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from colorit import *\n\n# Use this to ensure that ColorIt will be usable by certain command line interfaces\n# Note: This clears the terminal\ninit_colorit()\n\n# Foreground\nprint(color(\"This text is red\", Colors.red))\nprint(color(\"This text is orange\", Colors.orange))\nprint(color(\"This text is yellow\", Colors.yellow))\nprint(color(\"This text is green\", Colors.green))\nprint(color(\"This text is blue\", Colors.blue))\nprint(color(\"This text is purple\", Colors.purple))\nprint(color(\"This text is white\", Colors.white))\n\n# Background\nprint(background(\"This text has a background that is red\", Colors.red))\nprint(background(\"This text has a background that is orange\", Colors.orange))\nprint(background(\"This text has a background that is yellow\", Colors.yellow))\nprint(background(\"This text has a background that is green\", Colors.green))\nprint(background(\"This text has a background that is blue\", Colors.blue))\nprint(background(\"This text has a background that is purple\", Colors.purple))\nprint(background(\"This text has a background that is white\", Colors.white))\n\n# Custom\nprint(color(\"This color has a custom grey text color\", (150, 150, 150)))\nprint(background(\"This color has a custom grey background\", (150, 150, 150)))\n\n# Combination\nprint(\n    background(\n        color(\"This text is blue with a white background\", Colors.blue), Colors.white\n    )\n)\n\n# If you are using Windows Command Line, this is so that it doesn't close immediately\ninput()\n</code></pre>\n<p>This gives you:</p>\n<p><a href=\"https://i.stack.imgur.com/AESCH.png\" rel=\"noreferrer\"><img alt=\"Picture of ColorIt\" src=\"https://i.stack.imgur.com/AESCH.png\"/></a></p>\n<p>It's also worth noting that this is cross platform and has been tested on Mac, Linux, and Windows.</p>\n<p>You might want to try it out: <a href=\"https://github.com/SuperMaZingCoder/colorit\" rel=\"noreferrer\">https://github.com/SuperMaZingCoder/colorit</a></p>\n<p><code>colorit</code> is now available to be installed with PyPi! You can install it with <code>pip install color-it</code> on Windows and <code>pip3 install color-it</code> on macOS and Linux.</p>\n", "abstract": "I have a library called colorit. It is super simple. Here are some examples: This gives you:  It's also worth noting that this is cross platform and has been tested on Mac, Linux, and Windows. You might want to try it out: https://github.com/SuperMaZingCoder/colorit colorit is now available to be installed with PyPi! You can install it with pip install color-it on Windows and pip3 install color-it on macOS and Linux."}, {"id": 288556, "score": 41, "vote": 0, "content": "<p>On Windows you can use module 'win32console' (available in some Python distributions) or module 'ctypes' (Python 2.5 and up) to access the Win32 API.</p>\n<p>To see complete code that supports both ways, see the <a href=\"https://github.com/testoob/testoob/blob/master/src/testoob/reporting/colored.py\" rel=\"noreferrer\">color console reporting code</a> from <a href=\"https://github.com/testoob/testoob\" rel=\"noreferrer\">Testoob</a>.</p>\n<p>ctypes example:</p>\n<pre><code class=\"python\">import ctypes\n\n# Constants from the Windows API\nSTD_OUTPUT_HANDLE = -11\nFOREGROUND_RED    = 0x0004 # text color contains red.\n\ndef get_csbi_attributes(handle):\n    # Based on IPython's winconsole.py, written by Alexander Belchenko\n    import struct\n    csbi = ctypes.create_string_buffer(22)\n    res = ctypes.windll.kernel32.GetConsoleScreenBufferInfo(handle, csbi)\n    assert res\n\n    (bufx, bufy, curx, cury, wattr,\n    left, top, right, bottom, maxx, maxy) = struct.unpack(\"hhhhHhhhhhh\", csbi.raw)\n    return wattr\n\n\nhandle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)\nreset = get_csbi_attributes(handle)\n\nctypes.windll.kernel32.SetConsoleTextAttribute(handle, FOREGROUND_RED)\nprint \"Cherry on top\"\nctypes.windll.kernel32.SetConsoleTextAttribute(handle, reset)\n</code></pre>\n", "abstract": "On Windows you can use module 'win32console' (available in some Python distributions) or module 'ctypes' (Python 2.5 and up) to access the Win32 API. To see complete code that supports both ways, see the color console reporting code from Testoob. ctypes example:"}, {"id": 17064509, "score": 38, "vote": 0, "content": "<p>I have wrapped <a href=\"https://stackoverflow.com/questions/287871/how-to-print-colored-text-in-python/287944#287944\">joeld's answer</a> into a module with global functions that I can use anywhere in my code.</p>\n<p>File: log.py</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def enable():\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = \"\\033[1m\"\n\ndef disable():\n    HEADER = ''\n    OKBLUE = ''\n    OKGREEN = ''\n    WARNING = ''\n    FAIL = ''\n    ENDC = ''\n\ndef infog(msg):\n    print(OKGREEN + msg + ENDC)\n\ndef info(msg):\n    print(OKBLUE + msg + ENDC)\n\ndef warn(msg):\n    print(WARNING + msg + ENDC)\n\ndef err(msg):\n    print(FAIL + msg + ENDC)\n\nenable()\n</code></pre>\n<p>Use as follows:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import log\nlog.info(\"Hello, World!\")\nlog.err(\"System Error\")\n</code></pre>\n", "abstract": "I have wrapped joeld's answer into a module with global functions that I can use anywhere in my code. File: log.py Use as follows:"}, {"id": 58149095, "score": 32, "vote": 0, "content": "<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def black(text):\n    print('\\033[30m', text, '\\033[0m', sep='')\n\ndef red(text):\n    print('\\033[31m', text, '\\033[0m', sep='')\n\ndef green(text):\n    print('\\033[32m', text, '\\033[0m', sep='')\n\ndef yellow(text):\n    print('\\033[33m', text, '\\033[0m', sep='')\n\ndef blue(text):\n    print('\\033[34m', text, '\\033[0m', sep='')\n\ndef magenta(text):\n    print('\\033[35m', text, '\\033[0m', sep='')\n\ndef cyan(text):\n    print('\\033[36m', text, '\\033[0m', sep='')\n\ndef gray(text):\n    print('\\033[90m', text, '\\033[0m', sep='')\n\n\nblack(\"BLACK\")\nred(\"RED\")\ngreen(\"GREEN\")\nyellow(\"YELLOW\")\nblue(\"BLACK\")\nmagenta(\"MAGENTA\")\ncyan(\"CYAN\")\ngray(\"GRAY\")\n</code></pre>\n<p><a href=\"https://code.labstack.com/EoyDRCvJ\" rel=\"noreferrer\"><strong>Try online</strong></a> </p>\n", "abstract": "Try online "}, {"id": 68428529, "score": 30, "vote": 0, "content": "<p>Here is my modern (2021) solution: <a href=\"https://github.com/bluenote10/yachalk\" rel=\"nofollow noreferrer\">yachalk</a></p>\n<p>It is one of the few libraries that properly supports nested styles:</p>\n<p><a href=\"https://i.stack.imgur.com/piYe5.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/piYe5.png\"/></a></p>\n<p>Apart from that yachalk is auto-complete-friendly, has 256/truecolor support, comes with terminal-capability detection, and is fully typed.</p>\n<p>Here are some design decision you may consider for choosing your solution.</p>\n<h2>High-level libraries vs low-level libraries / manual style handling?</h2>\n<p>Many answers to this question demonstrate how to ANSI escape codes directly, or suggest low-level libraries that require manual style enabling/disabling.</p>\n<p>These approaches have subtle issues: Inserting on/off styles manually is</p>\n<ul>\n<li>more verbose syntactically, because resets have to be specified explicitly,</li>\n<li>more error prone, because you can accidentally forget to reset a style,</li>\n<li>fails to get edge cases right: For instance in some terminals it is necessary to reset styles before newlines, and re-activate them after the line break. Also, some terminal have problems with simply overriding mutually exclusive styles, and require inserting \"unnecessary\" reset codes. If a developer's local terminal doesn't have these quirks, the developer will not discover these quirks immediately. The issue will only be reported later by others or cause problems e.g. on CI terminals.</li>\n</ul>\n<p>Therefore if compatibility with many terminals is a goal, it's best to use a high-level library that offers automatic handling of style resets. This allows the library to take care of all edge cases by inserting the \"spurious\" ANSI escape codes where needed.</p>\n<h2>Why yet another library?</h2>\n<p>In JavaScript the de-facto standard library for the task is <a href=\"https://github.com/chalk/chalk\" rel=\"nofollow noreferrer\">chalk</a>, and after using it for a while in JS projects, the solutions available in the Python world were lacking in comparison. Not only is the chalk API more convenient to use (fully auto-complete compatible), it also gets all the edge cases right.</p>\n<p>The idea of <a href=\"https://github.com/bluenote10/yachalk\" rel=\"nofollow noreferrer\">yachalk</a> is to bring the same convenience to the Python ecosystem. If you're interested in a comparison to other libraries I've started <a href=\"https://github.com/bluenote10/yachalk#prior-art-why-yet-another-chalk-clone\" rel=\"nofollow noreferrer\">feature comparison</a> on the projects page. In addition, here is a long (but still incomplete) list of alternatives that came up during my research -- a lot to choose from :)</p>\n<ul>\n<li><a href=\"https://pypi.org/project/colored/\" rel=\"nofollow noreferrer\">colored</a></li>\n<li><a href=\"https://pypi.org/project/ansicolors/\" rel=\"nofollow noreferrer\">ansicolors</a></li>\n<li><a href=\"https://pypi.org/project/termcolor/\" rel=\"nofollow noreferrer\">termcolor</a></li>\n<li><a href=\"https://pypi.org/project/colorama/\" rel=\"nofollow noreferrer\">colorama</a></li>\n<li><a href=\"https://pypi.org/project/sty/\" rel=\"nofollow noreferrer\">sty</a></li>\n<li><a href=\"https://pypi.org/project/blessings/\" rel=\"nofollow noreferrer\">blessings</a></li>\n<li><a href=\"https://pypi.org/project/rich/\" rel=\"nofollow noreferrer\">rich</a></li>\n<li><a href=\"https://pypi.org/project/colorit/\" rel=\"nofollow noreferrer\">colorit</a></li>\n<li><a href=\"https://pypi.org/project/colorprint/\" rel=\"nofollow noreferrer\">colorprint</a></li>\n<li><a href=\"https://pypi.org/project/console-color/\" rel=\"nofollow noreferrer\">console-color</a></li>\n<li><a href=\"https://pypi.org/project/pyfancy/\" rel=\"nofollow noreferrer\">pyfance</a></li>\n<li><a href=\"https://pypi.org/project/couleur/\" rel=\"nofollow noreferrer\">couleur</a></li>\n<li><a href=\"https://github.com/lmittmann/style\" rel=\"nofollow noreferrer\">style</a> (formerly known as clr)</li>\n<li><a href=\"https://github.com/anthonyalmarza/chalk\" rel=\"nofollow noreferrer\">pychalk</a></li>\n<li><a href=\"https://pypi.org/project/simple-chalk/\" rel=\"nofollow noreferrer\">simple-chalk</a></li>\n<li><a href=\"https://pypi.org/project/chlk/\" rel=\"nofollow noreferrer\">chlk</a></li>\n<li><a href=\"https://pypi.org/project/chalky/\" rel=\"nofollow noreferrer\">chalky</a></li>\n<li><a href=\"https://pypi.org/project/constyle\" rel=\"nofollow noreferrer\">constyle</a></li>\n</ul>\n", "abstract": "Here is my modern (2021) solution: yachalk It is one of the few libraries that properly supports nested styles:  Apart from that yachalk is auto-complete-friendly, has 256/truecolor support, comes with terminal-capability detection, and is fully typed. Here are some design decision you may consider for choosing your solution. Many answers to this question demonstrate how to ANSI escape codes directly, or suggest low-level libraries that require manual style enabling/disabling. These approaches have subtle issues: Inserting on/off styles manually is Therefore if compatibility with many terminals is a goal, it's best to use a high-level library that offers automatic handling of style resets. This allows the library to take care of all edge cases by inserting the \"spurious\" ANSI escape codes where needed. In JavaScript the de-facto standard library for the task is chalk, and after using it for a while in JS projects, the solutions available in the Python world were lacking in comparison. Not only is the chalk API more convenient to use (fully auto-complete compatible), it also gets all the edge cases right. The idea of yachalk is to bring the same convenience to the Python ecosystem. If you're interested in a comparison to other libraries I've started feature comparison on the projects page. In addition, here is a long (but still incomplete) list of alternatives that came up during my research -- a lot to choose from :)"}, {"id": 39005305, "score": 28, "vote": 0, "content": "<p>I ended up doing this, and I felt it was cleanest:</p>\n<pre><code class=\"python\">formatters = {\n    'RED': '\\033[91m',\n    'GREEN': '\\033[92m',\n    'END': '\\033[0m',\n}\n\nprint 'Master is currently {RED}red{END}!'.format(**formatters)\nprint 'Help make master {GREEN}green{END} again!'.format(**formatters)\n</code></pre>\n", "abstract": "I ended up doing this, and I felt it was cleanest:"}, {"id": 287896, "score": 27, "vote": 0, "content": "<p>For Windows you cannot print to console with colors unless you're using the <a href=\"https://en.wikipedia.org/wiki/Windows_API\" rel=\"noreferrer\">Win32</a> API.</p>\n<p>For Linux it's as simple as using print, with the escape sequences outlined here:</p>\n<p><a href=\"http://www.linuxhowtos.org/Tips%20and%20Tricks/ansi_escape_sequences.htm\" rel=\"noreferrer\">Colors</a></p>\n<p>For the character to print like a box, it really depends on what font you are using for the console window. The pound symbol works well, but it depends on the font:</p>\n<pre><code class=\"python\">#\n</code></pre>\n", "abstract": "For Windows you cannot print to console with colors unless you're using the Win32 API. For Linux it's as simple as using print, with the escape sequences outlined here: Colors For the character to print like a box, it really depends on what font you are using for the console window. The pound symbol works well, but it depends on the font:"}, {"id": 29723536, "score": 24, "vote": 0, "content": "<p>Stupidly simple, based on <a href=\"https://stackoverflow.com/questions/287871/how-to-print-colored-text-in-python/287944#287944\">joeld's answer</a>:</p>\n<pre><code class=\"python\">class PrintInColor:\n    RED = '\\033[91m'\n    GREEN = '\\033[92m'\n    YELLOW = '\\033[93m'\n    LIGHT_PURPLE = '\\033[94m'\n    PURPLE = '\\033[95m'\n    END = '\\033[0m'\n\n    @classmethod\n    def red(cls, s, **kwargs):\n        print(cls.RED + s + cls.END, **kwargs)\n\n    @classmethod\n    def green(cls, s, **kwargs):\n        print(cls.GREEN + s + cls.END, **kwargs)\n\n    @classmethod\n    def yellow(cls, s, **kwargs):\n        print(cls.YELLOW + s + cls.END, **kwargs)\n\n    @classmethod\n    def lightPurple(cls, s, **kwargs):\n        print(cls.LIGHT_PURPLE + s + cls.END, **kwargs)\n\n    @classmethod\n    def purple(cls, s, **kwargs):\n        print(cls.PURPLE + s + cls.END, **kwargs)\n</code></pre>\n<p>Then just</p>\n<pre><code class=\"python\">PrintInColor.red('hello', end=' ')\nPrintInColor.green('world')\n</code></pre>\n", "abstract": "Stupidly simple, based on joeld's answer: Then just"}, {"id": 42528796, "score": 24, "vote": 0, "content": "<p>Building on <a href=\"https://stackoverflow.com/questions/287871/how-to-print-colored-text-in-python/287944#287944\">joeld's answer</a>, using <a href=\"https://pypi.python.org/pypi/lazyme\" rel=\"nofollow noreferrer\">https://pypi.python.org/pypi/lazyme</a> <br/>\n<code>pip install -U lazyme</code>:</p>\n<pre><code class=\"python\">from lazyme.string import color_print\n&gt;&gt;&gt; color_print('abc')\nabc\n&gt;&gt;&gt; color_print('abc', color='pink')\nabc\n&gt;&gt;&gt; color_print('abc', color='red')\nabc\n&gt;&gt;&gt; color_print('abc', color='yellow')\nabc\n&gt;&gt;&gt; color_print('abc', color='green')\nabc\n&gt;&gt;&gt; color_print('abc', color='blue', underline=True)\nabc\n&gt;&gt;&gt; color_print('abc', color='blue', underline=True, bold=True)\nabc\n&gt;&gt;&gt; color_print('abc', color='pink', underline=True, bold=True)\nabc\n</code></pre>\n<p>Screenshot:</p>\n<p><a href=\"https://i.stack.imgur.com/9NgeB.png\" rel=\"nofollow noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/9NgeB.png\"/></a></p>\n<hr/>\n<p>Some updates to the <code>color_print</code> with new formatters, e.g.:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from lazyme.string import palette, highlighter, formatter\n&gt;&gt;&gt; from lazyme.string import color_print\n&gt;&gt;&gt; palette.keys() # Available colors.\n['pink', 'yellow', 'cyan', 'magenta', 'blue', 'gray', 'default', 'black', 'green', 'white', 'red']\n&gt;&gt;&gt; highlighter.keys() # Available highlights.\n['blue', 'pink', 'gray', 'black', 'yellow', 'cyan', 'green', 'magenta', 'white', 'red']\n&gt;&gt;&gt; formatter.keys() # Available formatter,\n['hide', 'bold', 'italic', 'default', 'fast_blinking', 'faint', 'strikethrough', 'underline', 'blinking', 'reverse']\n</code></pre>\n<p>Note: <code>italic</code>, <code>fast blinking</code>, and <code>strikethrough</code> may not work on all terminals, and they don't work on Mac and Ubuntu.</p>\n<p>E.g.,</p>\n<pre><code class=\"python\">&gt;&gt;&gt; color_print('foo bar', color='pink', highlight='white')\nfoo bar\n&gt;&gt;&gt; color_print('foo bar', color='pink', highlight='white', reverse=True)\nfoo bar\n&gt;&gt;&gt; color_print('foo bar', color='pink', highlight='white', bold=True)\nfoo bar\n&gt;&gt;&gt; color_print('foo bar', color='pink', highlight='white', faint=True)\nfoo bar\n&gt;&gt;&gt; color_print('foo bar', color='pink', highlight='white', faint=True, reverse=True)\nfoo bar\n&gt;&gt;&gt; color_print('foo bar', color='pink', highlight='white', underline=True, reverse=True)\nfoo bar\n</code></pre>\n<p>Screenshot:</p>\n<p><a href=\"https://i.stack.imgur.com/HGNPc.png\" rel=\"nofollow noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/HGNPc.png\"/></a></p>\n", "abstract": "Building on joeld's answer, using https://pypi.python.org/pypi/lazyme \npip install -U lazyme: Screenshot:  Some updates to the color_print with new formatters, e.g.: Note: italic, fast blinking, and strikethrough may not work on all terminals, and they don't work on Mac and Ubuntu. E.g., Screenshot: "}, {"id": 11278750, "score": 23, "vote": 0, "content": "<p>Note how well the <code>with</code> keyword mixes with modifiers like these that need to be reset (using Python 3 and Colorama):</p>\n<pre><code class=\"python\">from colorama import Fore, Style\nimport sys\n\nclass Highlight:\n  def __init__(self, clazz, color):\n    self.color = color\n    self.clazz = clazz\n  def __enter__(self):\n    print(self.color, end=\"\")\n  def __exit__(self, type, value, traceback):\n    if self.clazz == Fore:\n      print(Fore.RESET, end=\"\")\n    else:\n      assert self.clazz == Style\n      print(Style.RESET_ALL, end=\"\")\n    sys.stdout.flush()\n\nwith Highlight(Fore, Fore.GREEN):\n  print(\"this is highlighted\")\nprint(\"this is not\")\n</code></pre>\n", "abstract": "Note how well the with keyword mixes with modifiers like these that need to be reset (using Python 3 and Colorama):"}, {"id": 8774709, "score": 21, "vote": 0, "content": "<p>You could use <a href=\"https://github.com/kennethreitz/clint\" rel=\"nofollow noreferrer\">Clint</a>:</p>\n<pre><code class=\"python\">from clint.textui import colored\nprint colored.red('some warning message')\nprint colored.green('nicely done!')\n</code></pre>\n", "abstract": "You could use Clint:"}, {"id": 287919, "score": 19, "vote": 0, "content": "<p>You can use the Python implementation of the <a href=\"https://en.wikipedia.org/wiki/Curses_%28programming_library%29\" rel=\"nofollow noreferrer\">curses</a> library:\n<em><a href=\"http://docs.python.org/library/curses.html\" rel=\"nofollow noreferrer\">curses \u2014 Terminal handling for character-cell displays</a></em></p>\n<p>Also, run this and you'll find your box:</p>\n<pre><code class=\"python\">for i in range(255):\n    print i, chr(i)\n</code></pre>\n", "abstract": "You can use the Python implementation of the curses library:\ncurses \u2014 Terminal handling for character-cell displays Also, run this and you'll find your box:"}, {"id": 64099955, "score": 17, "vote": 0, "content": "<h1>Emoji</h1>\n<p>You can use colors for text as others mentioned in their answers to have colorful text with a background or foreground color.</p>\n<p>But you can use <strong>emojis</strong> instead! for example, you can use<code>\u26a0\ufe0f</code> for warning messages and <code>\ud83d\uded1</code> for error messages.</p>\n<p>Or simply use these notebooks as a color:</p>\n<pre><code class=\"python\">\ud83d\udcd5: error message\n\ud83d\udcd9: warning message\n\ud83d\udcd7: ok status message\n\ud83d\udcd8: action message\n\ud83d\udcd3: canceled status message\n\ud83d\udcd4: Or anything you like and want to recognize immediately by color\n\n</code></pre>\n<h3>\ud83c\udf81 Bonus:</h3>\n<p>This method also helps you to quickly scan and find logs <strong>directly in the source code</strong>.</p>\n<p><sub>But some operating systems (including some Linux distributions in some version with some window managers) default emoji font is not colorful by default and you may want to make them colorful, first.</sub></p>\n<hr/>\n<h3>How to open emoji picker?</h3>\n<p><a href=\"https://support.apple.com/guide/mac-help/use-emoji-and-symbols-on-mac-mchlp1560/mac\" rel=\"noreferrer\"><strong>mac os</strong>:</a> <kbd>control</kbd> + <kbd>command</kbd> + <kbd>space</kbd></p>\n<p><a href=\"https://support.microsoft.com/en-us/windows/windows-10-keyboard-tips-and-tricks-588e0b72-0fff-6d3f-aeee-6e5116097942\" rel=\"noreferrer\"><strong>windows</strong>:</a> <kbd>win</kbd> + <kbd>.</kbd></p>\n<p><a href=\"https://www.omgubuntu.co.uk/2018/06/use-emoji-linux-ubuntu-apps\" rel=\"noreferrer\"><strong>linux</strong>:</a> <kbd>control</kbd> + <kbd>.</kbd> or  <kbd>control</kbd> + <kbd>;</kbd></p>\n", "abstract": "You can use colors for text as others mentioned in their answers to have colorful text with a background or foreground color. But you can use emojis instead! for example, you can use\u26a0\ufe0f for warning messages and \ud83d\uded1 for error messages. Or simply use these notebooks as a color: This method also helps you to quickly scan and find logs directly in the source code. But some operating systems (including some Linux distributions in some version with some window managers) default emoji font is not colorful by default and you may want to make them colorful, first. mac os: control + command + space windows: win + . linux: control + . or  control + ;"}, {"id": 287987, "score": 15, "vote": 0, "content": "<p>If you are programming a game perhaps you would like to change the background color and use only spaces? For example:</p>\n<pre><code class=\"python\">print \" \"+ \"\\033[01;41m\" + \" \" +\"\\033[01;46m\"  + \"  \" + \"\\033[01;42m\"\n</code></pre>\n", "abstract": "If you are programming a game perhaps you would like to change the background color and use only spaces? For example:"}, {"id": 50447424, "score": 15, "vote": 0, "content": "<p>An easier option would be to use the <code>cprint</code> function from the <a href=\"https://pypi.org/project/termcolor/\" rel=\"nofollow noreferrer\"><code>termcolor</code></a> package.</p>\n<p><a href=\"https://i.stack.imgur.com/v35jK.png\" rel=\"nofollow noreferrer\"><img alt=\"color-print-python\" src=\"https://i.stack.imgur.com/v35jK.png\"/></a></p>\n<p>It also supports <code>%s, %d</code> format of printing:</p>\n<p><a href=\"https://i.stack.imgur.com/BvgXH.png\" rel=\"nofollow noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/BvgXH.png\"/></a></p>\n<p>Results can be terminal dependant, so review the <strong>Terminal Properties</strong> section of the package documentation.</p>\n<ul>\n<li>Windows Command Prompt and Python IDLE don't work</li>\n</ul>\n<p><a href=\"https://i.stack.imgur.com/46mp4.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/46mp4.png\"/></a></p>\n<p><a href=\"https://i.stack.imgur.com/4A7ug.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/4A7ug.png\"/></a></p>\n<ul>\n<li>JupyterLab notebook does work</li>\n</ul>\n<p><a href=\"https://i.stack.imgur.com/kFhyO.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/kFhyO.png\"/></a></p>\n", "abstract": "An easier option would be to use the cprint function from the termcolor package.  It also supports %s, %d format of printing:  Results can be terminal dependant, so review the Terminal Properties section of the package documentation.   "}, {"id": 28388343, "score": 12, "vote": 0, "content": "<h2>YAY! Another version</h2>\n<p>While I find <a href=\"https://stackoverflow.com/a/26445590/3191896\">this answer</a> useful, I modified it a bit. This <a href=\"https://gist.github.com/Jossef/0ee20314577925b4027f\" rel=\"nofollow noreferrer\">GitHub Gist</a> is the result</p>\n<h3>Usage</h3>\n<pre><code class=\"python\">print colors.draw(\"i'm yellow\", bold=True, fg_yellow=True)\n</code></pre>\n<p><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/q1mJ3.png\"/></p>\n<p>In addition, you can wrap common usages:</p>\n<pre><code class=\"python\">print colors.error('sorry, ')\n</code></pre>\n<p><img alt=\"Asd\" src=\"https://i.stack.imgur.com/uGgd7.png\"/></p>\n<h3><a href=\"https://gist.github.com/Jossef/0ee20314577925b4027f\" rel=\"nofollow noreferrer\">https://gist.github.com/Jossef/0ee20314577925b4027f</a></h3>\n", "abstract": "While I find this answer useful, I modified it a bit. This GitHub Gist is the result  In addition, you can wrap common usages: "}, {"id": 11193790, "score": 11, "vote": 0, "content": "<p>If you are using Windows, then here you go!</p>\n<pre><code class=\"python\"># Display text on a Windows console\n# Windows XP with Python 2.7 or Python&amp;nbsp;3.2\nfrom ctypes import windll\n\n# Needed for Python2/Python3 diff\ntry:\n    input = raw_input\nexcept:\n    pass\nSTD_OUTPUT_HANDLE = -11\nstdout_handle = windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)\n# Look at the output and select the color you want.\n# For instance, hex E is yellow on black.\n# Hex 1E is yellow on blue.\n# Hex 2E is yellow on green and so on.\nfor color in range(0, 75):\n     windll.kernel32.SetConsoleTextAttribute(stdout_handle, color)\n     print(\"%X --&gt; %s\" % (color, \"Have a fine day!\"))\n     input(\"Press Enter to go on ... \")\n</code></pre>\n", "abstract": "If you are using Windows, then here you go!"}, {"id": 29806601, "score": 11, "vote": 0, "content": "<p>If you are using <a href=\"https://www.djangoproject.com/\" rel=\"nofollow noreferrer\">Django</a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from django.utils.termcolors import colorize\n&gt;&gt;&gt; print colorize(\"Hello, World!\", fg=\"blue\", bg='red',\n...                 opts=('bold', 'blink', 'underscore',))\nHello World!\n&gt;&gt;&gt; help(colorize)\n</code></pre>\n<p>Snapshot:</p>\n<p><img alt=\"Image\" src=\"https://i.stack.imgur.com/vq4Rs.png\"/></p>\n<p>(I generally use colored output for debugging on runserver terminal, so I added it.)</p>\n<p><sub>You can test if it is installed in your machine:\n<code>$ python -c \"import django; print django.VERSION\"</code>. To install it, check: <a href=\"https://docs.djangoproject.com/en/1.8/topics/install/\" rel=\"nofollow noreferrer\">How to install Django</a></sub></p>\n<p>Give it a <em>try</em>!!</p>\n", "abstract": "If you are using Django: Snapshot:  (I generally use colored output for debugging on runserver terminal, so I added it.) You can test if it is installed in your machine:\n$ python -c \"import django; print django.VERSION\". To install it, check: How to install Django Give it a try!!"}, {"id": 63551578, "score": 11, "vote": 0, "content": "<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import click\n\nclick.secho('Hello, World!', fg='green')\nclick.secho('Some more text', bg='blue', fg='white')\nclick.secho('ATTENTION', blink=True, bold=True)\n</code></pre>\n<p><a href=\"https://click.palletsprojects.com/en/7.x/utils/\" rel=\"nofollow noreferrer\"><code>click</code> (CLI library)</a> has a very convenient way of doing this, and is worth considering if you're writing a command-line tool, anyway.</p>\n", "abstract": "click (CLI library) has a very convenient way of doing this, and is worth considering if you're writing a command-line tool, anyway."}, {"id": 1073959, "score": 10, "vote": 0, "content": "<p>Here's a <a href=\"https://en.wikipedia.org/wiki/Curses_%28programming_library%29\" rel=\"nofollow noreferrer\">curses</a> example:</p>\n<pre><code class=\"python\">import curses\n\ndef main(stdscr):\n    stdscr.clear()\n    if curses.has_colors():\n        for i in xrange(1, curses.COLORS):\n            curses.init_pair(i, i, curses.COLOR_BLACK)\n            stdscr.addstr(\"COLOR %d! \" % i, curses.color_pair(i))\n            stdscr.addstr(\"BOLD! \", curses.color_pair(i) | curses.A_BOLD)\n            stdscr.addstr(\"STANDOUT! \", curses.color_pair(i) | curses.A_STANDOUT)\n            stdscr.addstr(\"UNDERLINE! \", curses.color_pair(i) | curses.A_UNDERLINE)\n            stdscr.addstr(\"BLINK! \", curses.color_pair(i) | curses.A_BLINK)\n            stdscr.addstr(\"DIM! \", curses.color_pair(i) | curses.A_DIM)\n            stdscr.addstr(\"REVERSE! \", curses.color_pair(i) | curses.A_REVERSE)\n    stdscr.refresh()\n    stdscr.getch()\n\nif __name__ == '__main__':\n    print \"init...\"\n    curses.wrapper(main)\n</code></pre>\n", "abstract": "Here's a curses example:"}, {"id": 15647557, "score": 10, "vote": 0, "content": "<p><a href=\"https://raw.github.com/fabric/fabric/master/fabric/colors.py\">https://raw.github.com/fabric/fabric/master/fabric/colors.py</a></p>\n<pre><code class=\"python\">\"\"\"\n.. versionadded:: 0.9.2\n\nFunctions for wrapping strings in ANSI color codes.\n\nEach function within this module returns the input string ``text``, wrapped\nwith ANSI color codes for the appropriate color.\n\nFor example, to print some text as green on supporting terminals::\n\n    from fabric.colors import green\n\n    print(green(\"This text is green!\"))\n\nBecause these functions simply return modified strings, you can nest them::\n\n    from fabric.colors import red, green\n\n    print(red(\"This sentence is red, except for \" + \\\n          green(\"these words, which are green\") + \".\"))\n\nIf ``bold`` is set to ``True``, the ANSI flag for bolding will be flipped on\nfor that particular invocation, which usually shows up as a bold or brighter\nversion of the original color on most terminals.\n\"\"\"\n\n\ndef _wrap_with(code):\n\n    def inner(text, bold=False):\n        c = code\n        if bold:\n            c = \"1;%s\" % c\n        return \"\\033[%sm%s\\033[0m\" % (c, text)\n    return inner\n\nred = _wrap_with('31')\ngreen = _wrap_with('32')\nyellow = _wrap_with('33')\nblue = _wrap_with('34')\nmagenta = _wrap_with('35')\ncyan = _wrap_with('36')\nwhite = _wrap_with('37')\n</code></pre>\n", "abstract": "https://raw.github.com/fabric/fabric/master/fabric/colors.py"}, {"id": 31310228, "score": 10, "vote": 0, "content": "<p>Yet another <a href=\"https://en.wikipedia.org/wiki/Python_Package_Index\" rel=\"nofollow noreferrer\">PyPI</a> module that wraps the Python\u00a03 <em>print</em> function:</p>\n<p><a href=\"https://pypi.python.org/pypi/colorprint\" rel=\"nofollow noreferrer\">https://pypi.python.org/pypi/colorprint</a></p>\n<p>It's usable in Python 2.x if you also <code>from __future__ import print</code>. Here is a Python\u00a02 example from the modules PyPI page:</p>\n<pre><code class=\"python\">from __future__ import print_function\nfrom colorprint import *\n\nprint('Hello', 'world', color='blue', end='', sep=', ')\nprint('!', color='red', format=['bold', 'blink'])\n</code></pre>\n<p>It outputs \"Hello, world!\" with the words in blue and the exclamation mark bold red and blinking.</p>\n", "abstract": "Yet another PyPI module that wraps the Python\u00a03 print function: https://pypi.python.org/pypi/colorprint It's usable in Python 2.x if you also from __future__ import print. Here is a Python\u00a02 example from the modules PyPI page: It outputs \"Hello, world!\" with the words in blue and the exclamation mark bold red and blinking."}, {"id": 37051472, "score": 10, "vote": 0, "content": "<p><a href=\"http://asciimatics.readthedocs.io/en/stable/intro.html\" rel=\"noreferrer\">asciimatics</a> provides a portable support for building text UI and animations:</p>\n<pre><code class=\"python\">#!/usr/bin/env python\nfrom asciimatics.effects import RandomNoise  # $ pip install asciimatics\nfrom asciimatics.renderers import SpeechBubble, Rainbow\nfrom asciimatics.scene import Scene\nfrom asciimatics.screen import Screen\nfrom asciimatics.exceptions import ResizeScreenError\n\n\ndef demo(screen):\n    render = Rainbow(screen, SpeechBubble('Rainbow'))\n    effects = [RandomNoise(screen, signal=render)]\n    screen.play([Scene(effects, -1)], stop_on_resize=True)\n\nwhile True:\n    try:\n        Screen.wrapper(demo)\n        break\n    except ResizeScreenError:\n        pass\n</code></pre>\n<p>Asciicast:</p>\n<p><a href=\"https://asciinema.org/a/06sabwtc1bw5wfiq23a71ccxq?autoplay=1\" rel=\"noreferrer\"><img alt=\"rainbow-colored text among ascii noise\" src=\"https://asciinema.org/a/06sabwtc1bw5wfiq23a71ccxq.png\"/></a></p>\n", "abstract": "asciimatics provides a portable support for building text UI and animations: Asciicast: "}, {"id": 66780271, "score": 10, "vote": 0, "content": "<p>If you want to use just built-in packages, follow this structure:</p>\n<p>Actually, I enhanced the <a href=\"https://stackoverflow.com/a/17064509/3702377\">Mohamed Samy</a> answer which is now responsible for multiple inputs as well as numbers. Also, it supports other <code>print()</code> arguments such as <code>end=</code>. Additionally, I added a <code>.store()</code> method in order to write down logs into a file as well.</p>\n<p>You can create a utility to use that anywhere into your codes:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># utility.py\n\nfrom datetime import datetime\n\nclass ColoredPrint:\n    def __init__(self):\n        self.PINK = '\\033[95m'\n        self.OKBLUE = '\\033[94m'\n        self.OKGREEN = '\\033[92m'\n        self.WARNING = '\\033[93m'\n        self.FAIL = '\\033[91m'\n        self.ENDC = '\\033[0m'\n\n    def disable(self):\n        self.PINK = ''\n        self.OKBLUE = ''\n        self.OKGREEN = ''\n        self.WARNING = ''\n        self.FAIL = ''\n        self.ENDC = ''\n\n    def store(self):\n        date = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        with open('logfile.log', mode='a') as file_:\n            file_.write(f\"{self.msg} -- {date}\")\n            file_.write(\"\\n\")\n\n    def success(self, *args, **kwargs):\n        self.msg = ' '.join(map(str, args))\n        print(self.OKGREEN + self.msg + self.ENDC, **kwargs)\n        return self\n\n    def info(self, *args, **kwargs):\n        self.msg = ' '.join(map(str, args))\n        print(self.OKBLUE + self.msg + self.ENDC, **kwargs)\n        return self\n\n    def warn(self, *args, **kwargs):\n        self.msg = ' '.join(map(str, args))\n        print(self.WARNING + self.msg + self.ENDC, **kwargs)\n        return self\n\n    def err(self, *args, **kwargs):\n        self.msg = ' '.join(map(str, args))\n        print(self.FAIL + self.msg + self.ENDC, **kwargs)\n        return self\n\n    def pink(self, *args, **kwargs):\n        self.msg = ' '.join(map(str, args))\n        print(self.PINK + self.msg + self.ENDC, **kwargs)\n        return self\n</code></pre>\n<p>e.g.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from utility import ColoredPrint\n\nlog = ColoredPrint()\n\nlog.success(\"Hello\" , 123, \"Bye\").store()\nlog.info(\"Hello\" , 123, \"Bye\")\nlog.warn(\"Hello\" , 123, \"Bye\")\nlog.err(\"Hello\" , 123, \"Bye\").store()\nlog.pink(\"Hello\" , 123, \"Bye\")\n</code></pre>\n<p>Out:</p>\n<p><a href=\"https://i.stack.imgur.com/HMVP6.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/HMVP6.png\"/></a></p>\n<hr/>\n<p>[UPDATE]:</p>\n<p>Now, its PyPI <a href=\"https://github.com/agn-7/colored-print\" rel=\"noreferrer\">package\ud83d\udd17</a> is available:</p>\n<pre class=\"lang-sh prettyprint-override\"><code class=\"python\">pip install python-colored-print\n</code></pre>\n", "abstract": "If you want to use just built-in packages, follow this structure: Actually, I enhanced the Mohamed Samy answer which is now responsible for multiple inputs as well as numbers. Also, it supports other print() arguments such as end=. Additionally, I added a .store() method in order to write down logs into a file as well. You can create a utility to use that anywhere into your codes: e.g. Out:  [UPDATE]: Now, its PyPI package\ud83d\udd17 is available:"}, {"id": 288030, "score": 7, "vote": 0, "content": "<h2>For the characters</h2>\n<p>Your terminal most probably uses Unicode (typically UTF-8 encoded) characters, so it's only a matter of the appropriate font selection to see your favorite character. Unicode char U+2588, \"Full block\" is the one I would suggest you use.</p>\n<p>Try the following:</p>\n<pre><code class=\"python\">import unicodedata\nfp= open(\"character_list\", \"w\")\nfor index in xrange(65536):\n    char= unichr(index)\n    try: its_name= unicodedata.name(char)\n    except ValueError: its_name= \"N/A\"\n    fp.write(\"%05d %04x %s %s\\n\" % (index, index, char.encode(\"UTF-8\"), its_name)\nfp.close()\n</code></pre>\n<p>Examine the file later with your favourite viewer.</p>\n<h2>For the colors</h2>\n<p><a href=\"http://www.python.org/doc/2.5.2/lib/module-curses.html\" rel=\"noreferrer\">curses</a> is the module you want to use. Check this <a href=\"http://docs.python.org/howto/curses.html\" rel=\"noreferrer\">tutorial</a>.</p>\n", "abstract": "Your terminal most probably uses Unicode (typically UTF-8 encoded) characters, so it's only a matter of the appropriate font selection to see your favorite character. Unicode char U+2588, \"Full block\" is the one I would suggest you use. Try the following: Examine the file later with your favourite viewer. curses is the module you want to use. Check this tutorial."}, {"id": 61219634, "score": 7, "vote": 0, "content": "<p>I suggest this new library <strong>Printy</strong>. They just released version 1.2.0 as a cross-platform library.</p>\n<p>Check it out:\n<a href=\"https://github.com/edraobdu/printy\" rel=\"nofollow noreferrer\">Printy on GitHub</a></p>\n<p>It is based on flags so you can do stuff like</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from printy import printy\n\n# With global flags, this will apply a bold (B) red (r) color and an underline (U) to the whole text\nprinty(\"Hello, World!\", \"rBU\")\n\n# With inline formats, this will apply a dim (D)\n#blue (b) to the word 'Hello' and a stroken (S)\n#yellow (y) to the word 'world', and the rest will remain as the predefined format\nprinty(\"this is a [bD]Hello@ [yS]world@ text\")\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/1YRLS.png\" rel=\"nofollow noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/1YRLS.png\"/></a></p>\n", "abstract": "I suggest this new library Printy. They just released version 1.2.0 as a cross-platform library. Check it out:\nPrinty on GitHub It is based on flags so you can do stuff like "}, {"id": 72752520, "score": 7, "vote": 0, "content": "<p>The <strong>simplest</strong> and <strong>convenient</strong> way of doing this, considering if you're writing a command-line tool.\nThis method will work anywhere on all consoles, without installing any fancy packages.</p>\n<p>To get the ANSI codes working on <strong>Windows</strong>, first, run <code>os.system('color')</code></p>\n<pre><code class=\"python\">import os\nos.system('color')\n\nCOLOR = '\\033[91m'  # change it, according to the color need\n\nEND = '\\033[0m'\n\nprint(COLOR + \"Hello World\" + END) #print a message\n\n\nexit=input() #to avoid closing the terminal windows\n</code></pre>\n<br/>\n<br/>\n<p><strong>For more colours</strong> :<br/></p>\n<p><a href=\"https://i.stack.imgur.com/7xsyK.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/7xsyK.png\"/></a></p>\n<p>Note: \\33[5m and \\33[6m are blinking.</p>\n<p>Thanks to @qubodup</p>\n", "abstract": "The simplest and convenient way of doing this, considering if you're writing a command-line tool.\nThis method will work anywhere on all consoles, without installing any fancy packages. To get the ANSI codes working on Windows, first, run os.system('color') For more colours :  Note: \\33[5m and \\33[6m are blinking. Thanks to @qubodup"}, {"id": 28159385, "score": 6, "vote": 0, "content": "<p>Use <a href=\"https://github.com/ilovecode1/pyfancy\" rel=\"nofollow noreferrer\">pyfancy</a>. It is a simple way to do color in the terminal!</p>\n<p>Example:</p>\n<pre><code class=\"python\">print(pyfancy.RED + \"Hello Red\" + pyfancy.END)\n</code></pre>\n", "abstract": "Use pyfancy. It is a simple way to do color in the terminal! Example:"}, {"id": 62530462, "score": 6, "vote": 0, "content": "<p>I created a project (<code>console-color</code>) and already published it to <a href=\"https://pypi.org/project/console-color/\" rel=\"nofollow noreferrer\">PyPI</a>.</p>\n<p>You can throw <code>pip install console-color</code> to install it.</p>\n<p>And I write the document with Sphinx-read-the-doc, see <a href=\"https://carsonslovoka.github.io/console-color/en/source/introduction.html\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>You can get more example from <a href=\"https://colab.research.google.com/drive/1cAYcC6DyiMCyD0RDcEo25LDFCh527TUQ?usp=sharing\" rel=\"nofollow noreferrer\">google-colab</a>.</p>\n<p>I still post some example to attract the user to click the above link:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># cprint is something like below\n# cprint(text: str, fore: T_RGB = None, bg: T_RGB = None, style: Style = '')\n# where T_RGB = Union[Tuple[int, int, int], str] for example. You can input (255, 0, 0) or '#ff0000' or 'ff0000'. They are OK.\n# The Style you can input the ``Style.`` (the IDE will help you to choose what you wanted)\n\n# from console_color import RGB, Fore, Style, cprint, create_print\nfrom console_color import *\n\ncprint(\"Hello, World!\", RGB.RED, RGB.YELLOW, Style.BOLD+Style.URL+Style.STRIKE)\ncprint(\"Hello, World!\", fore=(255, 0, 0), bg=\"ffff00\", style=Style.BOLD+Style.URL+Style.STRIKE)\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/ZzWF9.png\" rel=\"nofollow noreferrer\"><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/ZzWF9.png\"/></a></p>\n<p><em>Of course, you don\u2019t have to enter all the parameters. You can just add the attributes you want.</em></p>\n<hr/>\n<p>To be honest, this project is not special. It just uses the <code>f\"\\033[{target};2;{r};{g};{b}m{text}{style}\"</code>\nwhere target is 38 or 48, text is your input string, and style is '\\33[0m', '\\33[1m' ... '\\033[9m'. Some kind of stuff.</p>\n<p>And I just make it easy to use (at least for me).</p>\n", "abstract": "I created a project (console-color) and already published it to PyPI. You can throw pip install console-color to install it. And I write the document with Sphinx-read-the-doc, see here. You can get more example from google-colab. I still post some example to attract the user to click the above link:  Of course, you don\u2019t have to enter all the parameters. You can just add the attributes you want. To be honest, this project is not special. It just uses the f\"\\033[{target};2;{r};{g};{b}m{text}{style}\"\nwhere target is 38 or 48, text is your input string, and style is '\\33[0m', '\\33[1m' ... '\\033[9m'. Some kind of stuff. And I just make it easy to use (at least for me)."}, {"id": 68748316, "score": 5, "vote": 0, "content": "<p>I was moved there by google when I was looking how to color logs so:</p>\n<h1>coloredlogs</h1>\n<h2>Instalation</h2>\n<pre><code class=\"python\">pip install coloredlogs\n</code></pre>\n<h2>Usage</h2>\n<h5>Minimal usage:</h5>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">import logging\nimport coloredlogs\n\ncoloredlogs.install()  # install a handler on the root logger\n\nlogging.debug('message with level debug')\nlogging.info('message with level info')\nlogging.warning('message with level warning')\nlogging.error('message with level error')\nlogging.critical('message with level critical')\n</code></pre>\n<p>Results with:\n<a href=\"https://i.stack.imgur.com/A1axw.png\" rel=\"noreferrer\"><img alt=\"minimal usage\" src=\"https://i.stack.imgur.com/A1axw.png\"/></a></p>\n<h5>Start from message level debug:</h5>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">import logging\nimport coloredlogs\n\ncoloredlogs.install(level='DEBUG')  # install a handler on the root logger with level debug\n\nlogging.debug('message with level debug')\nlogging.info('message with level info')\nlogging.warning('message with level warning')\nlogging.error('message with level error')\nlogging.critical('message with level critical')\n</code></pre>\n<p>Results with:\n<a href=\"https://i.stack.imgur.com/S3AAi.png\" rel=\"noreferrer\"><img alt=\"debug level\" src=\"https://i.stack.imgur.com/S3AAi.png\"/></a></p>\n<h5>Hide messages from libraries:</h5>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">import logging\nimport coloredlogs\n\nlogger = logging.getLogger(__name__)  # get a specific logger object\ncoloredlogs.install(level='DEBUG')  # install a handler on the root logger with level debug\ncoloredlogs.install(level='DEBUG', logger=logger)  # pass a specific logger object\n\nlogging.debug('message with level debug')\nlogging.info('message with level info')\nlogging.warning('message with level warning')\nlogging.error('message with level error')\nlogging.critical('message with level critical')\n</code></pre>\n<p>Results with:\n<a href=\"https://i.stack.imgur.com/S3AAi.png\" rel=\"noreferrer\"><img alt=\"debug level\" src=\"https://i.stack.imgur.com/S3AAi.png\"/></a></p>\n<h5>Format log messages:</h5>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">import logging\nimport coloredlogs\n\nlogger = logging.getLogger(__name__)  # get a specific logger object\ncoloredlogs.install(level='DEBUG')  # install a handler on the root logger with level debug\ncoloredlogs.install(level='DEBUG', logger=logger)  # pass a specific logger object\ncoloredlogs.install(\n    level='DEBUG', logger=logger,\n    fmt='%(asctime)s.%(msecs)03d %(filename)s:%(lineno)d %(levelname)s %(message)s'\n)\n\nlogging.debug('message with level debug')\nlogging.info('message with level info')\nlogging.warning('message with level warning')\nlogging.error('message with level error')\nlogging.critical('message with level critical')\n</code></pre>\n<p>Results with:\n<a href=\"https://i.stack.imgur.com/0aBWR.png\" rel=\"noreferrer\"><img alt=\"format log messages\" src=\"https://i.stack.imgur.com/0aBWR.png\"/></a></p>\n<h5>Available format attributes:</h5>\n<ul>\n<li><code>%(asctime)s</code> - Time as human-readable string, when logging call was issued</li>\n<li><code>%(created)f</code> - Time as float when logging call was issued</li>\n<li><code>%(filename)s</code> - File name</li>\n<li><code>%(funcName)s</code> - Name of function containing the logging call</li>\n<li><code>%(hostname)s</code> - System hostname</li>\n<li><code>%(levelname)s</code> - Text logging level</li>\n<li><code>%(levelno)s</code> - Integer logging level</li>\n<li><code>%(lineno)d</code> - Line number where the logging call was issued</li>\n<li><code>%(message)s</code> - Message passed to logging call (same as <code>%(msg)s</code>)</li>\n<li><code>%(module)s</code> - File name without extension where the logging call was issued</li>\n<li><code>%(msecs)d</code> - Millisecond part of the time when logging call was issued</li>\n<li><code>%(msg)s</code> - Message passed to logging call (same as <code>%(message)s</code>)</li>\n<li><code>%(name)s</code> - Logger name</li>\n<li><code>%(pathname)s</code> - Full pathname to file containing the logging call</li>\n<li><code>%(process)d</code> - Process ID</li>\n<li><code>%(processName)s</code> - Process name</li>\n<li><code>%(programname)s</code> - System programname</li>\n<li><code>%(relativeCreated)d</code> - Time as integer in milliseconds when logging call was issued, relative to the time when logging module was loaded</li>\n<li><code>%(thread)d</code> -  Thread ID</li>\n<li><code>%(threadName)s</code> - Thread name</li>\n<li><code>%(username)s</code> - System username</li>\n</ul>\n<h2>Sources:</h2>\n<p><a href=\"https://pypi.org/project/coloredlogs/\" rel=\"noreferrer\">Coloredlogs package</a></p>\n<p><a href=\"https://docs.python.org/3/library/logging.html#logrecord-attributes\" rel=\"noreferrer\">Logging library</a></p>\n", "abstract": "I was moved there by google when I was looking how to color logs so: Results with:\n Results with:\n Results with:\n Results with:\n Coloredlogs package Logging library"}, {"id": 70599663, "score": 5, "vote": 0, "content": "<p>In <strong>windows 10</strong> you can try this tiny script, which works as a color mixer with values from 0-255 for Red, Green and blue:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import os\n\nos.system('')\n\n\ndef RGB(red=None, green=None, blue=None,bg=False):\n    if(bg==False and red!=None and green!=None and blue!=None):\n        return f'\\u001b[38;2;{red};{green};{blue}m'\n    elif(bg==True and red!=None and green!=None and blue!=None):\n        return f'\\u001b[48;2;{red};{green};{blue}m'\n    elif(red==None and green==None and blue==None):\n        return '\\u001b[0m'\n</code></pre>\n<p>and call the RGB function to make any combination of colors as:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">g0 = RGB()\ng1 = RGB(0,255,0)\ng2 = RGB(0,100,0,True)+\"\"+RGB(100,255,100)\ng3 = RGB(0,255,0,True)+\"\"+RGB(0,50,0)\n\nprint(f\"{g1}green1{g0}\")\nprint(f\"{g2}green2{g0}\")\nprint(f\"{g3}green3{g0}\")\n</code></pre>\n<p><code>RGB()</code> with no parameter will cleanup and set the <strong>foreground/background</strong> color to <strong>default</strong>. In case you want <strong>black</strong> you should call it as <code>RGB(0,0,0)</code> and for <strong>white</strong> <code>RGB(255,255,255)</code>. While <code>RGB(0,255,0)</code> creates <strong>absolute green</strong> <code>RGB(150,255,150)</code> will produce <strong>light green</strong>.</p>\n<p>This supports <strong>background</strong> &amp; <strong>foreground</strong> color, to set the color as <strong>background color</strong> you must pass it with <code>bg=True</code> which is <code>False</code> by default.</p>\n<p>For Example: To set <strong>red</strong> as the <strong>background color</strong> it should be called as <code>RGB(255,0,0,True)</code> but to choose <strong>red</strong> as <strong>font color</strong> just call it as <code>RGB(255,0,0,False)</code> since <code>bg</code> is by default <code>False</code> this simplifies to just call it as <code>RGB(255,0,0)</code></p>\n", "abstract": "In windows 10 you can try this tiny script, which works as a color mixer with values from 0-255 for Red, Green and blue: and call the RGB function to make any combination of colors as: RGB() with no parameter will cleanup and set the foreground/background color to default. In case you want black you should call it as RGB(0,0,0) and for white RGB(255,255,255). While RGB(0,255,0) creates absolute green RGB(150,255,150) will produce light green. This supports background & foreground color, to set the color as background color you must pass it with bg=True which is False by default. For Example: To set red as the background color it should be called as RGB(255,0,0,True) but to choose red as font color just call it as RGB(255,0,0,False) since bg is by default False this simplifies to just call it as RGB(255,0,0)"}, {"id": 7839185, "score": 4, "vote": 0, "content": "<p>I wrote a simple module, available at:\n<a href=\"http://pypi.python.org/pypi/colorconsole\" rel=\"nofollow\">http://pypi.python.org/pypi/colorconsole</a></p>\n<p>It works with Windows, Mac OS X and Linux.\nIt uses ANSI for Linux and Mac, but native calls to console functions on Windows.\nYou have colors, cursor positioning and keyboard input. It is not a replacement for curses, but can be very useful if you need to use in simple scripts or ASCII games.</p>\n", "abstract": "I wrote a simple module, available at:\nhttp://pypi.python.org/pypi/colorconsole It works with Windows, Mac OS X and Linux.\nIt uses ANSI for Linux and Mac, but native calls to console functions on Windows.\nYou have colors, cursor positioning and keyboard input. It is not a replacement for curses, but can be very useful if you need to use in simple scripts or ASCII games."}, {"id": 26695185, "score": 4, "vote": 0, "content": "<p>I wrote a module that handles colors in Linux, OS\u00a0X, and Windows. It supports all 16 colors on all platforms, you can set foreground and background colors at different times, and the string objects give sane results for things like len() and .capitalize().</p>\n<p><a href=\"https://github.com/Robpol86/colorclass\" rel=\"nofollow noreferrer\">https://github.com/Robpol86/colorclass</a></p>\n<p><img alt=\"Example on Windows cmd.exe\" src=\"https://i.stack.imgur.com/j7EjM.png\"/></p>\n", "abstract": "I wrote a module that handles colors in Linux, OS\u00a0X, and Windows. It supports all 16 colors on all platforms, you can set foreground and background colors at different times, and the string objects give sane results for things like len() and .capitalize(). https://github.com/Robpol86/colorclass "}, {"id": 52032616, "score": 4, "vote": 0, "content": "<p>I am new to Python and I'm excited every time I discover topics, like this one. But this time (suddenly) I feel like I have what to say. Especially because a few minutes ago I discovered a <em>wow</em> thing in Python (at least for me now):</p>\n<p><a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager\" rel=\"nofollow noreferrer\"><strong>Context Managers</strong></a></p>\n<pre><code class=\"python\">from contextlib import contextmanager\n# FORECOLOR\nBLACKFC,REDFC,GREENFC,YELLOWFC,BLUEFC = '38;30m','38;31m','38;32m','38;33m','38;34m'\n# BACKGOUND\nBLACKBG,REDBG,GREENBG,YELLOWBG,BLUEBG = '48;40m','48;41m','48;42m','48;43m','48;44m'\n\n@contextmanager\ndef printESC(prefix, color, text):\n  print(\"{prefix}{color}{text}\".format(prefix=prefix, color=color, text=text), end='')\n  yield\n  print(\"{prefix}0m\".format(prefix=prefix))\n\nwith printESC('\\x1B[', REDFC, 'Colored Text'):\n  pass\n</code></pre>\n<p><a href=\"https://repl.it/@VoldemarShalomo/Escape-sequences-for-visual-effects-in-terminal\" rel=\"nofollow noreferrer\">Example</a></p>\n<p>Or just like this:</p>\n<pre><code class=\"python\"># FORECOLOR\nBLACKFC,REDFC,GREENFC,YELLOWFC,BLUEFC = '38;30m','38;31m','38;32m','38;33m','38;34m'\n# BACKGOUND\nBLACKBG,REDBG,GREENBG,YELLOWBG,BLUEBG = '48;40m','48;41m','48;42m','48;43m','48;44m'\n\ndef printESC(prefix, color, text):\n  print(\"{prefix}{color}{text}\".format(prefix=prefix, color=color, text=text), end='')\n  print(\"{prefix}0m\".format(prefix=prefix))\n\nprintESC('\\x1B[', REDFC, 'Colored Text')\n</code></pre>\n", "abstract": "I am new to Python and I'm excited every time I discover topics, like this one. But this time (suddenly) I feel like I have what to say. Especially because a few minutes ago I discovered a wow thing in Python (at least for me now): Context Managers Example Or just like this:"}, {"id": 59274139, "score": 4, "vote": 0, "content": "<p>The simplest way I can find is not to use ANSI escape codes, but use <code>Fore</code> from import module <code>colorama</code>. Take a look at the code below:</p>\n<pre><code class=\"python\">from colorama import Fore, Style\n\nprint(Fore.MAGENTA + \"IZZ MAGENTA BRUH.\")\n\nprint(Style.RESET_ALL + \"IZZ BACK TO NORMALZ.\")\n</code></pre>\n<p>compared to the ANSI escape code:</p>\n<pre><code class=\"python\">print(\"\\u001b[31m IZZ RED (NO MAGENTA ON ANSI CODES).\\u001b[0m\")\n\nprint(\"BACK TO NORMALZ.\")\n</code></pre>\n", "abstract": "The simplest way I can find is not to use ANSI escape codes, but use Fore from import module colorama. Take a look at the code below: compared to the ANSI escape code:"}, {"id": 60252056, "score": 4, "vote": 0, "content": "<p>Here is a simple function I use to print a text message in color without having to remember ANSI codes but rather using standard RGB tuples to define the foreground and background colors.</p>\n<pre><code class=\"python\">def print_in_color(txt_msg, fore_tuple, back_tuple, ):\n    # Prints the text_msg in the foreground color specified by fore_tuple with the background specified by back_tuple\n    # text_msg is the text, fore_tuple is foreground color tuple (r,g,b), back_tuple is background tuple (r,g,b)\n    rf,bf,gf = fore_tuple\n    rb,gb,bb = back_tuple\n    msg = '{0}' + txt_msg\n    mat = '\\33[38;2;' + str(rf) + ';' + str(gf) + ';' + str(bf) + ';48;2;' + str(rb) + ';' +str(gb) + ';' + str(bb) + 'm'\n    print(msg .format(mat))\n    print('\\33[0m') # Returns default print color to back to black\n\n# Example of use using a message with variables\nfore_color = 'cyan'\nback_color = 'dark green'\nmsg = 'foreground color is {0} and the background color is {1}'.format(fore_color, back_color)\nprint_in_color(msg, (0,255,255), (0,127,127))\n</code></pre>\n", "abstract": "Here is a simple function I use to print a text message in color without having to remember ANSI codes but rather using standard RGB tuples to define the foreground and background colors."}, {"id": 65475628, "score": 4, "vote": 0, "content": "<pre class=\"lang-py prettyprint-override\"><code class=\"python\">print(\"\\033[1;32;40m Bright Green  \\n\")\n</code></pre>\n<p><img alt=\"1\" src=\"https://i.stack.imgur.com/esbQu.png\"/></p>\n", "abstract": ""}, {"id": 11178541, "score": 3, "vote": 0, "content": "<p>To address this problem I created a mind-numbingly simple package to print strings with interpolated color codes, called <a href=\"https://github.com/brianmhunt/icolor\" rel=\"nofollow\">icolor</a>.</p>\n<p>icolor includes two functions: <code>cformat</code> and <code>cprint</code>, each of which takes a string with substrings that are interpolated to map to ANSI escape sequences e.g.</p>\n<pre><code class=\"python\">from icolor import cformat # there is also cprint\n\ncformat(\"This is #RED;a red string, partially with a #xBLUE;blue background\")\n'This is \\x1b[31ma red string, partially with a \\x1b[44mblue background\\x1b[0m'\n</code></pre>\n<p>All the ANSI colors are included (e.g. <code>#RED;</code>, <code>#BLUE;</code>, etc.), as well as <code>#RESET;</code>, <code>#BOLD;</code> and others.</p>\n<p>Background colors have an <code>x</code> prefix, so a green background would be <code>#xGREEN;</code>.</p>\n<p>One can escape <code>#</code> with <code>##</code>.</p>\n<p>Given its simplicity, the best documentation is probably <a href=\"https://github.com/brianmhunt/icolor/blob/master/icolor.py\" rel=\"nofollow\">the code itself</a>.</p>\n<p>It is <a href=\"http://pypi.python.org/pypi/icolor/1.0\" rel=\"nofollow\">on PYPI</a>, so one can <code>sudo easy_install icolor</code>.</p>\n", "abstract": "To address this problem I created a mind-numbingly simple package to print strings with interpolated color codes, called icolor. icolor includes two functions: cformat and cprint, each of which takes a string with substrings that are interpolated to map to ANSI escape sequences e.g. All the ANSI colors are included (e.g. #RED;, #BLUE;, etc.), as well as #RESET;, #BOLD; and others. Background colors have an x prefix, so a green background would be #xGREEN;. One can escape # with ##. Given its simplicity, the best documentation is probably the code itself. It is on PYPI, so one can sudo easy_install icolor."}, {"id": 27233961, "score": 3, "vote": 0, "content": "<p>You can use shell escape characters that are available from any language.\nThese escape characters start with the ESC character followed by a number of arguments.</p>\n<p>For example, to output a red <em>\"Hello, World!\"</em> string in your terminal:</p>\n<pre><code class=\"python\">echo \"\\e[31m Hello, World! \\e[0m\"\n</code></pre>\n<p>Or from a Python script:</p>\n<pre><code class=\"python\">print(\"\\e[31m Hello world \\e[0m\")\n</code></pre>\n<p>Also, I wrote an article about <a href=\"http://shiroyasha.github.io/escape-sequences-a-quick-guide.html\" rel=\"nofollow noreferrer\">Escape sequences</a> that can probably help you get a better grasp of this mechanism.</p>\n", "abstract": "You can use shell escape characters that are available from any language.\nThese escape characters start with the ESC character followed by a number of arguments. For example, to output a red \"Hello, World!\" string in your terminal: Or from a Python script: Also, I wrote an article about Escape sequences that can probably help you get a better grasp of this mechanism."}, {"id": 69050278, "score": 3, "vote": 0, "content": "<p>You could use the <code>pygments</code> module to do this. For example:</p>\n<pre><code class=\"python\">from pygments import console\nprint(pygments.console.colorize(\"red\", \"This text is red.\"))\n</code></pre>\n<p>This doesn't allow you to provide a hexadecimal color for the terminal, but there are many built-in colors that you can try, like \"blue\", \"darkgreen\", \"yellow\", etc.</p>\n", "abstract": "You could use the pygments module to do this. For example: This doesn't allow you to provide a hexadecimal color for the terminal, but there are many built-in colors that you can try, like \"blue\", \"darkgreen\", \"yellow\", etc."}, {"id": 72768499, "score": 3, "vote": 0, "content": "<p>Minimal Class:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class log:\n    f = lambda color: lambda string: print(color + string + \"\\33[0m\")\n\n    black = f(\"\\33[30m\")\n    red = f(\"\\33[31m\")\n    green = f(\"\\33[32m\")\n    yellow = f(\"\\33[33m\")\n    blue = f(\"\\33[34m\")\n    megenta = f(\"\\33[35m\")\n    cyan = f(\"\\33[36m\")\n    white = f(\"\\33[37m\")\n\n# Usage\nlog.blue(\"Blue World!\")\n</code></pre>\n", "abstract": "Minimal Class:"}, {"id": 18923126, "score": 2, "vote": 0, "content": "<p>My two cents (<a href=\"https://github.com/dnmellen/pycolorterm\" rel=\"nofollow\">PyColorTerm</a>):</p>\n<p>Installation:</p>\n<pre><code class=\"python\">sudo apt-get install python-pip\npip install pycolorterm\n</code></pre>\n<p>Python script:</p>\n<pre><code class=\"python\">from pycolorterm import pycolorterm\n\nwith pycolorterm.pretty_output(pycolorterm.FG_GREEN) as out:\n    out.write('Works OK!')\n</code></pre>\n<p>\"works OK!\" shows in green.</p>\n", "abstract": "My two cents (PyColorTerm): Installation: Python script: \"works OK!\" shows in green."}, {"id": 65238905, "score": 2, "vote": 0, "content": "<p>Some of the solutions like:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">fg = lambda text, color: \"\\33[38;5;\" + str(color) + \"m\" + text + \"\\33[0m\"\nbg = lambda text, color: \"\\33[48;5;\" + str(color) + \"m\" + text + \"\\33[0m\"\n\ndef print_six(row, format, end=\"\\n\"):\n    for col in range(6):\n        color = row*6 + col - 2\n        if color&gt;=0:\n            text = \"{:3d}\".format(color)\n            print (format(text,color), end=\" \")\n        else:\n            print(end=\"    \")   # Four spaces\n    print(end=end)\n\nfor row in range(0, 43):\n    print_six(row, fg, \" \")\n    print_six(row, bg)\n\nprint(fg(\"text\", 160))\n\n</code></pre>\n<p><strong>OR</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def colored(r, g, b, text):\n    return \"\\033[38;2;{};{};{}m{} \\033[38;2;255;255;255m\".format(r, g, b, text)\n\n\ntext = 'Hello, World!'\ncolored_text = colored(255, 0, 0, text)\nprint(colored_text)\n\n</code></pre>\n<p><strong>OR</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">class Color:\n    COLOR = [f\"\\33[{i}m\" for i in range(44)]\n\nfor i in range(44):\n    print(Color.COLOR[i] + 'text')\n\n</code></pre>\n<p><strong>might not work</strong> on Windows 10 terminals or PowerShell windows or their might be other cases where these might not work directly.</p>\n<p>But on inserting, these two small lines at the beginning of the program might help:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import os\nos.system('')\n</code></pre>\n<p><code>os.system('')</code> allows you to print ANSI codes in the Terminal which colors your output according to your choice (but there can be other system specific functions that you might need to call, to be able to print colored text in terminal).</p>\n", "abstract": "Some of the solutions like: OR OR might not work on Windows 10 terminals or PowerShell windows or their might be other cases where these might not work directly. But on inserting, these two small lines at the beginning of the program might help: os.system('') allows you to print ANSI codes in the Terminal which colors your output according to your choice (but there can be other system specific functions that you might need to call, to be able to print colored text in terminal)."}, {"id": 68132906, "score": 2, "vote": 0, "content": "<p>This answer attempts to expand the concept of writing colorized text to the terminal by using a <em>regular expression</em> to colorize keywords in a block of text.</p>\n<p>This answer also use the <em>Python</em> library <a href=\"https://github.com/willmcgugan/rich\" rel=\"nofollow noreferrer\">Rich</a>, which was briefly covered in a previous answer to this question.  In this answer I use the function <em>rich.color.ANSI_COLOR_NAMES</em> to obtain a random list of colors that will be used to highlight predefined search terms.</p>\n<pre><code class=\"python\">import random\nimport re as regex\nfrom rich import color\nfrom rich import print\n\n\ndef create_dynamic_regex(search_words):\n    \"\"\"\n    This function is used to create a dynamic regular expression\n    string and a list of random colors. Both these elements will\n    be used in the function colorize_text()\n\n    :param search_words: list of search terms\n    :return: regular expression search string and a list of colors\n    :rtype: string, list\n    \"\"\"\n    colors_required = create_list_of_colors(len(search_words))\n    number_of_search_words = len(search_words)\n    combined_string = ''\n    for search_word in search_words:\n        number_of_search_words -= 1\n        if number_of_search_words != 0:\n            current_string = ''.join(r'(\\b' + search_word + r'\\b)|')\n            combined_string = (combined_string + current_string)\n        elif number_of_search_words == 0:\n            current_string = ''.join(r'(\\b' + search_word + r'\\b)')\n            combined_string = (combined_string + current_string)\n    return combined_string, colors_required\n\n\ndef random_color():\n    \"\"\"\n    This function is used to create a random color using the\n    Python package rich.\n    :return: color name\n    :rtype: string\n    \"\"\"\n    selected_color = random.choice(list(color.ANSI_COLOR_NAMES.keys()))\n    return selected_color\n\n\ndef create_list_of_colors(number_of_colors):\n    \"\"\"\n    This function is used to generate a list of colors,\n    which will be used in the function colorize_text()\n    :param number_of_colors:\n    :return: list of colors\n    :rtype: list\n    \"\"\"\n    list_of_colors = [random_color() for _ in range(number_of_colors)]\n    return list_of_colors\n\n\ndef colorize_text(text, regex_string, array_of_colors):\n    \"\"\"\n    This function is used to colorize specific words in a text string.\n    :param text: text string potentially containing specific words to colorize.\n    :param regex_string: regular expression search string\n    :param array_of_colors: list of colors\n    :return: colorized text\n    :rtype: string\n    \"\"\"\n    available_colors = array_of_colors\n    word_regex = regex.compile(f\"{regex_string}\", regex.IGNORECASE)\n    i = 0\n    output = \"\"\n    for word in word_regex.finditer(text):\n        get_color = available_colors[word.lastindex - 1]\n        output += \"\".join([text[i:word.start()],\n                           \"[%s]\" % available_colors[word.lastindex - 1],\n                           text[word.start():word.end()], \"[/%s]\" % available_colors[word.lastindex - 1]])\n        i = word.end()\n    return ''.join([output, text[word.end():]])\n\n\ndef generate_console_output(text_to_search, words_to_find):\n    \"\"\"\n    This function is used generate colorized text that will\n    be outputting to the console.\n\n    :param text_to_search: text string potentially containing specific words to colorize.\n    :param words_to_find: list of search terms.\n    :return: A string containing colorized words.\n    :rtype: string\n    \"\"\"\n    search_terms, colors = create_dynamic_regex(words_to_find)\n    colorize_html = colorize_text(text_to_search, search_terms, colors)\n    print(colorize_html)\n\n\ntext = \"The dog chased the cat that was looking for the mouse that the dog was playing with.\"\nwords = ['dog', 'cat', 'mouse']\ngenerate_console_output(text, words)\n</code></pre>\n<p>Here is the print output from the code above:</p>\n<p><a href=\"https://i.stack.imgur.com/Z3qX4.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Z3qX4.png\"/></a></p>\n<p>I created two GISTs for colorizing text.</p>\n<ul>\n<li><a href=\"https://gist.github.com/johnbumgarner/035fd1dda6044a03cefca0ea1d66fbec\" rel=\"nofollow noreferrer\">colorized text terminal output</a></li>\n<li><a href=\"https://gist.github.com/johnbumgarner/5f7139b00bff22d9faa6a2badcc824fe#file-colorize_keywords_in_text_html_output-py\" rel=\"nofollow noreferrer\">colorized text HTML output</a></li>\n</ul>\n", "abstract": "This answer attempts to expand the concept of writing colorized text to the terminal by using a regular expression to colorize keywords in a block of text. This answer also use the Python library Rich, which was briefly covered in a previous answer to this question.  In this answer I use the function rich.color.ANSI_COLOR_NAMES to obtain a random list of colors that will be used to highlight predefined search terms. Here is the print output from the code above:  I created two GISTs for colorizing text."}, {"id": 73036565, "score": 2, "vote": 0, "content": "<p>There is a more efficient way here.</p>\n<pre><code class=\"python\"># Colours\npure_red = \"\\033[0;31m\"\ndark_green = \"\\033[0;32m\"\norange = \"\\033[0;33m\"\ndark_blue = \"\\033[0;34m\"\nbright_purple = \"\\033[0;35m\"\ndark_cyan = \"\\033[0;36m\"\ndull_white = \"\\033[0;37m\"\npure_black = \"\\033[0;30m\"\nbright_red = \"\\033[0;91m\"\nlight_green = \"\\033[0;92m\"\nyellow = \"\\033[0;93m\"\nbright_blue = \"\\033[0;94m\"\nmagenta = \"\\033[0;95m\"\nlight_cyan = \"\\033[0;96m\"\nbright_black = \"\\033[0;90m\"\nbright_white = \"\\033[0;97m\"\ncyan_back = \"\\033[0;46m\"\npurple_back = \"\\033[0;45m\"\nwhite_back = \"\\033[0;47m\"\nblue_back = \"\\033[0;44m\"\norange_back = \"\\033[0;43m\"\ngreen_back = \"\\033[0;42m\"\npink_back = \"\\033[0;41m\"\ngrey_back = \"\\033[0;40m\"\ngrey = '\\033[38;4;236m'\nbold = \"\\033[1m\"\nunderline = \"\\033[4m\"\nitalic = \"\\033[3m\"\ndarken = \"\\033[2m\"\ninvisible = '\\033[08m'\nreverse_colour = '\\033[07m'\nreset_colour = '\\033[0m'\ngrey = \"\\x1b[90m\"\n</code></pre>\n<h3>User Manual</h3>\n<ul>\n<li><p><code>reverse_colour</code> means that you reverse the colour that you just chose but in highlight mode (default is white).</p>\n</li>\n<li><p><code>pink_back</code> (<code>green_back</code> etc... those with back) means that it is highlighted in pink (based on the name).</p>\n</li>\n<li><p><code>reset_colour</code> resets the colour (see picture 1 for more details).</p>\n</li>\n</ul>\n<p>I believe I don't need to explain much more as it is listed at the <em>variable name</em>.</p>\n<p>If you wish to try the code, please go to <a href=\"http://www.replit.com\" rel=\"nofollow noreferrer\">replit</a> IDE to test the code. The sample code is <a href=\"https://replit.com/@indexaker/Trial#main.py\" rel=\"nofollow noreferrer\">here</a></p>\n<hr/>\n<p>Code (Picture 1):</p>\n<p><a href=\"https://i.stack.imgur.com/7hifz.png\" rel=\"nofollow noreferrer\"><img alt=\"My coding\" src=\"https://i.stack.imgur.com/7hifz.png\"/></a></p>\n<p>Output (Picture 2):</p>\n<p><a href=\"https://i.stack.imgur.com/E652Q.png\" rel=\"nofollow noreferrer\"><img alt=\"Code output\" src=\"https://i.stack.imgur.com/E652Q.png\"/></a></p>\n", "abstract": "There is a more efficient way here. reverse_colour means that you reverse the colour that you just chose but in highlight mode (default is white). pink_back (green_back etc... those with back) means that it is highlighted in pink (based on the name). reset_colour resets the colour (see picture 1 for more details). I believe I don't need to explain much more as it is listed at the variable name. If you wish to try the code, please go to replit IDE to test the code. The sample code is here Code (Picture 1):  Output (Picture 2): "}, {"id": 73158800, "score": 0, "vote": 0, "content": "<p>I wrote a library which is available on PyPI, with a simple API that follows the standard print function.</p>\n<p>You can install it with <code>pip install coloring</code>.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import coloring\n\n# Directly use print-like functions\ncoloring.print_red('Hello', 12)\ncoloring.print_green('Hey', end=\"\", sep=\";\")\nprint()\n\n# Get str as return\nprint(coloring.red('hello'))\n\n# Use the generic colorize function\nprint(coloring.colorize(\"I'm red\", \"red\")) # Using color names\nprint(coloring.colorize(\"I'm green\", (0, 255, 0)))  # Using RGB colors\nprint(coloring.colorize(\"I'm blue\", \"#0000ff\"))  # Using hex colors\n\n# Or using styles (underline, bold, italic, ...)\nprint(coloring.colorize('Hello', 'red', s='ub'))  # underline and bold\n\n</code></pre>\n<p>Executed code:</p>\n<p><a href=\"https://i.stack.imgur.com/4lCwT.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/4lCwT.png\"/></a></p>\n<p>You can check all the features here: <a href=\"https://github.com/Nazime/coloring\" rel=\"nofollow noreferrer\">https://github.com/Nazime/coloring</a>.</p>\n", "abstract": "I wrote a library which is available on PyPI, with a simple API that follows the standard print function. You can install it with pip install coloring. Executed code:  You can check all the features here: https://github.com/Nazime/coloring."}, {"id": 73917459, "score": 0, "vote": 0, "content": "<p>as a fan of the RGB standard, I would do it like this:</p>\n<pre><code class=\"python\">def color_text(text, rgb):\n    r, g, b = rgb\n    return f\"\\033[38;2;{r};{g};{b}m{text}\\033[0m\"\n\nclass rgb():\n    BLACK = (0, 0, 0)\n    RED = (255, 0, 0)\n    GREEN = (0, 255, 0)\n    BLUE = (0, 0, 255)\n    YELLOW = (255, 255, 0)\n    # and so on ...\n\nprint(color_text(\"hello colored world\", rgb.GREEN))\n</code></pre>\n<p><em>PS: strongly inspired by CircuitSacul's answer</em></p>\n", "abstract": "as a fan of the RGB standard, I would do it like this: PS: strongly inspired by CircuitSacul's answer"}]}, {"link": "https://stackoverflow.com/questions/4906977/how-do-i-access-environment-variables-in-python", "question": {"id": "4906977", "title": "How do I access environment variables in Python?", "content": "<p>How do I get the value of an environment variable in Python?</p>\n", "abstract": "How do I get the value of an environment variable in Python?"}, "answers": [{"id": 4907053, "score": 4170, "vote": 0, "content": "<p>Environment variables are accessed through <a href=\"https://docs.python.org/library/os.html#os.environ\" rel=\"noreferrer\"><code>os.environ</code></a>:</p>\n<pre><code class=\"python\">import os\nprint(os.environ['HOME'])\n</code></pre>\n<p>To see a list of all environment variables:</p>\n<pre><code class=\"python\">print(os.environ)\n</code></pre>\n<hr/>\n<p>If a key is not present, attempting to access it will raise a <code>KeyError</code>. To avoid this:</p>\n<pre><code class=\"python\"># Returns `None` if key doesn't exist\nprint(os.environ.get('KEY_THAT_MIGHT_EXIST'))\n\n# Returns `default_value` if key doesn't exist\nprint(os.environ.get('KEY_THAT_MIGHT_EXIST', default_value))\n\n# Returns `default_value` if key doesn't exist\nprint(os.getenv('KEY_THAT_MIGHT_EXIST', default_value))\n</code></pre>\n", "abstract": "Environment variables are accessed through os.environ: To see a list of all environment variables: If a key is not present, attempting to access it will raise a KeyError. To avoid this:"}, {"id": 11447648, "score": 324, "vote": 0, "content": "<p>To check if the key exists (returns <code>True</code> or <code>False</code>)</p>\n<pre><code class=\"python\">'HOME' in os.environ\n</code></pre>\n<p>You can also use <code>get()</code> when printing the key; useful if you want to use a default.</p>\n<pre><code class=\"python\">print(os.environ.get('HOME', '/home/username/'))\n</code></pre>\n<p>where <code>/home/username/</code> is the default</p>\n", "abstract": "To check if the key exists (returns True or False) You can also use get() when printing the key; useful if you want to use a default. where /home/username/ is the default"}, {"id": 49211023, "score": 76, "vote": 0, "content": "<p>Actually it can be done this way:</p>\n<pre><code class=\"python\">import os\n\nfor item, value in os.environ.items():\n    print('{}: {}'.format(item, value))\n</code></pre>\n<p>Or simply:</p>\n<pre><code class=\"python\">for i, j in os.environ.items():\n    print(i, j)\n</code></pre>\n<p>For viewing the value in the parameter:</p>\n<pre><code class=\"python\">print(os.environ['HOME'])\n</code></pre>\n<p>Or:</p>\n<pre><code class=\"python\">print(os.environ.get('HOME'))\n</code></pre>\n<p>To set the value:</p>\n<pre><code class=\"python\">os.environ['HOME'] = '/new/value'\n</code></pre>\n", "abstract": "Actually it can be done this way: Or simply: For viewing the value in the parameter: Or: To set the value:"}, {"id": 9926915, "score": 74, "vote": 0, "content": "<p>Here's how to check if <code>$FOO</code> is set:</p>\n<pre><code class=\"python\">try:  \n   os.environ[\"FOO\"]\nexcept KeyError: \n   print \"Please set the environment variable FOO\"\n   sys.exit(1)\n</code></pre>\n", "abstract": "Here's how to check if $FOO is set:"}, {"id": 4907002, "score": 60, "vote": 0, "content": "<p>You can access the environment variables using</p>\n<pre><code class=\"python\">import os\nprint os.environ\n</code></pre>\n<p>Try to see the content of the PYTHONPATH or PYTHONHOME environment variables. Maybe this will be helpful for your second question.</p>\n", "abstract": "You can access the environment variables using Try to see the content of the PYTHONPATH or PYTHONHOME environment variables. Maybe this will be helpful for your second question."}, {"id": 4907004, "score": 37, "vote": 0, "content": "<p>As for the environment variables:</p>\n<pre><code class=\"python\">import os\nprint os.environ[\"HOME\"]\n</code></pre>\n", "abstract": "As for the environment variables:"}, {"id": 43074113, "score": 30, "vote": 0, "content": "<pre><code class=\"python\">import os\nfor a in os.environ:\n    print('Var: ', a, 'Value: ', os.getenv(a))\nprint(\"all done\")\n</code></pre>\n<p>That will print all of the environment variables along with their values.</p>\n", "abstract": "That will print all of the environment variables along with their values."}, {"id": 67600405, "score": 28, "vote": 0, "content": "<p>Import the <code>os</code> module:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import os\n</code></pre>\n<p>To get an environment variable:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">os.environ.get('Env_var')\n</code></pre>\n<p>To set an environment variable:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\"># Set environment variables\nos.environ['Env_var'] = 'Some Value'\n</code></pre>\n", "abstract": "Import the os module: To get an environment variable: To set an environment variable:"}, {"id": 41561017, "score": 23, "vote": 0, "content": "<p>If you are planning to use the code in a production web application code, using any web framework like <a href=\"https://en.wikipedia.org/wiki/Django_%28web_framework%29\" rel=\"nofollow noreferrer\">Django</a> and <a href=\"https://en.wikipedia.org/wiki/Flask_%28web_framework%29\" rel=\"nofollow noreferrer\">Flask</a>, use projects like <a href=\"https://github.com/rconradharris/envparse\" rel=\"nofollow noreferrer\">envparse</a>. Using it, you can read the value as your defined type.</p>\n<pre><code class=\"python\">from envparse import env\n# will read WHITE_LIST=hello,world,hi to white_list = [\"hello\", \"world\", \"hi\"]\nwhite_list = env.list(\"WHITE_LIST\", default=[])\n# Perfect for reading boolean\nDEBUG = env.bool(\"DEBUG\", default=False)\n</code></pre>\n<p>NOTE: kennethreitz's <a href=\"https://github.com/kennethreitz/autoenv\" rel=\"nofollow noreferrer\">autoenv</a> is a recommended tool for making project-specific environment variables. For those who are using <code>autoenv</code>, please note to keep the <code>.env</code> file private (inaccessible to public).</p>\n", "abstract": "If you are planning to use the code in a production web application code, using any web framework like Django and Flask, use projects like envparse. Using it, you can read the value as your defined type. NOTE: kennethreitz's autoenv is a recommended tool for making project-specific environment variables. For those who are using autoenv, please note to keep the .env file private (inaccessible to public)."}, {"id": 53854947, "score": 14, "vote": 0, "content": "<p>There are also a number of great libraries. <a href=\"https://pypi.org/project/envs/\" rel=\"nofollow noreferrer\">Envs</a>, for example, will allow you to parse objects out of your environment variables, which is rad. For example:</p>\n<pre><code class=\"python\">from envs import env\nenv('SECRET_KEY') # 'your_secret_key_here'\nenv('SERVER_NAMES',var_type='list') #['your', 'list', 'here']\n</code></pre>\n", "abstract": "There are also a number of great libraries. Envs, for example, will allow you to parse objects out of your environment variables, which is rad. For example:"}, {"id": 61104187, "score": 9, "vote": 0, "content": "<p>You can also try this:</p>\n<p>First, install <code>python-decouple</code></p>\n<pre><code class=\"python\">pip install python-decouple\n</code></pre>\n<p>Import it in your file</p>\n<pre><code class=\"python\">from decouple import config\n</code></pre>\n<p>Then get the environment variable</p>\n<pre><code class=\"python\">SECRET_KEY=config('SECRET_KEY')\n</code></pre>\n<p>Read more about the Python library <a href=\"https://pypi.org/project/python-decouple/\" rel=\"nofollow noreferrer\">here</a>.</p>\n", "abstract": "You can also try this: First, install python-decouple Import it in your file Then get the environment variable Read more about the Python library here."}, {"id": 65728905, "score": 8, "vote": 0, "content": "<p><strong>Edited - October 2021</strong></p>\n<p>Following @Peter's comment, here's how you can test it:</p>\n<p><code>main.py</code></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">#!/usr/bin/env python\n\n\nfrom os import environ\n\n# Initialize variables\nnum_of_vars = 50\nfor i in range(1, num_of_vars):\n    environ[f\"_BENCHMARK_{i}\"] = f\"BENCHMARK VALUE {i}\"  \n\ndef stopwatch(repeat=1, autorun=True):\n    \"\"\"\n    Source: https://stackoverflow.com/a/68660080/5285732\n    stopwatch decorator to calculate the total time of a function\n    \"\"\"\n    import timeit\n    import functools\n    \n    def outer_func(func):\n        @functools.wraps(func)\n        def time_func(*args, **kwargs):\n            t1 = timeit.default_timer()\n            for _ in range(repeat):\n                r = func(*args, **kwargs)\n            t2 = timeit.default_timer()\n            print(f\"Function={func.__name__}, Time={t2 - t1}\")\n            return r\n        \n        if autorun:\n            try:\n                time_func()\n            except TypeError:\n                raise Exception(f\"{time_func.__name__}: autorun only works with no parameters, you may want to use @stopwatch(autorun=False)\") from None\n        \n        return time_func\n    \n    if callable(repeat):\n        func = repeat\n        repeat = 1\n        return outer_func(func)\n    \n    return outer_func\n\n@stopwatch(repeat=10000)\ndef using_environ():\n    for item in environ:\n        pass\n\n@stopwatch\ndef using_dict(repeat=10000):\n    env_vars_dict = dict(environ)\n    for item in env_vars_dict:\n        pass\n</code></pre>\n<pre class=\"lang-sh prettyprint-override\"><code class=\"python\">python \"main.py\"\n\n# Output\nFunction=using_environ, Time=0.216224731\nFunction=using_dict, Time=0.00014206099999999888\n</code></pre>\n<p>If this is true ... It's 1500x faster to use a <code>dict()</code> instead of accessing <code>environ</code> directly.</p>\n<hr/>\n<p>A performance-driven approach - calling <code>environ</code> is expensive, so it's better to call it once and save it to a dictionary. Full example:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from os import environ\n\n\n# Slower\nprint(environ[\"USER\"], environ[\"NAME\"])\n\n# Faster\nenv_dict = dict(environ)\nprint(env_dict[\"USER\"], env_dict[\"NAME\"])\n</code></pre>\n<p>P.S- if you worry about exposing private environment variables, then sanitize <code>env_dict</code> after the assignment.</p>\n", "abstract": "Edited - October 2021 Following @Peter's comment, here's how you can test it: main.py If this is true ... It's 1500x faster to use a dict() instead of accessing environ directly. A performance-driven approach - calling environ is expensive, so it's better to call it once and save it to a dictionary. Full example: P.S- if you worry about exposing private environment variables, then sanitize env_dict after the assignment."}, {"id": 58958098, "score": 5, "vote": 0, "content": "<p>For Django, see <a href=\"https://github.com/joke2k/django-environ\" rel=\"nofollow noreferrer\">Django-environ</a>.</p>\n<pre><code class=\"python\">$ pip install django-environ\n\nimport environ\n\nenv = environ.Env(\n    # set casting, default value\n    DEBUG=(bool, False)\n)\n# reading .env file\nenviron.Env.read_env()\n\n# False if not in os.environ\nDEBUG = env('DEBUG')\n\n# Raises Django's ImproperlyConfigured exception if SECRET_KEY not in os.environ\nSECRET_KEY = env('SECRET_KEY')\n</code></pre>\n", "abstract": "For Django, see Django-environ."}, {"id": 66621790, "score": 2, "vote": 0, "content": "<p>You should first import os using</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import os\n</code></pre>\n<p>and then actually print the environment variable value</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">print(os.environ['yourvariable'])\n</code></pre>\n<p>of course, replace yourvariable as the variable you want to access.</p>\n", "abstract": "You should first import os using and then actually print the environment variable value of course, replace yourvariable as the variable you want to access."}, {"id": 70524904, "score": 2, "vote": 0, "content": "<p>The tricky part of using nested <em>for-loops</em> in one-liners is that you <strong>have</strong> to use list comprehension. So in order to print <strong>all</strong> your environment variables, without having to import a foreign library, you can use:</p>\n<pre class=\"lang-sh prettyprint-override\"><code class=\"python\">python -c \"import os;L=[f'{k}={v}' for k,v in os.environ.items()]; print('\\n'.join(L))\"\n</code></pre>\n", "abstract": "The tricky part of using nested for-loops in one-liners is that you have to use list comprehension. So in order to print all your environment variables, without having to import a foreign library, you can use:"}]}, {"link": "https://stackoverflow.com/questions/466345/convert-string-jun-1-2005-133pm-into-datetime", "question": {"id": "466345", "title": "Convert string &quot;Jun 1 2005 1:33PM&quot; into datetime", "content": "<p>How do I convert the following string to a <a href=\"https://docs.python.org/3/library/datetime.html#datetime-objects\" rel=\"noreferrer\"><code>datetime</code></a> object?</p>\n<pre><code class=\"python\">\"Jun 1 2005  1:33PM\"\n</code></pre>\n", "abstract": "How do I convert the following string to a datetime object?"}, "answers": [{"id": 466376, "score": 4343, "vote": 0, "content": "<p><a href=\"https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime\" rel=\"noreferrer\"><code>datetime.strptime</code></a> parses an input string in the user-specified format into a <em>timezone-naive</em> <a href=\"https://docs.python.org/3/library/datetime.html#datetime-objects\" rel=\"noreferrer\"><code>datetime</code></a> object:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')\ndatetime.datetime(2005, 6, 1, 13, 33)\n</code></pre>\n<p>To obtain a <a href=\"https://docs.python.org/3/library/datetime.html#date-objects\" rel=\"noreferrer\"><code>date</code></a> object using an existing <code>datetime</code> object, convert it using <code>.date()</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; datetime.strptime('Jun 1 2005', '%b %d %Y').date()\ndate(2005, 6, 1)\n</code></pre>\n<hr/>\n<p><strong>Links:</strong></p>\n<ul>\n<li><p><code>strptime</code> docs: <a href=\"https://docs.python.org/2/library/datetime.html#datetime.datetime.strptime\" rel=\"noreferrer\" title=\"datetime.datetime.strptime\">Python 2</a>, <a href=\"https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime\" rel=\"noreferrer\">Python 3</a></p>\n</li>\n<li><p><code>strptime</code>/<code>strftime</code> format string docs: <a href=\"https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior\" rel=\"noreferrer\" title=\"strftime-and-strptime-behavior\">Python 2</a>, <a href=\"https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior\" rel=\"noreferrer\">Python 3</a></p>\n</li>\n<li><p><a href=\"http://strftime.org/\" rel=\"noreferrer\">strftime.org</a> format string cheatsheet</p>\n</li>\n</ul>\n<p><strong>Notes:</strong></p>\n<ul>\n<li><code>strptime</code> = \"string parse time\"</li>\n<li><code>strftime</code> = \"string format time\"</li>\n</ul>\n", "abstract": "datetime.strptime parses an input string in the user-specified format into a timezone-naive datetime object: To obtain a date object using an existing datetime object, convert it using .date(): Links: strptime docs: Python 2, Python 3 strptime/strftime format string docs: Python 2, Python 3 strftime.org format string cheatsheet Notes:"}, {"id": 470303, "score": 1038, "vote": 0, "content": "<p>Use the third-party <a href=\"https://dateutil.readthedocs.io\" rel=\"noreferrer\"><code>dateutil</code></a> library:</p>\n<pre><code class=\"python\">from dateutil import parser\nparser.parse(\"Aug 28 1999 12:00AM\")  # datetime.datetime(1999, 8, 28, 0, 0)\n</code></pre>\n<p>It can handle most date formats and is more convenient than <code>strptime</code> since it usually guesses the correct format. It is also very useful for writing tests, where readability is more important than performance.</p>\n<p>Install it with:</p>\n<pre><code class=\"python\">pip install python-dateutil\n</code></pre>\n", "abstract": "Use the third-party dateutil library: It can handle most date formats and is more convenient than strptime since it usually guesses the correct format. It is also very useful for writing tests, where readability is more important than performance. Install it with:"}, {"id": 466366, "score": 512, "vote": 0, "content": "<p>Check out <a href=\"http://docs.python.org/3/library/time.html#time.strptime\" rel=\"noreferrer\">strptime</a> in the <a href=\"http://docs.python.org/3/library/time.html\" rel=\"noreferrer\">time</a> module.  It is the inverse of <a href=\"http://docs.python.org/3/library/time.html#time.strftime\" rel=\"noreferrer\">strftime</a>.</p>\n<pre><code class=\"python\">$ python\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; my_time = time.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')\ntime.struct_time(tm_year=2005, tm_mon=6, tm_mday=1,\n                 tm_hour=13, tm_min=33, tm_sec=0,\n                 tm_wday=2, tm_yday=152, tm_isdst=-1)\n\ntimestamp = time.mktime(my_time)\n# convert time object to datetime\nfrom datetime import datetime\nmy_datetime = datetime.fromtimestamp(timestamp)\n# convert time object to date\nfrom datetime import date\nmy_date = date.fromtimestamp(timestamp)\n</code></pre>\n", "abstract": "Check out strptime in the time module.  It is the inverse of strftime."}, {"id": 54830426, "score": 251, "vote": 0, "content": "<h2>Python &gt;= 3.7</h2>\n<p>To convert a <strong>YYYY-MM-DD</strong> string to a datetime object, <a href=\"https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat\" rel=\"nofollow noreferrer\">datetime.fromisoformat</a> could be used.</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">from datetime import datetime\n\ndate_string = \"2012-12-12 10:10:10\"\nprint (datetime.fromisoformat(date_string))\n2012-12-12 10:10:10\n</code></pre>\n<p>Caution from the documentation:</p>\n<blockquote>\n<p>This does <em>not</em> support parsing arbitrary ISO 8601 strings - it is only intended as the inverse operation of <a href=\"https://docs.python.org/3/library/datetime.html#datetime.datetime.isoformat\" rel=\"nofollow noreferrer\"><code>datetime.isoformat()</code></a>. A more full-featured ISO 8601 parser, <code>dateutil.parser.isoparse</code> is available in the third-party package <a href=\"https://dateutil.readthedocs.io/en/stable/parser.html#dateutil.parser.isoparse\" rel=\"nofollow noreferrer\"><code>dateutil</code></a>.</p>\n</blockquote>\n", "abstract": "To convert a YYYY-MM-DD string to a datetime object, datetime.fromisoformat could be used. Caution from the documentation: This does not support parsing arbitrary ISO 8601 strings - it is only intended as the inverse operation of datetime.isoformat(). A more full-featured ISO 8601 parser, dateutil.parser.isoparse is available in the third-party package dateutil."}, {"id": 22128786, "score": 132, "vote": 0, "content": "<p>I have put together a project that can convert some really neat expressions. Check out <strong><a href=\"http://github.com/stevepeak/timestring\" rel=\"noreferrer\">timestring</a></strong>.</p>\n<h2>Here are some examples below:</h2>\n<code>pip install timestring</code>\n<pre><code class=\"python\">&gt;&gt;&gt; import timestring\n&gt;&gt;&gt; timestring.Date('monday, aug 15th 2015 at 8:40 pm')\n&lt;timestring.Date 2015-08-15 20:40:00 4491909392&gt;\n&gt;&gt;&gt; timestring.Date('monday, aug 15th 2015 at 8:40 pm').date\ndatetime.datetime(2015, 8, 15, 20, 40)\n&gt;&gt;&gt; timestring.Range('next week')\n&lt;timestring.Range From 03/10/14 00:00:00 to 03/03/14 00:00:00 4496004880&gt;\n&gt;&gt;&gt; (timestring.Range('next week').start.date, timestring.Range('next week').end.date)\n(datetime.datetime(2014, 3, 10, 0, 0), datetime.datetime(2014, 3, 14, 0, 0))\n</code></pre>\n", "abstract": "I have put together a project that can convert some really neat expressions. Check out timestring."}, {"id": 27401685, "score": 68, "vote": 0, "content": "<p>Remember this and you didn't need to get confused in datetime conversion again.</p>\n<p>String to datetime object = <code>strptime</code></p>\n<p>datetime object to other formats = <code>strftime</code></p>\n<p><code>Jun 1 2005  1:33PM</code></p>\n<p>is equals to</p>\n<p><code>%b %d %Y %I:%M%p</code></p>\n<blockquote>\n<p>%b    Month as locale\u2019s abbreviated name(Jun)</p>\n<p>%d    Day of the month as a zero-padded decimal number(1)</p>\n<p>%Y    Year with century as a decimal number(2015)</p>\n<p>%I    Hour (12-hour clock) as a zero-padded decimal number(01)</p>\n<p>%M    Minute as a zero-padded decimal number(33)</p>\n<p>%p    Locale\u2019s equivalent of either AM or PM(PM)</p>\n</blockquote>\n<p>so you need strptime i-e converting <code>string</code> to </p>\n<pre><code class=\"python\">&gt;&gt;&gt; dates = []\n&gt;&gt;&gt; dates.append('Jun 1 2005  1:33PM')\n&gt;&gt;&gt; dates.append('Aug 28 1999 12:00AM')\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; for d in dates:\n...     date = datetime.strptime(d, '%b %d %Y %I:%M%p')\n...     print type(date)\n...     print date\n... \n</code></pre>\n<p>Output</p>\n<pre><code class=\"python\">&lt;type 'datetime.datetime'&gt;\n2005-06-01 13:33:00\n&lt;type 'datetime.datetime'&gt;\n1999-08-28 00:00:00\n</code></pre>\n<p>What if you have different format of dates you can use panda or dateutil.parse</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import dateutil\n&gt;&gt;&gt; dates = []\n&gt;&gt;&gt; dates.append('12 1 2017')\n&gt;&gt;&gt; dates.append('1 1 2017')\n&gt;&gt;&gt; dates.append('1 12 2017')\n&gt;&gt;&gt; dates.append('June 1 2017 1:30:00AM')\n&gt;&gt;&gt; [parser.parse(x) for x in dates]\n</code></pre>\n<p>OutPut</p>\n<pre><code class=\"python\">[datetime.datetime(2017, 12, 1, 0, 0), datetime.datetime(2017, 1, 1, 0, 0), datetime.datetime(2017, 1, 12, 0, 0), datetime.datetime(2017, 6, 1, 1, 30)]\n</code></pre>\n", "abstract": "Remember this and you didn't need to get confused in datetime conversion again. String to datetime object = strptime datetime object to other formats = strftime Jun 1 2005  1:33PM is equals to %b %d %Y %I:%M%p %b    Month as locale\u2019s abbreviated name(Jun) %d    Day of the month as a zero-padded decimal number(1) %Y    Year with century as a decimal number(2015) %I    Hour (12-hour clock) as a zero-padded decimal number(01) %M    Minute as a zero-padded decimal number(33) %p    Locale\u2019s equivalent of either AM or PM(PM) so you need strptime i-e converting string to  Output What if you have different format of dates you can use panda or dateutil.parse OutPut"}, {"id": 22223725, "score": 48, "vote": 0, "content": "<p>Many timestamps have an implied timezone. To ensure that your code will work in every timezone, you should use UTC internally and attach a timezone each time a foreign object enters the system.</p>\n<p>Python 3.2+:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; datetime.datetime.strptime(\n...     \"March 5, 2014, 20:13:50\", \"%B %d, %Y, %H:%M:%S\"\n... ).replace(tzinfo=datetime.timezone(datetime.timedelta(hours=-3)))\n</code></pre>\n<p>This assumes you know the offset. If you don't, but you know e.g. the location, you can use the <code>pytz</code> package to query the <a href=\"https://www.iana.org/time-zones\" rel=\"nofollow noreferrer\">IANA time zone database</a> for the offset. I'll use Tehran here as an example because it has a half-hour offset:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; tehran = pytz.timezone(\"Asia/Tehran\")\n&gt;&gt;&gt; local_time = tehran.localize(\n...   datetime.datetime.strptime(\"March 5, 2014, 20:13:50\",\n...                              \"%B %d, %Y, %H:%M:%S\")\n... )\n&gt;&gt;&gt; local_time\ndatetime.datetime(2014, 3, 5, 20, 13, 50, tzinfo=&lt;DstTzInfo 'Asia/Tehran' +0330+3:30:00 STD&gt;)\n</code></pre>\n<p>As you can see, <code>pytz</code> has determined that the offset was +3:30 at that particular date. You can now convert this to UTC time, and it will apply the offset:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; utc_time = local_time.astimezone(pytz.utc)\n&gt;&gt;&gt; utc_time\ndatetime.datetime(2014, 3, 5, 16, 43, 50, tzinfo=&lt;UTC&gt;)\n</code></pre>\n<p>Note that dates before the adoption of timezones will give you weird offsets. This is because the IANA has decided to use <a href=\"https://en.wikipedia.org/wiki/Local_mean_time\" rel=\"nofollow noreferrer\">Local Mean Time</a>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; chicago = pytz.timezone(\"America/Chicago\")\n&gt;&gt;&gt; weird_time = chicago.localize(\n...   datetime.datetime.strptime(\"November 18, 1883, 11:00:00\",\n...                              \"%B %d, %Y, %H:%M:%S\")\n... )\n&gt;&gt;&gt; weird_time.astimezone(pytz.utc)\ndatetime.datetime(1883, 11, 18, 7, 34, tzinfo=&lt;UTC&gt;)\n</code></pre>\n<p>The weird \"7 hours and 34 minutes\" are derived from the longitude of Chicago. I used this timestamp because it is right before <a href=\"https://www.loc.gov/item/today-in-history/november-18/#time\" rel=\"nofollow noreferrer\">standardized time was adopted in Chicago</a>.</p>\n", "abstract": "Many timestamps have an implied timezone. To ensure that your code will work in every timezone, you should use UTC internally and attach a timezone each time a foreign object enters the system. Python 3.2+: This assumes you know the offset. If you don't, but you know e.g. the location, you can use the pytz package to query the IANA time zone database for the offset. I'll use Tehran here as an example because it has a half-hour offset: As you can see, pytz has determined that the offset was +3:30 at that particular date. You can now convert this to UTC time, and it will apply the offset: Note that dates before the adoption of timezones will give you weird offsets. This is because the IANA has decided to use Local Mean Time: The weird \"7 hours and 34 minutes\" are derived from the longitude of Chicago. I used this timestamp because it is right before standardized time was adopted in Chicago."}, {"id": 64199825, "score": 38, "vote": 0, "content": "<p>If your string is in <a href=\"https://en.wikipedia.org/wiki/ISO_8601\" rel=\"nofollow noreferrer\">ISO 8601</a> format and you have Python 3.7+, you can use the following simple code:</p>\n<pre><code class=\"python\">import datetime\n\naDate = datetime.date.fromisoformat('2020-10-04')\n</code></pre>\n<p>for dates and</p>\n<pre><code class=\"python\">import datetime\n\naDateTime = datetime.datetime.fromisoformat('2020-10-04 22:47:00')\n</code></pre>\n<p>for strings containing date and time. If timestamps are included, the function <code>datetime.datetime.isoformat()</code> supports the following format:</p>\n<pre><code class=\"python\">YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]]\n</code></pre>\n<p>Where <code>*</code> matches any single character. See also <a href=\"https://docs.python.org/3/library/datetime.html#datetime.date.fromisoformat\" rel=\"nofollow noreferrer\">here</a> and <a href=\"https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat\" rel=\"nofollow noreferrer\">here</a>.</p>\n", "abstract": "If your string is in ISO 8601 format and you have Python 3.7+, you can use the following simple code: for dates and for strings containing date and time. If timestamps are included, the function datetime.datetime.isoformat() supports the following format: Where * matches any single character. See also here and here."}, {"id": 34377575, "score": 34, "vote": 0, "content": "<p>Here are two solutions using Pandas to convert dates formatted as strings into datetime.date objects.</p>\n<pre><code class=\"python\">import pandas as pd\n\ndates = ['2015-12-25', '2015-12-26']\n\n# 1) Use a list comprehension.\n&gt;&gt;&gt; [d.date() for d in pd.to_datetime(dates)]\n[datetime.date(2015, 12, 25), datetime.date(2015, 12, 26)]\n\n# 2) Convert the dates to a DatetimeIndex and extract the python dates.\n&gt;&gt;&gt; pd.DatetimeIndex(dates).date.tolist()\n[datetime.date(2015, 12, 25), datetime.date(2015, 12, 26)]\n</code></pre>\n<p><strong>Timings</strong></p>\n<pre><code class=\"python\">dates = pd.DatetimeIndex(start='2000-1-1', end='2010-1-1', freq='d').date.tolist()\n\n&gt;&gt;&gt; %timeit [d.date() for d in pd.to_datetime(dates)]\n# 100 loops, best of 3: 3.11 ms per loop\n\n&gt;&gt;&gt; %timeit pd.DatetimeIndex(dates).date.tolist()\n# 100 loops, best of 3: 6.85 ms per loop\n</code></pre>\n<p>And here is how to convert the OP's original date-time examples:</p>\n<pre><code class=\"python\">datetimes = ['Jun 1 2005  1:33PM', 'Aug 28 1999 12:00AM']\n\n&gt;&gt;&gt; pd.to_datetime(datetimes).to_pydatetime().tolist()\n[datetime.datetime(2005, 6, 1, 13, 33), \n datetime.datetime(1999, 8, 28, 0, 0)]\n</code></pre>\n<p>There are many options for converting from the strings to Pandas Timestamps using <code>to_datetime</code>, so check the <a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.to_datetime.html\" rel=\"noreferrer\">docs</a> if you need anything special.</p>\n<p>Likewise, Timestamps have many <a href=\"http://pandas.pydata.org/pandas-docs/stable/api.html#datetimelike-properties\" rel=\"noreferrer\">properties and methods</a> that can be accessed in addition to <code>.date</code></p>\n", "abstract": "Here are two solutions using Pandas to convert dates formatted as strings into datetime.date objects. Timings And here is how to convert the OP's original date-time examples: There are many options for converting from the strings to Pandas Timestamps using to_datetime, so check the docs if you need anything special. Likewise, Timestamps have many properties and methods that can be accessed in addition to .date"}, {"id": 48054268, "score": 32, "vote": 0, "content": "<p>I personally like the solution using the <code>parser</code> module, which is the second answer to this question and is beautiful, as you don't have to construct any string literals to get it working. <strong>But</strong>, one downside is that it is <strong>90% slower</strong> than the accepted answer with <code>strptime</code>.</p>\n<pre><code class=\"python\">from dateutil import parser\nfrom datetime import datetime\nimport timeit\n\ndef dt():\n    dt = parser.parse(\"Jun 1 2005  1:33PM\")\ndef strptime():\n    datetime_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')\n\nprint(timeit.timeit(stmt=dt, number=10**5))\nprint(timeit.timeit(stmt=strptime, number=10**5))\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<p>10.70296801342902 <br/>\n1.3627995655316933</p>\n</blockquote>\n<p>As long as you are not doing this <em>a million</em> times over and over again, I still think the <code>parser</code> method is more convenient and will handle most of the time formats automatically.</p>\n", "abstract": "I personally like the solution using the parser module, which is the second answer to this question and is beautiful, as you don't have to construct any string literals to get it working. But, one downside is that it is 90% slower than the accepted answer with strptime. Output: 10.70296801342902 \n1.3627995655316933 As long as you are not doing this a million times over and over again, I still think the parser method is more convenient and will handle most of the time formats automatically."}, {"id": 7761860, "score": 25, "vote": 0, "content": "<p>Something that isn't mentioned here and is useful: adding a suffix to the day. I decoupled the suffix logic so you can use it for any number you like, not just dates.</p>\n<pre><code class=\"python\">import time\n\ndef num_suffix(n):\n    '''\n    Returns the suffix for any given int\n    '''\n    suf = ('th','st', 'nd', 'rd')\n    n = abs(n) # wise guy\n    tens = int(str(n)[-2:])\n    units = n % 10\n    if tens &gt; 10 and tens &lt; 20:\n        return suf[0] # teens with 'th'\n    elif units &lt;= 3:\n        return suf[units]\n    else:\n        return suf[0] # 'th'\n\ndef day_suffix(t):\n    '''\n    Returns the suffix of the given struct_time day\n    '''\n    return num_suffix(t.tm_mday)\n\n# Examples\nprint num_suffix(123)\nprint num_suffix(3431)\nprint num_suffix(1234)\nprint ''\nprint day_suffix(time.strptime(\"1 Dec 00\", \"%d %b %y\"))\nprint day_suffix(time.strptime(\"2 Nov 01\", \"%d %b %y\"))\nprint day_suffix(time.strptime(\"3 Oct 02\", \"%d %b %y\"))\nprint day_suffix(time.strptime(\"4 Sep 03\", \"%d %b %y\"))\nprint day_suffix(time.strptime(\"13 Nov 90\", \"%d %b %y\"))\nprint day_suffix(time.strptime(\"14 Oct 10\", \"%d %b %y\"))\u200b\u200b\u200b\u200b\u200b\u200b\u200b\n</code></pre>\n", "abstract": "Something that isn't mentioned here and is useful: adding a suffix to the day. I decoupled the suffix logic so you can use it for any number you like, not just dates."}, {"id": 34871180, "score": 19, "vote": 0, "content": "<pre><code class=\"python\">In [34]: import datetime\n\nIn [35]: _now = datetime.datetime.now()\n\nIn [36]: _now\nOut[36]: datetime.datetime(2016, 1, 19, 9, 47, 0, 432000)\n\nIn [37]: print _now\n2016-01-19 09:47:00.432000\n\nIn [38]: _parsed = datetime.datetime.strptime(str(_now),\"%Y-%m-%d %H:%M:%S.%f\")\n\nIn [39]: _parsed\nOut[39]: datetime.datetime(2016, 1, 19, 9, 47, 0, 432000)\n\nIn [40]: assert _now == _parsed\n</code></pre>\n", "abstract": ""}, {"id": 27046382, "score": 17, "vote": 0, "content": "<p>Django Timezone aware datetime object example.</p>\n<pre><code class=\"python\">import datetime\nfrom django.utils.timezone import get_current_timezone\ntz = get_current_timezone()\n\nformat = '%b %d %Y %I:%M%p'\ndate_object = datetime.datetime.strptime('Jun 1 2005  1:33PM', format)\ndate_obj = tz.localize(date_object)\n</code></pre>\n<p>This conversion is very important for Django and Python when you have <code>USE_TZ = True</code>:</p>\n<pre><code class=\"python\">RuntimeWarning: DateTimeField MyModel.created received a naive datetime (2016-03-04 00:00:00) while time zone support is active.\n</code></pre>\n", "abstract": "Django Timezone aware datetime object example. This conversion is very important for Django and Python when you have USE_TZ = True:"}, {"id": 35202640, "score": 16, "vote": 0, "content": "<p>Create a small utility function like:</p>\n<pre><code class=\"python\">def date(datestr=\"\", format=\"%Y-%m-%d\"):\n    from datetime import datetime\n    if not datestr:\n        return datetime.today().date()\n    return datetime.strptime(datestr, format).date()\n</code></pre>\n<p>This is versatile enough:</p>\n<ul>\n<li>If you don't pass any arguments it will return today's date.</li>\n<li>There's a date format as default that you can override.</li>\n<li>You can easily modify it to return a datetime.</li>\n</ul>\n", "abstract": "Create a small utility function like: This is versatile enough:"}, {"id": 51869533, "score": 16, "vote": 0, "content": "<p>This would be helpful for converting a string to datetime and also with a time zone:</p>\n<pre><code class=\"python\">def convert_string_to_time(date_string, timezone):\n\n    from datetime import datetime\n    import pytz\n\n    date_time_obj = datetime.strptime(date_string[:26], '%Y-%m-%d %H:%M:%S.%f')\n    date_time_obj_timezone = pytz.timezone(timezone).localize(date_time_obj)\n\n    return date_time_obj_timezone\n\ndate = '2018-08-14 13:09:24.543953+00:00'\nTIME_ZONE = 'UTC'\ndate_time_obj_timezone = convert_string_to_time(date, TIME_ZONE)\n</code></pre>\n", "abstract": "This would be helpful for converting a string to datetime and also with a time zone:"}, {"id": 42515333, "score": 11, "vote": 0, "content": "<p><strong>arrow</strong> offers many useful functions for dates and times. This bit of code provides an answer to the question and shows that arrow is also capable of formatting dates easily and displaying information for other locales.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import arrow\n&gt;&gt;&gt; dateStrings = [ 'Jun 1  2005 1:33PM', 'Aug 28 1999 12:00AM' ]\n&gt;&gt;&gt; for dateString in dateStrings:\n...     dateString\n...     arrow.get(dateString.replace('  ',' '), 'MMM D YYYY H:mmA').datetime\n...     arrow.get(dateString.replace('  ',' '), 'MMM D YYYY H:mmA').format('ddd, Do MMM YYYY HH:mm')\n...     arrow.get(dateString.replace('  ',' '), 'MMM D YYYY H:mmA').humanize(locale='de')\n...\n'Jun 1  2005 1:33PM'\ndatetime.datetime(2005, 6, 1, 13, 33, tzinfo=tzutc())\n'Wed, 1st Jun 2005 13:33'\n'vor 11 Jahren'\n'Aug 28 1999 12:00AM'\ndatetime.datetime(1999, 8, 28, 0, 0, tzinfo=tzutc())\n'Sat, 28th Aug 1999 00:00'\n'vor 17 Jahren'\n</code></pre>\n<p>See <a href=\"http://arrow.readthedocs.io/en/latest/\" rel=\"nofollow noreferrer\">http://arrow.readthedocs.io/en/latest/</a> for more.</p>\n", "abstract": "arrow offers many useful functions for dates and times. This bit of code provides an answer to the question and shows that arrow is also capable of formatting dates easily and displaying information for other locales. See http://arrow.readthedocs.io/en/latest/ for more."}, {"id": 59706589, "score": 8, "vote": 0, "content": "<p>You can also check out <a href=\"https://dateparser.readthedocs.io/en/latest/\" rel=\"nofollow noreferrer\"><code>dateparser</code></a>:</p>\n<blockquote>\n<p><a href=\"https://pypi.org/project/dateparser/\" rel=\"nofollow noreferrer\"><code>dateparser</code></a> provides modules to easily parse localized dates in almost\nany string formats commonly found on web pages.</p>\n</blockquote>\n<p>Install:</p>\n<pre><code class=\"python\">pip install dateparser\n</code></pre>\n<p>This is, I think, the easiest way you can parse dates.</p>\n<blockquote>\n<p>The most straightforward way is to use the <code>dateparser.parse</code> function,\nthat wraps around most of the functionality in the module.</p>\n</blockquote>\n<p>Sample code:</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">import dateparser\n\nt1 = 'Jun 1 2005  1:33PM'\nt2 = 'Aug 28 1999 12:00AM'\n\ndt1 = dateparser.parse(t1)\ndt2 = dateparser.parse(t2)\n\nprint(dt1)\nprint(dt2)\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">2005-06-01 13:33:00\n1999-08-28 00:00:00\n</code></pre>\n", "abstract": "You can also check out dateparser: dateparser provides modules to easily parse localized dates in almost\nany string formats commonly found on web pages. Install: This is, I think, the easiest way you can parse dates. The most straightforward way is to use the dateparser.parse function,\nthat wraps around most of the functionality in the module. Sample code: Output:"}, {"id": 30577110, "score": 7, "vote": 0, "content": "<p>You can use <a href=\"https://github.com/ralphavalon/easy_date\" rel=\"noreferrer\">easy_date</a> to make it easy:</p>\n<pre><code class=\"python\">import date_converter\nconverted_date = date_converter.string_to_datetime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')\n</code></pre>\n", "abstract": "You can use easy_date to make it easy:"}, {"id": 47925290, "score": 5, "vote": 0, "content": "<p>If you want only date format then you can manually convert it by passing your individual fields like:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; date = datetime.date(int('2017'),int('12'),int('21'))\n&gt;&gt;&gt; date\ndatetime.date(2017, 12, 21)\n&gt;&gt;&gt; type(date)\n&lt;type 'datetime.date'&gt;\n</code></pre>\n<p>You can pass your split string values to convert it into date type like:</p>\n<pre><code class=\"python\">selected_month_rec = '2017-09-01'\ndate_formate = datetime.date(int(selected_month_rec.split('-')[0]),int(selected_month_rec.split('-')[1]),int(selected_month_rec.split('-')[2]))\n</code></pre>\n<p>You will get the resulting value in date format.</p>\n", "abstract": "If you want only date format then you can manually convert it by passing your individual fields like: You can pass your split string values to convert it into date type like: You will get the resulting value in date format."}, {"id": 69917740, "score": 5, "vote": 0, "content": "<p>Similar to <a href=\"https://stackoverflow.com/questions/466345/convert-string-jun-1-2005-133pm-into-datetime/47925290#47925290\">Javed's answer</a>, I just wanted date from string - so combining <a href=\"https://stackoverflow.com/questions/466345/convert-string-jun-1-2005-133pm-into-datetime/470303#470303\">Simon's</a> and Javed's logic, we get:</p>\n<pre><code class=\"python\">from dateutil import parser\nimport datetime\n\ns = '2021-03-04'\n\nparser.parse(s).date()\n</code></pre>\n<p>Output</p>\n<blockquote>\n<p><code>datetime.date(2021, 3, 4)</code></p>\n</blockquote>\n", "abstract": "Similar to Javed's answer, I just wanted date from string - so combining Simon's and Javed's logic, we get: Output datetime.date(2021, 3, 4)"}, {"id": 64114476, "score": 4, "vote": 0, "content": "<p>It seems using <a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Timestamp.html\" rel=\"nofollow noreferrer\">pandas Timestamp</a> is the fastest:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">import pandas as pd\n\nN = 1000\n\nl = ['Jun 1 2005  1:33PM'] * N\n\nlist(pd.to_datetime(l, format=format))\n\n%timeit _ = list(pd.to_datetime(l, format=format))\n1.58 ms \u00b1 21.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n</code></pre>\n<h3>Other solutions</h3>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">from datetime import datetime\n%timeit _ = list(map(lambda x: datetime.strptime(x, format), l))\n9.41 ms \u00b1 95.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n\nfrom dateutil.parser import parse\n%timeit _ = list(map(lambda x: parse(x), l))\n73.8 ms \u00b1 1.14 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n</code></pre>\n<p>If the string is an <a href=\"https://en.wikipedia.org/wiki/ISO_8601\" rel=\"nofollow noreferrer\">ISO\u00a08601</a> string, please use <a href=\"https://pypi.org/project/ciso8601/\" rel=\"nofollow noreferrer\">csio8601</a>:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">import ciso8601\n\nl = ['2014-01-09'] * N\n\n%timeit _ = list(map(lambda x: ciso8601.parse_datetime(x), l))\n186 \u00b5s \u00b1 4.13 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n</code></pre>\n", "abstract": "It seems using pandas Timestamp is the fastest: If the string is an ISO\u00a08601 string, please use csio8601:"}, {"id": 68889318, "score": 3, "vote": 0, "content": "<p>If you <em>don't</em> want to explicitly specify which format your string is in with respect to the date time format, you can use this hack to by pass that step:</p>\n<pre><code class=\"python\">from dateutil.parser import parse\n\n# Function that'll guess the format and convert it into the python datetime format\ndef update_event(start_datetime=None, end_datetime=None, description=None):\n    if start_datetime is not None:\n        new_start_time = parse(start_datetime)\n\n        return new_start_time\n\n# Sample input dates in different formats\nd = ['06/07/2021 06:40:23.277000', '06/07/2021 06:40', '06/07/2021']\n\nnew = [update_event(i) for i in d]\n\nfor date in new:\n    print(date)\n    # Sample output dates in Python datetime object\n    #   2014-04-23 00:00:00\n    #   2013-04-24 00:00:00\n    #   2014-04-25 00:00:00\n</code></pre>\n<p>If you want to convert it into some other datetime format, just modify the last line with the format you like for example something like <code>date.strftime('%Y/%m/%d %H:%M:%S.%f')</code>:</p>\n<pre><code class=\"python\">from dateutil.parser import parse\n\ndef update_event(start_datetime=None, end_datetime=None, description=None):\n    if start_datetime is not None:\n        new_start_time = parse(start_datetime)\n\n        return new_start_time\n\n# Sample input dates in different formats\nd = ['06/07/2021 06:40:23.277000', '06/07/2021 06:40', '06/07/2021']\n\n# Passing the dates one by one through the function\nnew = [update_event(i) for i in d]\n\nfor date in new:\n    print(date.strftime('%Y/%m/%d %H:%M:%S.%f'))\n    # Sample output dates in required Python datetime object\n    #   2021/06/07 06:40:23.277000\n    #   2021/06/07 06:40:00.000000\n    #   2021/06/07 00:00:00.000000\n</code></pre>\n<p>Try running the above snippet to have a better clarity.</p>\n", "abstract": "If you don't want to explicitly specify which format your string is in with respect to the date time format, you can use this hack to by pass that step: If you want to convert it into some other datetime format, just modify the last line with the format you like for example something like date.strftime('%Y/%m/%d %H:%M:%S.%f'): Try running the above snippet to have a better clarity."}, {"id": 47876476, "score": 2, "vote": 0, "content": "<p>See <a href=\"https://stackoverflow.com/questions/6615533/is-there-a-python-equivalent-to-cs-datetime-tryparse/47876446#47876446\">my answer</a>.</p>\n<p>In real-world data this is a real problem: multiple, mismatched, incomplete, inconsistent and multilanguage/region date formats, often mixed freely in one dataset. It's not ok for production code to fail, let alone go exception-happy like a fox.</p>\n<p>We need to try...catch multiple datetime formats fmt1,fmt2,...,fmtn and suppress/handle the exceptions (from <code>strptime()</code>) for all those that mismatch (and in particular, avoid needing a yukky n-deep indented ladder of try..catch clauses). From <a href=\"https://stackoverflow.com/questions/6615533/is-there-a-python-equivalent-to-cs-datetime-tryparse/47876446#47876446\">my solution</a></p>\n<pre><code class=\"python\">def try_strptime(s, fmts=['%d-%b-%y','%m/%d/%Y']):\n    for fmt in fmts:\n        try:\n            return datetime.strptime(s, fmt)\n        except:\n            continue\n\n    return None # or reraise the ValueError if no format matched, if you prefer\n</code></pre>\n", "abstract": "See my answer. In real-world data this is a real problem: multiple, mismatched, incomplete, inconsistent and multilanguage/region date formats, often mixed freely in one dataset. It's not ok for production code to fail, let alone go exception-happy like a fox. We need to try...catch multiple datetime formats fmt1,fmt2,...,fmtn and suppress/handle the exceptions (from strptime()) for all those that mismatch (and in particular, avoid needing a yukky n-deep indented ladder of try..catch clauses). From my solution"}, {"id": 53995363, "score": 2, "vote": 0, "content": "<p>Use:</p>\n<pre><code class=\"python\">emp = pd.read_csv(\"C:\\\\py\\\\programs\\\\pandas_2\\\\pandas\\\\employees.csv\")\nemp.info()\n</code></pre>\n<p>It shows \"Start Date Time\" Column and \"Last Login Time\" both are \"object = strings\" in data-frame:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1000 entries, 0 to 999\nData columns (total 8 columns):\nFirst Name           933 non-null object\nGender               855 non-null object\n\n    Start Date           1000 non-null object\n\n    Last Login Time      1000 non-null object\n\nSalary               1000 non-null int64\nBonus %              1000 non-null float64\nSenior Management    933 non-null object\nTeam                 957 non-null object\ndtypes: float64(1), int64(1), object(6)\nmemory usage: 62.6+ KB\n</code></pre>\n<p>By using the <code>parse_dates</code> option in <code>read_csv</code> mention, you can convert your string datetime into the pandas datetime format.</p>\n<pre><code class=\"python\">emp = pd.read_csv(\"C:\\\\py\\\\programs\\\\pandas_2\\\\pandas\\\\employees.csv\", parse_dates=[\"Start Date\", \"Last Login Time\"])\nemp.info()\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1000 entries, 0 to 999\nData columns (total 8 columns):\nFirst Name           933 non-null object\nGender               855 non-null object\n\n     Start Date           1000 non-null datetime64[ns]\n     Last Login Time      1000 non-null datetime64[ns]\n\nSalary               1000 non-null int64\nBonus %              1000 non-null float64\nSenior Management    933 non-null object\nTeam                 957 non-null object\ndtypes: datetime64[ns](2), float64(1), int64(1), object(4)\nmemory usage: 62.6+ KB\n</code></pre>\n", "abstract": "Use: It shows \"Start Date Time\" Column and \"Last Login Time\" both are \"object = strings\" in data-frame: By using the parse_dates option in read_csv mention, you can convert your string datetime into the pandas datetime format. Output:"}, {"id": 66809743, "score": 2, "vote": 0, "content": "<p>A short sample mapping a yyyy-mm-dd date string to a datetime.date object:</p>\n<pre><code class=\"python\">from datetime import date\ndate_from_yyyy_mm_dd = lambda \u03b4 : date(*[int(_) for _ in \u03b4.split('-')])\ndate_object = date_from_yyyy_mm_dd('2021-02-15')\n</code></pre>\n", "abstract": "A short sample mapping a yyyy-mm-dd date string to a datetime.date object:"}]}, {"link": "https://stackoverflow.com/questions/5137497/find-the-current-directory-and-files-directory", "question": {"id": "5137497", "title": "Find the current directory and file&#39;s directory", "content": "<p>How do I determine:</p>\n<ol>\n<li>the current directory (where I was in the terminal when I ran the Python script), and</li>\n<li>where the Python file I am executing is?</li>\n</ol>\n", "abstract": "How do I determine:"}, "answers": [{"id": 5137509, "score": 4397, "vote": 0, "content": "<p>To get the full path to the directory a Python file is contained in, write this in that file:</p>\n<pre><code class=\"python\">import os \ndir_path = os.path.dirname(os.path.realpath(__file__))\n</code></pre>\n<p>(Note that the incantation above won't work if you've already used <code>os.chdir()</code> to change your current working directory, since the value of the <code>__file__</code> constant is relative to the current working directory and is not changed by an <code>os.chdir()</code> call.)</p>\n<hr/>\n<p>To get the current working directory use </p>\n<pre><code class=\"python\">import os\ncwd = os.getcwd()\n</code></pre>\n<hr/>\n<p>Documentation references for the modules, constants and functions used above:</p>\n<ul>\n<li>The <a href=\"https://docs.python.org/library/os.html\"><code>os</code></a> and <a href=\"https://docs.python.org/library/os.path.html#module-os.path\"><code>os.path</code></a> modules.</li>\n<li>The <a href=\"https://docs.python.org/reference/datamodel.html\"><code>__file__</code></a> constant</li>\n<li><a href=\"https://docs.python.org/library/os.path.html#os.path.realpath\"><code>os.path.realpath(path)</code></a> (returns <em>\"the canonical path of the specified filename, eliminating any symbolic links encountered in the path\"</em>)</li>\n<li><a href=\"https://docs.python.org/library/os.path.html#os.path.dirname\"><code>os.path.dirname(path)</code></a> (returns <em>\"the directory name of pathname <code>path</code>\"</em>)</li>\n<li><a href=\"https://docs.python.org/library/os.html#os.getcwd\"><code>os.getcwd()</code></a> (returns <em>\"a string representing the current working directory\"</em>)</li>\n<li><a href=\"https://docs.python.org/library/os.html#os.chdir\"><code>os.chdir(path)</code></a> (<em>\"change the current working directory to <code>path</code>\"</em>)</li>\n</ul>\n", "abstract": "To get the full path to the directory a Python file is contained in, write this in that file: (Note that the incantation above won't work if you've already used os.chdir() to change your current working directory, since the value of the __file__ constant is relative to the current working directory and is not changed by an os.chdir() call.) To get the current working directory use  Documentation references for the modules, constants and functions used above:"}, {"id": 5137507, "score": 367, "vote": 0, "content": "<p><a href=\"https://sourceware.org/gdb/onlinedocs/gdb/Working-Directory.html\" rel=\"noreferrer\">Current working directory</a>:  <a href=\"https://docs.python.org/2/library/os.html#os.getcwd\" rel=\"noreferrer\"><code>os.getcwd()</code></a></p>\n<p>And the <a href=\"http://docs.python.org/reference/datamodel.html\" rel=\"noreferrer\"><code>__file__</code> attribute</a> can help you find out where the file you are executing is located. This Stack\u00a0Overflow post explains everything:  <em><a href=\"https://stackoverflow.com/questions/2632199/how-do-i-get-the-path-of-the-current-executed-file-in-python\">How do I get the path of the current executed file in Python?</a></em></p>\n", "abstract": "Current working directory:  os.getcwd() And the __file__ attribute can help you find out where the file you are executing is located. This Stack\u00a0Overflow post explains everything:  How do I get the path of the current executed file in Python?"}, {"id": 13720875, "score": 344, "vote": 0, "content": "<p>You may find this useful as a reference:</p>\n<pre><code class=\"python\">import os\n\nprint(\"Path at terminal when executing this file\")\nprint(os.getcwd() + \"\\n\")\n\nprint(\"This file path, relative to os.getcwd()\")\nprint(__file__ + \"\\n\")\n\nprint(\"This file full path (following symlinks)\")\nfull_path = os.path.realpath(__file__)\nprint(full_path + \"\\n\")\n\nprint(\"This file directory and name\")\npath, filename = os.path.split(full_path)\nprint(path + ' --&gt; ' + filename + \"\\n\")\n\nprint(\"This file directory only\")\nprint(os.path.dirname(full_path))\n</code></pre>\n", "abstract": "You may find this useful as a reference:"}, {"id": 46061872, "score": 244, "vote": 0, "content": "<p>The <a href=\"https://docs.python.org/3/library/pathlib.html\" rel=\"noreferrer\"><code>pathlib</code></a> module, <a href=\"https://docs.python.org/3/whatsnew/3.4.html#pathlib\" rel=\"noreferrer\">introduced in Python 3.4</a> (<em><a href=\"https://www.python.org/dev/peps/pep-0428/\" rel=\"noreferrer\">PEP 428 \u2014 The pathlib module \u2014 object-oriented filesystem paths</a></em>), makes the path-related experience much much better.</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">pwd\n\n/home/skovorodkin/stack\n\ntree\n\n.\n\u2514\u2500\u2500 scripts\n    \u251c\u2500\u2500 1.py\n    \u2514\u2500\u2500 2.py\n</code></pre>\n<p>In order to get the current working directory, use <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.cwd\" rel=\"noreferrer\"><code>Path.cwd()</code></a>:</p>\n<pre><code class=\"python\">from pathlib import Path\n\nprint(Path.cwd())  # /home/skovorodkin/stack\n</code></pre>\n<p>To get an absolute path to your script file, use the <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve\" rel=\"noreferrer\"><code>Path.resolve()</code></a> method:</p>\n<pre><code class=\"python\">print(Path(__file__).resolve())  # /home/skovorodkin/stack/scripts/1.py\n</code></pre>\n<p>And to get the path of a directory where your script is located, access <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.parent\" rel=\"noreferrer\"><code>.parent</code></a> (it is recommended to call <code>.resolve()</code> before <code>.parent</code>):</p>\n<pre><code class=\"python\">print(Path(__file__).resolve().parent)  # /home/skovorodkin/stack/scripts\n</code></pre>\n<p>Remember that <code>__file__</code> is not reliable in some situations: <em><a href=\"https://stackoverflow.com/questions/2632199/how-do-i-get-the-path-of-the-current-executed-file-in-python\">How do I get the path of the current executed file in Python?</a></em>.</p>\n<hr/>\n<p>Please note, that <code>Path.cwd()</code>, <code>Path.resolve()</code> and other <code>Path</code> methods return path objects (<a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.PosixPath\" rel=\"noreferrer\"><code>PosixPath</code></a> in my case), not strings. In Python 3.4 and 3.5 that caused some pain, because <a href=\"https://docs.python.org/3.5/library/functions.html#open\" rel=\"noreferrer\"><code>open</code></a> built-in function could only work with string or bytes objects, and did not support <code>Path</code> objects, so you had to convert <code>Path</code> objects to strings or use the <a href=\"https://docs.python.org/3/library/pathlib.html#pathlib.Path.open\" rel=\"noreferrer\"><code>Path.open()</code></a> method, but the latter option required you to change old code:</p>\n<h2>File <em>scripts/2.py</em></h2>\n<pre><code class=\"python\">from pathlib import Path\n\np = Path(__file__).resolve()\n\nwith p.open() as f: pass\nwith open(str(p)) as f: pass\nwith open(p) as f: pass\n\nprint('OK')\n</code></pre>\n<h3>Output</h3>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">python3.5 scripts/2.py\n\nTraceback (most recent call last):\n  File \"scripts/2.py\", line 11, in &lt;module&gt;\n    with open(p) as f:\nTypeError: invalid file: PosixPath('/home/skovorodkin/stack/scripts/2.py')\n</code></pre>\n<p>As you can see, <code>open(p)</code> does not work with Python 3.5.</p>\n<p><em><a href=\"https://www.python.org/dev/peps/pep-0519/\" rel=\"noreferrer\">PEP 519 \u2014 Adding a file system path protocol</a></em>, implemented in Python 3.6, adds support of <a href=\"https://docs.python.org/3/library/os.html#os.PathLike\" rel=\"noreferrer\"><code>PathLike</code></a> objects to the <a href=\"https://docs.python.org/3/library/functions.html#open\" rel=\"noreferrer\"><code>open</code></a> function, so now you can pass <code>Path</code> objects to the <code>open</code> function directly:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">python3.6 scripts/2.py\n\nOK\n</code></pre>\n", "abstract": "The pathlib module, introduced in Python 3.4 (PEP 428 \u2014 The pathlib module \u2014 object-oriented filesystem paths), makes the path-related experience much much better. In order to get the current working directory, use Path.cwd(): To get an absolute path to your script file, use the Path.resolve() method: And to get the path of a directory where your script is located, access .parent (it is recommended to call .resolve() before .parent): Remember that __file__ is not reliable in some situations: How do I get the path of the current executed file in Python?. Please note, that Path.cwd(), Path.resolve() and other Path methods return path objects (PosixPath in my case), not strings. In Python 3.4 and 3.5 that caused some pain, because open built-in function could only work with string or bytes objects, and did not support Path objects, so you had to convert Path objects to strings or use the Path.open() method, but the latter option required you to change old code: As you can see, open(p) does not work with Python 3.5. PEP 519 \u2014 Adding a file system path protocol, implemented in Python 3.6, adds support of PathLike objects to the open function, so now you can pass Path objects to the open function directly:"}, {"id": 10293159, "score": 73, "vote": 0, "content": "<ol>\n<li><p>To get the current directory full path</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&gt;&gt;import os\n&gt;&gt;print os.getcwd()\n</code></pre>\n<p>Output: \"C :\\Users\\admin\\myfolder\"</p>\n</li>\n<li><p>To get the current directory folder name alone</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&gt;&gt;import os\n&gt;&gt;str1=os.getcwd()\n&gt;&gt;str2=str1.split('\\\\')\n&gt;&gt;n=len(str2)\n&gt;&gt;print str2[n-1]\n</code></pre>\n<p>Output: \"myfolder\"</p>\n</li>\n</ol>\n", "abstract": "To get the current directory full path Output: \"C :\\Users\\admin\\myfolder\" To get the current directory folder name alone Output: \"myfolder\""}, {"id": 39771209, "score": 49, "vote": 0, "content": "<p><a href=\"https://docs.python.org/3.8/library/pathlib.html\" rel=\"noreferrer\">Pathlib</a> can be used this way to get the directory containing the current script:</p>\n<pre><code class=\"python\">import pathlib\nfilepath = pathlib.Path(__file__).resolve().parent\n</code></pre>\n", "abstract": "Pathlib can be used this way to get the directory containing the current script:"}, {"id": 12767520, "score": 42, "vote": 0, "content": "<p>If you are trying to find the current directory of the file you are currently in:</p>\n<p>OS agnostic way:</p>\n<pre><code class=\"python\">dirname, filename = os.path.split(os.path.abspath(__file__))\n</code></pre>\n", "abstract": "If you are trying to find the current directory of the file you are currently in: OS agnostic way:"}, {"id": 28637689, "score": 38, "vote": 0, "content": "<p>If you're using Python 3.4, there is the brand new higher-level <code>pathlib</code> module which allows you to conveniently call <code>pathlib.Path.cwd()</code> to get a <code>Path</code> object representing your current working directory, along with many other new features.</p>\n<p>More info on this new API can be found <a href=\"https://docs.python.org/3.4/library/pathlib.html\" rel=\"noreferrer\">here</a>.</p>\n", "abstract": "If you're using Python 3.4, there is the brand new higher-level pathlib module which allows you to conveniently call pathlib.Path.cwd() to get a Path object representing your current working directory, along with many other new features. More info on this new API can be found here."}, {"id": 32711758, "score": 37, "vote": 0, "content": "<p>To get the current directory full path:<br/></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">os.path.realpath('.')\n</code></pre>\n", "abstract": "To get the current directory full path:"}, {"id": 33540872, "score": 33, "vote": 0, "content": "<p><strong>Answer to #1:</strong></p>\n<p>If you want the current directory, do this:</p>\n<pre><code class=\"python\">import os\nos.getcwd()\n</code></pre>\n<p>If you want just any folder name and you have the path to that folder, do this:</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">def get_folder_name(folder):\n    '''\n    Returns the folder name, given a full folder path\n    '''\n    return folder.split(os.sep)[-1]\n</code></pre>\n<p><strong>Answer to #2:</strong></p>\n<pre><code class=\"python\">import os\nprint os.path.abspath(__file__)\n</code></pre>\n", "abstract": "Answer to #1: If you want the current directory, do this: If you want just any folder name and you have the path to that folder, do this: Answer to #2:"}, {"id": 19269546, "score": 30, "vote": 0, "content": "<p>I think the most succinct way to find just the name of your current execution context would be:</p>\n<pre><code class=\"python\">current_folder_path, current_folder_name = os.path.split(os.getcwd())\n</code></pre>\n", "abstract": "I think the most succinct way to find just the name of your current execution context would be:"}, {"id": 18185825, "score": 17, "vote": 0, "content": "<p>If you're searching for the location of the currently executed script, you can use <code>sys.argv[0]</code> to get the full path.</p>\n", "abstract": "If you're searching for the location of the currently executed script, you can use sys.argv[0] to get the full path."}, {"id": 44569198, "score": 14, "vote": 0, "content": "<p>For question 1, use <code>os.getcwd() # Get working directory</code> and <code>os.chdir(r'D:\\Steam\\steamapps\\common') # Set working directory</code></p>\n<hr/>\n<p>I recommend using <code>sys.argv[0]</code> for question 2 because <code>sys.argv</code> is immutable and therefore always returns the current file (module object path) and not affected by <code>os.chdir()</code>. Also you can do like this:</p>\n<pre><code class=\"python\">import os\nthis_py_file = os.path.realpath(__file__)\n\n# vvv Below comes your code vvv #\n</code></pre>\n<p>But that snippet and <code>sys.argv[0]</code> will not work or will work weird when compiled by PyInstaller, because magic properties are not set in <code>__main__</code> level and <code>sys.argv[0]</code> is the way your executable was called (it means that it becomes affected by the working directory).</p>\n", "abstract": "For question 1, use os.getcwd() # Get working directory and os.chdir(r'D:\\Steam\\steamapps\\common') # Set working directory I recommend using sys.argv[0] for question 2 because sys.argv is immutable and therefore always returns the current file (module object path) and not affected by os.chdir(). Also you can do like this: But that snippet and sys.argv[0] will not work or will work weird when compiled by PyInstaller, because magic properties are not set in __main__ level and sys.argv[0] is the way your executable was called (it means that it becomes affected by the working directory)."}]}, {"link": "https://stackoverflow.com/questions/30081275/why-is-1000000000000000-in-range1000000000000001-so-fast-in-python-3", "question": {"id": "30081275", "title": "Why is &quot;1000000000000000 in range(1000000000000001)&quot; so fast in Python 3?", "content": "<p>It is my understanding that the <code>range()</code> function, which is actually <a href=\"https://docs.python.org/3/library/stdtypes.html#typesseq-range\" rel=\"noreferrer\">an object type in Python 3</a>, generates its contents on the fly, similar to a generator.</p>\n<p>This being the case, I would have expected the following line to take an inordinate amount of time because, in order to determine whether 1 quadrillion is in the range, a quadrillion values would have to be generated:</p>\n<pre><code class=\"python\">1_000_000_000_000_000 in range(1_000_000_000_000_001)\n</code></pre>\n<p>Furthermore: it seems that no matter how many zeroes I add on, the calculation more or less takes the same amount of time (basically instantaneous).</p>\n<p>I have also tried things like this, but the calculation is still almost instant:</p>\n<pre><code class=\"python\"># count by tens\n1_000_000_000_000_000_000_000 in range(0,1_000_000_000_000_000_000_001,10)\n</code></pre>\n<p>If I try to implement my own range function, the result is not so nice!</p>\n<pre><code class=\"python\">def my_crappy_range(N):\n    i = 0\n    while i &lt; N:\n        yield i\n        i += 1\n    return\n</code></pre>\n<p>What is the <code>range()</code> object doing under the hood that makes it so fast?</p>\n<hr/>\n<p><a href=\"https://stackoverflow.com/a/30081318/2437514\">Martijn Pieters's answer</a> was chosen for its completeness, but also see <a href=\"https://stackoverflow.com/a/30081894/2437514\">abarnert's first answer</a> for a good discussion of what it means for <code>range</code> to be a full-fledged <em>sequence</em> in Python 3, and some information/warning regarding potential inconsistency for <code>__contains__</code> function optimization across Python implementations. <a href=\"https://stackoverflow.com/a/30088140/2437514\">abarnert's other answer</a> goes into some more detail and provides links for those interested in the history behind the optimization in Python 3 (and lack of optimization of <code>xrange</code> in Python 2). Answers <a href=\"https://stackoverflow.com/a/30081467/2437514\">by poke</a> and <a href=\"https://stackoverflow.com/a/30081470/2437514\">by wim</a> provide the relevant C source code and explanations for those who are interested.</p>\n", "abstract": "It is my understanding that the range() function, which is actually an object type in Python 3, generates its contents on the fly, similar to a generator. This being the case, I would have expected the following line to take an inordinate amount of time because, in order to determine whether 1 quadrillion is in the range, a quadrillion values would have to be generated: Furthermore: it seems that no matter how many zeroes I add on, the calculation more or less takes the same amount of time (basically instantaneous). I have also tried things like this, but the calculation is still almost instant: If I try to implement my own range function, the result is not so nice! What is the range() object doing under the hood that makes it so fast? Martijn Pieters's answer was chosen for its completeness, but also see abarnert's first answer for a good discussion of what it means for range to be a full-fledged sequence in Python 3, and some information/warning regarding potential inconsistency for __contains__ function optimization across Python implementations. abarnert's other answer goes into some more detail and provides links for those interested in the history behind the optimization in Python 3 (and lack of optimization of xrange in Python 2). Answers by poke and by wim provide the relevant C source code and explanations for those who are interested."}, "answers": [{"id": 30081318, "score": 2863, "vote": 0, "content": "<p>The Python 3 <code>range()</code> object doesn't produce numbers immediately; it is a smart <a href=\"https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence\" rel=\"noreferrer\">sequence object</a> that produces numbers <em>on demand</em>. All it contains is your start, stop and step values, then as you iterate over the object the next integer is calculated each iteration.</p>\n<p>The object also implements the <a href=\"https://docs.python.org/3/reference/datamodel.html#object.__contains__\" rel=\"noreferrer\"><code>object.__contains__</code> hook</a>, and <em>calculates</em> if your number is part of its range. Calculating is a (near) constant time operation <sup>*</sup>. There is never a need to scan through all possible integers in the range.</p>\n<p>From the <a href=\"https://docs.python.org/3/library/stdtypes.html#range\" rel=\"noreferrer\"><code>range()</code> object documentation</a>:</p>\n<blockquote>\n<p>The advantage of the <code>range</code> type over a regular <code>list</code> or <code>tuple</code> is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the <code>start</code>, <code>stop</code> and <code>step</code> values, calculating individual items and subranges as needed).</p>\n</blockquote>\n<p>So at a minimum, your <code>range()</code> object would do:</p>\n<pre><code class=\"python\">class my_range:\n    def __init__(self, start, stop=None, step=1, /):\n        if stop is None:\n            start, stop = 0, start\n        self.start, self.stop, self.step = start, stop, step\n        if step &lt; 0:\n            lo, hi, step = stop, start, -step\n        else:\n            lo, hi = start, stop\n        self.length = 0 if lo &gt; hi else ((hi - lo - 1) // step) + 1\n\n    def __iter__(self):\n        current = self.start\n        if self.step &lt; 0:\n            while current &gt; self.stop:\n                yield current\n                current += self.step\n        else:\n            while current &lt; self.stop:\n                yield current\n                current += self.step\n\n    def __len__(self):\n        return self.length\n\n    def __getitem__(self, i):\n        if i &lt; 0:\n            i += self.length\n        if 0 &lt;= i &lt; self.length:\n            return self.start + i * self.step\n        raise IndexError('my_range object index out of range')\n\n    def __contains__(self, num):\n        if self.step &lt; 0:\n            if not (self.stop &lt; num &lt;= self.start):\n                return False\n        else:\n            if not (self.start &lt;= num &lt; self.stop):\n                return False\n        return (num - self.start) % self.step == 0\n</code></pre>\n<p>This is still missing several things that a real <code>range()</code> supports (such as the <code>.index()</code> or <code>.count()</code> methods, hashing, equality testing, or slicing), but should give you an idea.</p>\n<p>I also simplified the <code>__contains__</code> implementation to only focus on integer tests; if you give a real <code>range()</code> object a non-integer value (including subclasses of <code>int</code>), a slow scan is initiated to see if there is a match, just as if you use a containment test against a list of all the contained values. This was done to continue to support other numeric types that just happen to support equality testing with integers but are not expected to support integer arithmetic as well. See the original <a href=\"http://bugs.python.org/issue1766304\" rel=\"noreferrer\">Python issue</a> that implemented the containment test.</p>\n<hr/>\n<p>* <em>Near</em> constant time because Python integers are unbounded and so math operations also grow in time as N grows, making this a O(log N) operation. Since it\u2019s all executed in optimised C code and Python stores integer values in 30-bit chunks, you\u2019d run out of memory before you saw any performance impact due to the size of the integers involved here.</p>\n", "abstract": "The Python 3 range() object doesn't produce numbers immediately; it is a smart sequence object that produces numbers on demand. All it contains is your start, stop and step values, then as you iterate over the object the next integer is calculated each iteration. The object also implements the object.__contains__ hook, and calculates if your number is part of its range. Calculating is a (near) constant time operation *. There is never a need to scan through all possible integers in the range. From the range() object documentation: The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed). So at a minimum, your range() object would do: This is still missing several things that a real range() supports (such as the .index() or .count() methods, hashing, equality testing, or slicing), but should give you an idea. I also simplified the __contains__ implementation to only focus on integer tests; if you give a real range() object a non-integer value (including subclasses of int), a slow scan is initiated to see if there is a match, just as if you use a containment test against a list of all the contained values. This was done to continue to support other numeric types that just happen to support equality testing with integers but are not expected to support integer arithmetic as well. See the original Python issue that implemented the containment test. * Near constant time because Python integers are unbounded and so math operations also grow in time as N grows, making this a O(log N) operation. Since it\u2019s all executed in optimised C code and Python stores integer values in 30-bit chunks, you\u2019d run out of memory before you saw any performance impact due to the size of the integers involved here."}, {"id": 30081894, "score": 1121, "vote": 0, "content": "<p>The fundamental misunderstanding here is in thinking that <code>range</code> is a generator. It's not. In fact, it's not any kind of iterator.</p>\n<p>You can tell this pretty easily:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a = range(5)\n&gt;&gt;&gt; print(list(a))\n[0, 1, 2, 3, 4]\n&gt;&gt;&gt; print(list(a))\n[0, 1, 2, 3, 4]\n</code></pre>\n<p>If it were a generator, iterating it once would exhaust it:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; b = my_crappy_range(5)\n&gt;&gt;&gt; print(list(b))\n[0, 1, 2, 3, 4]\n&gt;&gt;&gt; print(list(b))\n[]\n</code></pre>\n<p>What <code>range</code> actually is, is a sequence, just like a list. You can even test this:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import collections.abc\n&gt;&gt;&gt; isinstance(a, collections.abc.Sequence)\nTrue\n</code></pre>\n<p>This means it has to follow all the rules of being a sequence:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; a[3]         # indexable\n3\n&gt;&gt;&gt; len(a)       # sized\n5\n&gt;&gt;&gt; 3 in a       # membership\nTrue\n&gt;&gt;&gt; reversed(a)  # reversible\n&lt;range_iterator at 0x101cd2360&gt;\n&gt;&gt;&gt; a.index(3)   # implements 'index'\n3\n&gt;&gt;&gt; a.count(3)   # implements 'count'\n1\n</code></pre>\n<hr/>\n<p>The difference between a <code>range</code> and a <code>list</code> is that a <code>range</code> is a <em>lazy</em> or <em>dynamic</em> sequence; it doesn't remember all of its values, it just remembers its <code>start</code>, <code>stop</code>, and <code>step</code>, and creates the values on demand on <code>__getitem__</code>.</p>\n<p>(As a side note, if you <code>print(iter(a))</code>, you'll notice that <code>range</code> uses the same <code>listiterator</code> type as <code>list</code>. How does that work? A <code>listiterator</code> doesn't use anything special about <code>list</code> except for the fact that it provides a C implementation of <code>__getitem__</code>, so it works fine for <code>range</code> too.)</p>\n<hr/>\n<p>Now, there's nothing that says that <code>Sequence.__contains__</code> has to be constant time\u2014in fact, for obvious examples of sequences like <code>list</code>, it isn't. But there's nothing that says it <em>can't</em> be. And it's easier to implement <code>range.__contains__</code> to just check it mathematically (<code>(val - start) % step</code>, but with some extra complexity to deal with negative steps) than to actually generate and test all the values, so why <em>shouldn't</em> it do it the better way?</p>\n<p>But there doesn't seem to be anything in the language that <em>guarantees</em> this will happen. As Ashwini Chaudhari points out, if you give it a non-integral value, instead of converting to integer and doing the mathematical test, it will fall back to iterating all the values and comparing them one by one. And just because CPython 3.2+ and PyPy 3.x versions happen to contain this optimization, and it's an obvious good idea and easy to do, there's no reason that IronPython or NewKickAssPython 3.x couldn't leave it out. (And in fact, CPython 3.0-3.1 <em>didn't</em> include it.)</p>\n<hr/>\n<p>If <code>range</code> actually were a generator, like <code>my_crappy_range</code>, then it wouldn't make sense to test <code>__contains__</code> this way, or at least the way it makes sense wouldn't be obvious. If you'd already iterated the first 3 values, is <code>1</code> still <code>in</code> the generator? Should testing for <code>1</code> cause it to iterate and consume all the values up to <code>1</code> (or up to the first value <code>&gt;= 1</code>)?</p>\n", "abstract": "The fundamental misunderstanding here is in thinking that range is a generator. It's not. In fact, it's not any kind of iterator. You can tell this pretty easily: If it were a generator, iterating it once would exhaust it: What range actually is, is a sequence, just like a list. You can even test this: This means it has to follow all the rules of being a sequence: The difference between a range and a list is that a range is a lazy or dynamic sequence; it doesn't remember all of its values, it just remembers its start, stop, and step, and creates the values on demand on __getitem__. (As a side note, if you print(iter(a)), you'll notice that range uses the same listiterator type as list. How does that work? A listiterator doesn't use anything special about list except for the fact that it provides a C implementation of __getitem__, so it works fine for range too.) Now, there's nothing that says that Sequence.__contains__ has to be constant time\u2014in fact, for obvious examples of sequences like list, it isn't. But there's nothing that says it can't be. And it's easier to implement range.__contains__ to just check it mathematically ((val - start) % step, but with some extra complexity to deal with negative steps) than to actually generate and test all the values, so why shouldn't it do it the better way? But there doesn't seem to be anything in the language that guarantees this will happen. As Ashwini Chaudhari points out, if you give it a non-integral value, instead of converting to integer and doing the mathematical test, it will fall back to iterating all the values and comparing them one by one. And just because CPython 3.2+ and PyPy 3.x versions happen to contain this optimization, and it's an obvious good idea and easy to do, there's no reason that IronPython or NewKickAssPython 3.x couldn't leave it out. (And in fact, CPython 3.0-3.1 didn't include it.) If range actually were a generator, like my_crappy_range, then it wouldn't make sense to test __contains__ this way, or at least the way it makes sense wouldn't be obvious. If you'd already iterated the first 3 values, is 1 still in the generator? Should testing for 1 cause it to iterate and consume all the values up to 1 (or up to the first value >= 1)?"}, {"id": 30081470, "score": 466, "vote": 0, "content": "<p>Use the <a href=\"https://github.com/python/cpython/blob/cff677abe1823900e954592035a170eb67840971/Objects/rangeobject.c#L364-L413\" rel=\"nofollow noreferrer\">source</a>, Luke!</p>\n<p>In CPython, <code>range(...).__contains__</code> (a method wrapper) will eventually delegate to a simple calculation which checks if the value can possibly be in the range.  The reason for the speed here is we're using <strong>mathematical reasoning about the bounds, rather than a direct iteration of the range object</strong>.  To explain the logic used:</p>\n<ol>\n<li>Check that the number is between <code>start</code> and <code>stop</code>, and</li>\n<li>Check that the stride value doesn't \"step over\" our number.</li>\n</ol>\n<p>For example, <code>994</code> is in <code>range(4, 1000, 2)</code> because:</p>\n<ol>\n<li><code>4 &lt;= 994 &lt; 1000</code>, and</li>\n<li><code>(994 - 4) % 2 == 0</code>.</li>\n</ol>\n<p>The full C code is included below, which is a bit more verbose because of memory management and reference counting details, but the basic idea is there:</p>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">static int\nrange_contains_long(rangeobject *r, PyObject *ob)\n{\n    int cmp1, cmp2, cmp3;\n    PyObject *tmp1 = NULL;\n    PyObject *tmp2 = NULL;\n    PyObject *zero = NULL;\n    int result = -1;\n\n    zero = PyLong_FromLong(0);\n    if (zero == NULL) /* MemoryError in int(0) */\n        goto end;\n\n    /* Check if the value can possibly be in the range. */\n\n    cmp1 = PyObject_RichCompareBool(r-&gt;step, zero, Py_GT);\n    if (cmp1 == -1)\n        goto end;\n    if (cmp1 == 1) { /* positive steps: start &lt;= ob &lt; stop */\n        cmp2 = PyObject_RichCompareBool(r-&gt;start, ob, Py_LE);\n        cmp3 = PyObject_RichCompareBool(ob, r-&gt;stop, Py_LT);\n    }\n    else { /* negative steps: stop &lt; ob &lt;= start */\n        cmp2 = PyObject_RichCompareBool(ob, r-&gt;start, Py_LE);\n        cmp3 = PyObject_RichCompareBool(r-&gt;stop, ob, Py_LT);\n    }\n\n    if (cmp2 == -1 || cmp3 == -1) /* TypeError */\n        goto end;\n    if (cmp2 == 0 || cmp3 == 0) { /* ob outside of range */\n        result = 0;\n        goto end;\n    }\n\n    /* Check that the stride does not invalidate ob's membership. */\n    tmp1 = PyNumber_Subtract(ob, r-&gt;start);\n    if (tmp1 == NULL)\n        goto end;\n    tmp2 = PyNumber_Remainder(tmp1, r-&gt;step);\n    if (tmp2 == NULL)\n        goto end;\n    /* result = ((int(ob) - start) % step) == 0 */\n    result = PyObject_RichCompareBool(tmp2, zero, Py_EQ);\n  end:\n    Py_XDECREF(tmp1);\n    Py_XDECREF(tmp2);\n    Py_XDECREF(zero);\n    return result;\n}\n\nstatic int\nrange_contains(rangeobject *r, PyObject *ob)\n{\n    if (PyLong_CheckExact(ob) || PyBool_Check(ob))\n        return range_contains_long(r, ob);\n\n    return (int)_PySequence_IterSearch((PyObject*)r, ob,\n                                       PY_ITERSEARCH_CONTAINS);\n}\n</code></pre>\n<p>The \"meat\" of the idea is mentioned in the comment lines:</p>\n<pre><code class=\"python\">/* positive steps: start &lt;= ob &lt; stop */\n/* negative steps: stop &lt; ob &lt;= start */\n/* result = ((int(ob) - start) % step) == 0 */ \n</code></pre>\n<p>As a final note - look at the <code>range_contains</code> function at the bottom of the code snippet.  If the exact type check fails then we don't use the clever algorithm described, instead falling back to a dumb iteration search of the range using <code>_PySequence_IterSearch</code>!  You can check this behaviour in the interpreter (I'm using v3.5.0 here):</p>\n<pre><code class=\"python\">&gt;&gt;&gt; x, r = 1000000000000000, range(1000000000000001)\n&gt;&gt;&gt; class MyInt(int):\n...     pass\n... \n&gt;&gt;&gt; x_ = MyInt(x)\n&gt;&gt;&gt; x in r  # calculates immediately :) \nTrue\n&gt;&gt;&gt; x_ in r  # iterates for ages.. :( \n^\\Quit (core dumped)\n</code></pre>\n", "abstract": "Use the source, Luke! In CPython, range(...).__contains__ (a method wrapper) will eventually delegate to a simple calculation which checks if the value can possibly be in the range.  The reason for the speed here is we're using mathematical reasoning about the bounds, rather than a direct iteration of the range object.  To explain the logic used: For example, 994 is in range(4, 1000, 2) because: The full C code is included below, which is a bit more verbose because of memory management and reference counting details, but the basic idea is there: The \"meat\" of the idea is mentioned in the comment lines: As a final note - look at the range_contains function at the bottom of the code snippet.  If the exact type check fails then we don't use the clever algorithm described, instead falling back to a dumb iteration search of the range using _PySequence_IterSearch!  You can check this behaviour in the interpreter (I'm using v3.5.0 here):"}, {"id": 30081467, "score": 190, "vote": 0, "content": "<p>To add to Martijn\u2019s answer, this is the relevant part of <a href=\"https://hg.python.org/cpython/file/7f8cd879687b/Objects/rangeobject.c#l415\" rel=\"noreferrer\">the source</a> (in C, as the range object is written in native code):</p>\n<pre class=\"lang-c prettyprint-override\"><code class=\"python\">static int\nrange_contains(rangeobject *r, PyObject *ob)\n{\n    if (PyLong_CheckExact(ob) || PyBool_Check(ob))\n        return range_contains_long(r, ob);\n\n    return (int)_PySequence_IterSearch((PyObject*)r, ob,\n                                       PY_ITERSEARCH_CONTAINS);\n}\n</code></pre>\n<p>So for <code>PyLong</code> objects (which is <code>int</code> in Python 3), it will use the <code>range_contains_long</code> function to determine the result. And that function essentially checks if <code>ob</code> is in the specified range (although it looks a bit more complex in C).</p>\n<p>If it\u2019s not an <code>int</code> object, it falls back to iterating until it finds the value (or not).</p>\n<p>The whole logic could be translated to pseudo-Python like this:</p>\n<pre><code class=\"python\">def range_contains (rangeObj, obj):\n    if isinstance(obj, int):\n        return range_contains_long(rangeObj, obj)\n\n    # default logic by iterating\n    return any(obj == x for x in rangeObj)\n\ndef range_contains_long (r, num):\n    if r.step &gt; 0:\n        # positive step: r.start &lt;= num &lt; r.stop\n        cmp2 = r.start &lt;= num\n        cmp3 = num &lt; r.stop\n    else:\n        # negative step: r.start &gt;= num &gt; r.stop\n        cmp2 = num &lt;= r.start\n        cmp3 = r.stop &lt; num\n\n    # outside of the range boundaries\n    if not cmp2 or not cmp3:\n        return False\n\n    # num must be on a valid step inside the boundaries\n    return (num - r.start) % r.step == 0\n</code></pre>\n", "abstract": "To add to Martijn\u2019s answer, this is the relevant part of the source (in C, as the range object is written in native code): So for PyLong objects (which is int in Python 3), it will use the range_contains_long function to determine the result. And that function essentially checks if ob is in the specified range (although it looks a bit more complex in C). If it\u2019s not an int object, it falls back to iterating until it finds the value (or not). The whole logic could be translated to pseudo-Python like this:"}, {"id": 30088140, "score": 128, "vote": 0, "content": "<p>If you're wondering <em>why</em> this optimization was added to <code>range.__contains__</code>, and why it <em>wasn't</em> added to <code>xrange.__contains__</code> in 2.7:</p>\n<p>First, as Ashwini Chaudhary discovered, <a href=\"http://bugs.python.org/issue1766304\" rel=\"noreferrer\">issue 1766304</a> was opened explicitly to optimize <code>[x]range.__contains__</code>. A patch for this was <a href=\"https://hg.python.org/cpython/rev/d599a3f2e72d/\" rel=\"noreferrer\">accepted and checked in for 3.2</a>, but not backported to 2.7 because \"<code>xrange</code> has behaved like this for such a long time that I don't see what it buys us to commit the patch this late.\" (2.7 was nearly out at that point.)</p>\n<p>Meanwhile:</p>\n<p>Originally, <code>xrange</code> was a not-quite-sequence object. As <a href=\"https://docs.python.org/3.1/library/stdtypes.html#range-type\" rel=\"noreferrer\">the 3.1 docs</a> say:</p>\n<blockquote>\n<p>Range objects have very little behavior: they only support indexing, iteration, and the <code>len</code> function.</p>\n</blockquote>\n<p>This wasn't quite true; an <code>xrange</code> object actually supported a few other things that come automatically with indexing and <code>len</code>,<sup>*</sup> including <code>__contains__</code> (via linear search). But nobody thought it was worth making them full sequences at the time.</p>\n<p>Then, as part of implementing the <a href=\"https://www.python.org/dev/peps/pep-3119/\" rel=\"noreferrer\">Abstract Base Classes</a> PEP, it was important to figure out which builtin types should be marked as implementing which ABCs, and <code>xrange</code>/<code>range</code> claimed to implement <code>collections.Sequence</code>, even though it still only handled the same \"very little behavior\". Nobody noticed that problem until <a href=\"http://bugs.python.org/issue9213\" rel=\"noreferrer\">issue 9213</a>. The patch for that issue not only added <code>index</code> and <code>count</code> to 3.2's <code>range</code>, it also re-worked the optimized <code>__contains__</code> (which shares the same math with <code>index</code>, and is directly used by <code>count</code>).<sup>**</sup> <a href=\"https://github.com/python/cpython/commit/8ee11f7e599b2c5b4de39047bf11bde2246e968f\" rel=\"noreferrer\">This change</a> went in for 3.2 as well, and was not backported to 2.x, because \"it's a bugfix that adds new methods\". (At this point, 2.7 was already past rc status.)</p>\n<p>So, there were two chances to get this optimization backported to 2.7, but they were both rejected.</p>\n<hr/>\n<p><sub>* In fact, you even get iteration for free with indexing alone, but <a href=\"https://docs.python.org/2/whatsnew/2.3.html#optimizations\" rel=\"noreferrer\">in 2.3</a> <code>xrange</code> objects got a custom iterator.</sub></p>\n<p><sub>** The first version actually reimplemented it, and got the details wrong\u2014e.g., it would give you <code>MyIntSubclass(2) in range(5) == False</code>. But Daniel Stutzbach's updated version of the patch restored most of the previous code, including the fallback to the generic, slow <code>_PySequence_IterSearch</code> that pre-3.2 <code>range.__contains__</code> was implicitly using when the optimization doesn't apply.</sub></p>\n", "abstract": "If you're wondering why this optimization was added to range.__contains__, and why it wasn't added to xrange.__contains__ in 2.7: First, as Ashwini Chaudhary discovered, issue 1766304 was opened explicitly to optimize [x]range.__contains__. A patch for this was accepted and checked in for 3.2, but not backported to 2.7 because \"xrange has behaved like this for such a long time that I don't see what it buys us to commit the patch this late.\" (2.7 was nearly out at that point.) Meanwhile: Originally, xrange was a not-quite-sequence object. As the 3.1 docs say: Range objects have very little behavior: they only support indexing, iteration, and the len function. This wasn't quite true; an xrange object actually supported a few other things that come automatically with indexing and len,* including __contains__ (via linear search). But nobody thought it was worth making them full sequences at the time. Then, as part of implementing the Abstract Base Classes PEP, it was important to figure out which builtin types should be marked as implementing which ABCs, and xrange/range claimed to implement collections.Sequence, even though it still only handled the same \"very little behavior\". Nobody noticed that problem until issue 9213. The patch for that issue not only added index and count to 3.2's range, it also re-worked the optimized __contains__ (which shares the same math with index, and is directly used by count).** This change went in for 3.2 as well, and was not backported to 2.x, because \"it's a bugfix that adds new methods\". (At this point, 2.7 was already past rc status.) So, there were two chances to get this optimization backported to 2.7, but they were both rejected. * In fact, you even get iteration for free with indexing alone, but in 2.3 xrange objects got a custom iterator. ** The first version actually reimplemented it, and got the details wrong\u2014e.g., it would give you MyIntSubclass(2) in range(5) == False. But Daniel Stutzbach's updated version of the patch restored most of the previous code, including the fallback to the generic, slow _PySequence_IterSearch that pre-3.2 range.__contains__ was implicitly using when the optimization doesn't apply."}, {"id": 30081959, "score": 59, "vote": 0, "content": "<p>The other answers explained it well already, but I'd like to offer another experiment illustrating the nature of range objects:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; r = range(5)\n&gt;&gt;&gt; for i in r:\n        print(i, 2 in r, list(r))\n        \n0 True [0, 1, 2, 3, 4]\n1 True [0, 1, 2, 3, 4]\n2 True [0, 1, 2, 3, 4]\n3 True [0, 1, 2, 3, 4]\n4 True [0, 1, 2, 3, 4]\n</code></pre>\n<p>As you can see, a <code>range</code> object is an object that remembers its range and can be used many times (even while iterating over it), not just a one-time generator.</p>\n", "abstract": "The other answers explained it well already, but I'd like to offer another experiment illustrating the nature of range objects: As you can see, a range object is an object that remembers its range and can be used many times (even while iterating over it), not just a one-time generator."}, {"id": 49318899, "score": 39, "vote": 0, "content": "<p>It's all about a <strong>lazy approach</strong> to the evaluation and some <strong>extra optimization</strong> of <code>range</code>.\nValues in ranges don't need to be computed until real use, or even further due to extra optimization.</p>\n<p>By the way, your integer is not such big, consider <code>sys.maxsize</code></p>\n<p><code>sys.maxsize in range(sys.maxsize)</code> <em>is pretty fast</em></p>\n<p>due to optimization - it's easy to compare given integers just with min and max of range.</p>\n<p>but:</p>\n<p><code>Decimal(sys.maxsize) in range(sys.maxsize)</code> <em>is pretty slow</em>.</p>\n<p>(in this case, there is no optimization in <code>range</code>, so if python receives unexpected Decimal, python will compare all numbers)</p>\n<p>You should be aware of an implementation detail but should not be relied upon, because this may change in the future.</p>\n", "abstract": "It's all about a lazy approach to the evaluation and some extra optimization of range.\nValues in ranges don't need to be computed until real use, or even further due to extra optimization. By the way, your integer is not such big, consider sys.maxsize sys.maxsize in range(sys.maxsize) is pretty fast due to optimization - it's easy to compare given integers just with min and max of range. but: Decimal(sys.maxsize) in range(sys.maxsize) is pretty slow. (in this case, there is no optimization in range, so if python receives unexpected Decimal, python will compare all numbers) You should be aware of an implementation detail but should not be relied upon, because this may change in the future."}, {"id": 54203493, "score": 30, "vote": 0, "content": "<h2>TL;DR</h2>\n<p>The object returned by <code>range()</code> is actually a <code>range</code> object. This object implements the iterator interface so you can iterate over its values sequentially, just like a generator, list, or tuple.</p>\n<p>But it <strong>also</strong> implements the <a href=\"https://docs.python.org/3/reference/datamodel.html#object.__contains__\" rel=\"noreferrer\"><code>__contains__</code></a> interface which is actually what gets called when an object appears on the right-hand side of the <code>in</code> operator. The <code>__contains__()</code> method returns a <code>bool</code> of whether or not the item on the left-hand side of the <code>in</code> is in the object. Since <code>range</code> objects know their bounds and stride, this is very easy to implement in O(1).</p>\n", "abstract": "The object returned by range() is actually a range object. This object implements the iterator interface so you can iterate over its values sequentially, just like a generator, list, or tuple. But it also implements the __contains__ interface which is actually what gets called when an object appears on the right-hand side of the in operator. The __contains__() method returns a bool of whether or not the item on the left-hand side of the in is in the object. Since range objects know their bounds and stride, this is very easy to implement in O(1)."}, {"id": 59037501, "score": 5, "vote": 0, "content": "<ol>\n<li>Due to optimization, it is very easy to compare given integers just with min and max range.</li>\n<li>The reason that the <strong>range()</strong> function is so fast in Python3 is that here we use mathematical reasoning for the bounds, rather than a direct iteration of the range object.</li>\n<li>So for explaining the logic here:</li>\n</ol>\n<ul>\n<li>Check whether the number is between the start and stop.</li>\n<li>Check whether the step precision value doesn't go over our number.</li>\n</ul>\n<ol start=\"4\">\n<li><p>Take an example, <strong>997 is in range(4, 1000, 3)</strong> because:</p>\n<p><code>4 &lt;= 997 &lt; 1000, and (997 - 4) % 3 == 0.</code></p>\n</li>\n</ol>\n", "abstract": "Take an example, 997 is in range(4, 1000, 3) because: 4 <= 997 < 1000, and (997 - 4) % 3 == 0."}, {"id": 60628550, "score": 4, "vote": 0, "content": "<p>Try <code>x-1 in (i for i in range(x))</code> for large <code>x</code> values, which uses a generator comprehension to avoid invoking the <code>range.__contains__</code> optimisation.</p>\n", "abstract": "Try x-1 in (i for i in range(x)) for large x values, which uses a generator comprehension to avoid invoking the range.__contains__ optimisation."}, {"id": 64283933, "score": 3, "vote": 0, "content": "<p><strong>TLDR;</strong>\nthe <code>range</code> is an arithmetic series so it can very easily calculate whether the object is there. It could even get the index of it if it were list like really quickly.</p>\n", "abstract": "TLDR;\nthe range is an arithmetic series so it can very easily calculate whether the object is there. It could even get the index of it if it were list like really quickly."}, {"id": 73609795, "score": -2, "vote": 0, "content": "<p><code>__contains__</code> method compares directly with the start and end of the range</p>\n", "abstract": "__contains__ method compares directly with the start and end of the range"}]}, {"link": "https://stackoverflow.com/questions/11346283/renaming-column-names-in-pandas", "question": {"id": "11346283", "title": "Renaming column names in Pandas", "content": "<p>I want to change the column labels of a Pandas DataFrame from</p>\n<pre><code class=\"python\">['$a', '$b', '$c', '$d', '$e']\n</code></pre>\n<p>to</p>\n<pre><code class=\"python\">['a', 'b', 'c', 'd', 'e']\n</code></pre>\n", "abstract": "I want to change the column labels of a Pandas DataFrame from to"}, "answers": [{"id": 11354850, "score": 4057, "vote": 0, "content": "<h2>Rename Specific Columns</h2>\n<p>Use the <a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.rename.html\" rel=\"noreferrer\"><code>df.rename()</code></a> function and refer the columns to be renamed. Not all the columns have to be renamed:</p>\n<pre><code class=\"python\">df = df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'})\n# Or rename the existing DataFrame (rather than creating a copy) \ndf.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'}, inplace=True)\n</code></pre>\n<p><strong>Minimal Code Example</strong></p>\n<pre><code class=\"python\">df = pd.DataFrame('x', index=range(3), columns=list('abcde'))\ndf\n\n   a  b  c  d  e\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n</code></pre>\n<p>The following methods all work and produce the same output:</p>\n<pre><code class=\"python\">df2 = df.rename({'a': 'X', 'b': 'Y'}, axis=1)  # new method\ndf2 = df.rename({'a': 'X', 'b': 'Y'}, axis='columns')\ndf2 = df.rename(columns={'a': 'X', 'b': 'Y'})  # old method  \n\ndf2\n\n   X  Y  c  d  e\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n</code></pre>\n<p>Remember to assign the result back, as the modification is not-inplace. Alternatively, specify <code>inplace=True</code>:</p>\n<pre><code class=\"python\">df.rename({'a': 'X', 'b': 'Y'}, axis=1, inplace=True)\ndf\n\n   X  Y  c  d  e\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n \n</code></pre>\n<p>From v0.25, you can also specify <code>errors='raise'</code> to raise errors if an invalid column-to-rename is specified. See <a href=\"https://pandas-docs.github.io/pandas-docs-travis/reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename\" rel=\"noreferrer\">v0.25 <code>rename()</code> docs</a>.</p>\n<hr/>\n<h2>Reassign Column Headers</h2>\n<p>Use <a href=\"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.set_axis.html\" rel=\"noreferrer\"><code>df.set_axis()</code></a> with <code>axis=1</code> and <code>inplace=False</code> (to return a copy).</p>\n<pre><code class=\"python\">df2 = df.set_axis(['V', 'W', 'X', 'Y', 'Z'], axis=1, inplace=False)\ndf2\n\n   V  W  X  Y  Z\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n</code></pre>\n<p>This returns a copy, but you can modify the DataFrame in-place by setting <code>inplace=True</code> (this is the default behaviour for versions &lt;=0.24 but is likely to change in the future).</p>\n<p>You can also assign headers directly:</p>\n<pre><code class=\"python\">df.columns = ['V', 'W', 'X', 'Y', 'Z']\ndf\n\n   V  W  X  Y  Z\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n</code></pre>\n", "abstract": "Use the df.rename() function and refer the columns to be renamed. Not all the columns have to be renamed: Minimal Code Example The following methods all work and produce the same output: Remember to assign the result back, as the modification is not-inplace. Alternatively, specify inplace=True: From v0.25, you can also specify errors='raise' to raise errors if an invalid column-to-rename is specified. See v0.25 rename() docs. Use df.set_axis() with axis=1 and inplace=False (to return a copy). This returns a copy, but you can modify the DataFrame in-place by setting inplace=True (this is the default behaviour for versions <=0.24 but is likely to change in the future). You can also assign headers directly:"}, {"id": 11346337, "score": 2451, "vote": 0, "content": "<p>Just assign it to the <code>.columns</code> attribute:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; df = pd.DataFrame({'$a':[1,2], '$b': [10,20]})\n&gt;&gt;&gt; df\n   $a  $b\n0   1  10\n1   2  20\n\n&gt;&gt;&gt; df.columns = ['a', 'b']\n&gt;&gt;&gt; df\n   a   b\n0  1  10\n1  2  20\n</code></pre>\n", "abstract": "Just assign it to the .columns attribute:"}, {"id": 16667215, "score": 487, "vote": 0, "content": "<p>The <a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.rename.html\" rel=\"noreferrer\"><code>rename</code></a> method can take a <strong><em>function</em></strong>, for example:</p>\n<pre><code class=\"python\">In [11]: df.columns\nOut[11]: Index([u'$a', u'$b', u'$c', u'$d', u'$e'], dtype=object)\n\nIn [12]: df.rename(columns=lambda x: x[1:], inplace=True)\n\nIn [13]: df.columns\nOut[13]: Index([u'a', u'b', u'c', u'd', u'e'], dtype=object)\n</code></pre>\n", "abstract": "The rename method can take a function, for example:"}, {"id": 30546734, "score": 250, "vote": 0, "content": "<p>As documented in <em><a href=\"http://pandas.pydata.org/pandas-docs/stable/text.html\" rel=\"noreferrer\">Working with text data</a></em>:</p>\n<pre><code class=\"python\">df.columns = df.columns.str.replace('$', '')\n</code></pre>\n", "abstract": "As documented in Working with text data:"}, {"id": 46912050, "score": 190, "vote": 0, "content": "<h1>Pandas 0.21+ Answer</h1>\n<p>There have been some significant updates to column renaming in version 0.21. </p>\n<ul>\n<li>The <a href=\"http://pandas.pydata.org/pandas-docs/version/0.21/whatsnew.html#rename-reindex-now-also-accept-axis-keyword\" rel=\"noreferrer\"><code>rename</code> method</a> has added the <code>axis</code> parameter which may be set to <code>columns</code> or <code>1</code>. This update makes this method match the rest of the pandas API. It still has the <code>index</code> and <code>columns</code> parameters but you are no longer forced to use them. </li>\n<li>The <a href=\"http://pandas.pydata.org/pandas-docs/version/0.21/generated/pandas.DataFrame.set_axis.html#pandas.DataFrame.set_axis\" rel=\"noreferrer\"><code>set_axis</code> method</a> with the <code>inplace</code> set to <code>False</code> enables you to rename all the index or column labels with a list.</li>\n</ul>\n<h2>Examples for Pandas 0.21+</h2>\n<p>Construct sample DataFrame:</p>\n<pre><code class=\"python\">df = pd.DataFrame({'$a':[1,2], '$b': [3,4], \n                   '$c':[5,6], '$d':[7,8], \n                   '$e':[9,10]})\n\n   $a  $b  $c  $d  $e\n0   1   3   5   7   9\n1   2   4   6   8  10\n</code></pre>\n<h3>Using <code>rename</code> with <code>axis='columns'</code> or <code>axis=1</code></h3>\n<pre><code class=\"python\">df.rename({'$a':'a', '$b':'b', '$c':'c', '$d':'d', '$e':'e'}, axis='columns')\n</code></pre>\n<p>or </p>\n<pre><code class=\"python\">df.rename({'$a':'a', '$b':'b', '$c':'c', '$d':'d', '$e':'e'}, axis=1)\n</code></pre>\n<p>Both result in the following:</p>\n<pre><code class=\"python\">   a  b  c  d   e\n0  1  3  5  7   9\n1  2  4  6  8  10\n</code></pre>\n<p>It is still possible to use the old method signature:</p>\n<pre><code class=\"python\">df.rename(columns={'$a':'a', '$b':'b', '$c':'c', '$d':'d', '$e':'e'})\n</code></pre>\n<p>The <code>rename</code> function also accepts functions that will be applied to each column name.</p>\n<pre><code class=\"python\">df.rename(lambda x: x[1:], axis='columns')\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">df.rename(lambda x: x[1:], axis=1)\n</code></pre>\n<hr/>\n<h3>Using <code>set_axis</code> with a list and <code>inplace=False</code></h3>\n<p>You can supply a list to the <code>set_axis</code> method that is equal in length to the number of columns (or index). Currently, <code>inplace</code> defaults to <code>True</code>, but <code>inplace</code> will be defaulted to <code>False</code> in future releases.</p>\n<pre><code class=\"python\">df.set_axis(['a', 'b', 'c', 'd', 'e'], axis='columns', inplace=False)\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">df.set_axis(['a', 'b', 'c', 'd', 'e'], axis=1, inplace=False)\n</code></pre>\n<hr/>\n<h3>Why not use <code>df.columns = ['a', 'b', 'c', 'd', 'e']</code>?</h3>\n<p>There is nothing wrong with assigning columns directly like this. It is a perfectly good solution. </p>\n<p>The advantage of using <code>set_axis</code> is that it can be used as part of a method chain and that it returns a new copy of the DataFrame. Without it, you would have to store your intermediate steps of the chain to another variable before reassigning the columns.</p>\n<pre><code class=\"python\"># new for pandas 0.21+\ndf.some_method1()\n  .some_method2()\n  .set_axis()\n  .some_method3()\n\n# old way\ndf1 = df.some_method1()\n        .some_method2()\ndf1.columns = columns\ndf1.some_method3()\n</code></pre>\n", "abstract": "There have been some significant updates to column renaming in version 0.21.  Construct sample DataFrame: or  Both result in the following: It is still possible to use the old method signature: The rename function also accepts functions that will be applied to each column name. or You can supply a list to the set_axis method that is equal in length to the number of columns (or index). Currently, inplace defaults to True, but inplace will be defaulted to False in future releases. or There is nothing wrong with assigning columns directly like this. It is a perfectly good solution.  The advantage of using set_axis is that it can be used as part of a method chain and that it returns a new copy of the DataFrame. Without it, you would have to store your intermediate steps of the chain to another variable before reassigning the columns."}, {"id": 22657894, "score": 151, "vote": 0, "content": "<p>Since you only want to remove the $ sign in all column names, you could just do:</p>\n<pre><code class=\"python\">df = df.rename(columns=lambda x: x.replace('$', ''))\n</code></pre>\n<p>OR</p>\n<pre><code class=\"python\">df.rename(columns=lambda x: x.replace('$', ''), inplace=True)\n</code></pre>\n", "abstract": "Since you only want to remove the $ sign in all column names, you could just do: OR"}, {"id": 61679284, "score": 138, "vote": 0, "content": "<p>Renaming columns in Pandas is an easy task.</p>\n<pre><code class=\"python\">df.rename(columns={'$a': 'a', '$b': 'b', '$c': 'c', '$d': 'd', '$e': 'e'}, inplace=True)\n</code></pre>\n", "abstract": "Renaming columns in Pandas is an easy task."}, {"id": 36149967, "score": 91, "vote": 0, "content": "<pre><code class=\"python\">df.columns = ['a', 'b', 'c', 'd', 'e']\n</code></pre>\n<p>It will replace the existing names with the names you provide, in the order you provide.</p>\n", "abstract": "It will replace the existing names with the names you provide, in the order you provide."}, {"id": 30380922, "score": 79, "vote": 0, "content": "<p>Use:</p>\n<pre><code class=\"python\">old_names = ['$a', '$b', '$c', '$d', '$e'] \nnew_names = ['a', 'b', 'c', 'd', 'e']\ndf.rename(columns=dict(zip(old_names, new_names)), inplace=True)\n</code></pre>\n<p>This way you can manually edit the <code>new_names</code> as you wish. It works great when you need to rename only a few columns to correct misspellings, accents, remove special characters, etc.</p>\n", "abstract": "Use: This way you can manually edit the new_names as you wish. It works great when you need to rename only a few columns to correct misspellings, accents, remove special characters, etc."}, {"id": 46192213, "score": 43, "vote": 0, "content": "<h1>One line or Pipeline solutions</h1>\n<p>I'll focus on two things:</p>\n<ol>\n<li><p>OP clearly states</p>\n<blockquote>\n<p>I have the edited column names stored it in a list, but I don't know how to replace the column names.</p>\n</blockquote>\n<p>I do not want to solve the problem of how to replace <code>'$'</code> or strip the first character off of each column header.  OP has already done this step.  Instead I want to focus on replacing the existing <code>columns</code> object with a new one given a list of replacement column names.</p>\n</li>\n<li><p><code>df.columns = new</code> where <code>new</code> is the list of new columns names is as simple as it gets.  The drawback of this approach is that it requires editing the existing dataframe's <code>columns</code> attribute and it isn't done inline.  I'll show a few ways to perform this via pipelining without editing the existing dataframe.</p>\n</li>\n</ol>\n<hr/>\n<p><strong>Setup 1</strong><br/>\nTo focus on the need to rename of replace column names with a pre-existing list, I'll create a new sample dataframe <code>df</code> with initial column names and unrelated new column names.</p>\n<pre><code class=\"python\">df = pd.DataFrame({'Jack': [1, 2], 'Mahesh': [3, 4], 'Xin': [5, 6]})\nnew = ['x098', 'y765', 'z432']\n\ndf\n\n   Jack  Mahesh  Xin\n0     1       3    5\n1     2       4    6\n</code></pre>\n<hr/>\n<p><strong>Solution 1</strong><br/>\n<a href=\"https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.rename.html\" rel=\"noreferrer\"><strong><code>pd.DataFrame.rename</code></strong></a></p>\n<p>It has been said already that <strong>if</strong> you had a dictionary mapping the old column names to new column names, you could use <code>pd.DataFrame.rename</code>.</p>\n<pre><code class=\"python\">d = {'Jack': 'x098', 'Mahesh': 'y765', 'Xin': 'z432'}\ndf.rename(columns=d)\n\n   x098  y765  z432\n0     1     3     5\n1     2     4     6\n</code></pre>\n<p>However, you can easily create that dictionary and include it in the call to <code>rename</code>.  The following takes advantage of the fact that when iterating over <code>df</code>, we iterate over each column name.</p>\n<pre><code class=\"python\"># Given just a list of new column names\ndf.rename(columns=dict(zip(df, new)))\n\n   x098  y765  z432\n0     1     3     5\n1     2     4     6\n</code></pre>\n<p>This works great if your original column names are unique.  But if they are not, then this breaks down.</p>\n<hr/>\n<p><strong>Setup 2</strong><br/>\nNon-unique columns</p>\n<pre><code class=\"python\">df = pd.DataFrame(\n    [[1, 3, 5], [2, 4, 6]],\n    columns=['Mahesh', 'Mahesh', 'Xin']\n)\nnew = ['x098', 'y765', 'z432']\n\ndf\n\n   Mahesh  Mahesh  Xin\n0       1       3    5\n1       2       4    6\n</code></pre>\n<hr/>\n<p><strong>Solution 2</strong><br/>\n<a href=\"https://pandas.pydata.org/pandas-docs/stable/generated/pandas.concat.html\" rel=\"noreferrer\"><strong><code>pd.concat</code></strong></a> using the <code>keys</code> argument</p>\n<p>First, notice what happens when we attempt to use solution 1:</p>\n<pre><code class=\"python\">df.rename(columns=dict(zip(df, new)))\n\n   y765  y765  z432\n0     1     3     5\n1     2     4     6\n</code></pre>\n<p>We didn't map the <code>new</code> list as the column names.  We ended up repeating <code>y765</code>.  Instead, we can use the <code>keys</code> argument of the <code>pd.concat</code> function while iterating through the columns of <code>df</code>.</p>\n<pre><code class=\"python\">pd.concat([c for _, c in df.items()], axis=1, keys=new) \n\n   x098  y765  z432\n0     1     3     5\n1     2     4     6\n</code></pre>\n<hr/>\n<p><strong>Solution 3</strong><br/>\nReconstruct.  This should only be used if you have a single <code>dtype</code> for all columns.  Otherwise, you'll end up with <code>dtype</code> <code>object</code> for all columns and converting them back requires more dictionary work.</p>\n<p><em>Single <code>dtype</code></em></p>\n<pre><code class=\"python\">pd.DataFrame(df.values, df.index, new)\n\n   x098  y765  z432\n0     1     3     5\n1     2     4     6\n</code></pre>\n<p><em>Mixed <code>dtype</code></em></p>\n<pre><code class=\"python\">pd.DataFrame(df.values, df.index, new).astype(dict(zip(new, df.dtypes)))\n\n   x098  y765  z432\n0     1     3     5\n1     2     4     6\n</code></pre>\n<hr/>\n<p><strong>Solution 4</strong><br/>\nThis is a gimmicky trick with <code>transpose</code> and <code>set_index</code>.  <a href=\"https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.set_index.html\" rel=\"noreferrer\"><strong><code>pd.DataFrame.set_index</code></strong></a> allows us to set an index inline, but there is no corresponding <code>set_columns</code>.  So we can transpose, then <code>set_index</code>, and transpose back.  However, the same single <code>dtype</code> versus mixed <code>dtype</code> caveat from solution 3 applies here.</p>\n<p><em>Single <code>dtype</code></em></p>\n<pre><code class=\"python\">df.T.set_index(np.asarray(new)).T\n\n   x098  y765  z432\n0     1     3     5\n1     2     4     6\n</code></pre>\n<p><em>Mixed <code>dtype</code></em></p>\n<pre><code class=\"python\">df.T.set_index(np.asarray(new)).T.astype(dict(zip(new, df.dtypes)))\n\n   x098  y765  z432\n0     1     3     5\n1     2     4     6\n</code></pre>\n<hr/>\n<p><strong>Solution 5</strong><br/>\nUse a <code>lambda</code> in <code>pd.DataFrame.rename</code> that cycles through each element of <code>new</code>.<br/>\nIn this solution, we pass a lambda that takes <code>x</code> but then ignores it.  It also takes a <code>y</code> but doesn't expect it.  Instead, an iterator is given as a default value and I can then use that to cycle through one at a time without regard to what the value of <code>x</code> is.</p>\n<pre><code class=\"python\">df.rename(columns=lambda x, y=iter(new): next(y))\n\n   x098  y765  z432\n0     1     3     5\n1     2     4     6\n</code></pre>\n<p>And as pointed out to me by the folks in <a href=\"https://chat.stackoverflow.com/rooms/6/python\"><em>sopython</em> chat</a>, if I add a <code>*</code> in between <code>x</code> and <code>y</code>, I can protect my <code>y</code> variable.  Though, in this context I don't believe it needs protecting.  It is still worth mentioning.</p>\n<pre><code class=\"python\">df.rename(columns=lambda x, *, y=iter(new): next(y))\n\n   x098  y765  z432\n0     1     3     5\n1     2     4     6\n</code></pre>\n", "abstract": "I'll focus on two things: OP clearly states I have the edited column names stored it in a list, but I don't know how to replace the column names. I do not want to solve the problem of how to replace '$' or strip the first character off of each column header.  OP has already done this step.  Instead I want to focus on replacing the existing columns object with a new one given a list of replacement column names. df.columns = new where new is the list of new columns names is as simple as it gets.  The drawback of this approach is that it requires editing the existing dataframe's columns attribute and it isn't done inline.  I'll show a few ways to perform this via pipelining without editing the existing dataframe. Setup 1\nTo focus on the need to rename of replace column names with a pre-existing list, I'll create a new sample dataframe df with initial column names and unrelated new column names. Solution 1\npd.DataFrame.rename It has been said already that if you had a dictionary mapping the old column names to new column names, you could use pd.DataFrame.rename. However, you can easily create that dictionary and include it in the call to rename.  The following takes advantage of the fact that when iterating over df, we iterate over each column name. This works great if your original column names are unique.  But if they are not, then this breaks down. Setup 2\nNon-unique columns Solution 2\npd.concat using the keys argument First, notice what happens when we attempt to use solution 1: We didn't map the new list as the column names.  We ended up repeating y765.  Instead, we can use the keys argument of the pd.concat function while iterating through the columns of df. Solution 3\nReconstruct.  This should only be used if you have a single dtype for all columns.  Otherwise, you'll end up with dtype object for all columns and converting them back requires more dictionary work. Single dtype Mixed dtype Solution 4\nThis is a gimmicky trick with transpose and set_index.  pd.DataFrame.set_index allows us to set an index inline, but there is no corresponding set_columns.  So we can transpose, then set_index, and transpose back.  However, the same single dtype versus mixed dtype caveat from solution 3 applies here. Single dtype Mixed dtype Solution 5\nUse a lambda in pd.DataFrame.rename that cycles through each element of new.\nIn this solution, we pass a lambda that takes x but then ignores it.  It also takes a y but doesn't expect it.  Instead, an iterator is given as a default value and I can then use that to cycle through one at a time without regard to what the value of x is. And as pointed out to me by the folks in sopython chat, if I add a * in between x and y, I can protect my y variable.  Though, in this context I don't believe it needs protecting.  It is still worth mentioning."}, {"id": 39770407, "score": 42, "vote": 0, "content": "<h1>Column names vs Names of Series</h1>\n<p>I would like to explain a bit what happens behind the scenes.</p>\n<p>Dataframes are a set of Series.</p>\n<p>Series in turn are an extension of a <code>numpy.array</code>.</p>\n<p><code>numpy.array</code>s have a property <code>.name</code>.</p>\n<p>This is the name of the series. It is seldom that Pandas respects this attribute, but it lingers in places and can be used to hack some Pandas behaviors.</p>\n<h1>Naming the list of columns</h1>\n<p>A lot of answers here talks about the <code>df.columns</code> attribute being a <code>list</code> when in fact it is a <code>Series</code>. This means it has a <code>.name</code> attribute.</p>\n<p>This is what happens if you decide to fill in the name of the columns <code>Series</code>:</p>\n<pre><code class=\"python\">df.columns = ['column_one', 'column_two']\ndf.columns.names = ['name of the list of columns']\ndf.index.names = ['name of the index']\n\nname of the list of columns     column_one  column_two\nname of the index\n0                                    4           1\n1                                    5           2\n2                                    6           3\n</code></pre>\n<p>Note that the name of the index always comes one column lower.</p>\n<h2>Artefacts that linger</h2>\n<p>The <code>.name</code> attribute lingers on sometimes. If you set <code>df.columns = ['one', 'two']</code> then the <code>df.one.name</code> will be <code>'one'</code>.</p>\n<p>If you set <code>df.one.name = 'three'</code> then <code>df.columns</code> will still give you <code>['one', 'two']</code>, and <code>df.one.name</code> will give you <code>'three'</code>.</p>\n<h3>BUT</h3>\n<p><code>pd.DataFrame(df.one)</code> will return</p>\n<pre><code class=\"python\">    three\n0       1\n1       2\n2       3\n</code></pre>\n<p>Because Pandas reuses the <code>.name</code> of the already defined <code>Series</code>.</p>\n<h1>Multi-level column names</h1>\n<p>Pandas has ways of doing multi-layered column names. There is not so much magic involved, but I wanted to cover this in my answer too since I don't see anyone picking up on this here.</p>\n<pre><code class=\"python\">    |one            |\n    |one      |two  |\n0   |  4      |  1  |\n1   |  5      |  2  |\n2   |  6      |  3  |\n</code></pre>\n<p>This is easily achievable by setting columns to lists, like this:</p>\n<pre><code class=\"python\">df.columns = [['one', 'one'], ['one', 'two']]\n</code></pre>\n", "abstract": "I would like to explain a bit what happens behind the scenes. Dataframes are a set of Series. Series in turn are an extension of a numpy.array. numpy.arrays have a property .name. This is the name of the series. It is seldom that Pandas respects this attribute, but it lingers in places and can be used to hack some Pandas behaviors. A lot of answers here talks about the df.columns attribute being a list when in fact it is a Series. This means it has a .name attribute. This is what happens if you decide to fill in the name of the columns Series: Note that the name of the index always comes one column lower. The .name attribute lingers on sometimes. If you set df.columns = ['one', 'two'] then the df.one.name will be 'one'. If you set df.one.name = 'three' then df.columns will still give you ['one', 'two'], and df.one.name will give you 'three'. pd.DataFrame(df.one) will return Because Pandas reuses the .name of the already defined Series. Pandas has ways of doing multi-layered column names. There is not so much magic involved, but I wanted to cover this in my answer too since I don't see anyone picking up on this here. This is easily achievable by setting columns to lists, like this:"}, {"id": 60584778, "score": 32, "vote": 0, "content": "<p>Let's <em>understand</em> renaming by a small example...</p>\n<ol>\n<li><p>Renaming columns using mapping:</p>\n<pre><code class=\"python\"> df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]}) # Creating a df with column name A and B\n df.rename({\"A\": \"new_a\", \"B\": \"new_b\"}, axis='columns', inplace =True) # Renaming column A with 'new_a' and B with 'new_b'\n\n Output:\n\n    new_a  new_b\n 0  1       4\n 1  2       5\n 2  3       6\n</code></pre>\n</li>\n<li><p>Renaming index/Row_Name using mapping:</p>\n<pre><code class=\"python\"> df.rename({0: \"x\", 1: \"y\", 2: \"z\"}, axis='index', inplace =True) # Row name are getting replaced by 'x', 'y', and 'z'.\n\n Output:\n\n        new_a  new_b\n     x  1       4\n     y  2       5\n     z  3       6\n</code></pre>\n</li>\n</ol>\n", "abstract": "Let's understand renaming by a small example... Renaming columns using mapping: Renaming index/Row_Name using mapping:"}, {"id": 67467042, "score": 31, "vote": 0, "content": "<p>Suppose your dataset name is df, and df has.</p>\n<pre><code class=\"python\">df = ['$a', '$b', '$c', '$d', '$e']`\n</code></pre>\n<p>So, to rename these, we would simply do.</p>\n<pre><code class=\"python\">df.columns = ['a','b','c','d','e']\n</code></pre>\n", "abstract": "Suppose your dataset name is df, and df has. So, to rename these, we would simply do."}, {"id": 57670616, "score": 26, "vote": 0, "content": "<p>Let's say this is your dataframe.</p>\n<p><a href=\"https://i.stack.imgur.com/vazEj.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/vazEj.png\"/></a></p>\n<p>You can rename the columns using two methods.</p>\n<ol>\n<li><p>Using <code>dataframe.columns=[#list]</code></p>\n<pre><code class=\"python\">df.columns=['a','b','c','d','e']\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/uFQzo.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/uFQzo.png\"/></a></p>\n<p>The limitation of this method is that if one column has to be changed, full column list has to be passed. Also, this method is not applicable on index labels.\nFor example, if you passed this:</p>\n<pre><code class=\"python\">df.columns = ['a','b','c','d']\n</code></pre>\n<p>This will throw an error. Length mismatch: Expected axis has 5 elements, new values have 4 elements.</p></li>\n<li><p>Another method is the Pandas <code>rename()</code> method which is used to rename any index, column or row</p>\n<pre><code class=\"python\">df = df.rename(columns={'$a':'a'})\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/sqPu9.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/sqPu9.png\"/></a></p></li>\n</ol>\n<p>Similarly, you can change any rows or columns.</p>\n", "abstract": "Let's say this is your dataframe.  You can rename the columns using two methods. Using dataframe.columns=[#list]  The limitation of this method is that if one column has to be changed, full column list has to be passed. Also, this method is not applicable on index labels.\nFor example, if you passed this: This will throw an error. Length mismatch: Expected axis has 5 elements, new values have 4 elements. Another method is the Pandas rename() method which is used to rename any index, column or row  Similarly, you can change any rows or columns."}, {"id": 67978608, "score": 26, "vote": 0, "content": "<p>Many of pandas functions have an inplace parameter. When setting it True, the transformation applies directly to the dataframe that you are calling it on. For example:</p>\n<pre><code class=\"python\">df = pd.DataFrame({'$a':[1,2], '$b': [3,4]})\ndf.rename(columns={'$a': 'a'}, inplace=True)\ndf.columns\n\n&gt;&gt;&gt; Index(['a', '$b'], dtype='object')\n</code></pre>\n<p>Alternatively, there are cases where you want to preserve the original dataframe. I have often seen people fall into this case if creating the dataframe is an expensive task. For example, if creating the dataframe required querying a snowflake database. In this case, just make sure the the inplace parameter is set to False.</p>\n<pre><code class=\"python\">df = pd.DataFrame({'$a':[1,2], '$b': [3,4]})\ndf2 = df.rename(columns={'$a': 'a'}, inplace=False)\ndf.columns\n\n&gt;&gt;&gt; Index(['$a', '$b'], dtype='object')\n\ndf2.columns\n\n&gt;&gt;&gt; Index(['a', '$b'], dtype='object')\n</code></pre>\n<p>If these types of transformations are something that you do often, you could also look into a number of different pandas GUI tools. I'm the creator of one called <a href=\"https://trymito.io/soo\" rel=\"nofollow noreferrer\">Mito</a>. It\u2019s a spreadsheet that automatically converts your edits to python code.</p>\n", "abstract": "Many of pandas functions have an inplace parameter. When setting it True, the transformation applies directly to the dataframe that you are calling it on. For example: Alternatively, there are cases where you want to preserve the original dataframe. I have often seen people fall into this case if creating the dataframe is an expensive task. For example, if creating the dataframe required querying a snowflake database. In this case, just make sure the the inplace parameter is set to False. If these types of transformations are something that you do often, you could also look into a number of different pandas GUI tools. I'm the creator of one called Mito. It\u2019s a spreadsheet that automatically converts your edits to python code."}, {"id": 32322596, "score": 22, "vote": 0, "content": "<p>If you've got the dataframe, df.columns dumps everything into a list you can manipulate and then reassign into your dataframe as the names of columns...</p>\n<pre><code class=\"python\">columns = df.columns\ncolumns = [row.replace(\"$\", \"\") for row in columns]\ndf.rename(columns=dict(zip(columns, things)), inplace=True)\ndf.head() # To validate the output\n</code></pre>\n<p>Best way? I don't know. A way - yes.</p>\n<p>A better way of evaluating all the main techniques put forward in the answers to the question is below using cProfile to gage memory and execution time. @kadee, @kaitlyn, and @eumiro had the functions with the fastest execution times - though these functions are so fast we're comparing the rounding of 0.000 and 0.001 seconds for all the answers. Moral: my answer above likely isn't the 'best' way.</p>\n<pre><code class=\"python\">import pandas as pd\nimport cProfile, pstats, re\n\nold_names = ['$a', '$b', '$c', '$d', '$e']\nnew_names = ['a', 'b', 'c', 'd', 'e']\ncol_dict = {'$a': 'a', '$b': 'b', '$c': 'c', '$d': 'd', '$e': 'e'}\n\ndf = pd.DataFrame({'$a':[1, 2], '$b': [10, 20], '$c': ['bleep', 'blorp'], '$d': [1, 2], '$e': ['texa$', '']})\n\ndf.head()\n\ndef eumiro(df, nn):\n    df.columns = nn\n    # This direct renaming approach is duplicated in methodology in several other answers:\n    return df\n\ndef lexual1(df):\n    return df.rename(columns=col_dict)\n\ndef lexual2(df, col_dict):\n    return df.rename(columns=col_dict, inplace=True)\n\ndef Panda_Master_Hayden(df):\n    return df.rename(columns=lambda x: x[1:], inplace=True)\n\ndef paulo1(df):\n    return df.rename(columns=lambda x: x.replace('$', ''))\n\ndef paulo2(df):\n    return df.rename(columns=lambda x: x.replace('$', ''), inplace=True)\n\ndef migloo(df, on, nn):\n    return df.rename(columns=dict(zip(on, nn)), inplace=True)\n\ndef kadee(df):\n    return df.columns.str.replace('$', '')\n\ndef awo(df):\n    columns = df.columns\n    columns = [row.replace(\"$\", \"\") for row in columns]\n    return df.rename(columns=dict(zip(columns, '')), inplace=True)\n\ndef kaitlyn(df):\n    df.columns = [col.strip('$') for col in df.columns]\n    return df\n\nprint 'eumiro'\ncProfile.run('eumiro(df, new_names)')\nprint 'lexual1'\ncProfile.run('lexual1(df)')\nprint 'lexual2'\ncProfile.run('lexual2(df, col_dict)')\nprint 'andy hayden'\ncProfile.run('Panda_Master_Hayden(df)')\nprint 'paulo1'\ncProfile.run('paulo1(df)')\nprint 'paulo2'\ncProfile.run('paulo2(df)')\nprint 'migloo'\ncProfile.run('migloo(df, old_names, new_names)')\nprint 'kadee'\ncProfile.run('kadee(df)')\nprint 'awo'\ncProfile.run('awo(df)')\nprint 'kaitlyn'\ncProfile.run('kaitlyn(df)')\n</code></pre>\n", "abstract": "If you've got the dataframe, df.columns dumps everything into a list you can manipulate and then reassign into your dataframe as the names of columns... Best way? I don't know. A way - yes. A better way of evaluating all the main techniques put forward in the answers to the question is below using cProfile to gage memory and execution time. @kadee, @kaitlyn, and @eumiro had the functions with the fastest execution times - though these functions are so fast we're comparing the rounding of 0.000 and 0.001 seconds for all the answers. Moral: my answer above likely isn't the 'best' way."}, {"id": 51414545, "score": 22, "vote": 0, "content": "<pre><code class=\"python\">df.rename(index=str, columns={'A':'a', 'B':'b'})\n</code></pre>\n<p><em><a href=\"https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.rename.html\" rel=\"nofollow noreferrer\">pandas.DataFrame.rename</a></em></p>\n", "abstract": "pandas.DataFrame.rename"}, {"id": 35387028, "score": 21, "vote": 0, "content": "<pre><code class=\"python\">df = pd.DataFrame({'$a': [1], '$b': [1], '$c': [1], '$d': [1], '$e': [1]})\n</code></pre>\n<p>If your new list of columns is in the same order as the existing columns, the assignment is simple:</p>\n<pre><code class=\"python\">new_cols = ['a', 'b', 'c', 'd', 'e']\ndf.columns = new_cols\n&gt;&gt;&gt; df\n   a  b  c  d  e\n0  1  1  1  1  1\n</code></pre>\n<p>If you had a dictionary keyed on old column names to new column names, you could do the following:</p>\n<pre><code class=\"python\">d = {'$a': 'a', '$b': 'b', '$c': 'c', '$d': 'd', '$e': 'e'}\ndf.columns = df.columns.map(lambda col: d[col])  # Or `.map(d.get)` as pointed out by @PiRSquared.\n&gt;&gt;&gt; df\n   a  b  c  d  e\n0  1  1  1  1  1\n</code></pre>\n<p>If you don't have a list or dictionary mapping, you could strip the leading <code>$</code> symbol via a list comprehension:</p>\n<pre><code class=\"python\">df.columns = [col[1:] if col[0] == '$' else col for col in df]\n</code></pre>\n", "abstract": "If your new list of columns is in the same order as the existing columns, the assignment is simple: If you had a dictionary keyed on old column names to new column names, you could do the following: If you don't have a list or dictionary mapping, you could strip the leading $ symbol via a list comprehension:"}, {"id": 67914447, "score": 20, "vote": 0, "content": "<p>If you already have a list for the new column names, you can try this:</p>\n<pre><code class=\"python\">new_cols = ['a', 'b', 'c', 'd', 'e']\nnew_names_map = {df.columns[i]:new_cols[i] for i in range(len(new_cols))}\n\ndf.rename(new_names_map, axis=1, inplace=True)\n</code></pre>\n", "abstract": "If you already have a list for the new column names, you can try this:"}, {"id": 33872824, "score": 19, "vote": 0, "content": "<p>Another way we could replace the original column labels is by stripping the unwanted characters (here '$') from the original column labels.</p>\n<p>This could have been done by running a <em>for</em> loop over df.columns and appending the stripped columns to df.columns.</p>\n<p>Instead, we can do this neatly in a single statement by using list comprehension like below:</p>\n<pre><code class=\"python\">df.columns = [col.strip('$') for col in df.columns]\n</code></pre>\n<p>(<code>strip</code> method in Python strips the given character from beginning and end of the string.)</p>\n", "abstract": "Another way we could replace the original column labels is by stripping the unwanted characters (here '$') from the original column labels. This could have been done by running a for loop over df.columns and appending the stripped columns to df.columns. Instead, we can do this neatly in a single statement by using list comprehension like below: (strip method in Python strips the given character from beginning and end of the string.)"}, {"id": 33986975, "score": 19, "vote": 0, "content": "<p>It is real simple. Just use:</p>\n<pre><code class=\"python\">df.columns = ['Name1', 'Name2', 'Name3'...]\n</code></pre>\n<p>And it will assign the column names by the order you put them in.</p>\n", "abstract": "It is real simple. Just use: And it will assign the column names by the order you put them in."}, {"id": 68371189, "score": 16, "vote": 0, "content": "<pre><code class=\"python\"># This way it will work\nimport pandas as pd\n\n# Define a dictionary \nrankings = {'test': ['a'],\n        'odi': ['E'],\n        't20': ['P']}\n\n# Convert the dictionary into DataFrame\nrankings_pd = pd.DataFrame(rankings)\n\n# Before renaming the columns\nprint(rankings_pd)\n\nrankings_pd.rename(columns = {'test':'TEST'}, inplace = True)\n</code></pre>\n", "abstract": ""}, {"id": 35068123, "score": 13, "vote": 0, "content": "<p>You could use <a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.str.slice.html\" rel=\"noreferrer\"><code>str.slice</code></a> for that:</p>\n<pre><code class=\"python\">df.columns = df.columns.str.slice(1)\n</code></pre>\n", "abstract": "You could use str.slice for that:"}, {"id": 51219353, "score": 13, "vote": 0, "content": "<p>Another option is to rename using a regular expression:</p>\n<pre><code class=\"python\">import pandas as pd\nimport re\n\ndf = pd.DataFrame({'$a':[1,2], '$b':[3,4], '$c':[5,6]})\n\ndf = df.rename(columns=lambda x: re.sub('\\$','',x))\n&gt;&gt;&gt; df\n   a  b  c\n0  1  3  5\n1  2  4  6\n</code></pre>\n", "abstract": "Another option is to rename using a regular expression:"}, {"id": 38776854, "score": 12, "vote": 0, "content": "<p>My method is generic wherein you can add additional delimiters by comma separating <code>delimiters=</code> variable and future-proof it.</p>\n<p><strong>Working Code:</strong></p>\n<pre><code class=\"python\">import pandas as pd\nimport re\n\n\ndf = pd.DataFrame({'$a':[1,2], '$b': [3,4],'$c':[5,6], '$d': [7,8], '$e': [9,10]})\n\ndelimiters = '$'\nmatchPattern = '|'.join(map(re.escape, delimiters))\ndf.columns = [re.split(matchPattern, i)[1] for i in df.columns ]\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; df\n   $a  $b  $c  $d  $e\n0   1   3   5   7   9\n1   2   4   6   8  10\n\n&gt;&gt;&gt; df\n   a  b  c  d   e\n0  1  3  5  7   9\n1  2  4  6  8  10\n</code></pre>\n", "abstract": "My method is generic wherein you can add additional delimiters by comma separating delimiters= variable and future-proof it. Working Code: Output:"}, {"id": 39215492, "score": 11, "vote": 0, "content": "<p>Note that the approaches in previous answers do not work for a <em>MultiIndex</em>. For a <em>MultiIndex</em>, you need to do something like the following:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; df = pd.DataFrame({('$a','$x'):[1,2], ('$b','$y'): [3,4], ('e','f'):[5,6]})\n&gt;&gt;&gt; df\n   $a $b  e\n   $x $y  f\n0  1  3  5\n1  2  4  6\n&gt;&gt;&gt; rename = {('$a','$x'):('a','x'), ('$b','$y'):('b','y')}\n&gt;&gt;&gt; df.columns = pandas.MultiIndex.from_tuples([\n        rename.get(item, item) for item in df.columns.tolist()])\n&gt;&gt;&gt; df\n   a  b  e\n   x  y  f\n0  1  3  5\n1  2  4  6\n</code></pre>\n", "abstract": "Note that the approaches in previous answers do not work for a MultiIndex. For a MultiIndex, you need to do something like the following:"}, {"id": 44584447, "score": 10, "vote": 0, "content": "<p>If you have to deal with loads of columns named by the providing system out of your control, I came up with the following approach that is a combination of a general approach and specific replacements in one go.</p>\n<p>First create a dictionary from the dataframe column names using regular expressions in order to throw away certain appendixes of column names and then add specific replacements to the dictionary to name core columns as expected later in the receiving database.</p>\n<p>This is then applied to the dataframe in one go.</p>\n<pre><code class=\"python\">dict = dict(zip(df.columns, df.columns.str.replace('(:S$|:C1$|:L$|:D$|\\.Serial:L$)', '')))\ndict['brand_timeseries:C1'] = 'BTS'\ndict['respid:L'] = 'RespID'\ndict['country:C1'] = 'CountryID'\ndict['pim1:D'] = 'pim_actual'\ndf.rename(columns=dict, inplace=True)\n</code></pre>\n", "abstract": "If you have to deal with loads of columns named by the providing system out of your control, I came up with the following approach that is a combination of a general approach and specific replacements in one go. First create a dictionary from the dataframe column names using regular expressions in order to throw away certain appendixes of column names and then add specific replacements to the dictionary to name core columns as expected later in the receiving database. This is then applied to the dataframe in one go."}, {"id": 66706456, "score": 10, "vote": 0, "content": "<p>If you just want to remove the '$' sign then use the below code</p>\n<pre><code class=\"python\">df.columns = pd.Series(df.columns.str.replace(\"$\", \"\"))\n</code></pre>\n", "abstract": "If you just want to remove the '$' sign then use the below code"}, {"id": 60589137, "score": 8, "vote": 0, "content": "<p>In addition to the solution already provided, you can replace all the columns while you are reading the file. We can use <code>names</code> and <code>header=0</code> to do that.</p>\n<p>First, we create a list of the names that we like to use as our column names:</p>\n<pre><code class=\"python\">import pandas as pd\n\nufo_cols = ['city', 'color reported', 'shape reported', 'state', 'time']\nufo.columns = ufo_cols\n\nufo = pd.read_csv('link to the file you are using', names = ufo_cols, header = 0)\n</code></pre>\n<p>In this case, all the column names will be replaced with the names you have in your list.</p>\n", "abstract": "In addition to the solution already provided, you can replace all the columns while you are reading the file. We can use names and header=0 to do that. First, we create a list of the names that we like to use as our column names: In this case, all the column names will be replaced with the names you have in your list."}, {"id": 49915518, "score": 6, "vote": 0, "content": "<p>Here's a nifty little function I like to use to cut down on typing:</p>\n<pre><code class=\"python\">def rename(data, oldnames, newname):\n    if type(oldnames) == str: # Input can be a string or list of strings\n        oldnames = [oldnames] # When renaming multiple columns\n        newname = [newname] # Make sure you pass the corresponding list of new names\n    i = 0\n    for name in oldnames:\n        oldvar = [c for c in data.columns if name in c]\n        if len(oldvar) == 0:\n            raise ValueError(\"Sorry, couldn't find that column in the dataset\")\n        if len(oldvar) &gt; 1: # Doesn't have to be an exact match\n            print(\"Found multiple columns that matched \" + str(name) + \": \")\n            for c in oldvar:\n                print(str(oldvar.index(c)) + \": \" + str(c))\n            ind = input('Please enter the index of the column you would like to rename: ')\n            oldvar = oldvar[int(ind)]\n        if len(oldvar) == 1:\n            oldvar = oldvar[0]\n        data = data.rename(columns = {oldvar : newname[i]})\n        i += 1\n    return data\n</code></pre>\n<p>Here is an example of how it works:</p>\n<pre><code class=\"python\">In [2]: df = pd.DataFrame(np.random.randint(0, 10, size=(10, 4)), columns = ['col1', 'col2', 'omg', 'idk'])\n# First list = existing variables\n# Second list = new names for those variables\nIn [3]: df = rename(df, ['col', 'omg'],['first', 'ohmy'])\nFound multiple columns that matched col:\n0: col1\n1: col2\n\nPlease enter the index of the column you would like to rename: 0\n\nIn [4]: df.columns\nOut[5]: Index(['first', 'col2', 'ohmy', 'idk'], dtype='object')\n</code></pre>\n", "abstract": "Here's a nifty little function I like to use to cut down on typing: Here is an example of how it works:"}, {"id": 55635790, "score": 6, "vote": 0, "content": "<p>Assuming you can use a regular expression, this solution <em>removes</em> the need of manual encoding using a regular expression:</p>\n<pre><code class=\"python\">import pandas as pd\nimport re\n\nsrch = re.compile(r\"\\w+\")\n\ndata = pd.read_csv(\"CSV_FILE.csv\")\ncols = data.columns\nnew_cols = list(map(lambda v:v.group(), (list(map(srch.search, cols)))))\ndata.columns = new_cols\n</code></pre>\n", "abstract": "Assuming you can use a regular expression, this solution removes the need of manual encoding using a regular expression:"}, {"id": 62546763, "score": 6, "vote": 0, "content": "<p>I needed to rename features for XGBoost, and it didn't like any of these:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">import re\nregex = r\"[!\\\"#$%&amp;'()*+,\\-.\\/:;&lt;=&gt;?@[\\\\\\]^_`{|}~ ]+\"\nX_trn.columns = X_trn.columns.str.replace(regex, '_', regex=True)\nX_tst.columns = X_tst.columns.str.replace(regex, '_', regex=True)\n</code></pre>\n", "abstract": "I needed to rename features for XGBoost, and it didn't like any of these:"}, {"id": 73623532, "score": 1, "vote": 0, "content": "<p>My one line answer is</p>\n<p><code>df.columns = df_new_cols</code></p>\n<p>It is the best one with 1/3rd the processing time.</p>\n<p><code>timeit</code> comparison:</p>\n<p><em>df</em> has seven columns. I am trying to change a few of the names.</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">%timeit df.rename(columns={old_col:new_col for (old_col,new_col) in zip(df_old_cols,df_new_cols)},inplace=True)\n214 \u00b5s \u00b1 10.1 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n\n%timeit df.rename(columns=dict(zip(df_old_cols,df_new_cols)),inplace=True)\n212 \u00b5s \u00b1 7.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n\n%timeit df.columns = df_new_cols\n72.9 \u00b5s \u00b1 17.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n</code></pre>\n", "abstract": "My one line answer is df.columns = df_new_cols It is the best one with 1/3rd the processing time. timeit comparison: df has seven columns. I am trying to change a few of the names."}, {"id": 73010626, "score": 0, "vote": 0, "content": "<p>You can use the <a href=\"http://pandas.pydata.org/docs/reference/api/pandas.Series.str.lstrip.html#pandas.Series.str.lstrip\" rel=\"nofollow noreferrer\"><code>lstrip</code></a> or <a href=\"http://pandas.pydata.org/docs/reference/api/pandas.Series.str.strip.html#pandas.Series.str.strip\" rel=\"nofollow noreferrer\"><code>strip</code></a> methods with an index:</p>\n<pre><code class=\"python\">df.columns = df.columns.str.lstrip('$')\n</code></pre>\n<p>or</p>\n<pre><code class=\"python\">cols = ['$a', '$b', '$c', '$d', '$e']\npd.Series(cols).str.lstrip('$').tolist()\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">['a', 'b', 'c', 'd', 'e']\n</code></pre>\n", "abstract": "You can use the lstrip or strip methods with an index: or Output:"}]}, {"link": "https://stackoverflow.com/questions/1602934/check-if-a-given-key-already-exists-in-a-dictionary", "question": {"id": "1602934", "title": "Check if a given key already exists in a dictionary", "content": "<p>I wanted to test if a key exists in a dictionary before updating the value for the key.\nI wrote the following code:</p>\n<pre><code class=\"python\">if 'key1' in dict.keys():\n  print \"blah\"\nelse:\n  print \"boo\"\n</code></pre>\n<p>I think this is not the best way to accomplish this task. Is there a better way to test for a key in the dictionary?</p>\n", "abstract": "I wanted to test if a key exists in a dictionary before updating the value for the key.\nI wrote the following code: I think this is not the best way to accomplish this task. Is there a better way to test for a key in the dictionary?"}, "answers": [{"id": 1602964, "score": 4913, "vote": 0, "content": "<p><a href=\"https://docs.python.org/reference/expressions.html#membership-test-operations\" rel=\"noreferrer\"><code>in</code></a> tests for the existence of a key in a <a href=\"https://docs.python.org/library/stdtypes.html#dict\" rel=\"noreferrer\"><code>dict</code></a>:</p>\n<pre><code class=\"python\">d = {\"key1\": 10, \"key2\": 23}\n\nif \"key1\" in d:\n    print(\"this will execute\")\n\nif \"nonexistent key\" in d:\n    print(\"this will not\")\n</code></pre>\n<hr/>\n<p>Use <a href=\"https://docs.python.org/library/stdtypes.html#dict.get\" rel=\"noreferrer\"><code>dict.get()</code></a> to provide a default value when the key does not exist:</p>\n<pre><code class=\"python\">d = {}\n\nfor i in range(10):\n    d[i] = d.get(i, 0) + 1\n</code></pre>\n<hr/>\n<p>To provide a default value for <em>every</em> key, either use <a href=\"https://docs.python.org/library/stdtypes.html#dict.setdefault\" rel=\"noreferrer\"><code>dict.setdefault()</code></a> on each assignment:</p>\n<pre><code class=\"python\">d = {}\n\nfor i in range(10):\n    d[i] = d.setdefault(i, 0) + 1\n</code></pre>\n<p>or use <a href=\"https://docs.python.org/library/collections.html#collections.defaultdict\" rel=\"noreferrer\"><code>defaultdict</code></a> from the <a href=\"https://docs.python.org/library/collections.html\" rel=\"noreferrer\"><code>collections</code></a> module:</p>\n<pre><code class=\"python\">from collections import defaultdict\n\nd = defaultdict(int)\n\nfor i in range(10):\n    d[i] += 1\n</code></pre>\n", "abstract": "in tests for the existence of a key in a dict: Use dict.get() to provide a default value when the key does not exist: To provide a default value for every key, either use dict.setdefault() on each assignment: or use defaultdict from the collections module:"}, {"id": 1602944, "score": 1772, "vote": 0, "content": "<p>Use <code>key in my_dict</code> directly instead of <code>key in my_dict.keys()</code>:</p>\n<pre><code class=\"python\">if 'key1' in my_dict:\n    print(\"blah\")\nelse:\n    print(\"boo\")\n</code></pre>\n<p>That will be much <a href=\"https://stackoverflow.com/a/30527984/452708\">faster</a> as it uses the dictionary's O(1) hashing as opposed to doing an O(n) linear search on a list of keys.</p>\n", "abstract": "Use key in my_dict directly instead of key in my_dict.keys(): That will be much faster as it uses the dictionary's O(1) hashing as opposed to doing an O(n) linear search on a list of keys."}, {"id": 1602990, "score": 294, "vote": 0, "content": "<p>You can test for the presence of a key in a dictionary, using the <b>in</b> keyword:</p>\n<pre><code class=\"python\">d = {'a': 1, 'b': 2}\n'a' in d # &lt;== evaluates to True\n'c' in d # &lt;== evaluates to False\n</code></pre>\n<p>A common use for checking the existence of a key in a dictionary before mutating it is to default-initialize the value (e.g. if your values are lists, for example, and you want to ensure that there is an empty list to which you can append when inserting the first value for a key). In cases such as those, you may find the <a href=\"https://docs.python.org/2/library/collections.html#collections.defaultdict\" rel=\"noreferrer\"><code>collections.defaultdict()</code></a> type to be of interest.</p>\n<p>In older code, you may also find some uses of <code>has_key()</code>, a deprecated method for checking the existence of keys in dictionaries (just use <code>key_name in dict_name</code>, instead).</p>\n", "abstract": "You can test for the presence of a key in a dictionary, using the in keyword: A common use for checking the existence of a key in a dictionary before mutating it is to default-initialize the value (e.g. if your values are lists, for example, and you want to ensure that there is an empty list to which you can append when inserting the first value for a key). In cases such as those, you may find the collections.defaultdict() type to be of interest. In older code, you may also find some uses of has_key(), a deprecated method for checking the existence of keys in dictionaries (just use key_name in dict_name, instead)."}, {"id": 1602945, "score": 166, "vote": 0, "content": "<p>You can shorten your code to this:</p>\n<pre><code class=\"python\">if 'key1' in my_dict:\n    ...\n</code></pre>\n<p>However, this is at best a cosmetic improvement. Why do you believe this is not the best way?</p>\n", "abstract": "You can shorten your code to this: However, this is at best a cosmetic improvement. Why do you believe this is not the best way?"}, {"id": 30527984, "score": 91, "vote": 0, "content": "<p>For additional information on speed execution of the <a href=\"https://stackoverflow.com/questions/1602934/check-if-a-given-key-already-exists-in-a-dictionary/1602964#1602964\">accepted answer's</a> proposed methods (10\u00a0million loops):</p>\n<ul>\n<li><code>'key' in mydict</code> elapsed time 1.07 seconds</li>\n<li><code>mydict.get('key')</code> elapsed time 1.84 seconds</li>\n<li><code>mydefaultdict['key']</code> elapsed time 1.07 seconds</li>\n</ul>\n<p>Therefore using <code>in</code> or <code>defaultdict</code> are recommended against <code>get</code>.</p>\n", "abstract": "For additional information on speed execution of the accepted answer's proposed methods (10\u00a0million loops): Therefore using in or defaultdict are recommended against get."}, {"id": 1602950, "score": 65, "vote": 0, "content": "<p>I would recommend using the <code>setdefault</code> method instead.  It sounds like it will do everything you want.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; d = {'foo':'bar'}\n&gt;&gt;&gt; q = d.setdefault('foo','baz') #Do not override the existing key\n&gt;&gt;&gt; print q #The value takes what was originally in the dictionary\nbar\n&gt;&gt;&gt; print d\n{'foo': 'bar'}\n&gt;&gt;&gt; r = d.setdefault('baz',18) #baz was never in the dictionary\n&gt;&gt;&gt; print r #Now r has the value supplied above\n18\n&gt;&gt;&gt; print d #The dictionary's been updated\n{'foo': 'bar', 'baz': 18}\n</code></pre>\n", "abstract": "I would recommend using the setdefault method instead.  It sounds like it will do everything you want."}, {"id": 42527405, "score": 57, "vote": 0, "content": "<p>A dictionary in Python has a <code>get('key', default)</code> method. So you can just set a default value in case there isn't any key.</p>\n<pre><code class=\"python\">values = {...}\nmyValue = values.get('Key', None)\n</code></pre>\n", "abstract": "A dictionary in Python has a get('key', default) method. So you can just set a default value in case there isn't any key."}, {"id": 45766039, "score": 55, "vote": 0, "content": "<p>Using the <a href=\"https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator/394814#394814\">Python ternary operator</a>:</p>\n<pre><code class=\"python\">message = \"blah\" if 'key1' in my_dict else \"booh\"\nprint(message)\n</code></pre>\n", "abstract": "Using the Python ternary operator:"}, {"id": 21608048, "score": 46, "vote": 0, "content": "<p>Use EAFP (easier to ask forgiveness than permission):</p>\n<pre><code class=\"python\">try:\n   blah = dict[\"mykey\"]\n   # key exists in dict\nexcept KeyError:\n   # key doesn't exist in dict\n</code></pre>\n<p>See other Stack Overflow posts:</p>\n<ul>\n<li><em><a href=\"https://stackoverflow.com/questions/1835756/using-try-vs-if-in-python\">Using 'try' vs. 'if' in Python</a></em></li>\n<li><em><a href=\"https://stackoverflow.com/questions/204308/checking-for-member-existence-in-python\">Checking for member existence in Python</a></em></li>\n</ul>\n", "abstract": "Use EAFP (easier to ask forgiveness than permission): See other Stack Overflow posts:"}, {"id": 56282337, "score": 31, "vote": 0, "content": "<blockquote>\n<p>Check if a given key already exists in a dictionary</p>\n</blockquote>\n<p>To get the idea how to do that we first inspect what methods we can call on dictionary.</p>\n<p>Here are the methods:</p>\n<pre><code class=\"python\">d={'clear':0, 'copy':1, 'fromkeys':2, 'get':3, 'items':4, 'keys':5, 'pop':6, 'popitem':7, 'setdefault':8, 'update':9, 'values':10}\n</code></pre>\n<hr/>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">Python Dictionary clear()        Removes all Items\nPython Dictionary copy()         Returns Shallow Copy of a Dictionary\nPython Dictionary fromkeys()     Creates dictionary from given sequence\nPython Dictionary get()          Returns Value of The Key\nPython Dictionary items()        Returns view of dictionary (key, value) pair\nPython Dictionary keys()         Returns View Object of All Keys\nPython Dictionary pop()          Removes and returns element having given key\nPython Dictionary popitem()      Returns &amp; Removes Element From Dictionary\nPython Dictionary setdefault()   Inserts Key With a Value if Key is not Present\nPython Dictionary update()       Updates the Dictionary\nPython Dictionary values()       Returns view of all values in dictionary\n</code></pre>\n<hr/>\n<p>The brutal method to check if the key already exists may be the <code>get()</code> method:</p>\n<pre><code class=\"python\">d.get(\"key\")\n</code></pre>\n<p>The other two <em>interesting</em> methods <code>items()</code> and <code>keys()</code> sounds like too much of work. So let's examine if <code>get()</code> is the right method for us. We have our dict <code>d</code>:</p>\n<pre><code class=\"python\">d= {'clear':0, 'copy':1, 'fromkeys':2, 'get':3, 'items':4, 'keys':5, 'pop':6, 'popitem':7, 'setdefault':8, 'update':9, 'values':10}\n</code></pre>\n<p>Printing shows the key we don't have will return <code>None</code>:</p>\n<pre><code class=\"python\">print(d.get('key')) #None\nprint(d.get('clear')) #0\nprint(d.get('copy')) #1\n</code></pre>\n<p>We use that to get the information if the key is present or no.\nBut consider this if we create a dict with a single <code>key:None</code>:</p>\n<pre><code class=\"python\">d= {'key':None}\nprint(d.get('key')) #None\nprint(d.get('key2')) #None\n</code></pre>\n<p>Leading that <code>get()</code> method is not reliable in case some values may be <code>None</code>.</p>\n<p>This story should have a happier ending. If we use the <code>in</code> comparator:</p>\n<pre><code class=\"python\">print('key' in d) #True\nprint('key2' in d) #False\n</code></pre>\n<p>We get the correct results.</p>\n<p>We may examine the Python byte code:</p>\n<pre><code class=\"python\">import dis\ndis.dis(\"'key' in d\")\n#   1           0 LOAD_CONST               0 ('key')\n#               2 LOAD_NAME                0 (d)\n#               4 COMPARE_OP               6 (in)\n#               6 RETURN_VALUE\n\ndis.dis(\"d.get('key2')\")\n#   1           0 LOAD_NAME                0 (d)\n#               2 LOAD_METHOD              1 (get)\n#               4 LOAD_CONST               0 ('key2')\n#               6 CALL_METHOD              1\n#               8 RETURN_VALUE\n</code></pre>\n<p>This shows that <code>in</code> compare operator is not just more reliable, but even faster than <code>get()</code>.</p>\n", "abstract": "Check if a given key already exists in a dictionary To get the idea how to do that we first inspect what methods we can call on dictionary. Here are the methods: The brutal method to check if the key already exists may be the get() method: The other two interesting methods items() and keys() sounds like too much of work. So let's examine if get() is the right method for us. We have our dict d: Printing shows the key we don't have will return None: We use that to get the information if the key is present or no.\nBut consider this if we create a dict with a single key:None: Leading that get() method is not reliable in case some values may be None. This story should have a happier ending. If we use the in comparator: We get the correct results. We may examine the Python byte code: This shows that in compare operator is not just more reliable, but even faster than get()."}, {"id": 41256980, "score": 24, "vote": 0, "content": "<p><strong>The ways in which you can get the results are:</strong></p>\n<ul>\n<li>if your_dict.has_key(key) <a href=\"https://docs.python.org/3.1/whatsnew/3.0.html#builtins\" rel=\"noreferrer\">Removed in Python 3</a></li>\n<li>if key in your_dict</li>\n<li>try/except block</li>\n</ul>\n<p><strong>Which is better is dependent on 3 things:</strong></p>\n<ol>\n<li>Does the dictionary 'normally has the key' or 'normally does not have the key'.</li>\n<li>Do you intend to use conditions like if...else...elseif...else?</li>\n<li>How big is dictionary?</li>\n</ol>\n<p>Read More: <a href=\"http://paltman.com/try-except-performance-in-python-a-simple-test/\" rel=\"noreferrer\">http://paltman.com/try-except-performance-in-python-a-simple-test/</a></p>\n<p>Use of try/block instead of 'in' or 'if':</p>\n<pre><code class=\"python\">try:\n    my_dict_of_items[key_i_want_to_check]\nexcept KeyError:\n    # Do the operation you wanted to do for \"key not present in dict\".\nelse:\n    # Do the operation you wanted to do with \"key present in dict.\"\n</code></pre>\n", "abstract": "The ways in which you can get the results are: Which is better is dependent on 3 things: Read More: http://paltman.com/try-except-performance-in-python-a-simple-test/ Use of try/block instead of 'in' or 'if':"}, {"id": 16459431, "score": 21, "vote": 0, "content": "<h2>Python 2 only: (and Python\u00a02.7 supports `in` already)</h2>\n<p>You can use the <code>has_key()</code> method:</p>\n<pre><code class=\"python\">if dict.has_key('xyz')==1:\n    # Update the value for the key\nelse:\n    pass\n</code></pre>\n", "abstract": "You can use the has_key() method:"}, {"id": 16637874, "score": 19, "vote": 0, "content": "<p>Just an FYI adding to <a href=\"https://stackoverflow.com/questions/1602934/check-if-a-given-key-already-exists-in-a-dictionary/1602964#1602964\">Chris. B's (best) answer</a>:</p>\n<pre><code class=\"python\">d = defaultdict(int)\n</code></pre>\n<p>Works as well; the reason is that calling <code>int()</code> returns <code>0</code> which is what <code>defaultdict</code> does behind the scenes (when constructing a dictionary), hence the name \"Factory Function\" in the documentation.</p>\n", "abstract": "Just an FYI adding to Chris. B's (best) answer: Works as well; the reason is that calling int() returns 0 which is what defaultdict does behind the scenes (when constructing a dictionary), hence the name \"Factory Function\" in the documentation."}, {"id": 43632330, "score": 9, "vote": 0, "content": "<p>A Python dictionary has the method called <code>__contains__</code>. This method will return True if the dictionary has the key, else it returns False.</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">&gt;&gt;&gt; temp = {}\n\n&gt;&gt;&gt; help(temp.__contains__)\n\nHelp on built-in function __contains__:\n\n__contains__(key, /) method of builtins.dict instance\n    True if D has a key k, else False.\n</code></pre>\n", "abstract": "A Python dictionary has the method called __contains__. This method will return True if the dictionary has the key, else it returns False."}, {"id": 55885745, "score": 6, "vote": 0, "content": "<p>Another way of checking if a key exists using Boolean operators:</p>\n<pre class=\"lang-python prettyprint-override\"><code class=\"python\">d = {'a': 1, 'b':2}\nkeys = 'abcd'\n\nfor k in keys:\n    x = (k in d and 'blah') or 'boo'\n    print(x)\n</code></pre>\n<p>This returns</p>\n<pre><code class=\"python\">&gt;&gt;&gt; blah\n&gt;&gt;&gt; blah\n&gt;&gt;&gt; boo\n&gt;&gt;&gt; boo\n</code></pre>\n<p><strong>Explanation</strong></p>\n<p>First, you should know that in Python, <code>0</code>, <code>None</code>, or objects with zero length evaluate to <code>False</code>. Everything else evaluates to <code>True</code>. Boolean operations are evaluated left to right and return the operand not True or False.</p>\n<p>Let's see an example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 'Some string' or 1/0\n'Some string'\n&gt;&gt;&gt;\n</code></pre>\n<p>Since <code>'Some string'</code> evaluates to <code>True</code>, the rest of the <code>or</code> is not evaluated and there is no division by zero error raised.</p>\n<p>But if we switch the order <code>1/0</code> is evaluated first and raises an exception:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 1/0 or 'Some string'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nZeroDivisionError: division by zero\n&gt;&gt;&gt;\n</code></pre>\n<p>We can use this for pattern for checking if a key exists.</p>\n<pre><code class=\"python\">(k in d and 'blah')\n</code></pre>\n<p>does the same as</p>\n<pre><code class=\"python\">if k in d:\n    'blah'\nelse:\n    False\n</code></pre>\n<p>This already returns the correct result if the key exists, but we want it to print 'boo' when it doesn't. So, we take the result and <code>or</code> it with <code>'boo'</code></p>\n<pre><code class=\"python\">&gt;&gt;&gt; False or 'boo'\n'boo'\n&gt;&gt;&gt; 'blah' or 'boo'\n'blah'\n&gt;&gt;&gt;\n</code></pre>\n", "abstract": "Another way of checking if a key exists using Boolean operators: This returns Explanation First, you should know that in Python, 0, None, or objects with zero length evaluate to False. Everything else evaluates to True. Boolean operations are evaluated left to right and return the operand not True or False. Let's see an example: Since 'Some string' evaluates to True, the rest of the or is not evaluated and there is no division by zero error raised. But if we switch the order 1/0 is evaluated first and raises an exception: We can use this for pattern for checking if a key exists. does the same as This already returns the correct result if the key exists, but we want it to print 'boo' when it doesn't. So, we take the result and or it with 'boo'"}, {"id": 54660284, "score": 4, "vote": 0, "content": "<p>You can use a <code>for</code> loop to iterate over the dictionary and get the name of key you want to find in the dictionary. After that, check if it exist or not using <code>if</code> condition:</p>\n<pre><code class=\"python\">dic = {'first' : 12, 'second' : 123}\nfor each in dic:\n    if each == 'second':\n        print('the key exists and the corresponding value can be updated in the dictionary')\n</code></pre>\n", "abstract": "You can use a for loop to iterate over the dictionary and get the name of key you want to find in the dictionary. After that, check if it exist or not using if condition:"}]}, {"link": "https://stackoverflow.com/questions/379906/how-do-i-parse-a-string-to-a-float-or-int", "question": {"id": "379906", "title": "How do I parse a string to a float or int?", "content": "<ul>\n<li>How can I convert a <code>str</code> to <code>float</code>?\n<pre><code class=\"python\">\"545.2222\"  \u2192  545.2222\n</code></pre>\n</li>\n<li>How can I convert a <code>str</code> to <code>int</code>?\n<pre><code class=\"python\">\"31\"        \u2192  31\n</code></pre>\n</li>\n</ul>\n<hr/>\n<p><sub>For the reverse, see <a href=\"https://stackoverflow.com/questions/961632\">Convert integer to string in Python</a> and <a href=\"https://stackoverflow.com/questions/1317558\">Converting a float to a string without rounding it</a>.</sub></p>\n<p><sub>Please instead use <a href=\"https://stackoverflow.com/questions/20449427\">How can I read inputs as numbers?</a> to close duplicate questions where OP received a string <em>from user input</em> and immediately wants to convert it, or was hoping for <code>input</code> (in 3.x) to convert the type automatically.</sub></p>\n", "abstract": "For the reverse, see Convert integer to string in Python and Converting a float to a string without rounding it. Please instead use How can I read inputs as numbers? to close duplicate questions where OP received a string from user input and immediately wants to convert it, or was hoping for input (in 3.x) to convert the type automatically."}, "answers": [{"id": 379910, "score": 3009, "vote": 0, "content": "<pre><code class=\"python\">&gt;&gt;&gt; a = \"545.2222\"\n&gt;&gt;&gt; float(a)\n545.22220000000004\n&gt;&gt;&gt; int(float(a))\n545\n</code></pre>\n", "abstract": ""}, {"id": 20929983, "score": 587, "vote": 0, "content": "<h2>Python method to check if a string is a float:</h2>\n<pre><code class=\"python\">def is_float(value):\n  try:\n    float(value)\n    return True\n  except:\n    return False\n</code></pre>\n<p>A longer and more accurate name for this function could be: <code>is_convertible_to_float(value)</code></p>\n<h2>What is, and is not a float in <a href=\"http://en.wikipedia.org/wiki/Python_%28programming_language%29\" rel=\"nofollow noreferrer\">Python</a> may surprise you:</h2>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">val                   is_float(val) Note\n--------------------  ----------   --------------------------------\n\"\"                    False        Blank string\n\"127\"                 True         Passed string\nTrue                  True         Pure sweet Truth\n\"True\"                False        Vile contemptible lie\nFalse                 True         So false it becomes true\n\"123.456\"             True         Decimal\n\"      -127    \"      True         Spaces trimmed\n\"\\t\\n12\\r\\n\"          True         whitespace ignored\n\"NaN\"                 True         Not a number\n\"NaNanananaBATMAN\"    False        I am Batman\n\"-iNF\"                True         Negative infinity\n\"123.E4\"              True         Exponential notation\n\".1\"                  True         mantissa only\n\"1,234\"               False        Commas gtfo\nu'\\x30'               True         Unicode is fine.\n\"NULL\"                False        Null is not special\n0x3fade               True         Hexadecimal\n\"6e7777777777777\"     True         Shrunk to infinity\n\"1.797693e+308\"       True         This is max value\n\"infinity\"            True         Same as inf\n\"infinityandBEYOND\"   False        Extra characters wreck it\n\"12.34.56\"            False        Only one dot allowed\nu'\u56db'                 False        Japanese '4' is not a float.\n\"#56\"                 False        Pound sign\n\"56%\"                 False        Percent of what?\n\"0E0\"                 True         Exponential, move dot 0 places\n0**0                  True         0___0  Exponentiation\n\"-5e-5\"               True         Raise to a negative number\n\"+1e1\"                True         Plus is OK with exponent\n\"+1e1^5\"              False        Fancy exponent not interpreted\n\"+1e1.3\"              False        No decimals in exponent\n\"-+1\"                 False        Make up your mind\n\"(1)\"                 False        Parenthesis is bad\n</code></pre>\n<p>You think you know what numbers are? You are not so good as you think! Not big surprise.</p>\n<h2>Don't use this code on life-critical software!</h2>\n<p>Catching broad exceptions this way, killing canaries and gobbling the exception creates a tiny chance that a valid float as string will return false.  The <code>float(...)</code> line of code can failed for any of a thousand reasons that have nothing to do with the contents of the string.  But if you're writing life-critical software in a duck-typing prototype language like Python, then you've got much larger problems.</p>\n", "abstract": "A longer and more accurate name for this function could be: is_convertible_to_float(value) You think you know what numbers are? You are not so good as you think! Not big surprise. Catching broad exceptions this way, killing canaries and gobbling the exception creates a tiny chance that a valid float as string will return false.  The float(...) line of code can failed for any of a thousand reasons that have nothing to do with the contents of the string.  But if you're writing life-critical software in a duck-typing prototype language like Python, then you've got much larger problems."}, {"id": 379966, "score": 569, "vote": 0, "content": "<pre><code class=\"python\">def num(s):\n    try:\n        return int(s)\n    except ValueError:\n        return float(s)\n</code></pre>\n", "abstract": ""}, {"id": 9510585, "score": 160, "vote": 0, "content": "<p>This is another method which deserves to be mentioned here, <a href=\"http://docs.python.org/library/ast.html#ast.literal_eval\" rel=\"noreferrer\">ast.literal_eval</a>:</p>\n<blockquote>\n<p>This can be used for safely evaluating strings containing Python expressions from untrusted sources without the need to parse the values oneself.</p>\n</blockquote>\n<p>That is, a safe 'eval'</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import ast\n&gt;&gt;&gt; ast.literal_eval(\"545.2222\")\n545.2222\n&gt;&gt;&gt; ast.literal_eval(\"31\")\n31\n</code></pre>\n", "abstract": "This is another method which deserves to be mentioned here, ast.literal_eval: This can be used for safely evaluating strings containing Python expressions from untrusted sources without the need to parse the values oneself. That is, a safe 'eval'"}, {"id": 17815252, "score": 83, "vote": 0, "content": "<h2>Localization and commas</h2>\n<p>You should consider the possibility of commas in the string representation of a number, for cases like  <code>float(\"545,545.2222\")</code> which throws an exception. Instead, use methods in <code>locale</code> to convert the strings to numbers and interpret commas correctly. The <code>locale.atof</code> method converts to a float in one step once the locale has been set for the desired number convention.</p>\n<p><strong>Example 1 -- United States number conventions</strong> </p>\n<p>In the United States and the UK, commas can be used as a thousands separator.  In this example with American locale, the comma is handled properly as a separator:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import locale\n&gt;&gt;&gt; a = u'545,545.2222'\n&gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n'en_US.UTF-8'\n&gt;&gt;&gt; locale.atof(a)\n545545.2222\n&gt;&gt;&gt; int(locale.atof(a))\n545545\n&gt;&gt;&gt;\n</code></pre>\n<p><strong>Example 2 -- European number conventions</strong></p>\n<p>In the <a href=\"https://en.wikipedia.org/wiki/Decimal_mark\">majority of countries of the world</a>,  commas are used for decimal marks instead of periods.  In this example with French locale, the comma is correctly handled as a decimal mark:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import locale\n&gt;&gt;&gt; b = u'545,2222'\n&gt;&gt;&gt; locale.setlocale(locale.LC_ALL, 'fr_FR')\n'fr_FR'\n&gt;&gt;&gt; locale.atof(b)\n545.2222\n</code></pre>\n<p>The method <code>locale.atoi</code> is also available, but the argument should be an integer.</p>\n", "abstract": "You should consider the possibility of commas in the string representation of a number, for cases like  float(\"545,545.2222\") which throws an exception. Instead, use methods in locale to convert the strings to numbers and interpret commas correctly. The locale.atof method converts to a float in one step once the locale has been set for the desired number convention. Example 1 -- United States number conventions  In the United States and the UK, commas can be used as a thousands separator.  In this example with American locale, the comma is handled properly as a separator: Example 2 -- European number conventions In the majority of countries of the world,  commas are used for decimal marks instead of periods.  In this example with French locale, the comma is correctly handled as a decimal mark: The method locale.atoi is also available, but the argument should be an integer."}, {"id": 379968, "score": 81, "vote": 0, "content": "<pre><code class=\"python\">float(x) if '.' in x else int(x)\n</code></pre>\n", "abstract": ""}, {"id": 25299501, "score": 34, "vote": 0, "content": "<p>If you aren't averse to third-party modules, you could check out the <a href=\"https://pypi.org/project/fastnumbers\" rel=\"noreferrer\">fastnumbers</a> module. It provides a function called <a href=\"http://fastnumbers.readthedocs.io/en/master/api.html#fastnumbers.fast_real\" rel=\"noreferrer\">fast_real</a> that does exactly what this question is asking for and does it faster than a pure-Python implementation:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; from fastnumbers import fast_real\n&gt;&gt;&gt; fast_real(\"545.2222\")\n545.2222\n&gt;&gt;&gt; type(fast_real(\"545.2222\"))\nfloat\n&gt;&gt;&gt; fast_real(\"31\")\n31\n&gt;&gt;&gt; type(fast_real(\"31\"))\nint\n</code></pre>\n", "abstract": "If you aren't averse to third-party modules, you could check out the fastnumbers module. It provides a function called fast_real that does exactly what this question is asking for and does it faster than a pure-Python implementation:"}, {"id": 379932, "score": 27, "vote": 0, "content": "<p>Users <em>codelogic</em> and <em>harley</em> are correct, but keep in mind if you know the string is an integer (for example, 545) you can call int(\"545\") without first casting to float.</p>\n<p>If your strings are in a list, you could use the map function as well. </p>\n<pre><code class=\"python\">&gt;&gt;&gt; x = [\"545.0\", \"545.6\", \"999.2\"]\n&gt;&gt;&gt; map(float, x)\n[545.0, 545.60000000000002, 999.20000000000005]\n&gt;&gt;&gt;\n</code></pre>\n<p>It is only good if they're all the same type.</p>\n", "abstract": "Users codelogic and harley are correct, but keep in mind if you know the string is an integer (for example, 545) you can call int(\"545\") without first casting to float. If your strings are in a list, you could use the map function as well.  It is only good if they're all the same type."}, {"id": 31588754, "score": 27, "vote": 0, "content": "<blockquote>\n<p><strong>In Python, how can I parse a numeric string like \"545.2222\" to its corresponding float value, 542.2222? Or parse the string \"31\" to an integer, 31?</strong>\n  I just want to know how to parse a float string to a float, and (separately) an int string to an int.</p>\n</blockquote>\n<p>It's good that you ask to do these separately. If you're mixing them, you may be setting yourself up for problems later. The simple answer is:</p>\n<p><strong><code>\"545.2222\"</code> to float:</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; float(\"545.2222\")\n545.2222\n</code></pre>\n<p><strong><code>\"31\"</code> to an integer:</strong></p>\n<pre><code class=\"python\">&gt;&gt;&gt; int(\"31\")\n31\n</code></pre>\n<h1>Other conversions, ints to and from strings and literals:</h1>\n<p>Conversions from various bases, and you should know the base in advance (10 is the default). Note you can prefix them with what Python expects for its literals (see below) or remove the prefix:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; int(\"0b11111\", 2)\n31\n&gt;&gt;&gt; int(\"11111\", 2)\n31\n&gt;&gt;&gt; int('0o37', 8)\n31\n&gt;&gt;&gt; int('37', 8)\n31\n&gt;&gt;&gt; int('0x1f', 16)\n31\n&gt;&gt;&gt; int('1f', 16)\n31\n</code></pre>\n<p>If you don't know the base in advance, but you do know they will have the correct prefix, Python can infer this for you if you pass <code>0</code> as the base:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; int(\"0b11111\", 0)\n31\n&gt;&gt;&gt; int('0o37', 0)\n31\n&gt;&gt;&gt; int('0x1f', 0)\n31\n</code></pre>\n<h3>Non-Decimal (i.e. Integer) Literals from other Bases</h3>\n<p>If your motivation is to have your own code clearly represent hard-coded specific values, however, you may not need to convert from the bases - you can let Python do it for you automatically with the correct syntax.</p>\n<p>You can use the apropos prefixes to get automatic conversion to integers with <a href=\"https://docs.python.org/3/reference/lexical_analysis.html#integer-literals\" rel=\"noreferrer\">the following literals</a>. These are valid for Python 2 and 3:</p>\n<p>Binary, prefix <code>0b</code></p>\n<pre><code class=\"python\">&gt;&gt;&gt; 0b11111\n31\n</code></pre>\n<p>Octal, prefix <code>0o</code></p>\n<pre><code class=\"python\">&gt;&gt;&gt; 0o37\n31\n</code></pre>\n<p>Hexadecimal, prefix <code>0x</code></p>\n<pre><code class=\"python\">&gt;&gt;&gt; 0x1f\n31\n</code></pre>\n<p>This can be useful when describing binary flags, file permissions in code, or hex values for colors - for example, note no quotes:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 0b10101 # binary flags\n21\n&gt;&gt;&gt; 0o755 # read, write, execute perms for owner, read &amp; ex for group &amp; others\n493\n&gt;&gt;&gt; 0xffffff # the color, white, max values for red, green, and blue\n16777215\n</code></pre>\n<h3>Making ambiguous Python 2 octals compatible with Python 3</h3>\n<p>If you see an integer that starts with a 0, in Python 2, this is (deprecated) octal syntax.</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 037\n31\n</code></pre>\n<p>It is bad because it looks like the value should be <code>37</code>. So in Python 3, it now raises a <code>SyntaxError</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 037\n  File \"&lt;stdin&gt;\", line 1\n    037\n      ^\nSyntaxError: invalid token\n</code></pre>\n<p>Convert your Python 2 octals to octals that work in both 2 and 3 with the <code>0o</code> prefix:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; 0o37\n31\n</code></pre>\n", "abstract": "In Python, how can I parse a numeric string like \"545.2222\" to its corresponding float value, 542.2222? Or parse the string \"31\" to an integer, 31?\n  I just want to know how to parse a float string to a float, and (separately) an int string to an int. It's good that you ask to do these separately. If you're mixing them, you may be setting yourself up for problems later. The simple answer is: \"545.2222\" to float: \"31\" to an integer: Conversions from various bases, and you should know the base in advance (10 is the default). Note you can prefix them with what Python expects for its literals (see below) or remove the prefix: If you don't know the base in advance, but you do know they will have the correct prefix, Python can infer this for you if you pass 0 as the base: If your motivation is to have your own code clearly represent hard-coded specific values, however, you may not need to convert from the bases - you can let Python do it for you automatically with the correct syntax. You can use the apropos prefixes to get automatic conversion to integers with the following literals. These are valid for Python 2 and 3: Binary, prefix 0b Octal, prefix 0o Hexadecimal, prefix 0x This can be useful when describing binary flags, file permissions in code, or hex values for colors - for example, note no quotes: If you see an integer that starts with a 0, in Python 2, this is (deprecated) octal syntax. It is bad because it looks like the value should be 37. So in Python 3, it now raises a SyntaxError: Convert your Python 2 octals to octals that work in both 2 and 3 with the 0o prefix:"}, {"id": 7588720, "score": 21, "vote": 0, "content": "<p>The question seems a little bit old. But let me suggest a function, parseStr, which makes something similar, that is, returns integer or float and if a given ASCII string cannot be converted to none of them it returns it untouched. The code of course might be adjusted to do only what you want:</p>\n<pre><code class=\"python\">   &gt;&gt;&gt; import string\n   &gt;&gt;&gt; parseStr = lambda x: x.isalpha() and x or x.isdigit() and \\\n   ...                      int(x) or x.isalnum() and x or \\\n   ...                      len(set(string.punctuation).intersection(x)) == 1 and \\\n   ...                      x.count('.') == 1 and float(x) or x\n   &gt;&gt;&gt; parseStr('123')\n   123\n   &gt;&gt;&gt; parseStr('123.3')\n   123.3\n   &gt;&gt;&gt; parseStr('3HC1')\n   '3HC1'\n   &gt;&gt;&gt; parseStr('12.e5')\n   1200000.0\n   &gt;&gt;&gt; parseStr('12$5')\n   '12$5'\n   &gt;&gt;&gt; parseStr('12.2.2')\n   '12.2.2'\n</code></pre>\n", "abstract": "The question seems a little bit old. But let me suggest a function, parseStr, which makes something similar, that is, returns integer or float and if a given ASCII string cannot be converted to none of them it returns it untouched. The code of course might be adjusted to do only what you want:"}, {"id": 379909, "score": 19, "vote": 0, "content": "<p><code>float(\"545.2222\")</code> and <code>int(float(\"545.2222\"))</code></p>\n", "abstract": "float(\"545.2222\") and int(float(\"545.2222\"))"}, {"id": 16028076, "score": 17, "vote": 0, "content": "<p>The <a href=\"http://en.wikipedia.org/wiki/YAML\" rel=\"noreferrer\">YAML</a> parser can help you figure out what datatype your string is. Use <code>yaml.load()</code>, and then you can use <code>type(result)</code> to test for type:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import yaml\n\n&gt;&gt;&gt; a = \"545.2222\"\n&gt;&gt;&gt; result = yaml.load(a)\n&gt;&gt;&gt; result\n545.22220000000004\n&gt;&gt;&gt; type(result)\n&lt;type 'float'&gt;\n\n&gt;&gt;&gt; b = \"31\"\n&gt;&gt;&gt; result = yaml.load(b)\n&gt;&gt;&gt; result\n31\n&gt;&gt;&gt; type(result)\n&lt;type 'int'&gt;\n\n&gt;&gt;&gt; c = \"HI\"\n&gt;&gt;&gt; result = yaml.load(c)\n&gt;&gt;&gt; result\n'HI'\n&gt;&gt;&gt; type(result)\n&lt;type 'str'&gt;\n</code></pre>\n", "abstract": "The YAML parser can help you figure out what datatype your string is. Use yaml.load(), and then you can use type(result) to test for type:"}, {"id": 44994308, "score": 14, "vote": 0, "content": "<p>I use this function for that</p>\n<pre><code class=\"python\">import ast\n\ndef parse_str(s):\n   try:\n      return ast.literal_eval(str(s))\n   except:\n      return\n</code></pre>\n<p>It will convert the string to its type</p>\n<pre><code class=\"python\">value = parse_str('1')  # Returns Integer\nvalue = parse_str('1.5')  # Returns Float\n</code></pre>\n", "abstract": "I use this function for that It will convert the string to its type"}, {"id": 33017514, "score": 12, "vote": 0, "content": "<pre><code class=\"python\">def get_int_or_float(v):\n    number_as_float = float(v)\n    number_as_int = int(number_as_float)\n    return number_as_int if number_as_float == number_as_int else number_as_float\n</code></pre>\n", "abstract": ""}, {"id": 33044577, "score": 9, "vote": 0, "content": "<pre><code class=\"python\">def num(s):\n    \"\"\"num(s)\n    num(3),num(3.7)--&gt;3\n    num('3')--&gt;3, num('3.7')--&gt;3.7\n    num('3,700')--&gt;ValueError\n    num('3a'),num('a3'),--&gt;ValueError\n    num('3e4') --&gt; 30000.0\n    \"\"\"\n    try:\n        return int(s)\n    except ValueError:\n        try:\n            return float(s)\n        except ValueError:\n            raise ValueError('argument is not a string of number')\n</code></pre>\n", "abstract": ""}, {"id": 3988355, "score": 7, "vote": 0, "content": "<p>You need to take into account rounding to do this properly.</p>\n<p>i.e. - <code>int(5.1)</code> =&gt; 5\n<code>int(5.6)</code> =&gt; 5  -- wrong, should be 6 so we do <code>int(5.6 + 0.5)</code> =&gt; 6</p>\n<pre><code class=\"python\">def convert(n):\n    try:\n        return int(n)\n    except ValueError:\n        return float(n + 0.5)\n</code></pre>\n", "abstract": "You need to take into account rounding to do this properly. i.e. - int(5.1) => 5\nint(5.6) => 5  -- wrong, should be 6 so we do int(5.6 + 0.5) => 6"}, {"id": 69147924, "score": 7, "vote": 0, "content": "<p>You could use <code>json.loads</code>:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import json\n&gt;&gt;&gt; json.loads('123.456')\n123.456\n&gt;&gt;&gt; type(_)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; \n</code></pre>\n<p>As you can see it becomes a type of <code>float</code>.</p>\n", "abstract": "You could use json.loads: As you can see it becomes a type of float."}, {"id": 45063704, "score": 6, "vote": 0, "content": "<p>There is also regex, because sometimes string must be prepared and normalized before casting to a number:</p>\n<pre><code class=\"python\">import re\n\ndef parseNumber(value, as_int=False):\n    try:\n        number = float(re.sub('[^.\\-\\d]', '', value))\n        if as_int:\n            return int(number + 0.5)\n        else:\n            return number\n    except ValueError:\n        return float('nan')  # or None if you wish\n</code></pre>\n<p>Usage:</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">parseNumber('13,345')\n&gt; 13345.0\n\nparseNumber('- 123 000')\n&gt; -123000.0\n\nparseNumber('99999\\n')\n&gt; 99999.0\n</code></pre>\n<p>And by the way, something to verify you have a number:</p>\n<pre><code class=\"python\">import numbers\ndef is_number(value):\n    return isinstance(value, numbers.Number)\n    # Will work with int, float, long, Decimal\n</code></pre>\n", "abstract": "There is also regex, because sometimes string must be prepared and normalized before casting to a number: Usage: And by the way, something to verify you have a number:"}, {"id": 51126875, "score": 6, "vote": 0, "content": "<p>To <code>typecast</code> in Python use the constructor functions of the type, passing the string (or whatever value you are trying to cast) as a parameter.</p>\n<p>For example:</p>\n<pre><code class=\"python\">&gt;&gt;&gt;float(\"23.333\")\n   23.333\n</code></pre>\n<p>Behind the scenes, Python is calling the objects <code>__float__</code> method, which should return a float representation of the parameter. This is especially powerful, as you can define your own types (using classes) with a <code>__float__</code> method so that it can be casted into a float using <code>float(myobject)</code>.</p>\n", "abstract": "To typecast in Python use the constructor functions of the type, passing the string (or whatever value you are trying to cast) as a parameter. For example: Behind the scenes, Python is calling the objects __float__ method, which should return a float representation of the parameter. This is especially powerful, as you can define your own types (using classes) with a __float__ method so that it can be casted into a float using float(myobject)."}, {"id": 58997070, "score": 6, "vote": 0, "content": "<p><strong>Handles hex, octal, binary, decimal, and float</strong></p>\n<p>This solution will handle all of the string conventions for numbers (all that I know about).</p>\n<pre><code class=\"python\">def to_number(n):\n    ''' Convert any number representation to a number\n    This covers: float, decimal, hex, and octal numbers.\n    '''\n\n    try:\n        return int(str(n), 0)\n    except:\n        try:\n            # Python 3 doesn't accept \"010\" as a valid octal.  You must use the\n            # '0o' prefix\n            return int('0o' + n, 0)\n        except:\n            return float(n)\n</code></pre>\n<p>This test case output illustrates what I'm talking about.</p>\n<pre class=\"lang-none prettyprint-override\"><code class=\"python\">======================== CAPTURED OUTPUT =========================\nto_number(3735928559)   = 3735928559 == 3735928559\nto_number(\"0xFEEDFACE\") = 4277009102 == 4277009102\nto_number(\"0x0\")        =          0 ==          0\nto_number(100)          =        100 ==        100\nto_number(\"42\")         =         42 ==         42\nto_number(8)            =          8 ==          8\nto_number(\"0o20\")       =         16 ==         16\nto_number(\"020\")        =         16 ==         16\nto_number(3.14)         =       3.14 ==       3.14\nto_number(\"2.72\")       =       2.72 ==       2.72\nto_number(\"1e3\")        =     1000.0 ==       1000\nto_number(0.001)        =      0.001 ==      0.001\nto_number(\"0xA\")        =         10 ==         10\nto_number(\"012\")        =         10 ==         10\nto_number(\"0o12\")       =         10 ==         10\nto_number(\"0b01010\")    =         10 ==         10\nto_number(\"10\")         =         10 ==         10\nto_number(\"10.0\")       =       10.0 ==         10\nto_number(\"1e1\")        =       10.0 ==         10\n</code></pre>\n<p>Here is the test:</p>\n<pre><code class=\"python\">class test_to_number(unittest.TestCase):\n\n    def test_hex(self):\n        # All of the following should be converted to an integer\n        #\n        values = [\n\n                 #          HEX\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (0xDEADBEEF  , 3735928559), # Hex\n                (\"0xFEEDFACE\", 4277009102), # Hex\n                (\"0x0\"       ,          0), # Hex\n\n                 #        Decimals\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (100         ,        100), # Decimal\n                (\"42\"        ,         42), # Decimal\n            ]\n\n\n\n        values += [\n                 #        Octals\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (0o10        ,          8), # Octal\n                (\"0o20\"      ,         16), # Octal\n                (\"020\"       ,         16), # Octal\n            ]\n\n\n        values += [\n                 #        Floats\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (3.14        ,       3.14), # Float\n                (\"2.72\"      ,       2.72), # Float\n                (\"1e3\"       ,       1000), # Float\n                (1e-3        ,      0.001), # Float\n            ]\n\n        values += [\n                 #        All ints\n                 # ----------------------\n                 # Input     |   Expected\n                 # ----------------------\n                (\"0xA\"       ,         10),\n                (\"012\"       ,         10),\n                (\"0o12\"      ,         10),\n                (\"0b01010\"   ,         10),\n                (\"10\"        ,         10),\n                (\"10.0\"      ,         10),\n                (\"1e1\"       ,         10),\n            ]\n\n        for _input, expected in values:\n            value = to_number(_input)\n\n            if isinstance(_input, str):\n                cmd = 'to_number(\"{}\")'.format(_input)\n            else:\n                cmd = 'to_number({})'.format(_input)\n\n            print(\"{:23} = {:10} == {:10}\".format(cmd, value, expected))\n            self.assertEqual(value, expected)\n</code></pre>\n", "abstract": "Handles hex, octal, binary, decimal, and float This solution will handle all of the string conventions for numbers (all that I know about). This test case output illustrates what I'm talking about. Here is the test:"}, {"id": 59270522, "score": 6, "vote": 0, "content": "<p>Pass your string to this function:</p>\n<pre><code class=\"python\">def string_to_number(str):\n  if(\".\" in str):\n    try:\n      res = float(str)\n    except:\n      res = str\n  elif(str.isdigit()):\n    res = int(str)\n  else:\n    res = str\n  return(res)\n</code></pre>\n<p>It will return int, float or string depending on what was passed.</p>\n<h3>String that is an int</h3>\n<pre><code class=\"python\">print(type(string_to_number(\"124\")))\n&lt;class 'int'&gt;\n</code></pre>\n<h3>String that is a float</h3>\n<pre><code class=\"python\">print(type(string_to_number(\"12.4\")))\n&lt;class 'float'&gt;\n</code></pre>\n<h3>String that is a string</h3>\n<pre><code class=\"python\">print(type(string_to_number(\"hello\")))\n&lt;class 'str'&gt;\n</code></pre>\n<h3>String that looks like a float</h3>\n<pre><code class=\"python\">print(type(string_to_number(\"hel.lo\")))\n&lt;class 'str'&gt;\n</code></pre>\n", "abstract": "Pass your string to this function: It will return int, float or string depending on what was passed."}, {"id": 64275521, "score": 5, "vote": 0, "content": "<pre class=\"lang-py prettyprint-override\"><code class=\"python\">a = int(float(a)) if int(float(a)) == float(a) else float(a)\n</code></pre>\n", "abstract": ""}, {"id": 44041282, "score": 3, "vote": 0, "content": "<p><strong>This is a corrected version</strong> of <a href=\"https://stackoverflow.com/questions/379906/how-do-i-parse-a-string-to-a-float-or-int/33017514#33017514\">Totoro's answer</a>.</p>\n<p>This will try to parse a string and return either <code>int</code> or <code>float</code> depending on what the string represents. It might rise parsing exceptions or <a href=\"https://stackoverflow.com/a/1778381/5973334\">have some unexpected behaviour</a>.</p>\n<pre><code class=\"python\">  def get_int_or_float(v):\n        number_as_float = float(v)\n        number_as_int = int(number_as_float)\n        return number_as_int if number_as_float == number_as_int else\n        number_as_float\n</code></pre>\n", "abstract": "This is a corrected version of Totoro's answer. This will try to parse a string and return either int or float depending on what the string represents. It might rise parsing exceptions or have some unexpected behaviour."}, {"id": 68397181, "score": 2, "vote": 0, "content": "<p>If you are dealing with mixed integers and floats and want a consistent way to deal with your mixed data, here is my solution with the proper <a href=\"https://en.wikipedia.org/wiki/Docstring#Python\" rel=\"nofollow noreferrer\">docstring</a>:</p>\n<pre><code class=\"python\">def parse_num(candidate):\n    \"\"\"Parse string to number if possible\n    It work equally well with negative and positive numbers, integers and floats.\n\n    Args:\n        candidate (str): string to convert\n\n    Returns:\n        float | int | None: float or int if possible otherwise None\n    \"\"\"\n    try:\n        float_value = float(candidate)\n    except ValueError:\n        return None\n\n    # Optional part if you prefer int to float when decimal part is 0\n    if float_value.is_integer():\n        return int(float_value)\n    # end of the optional part\n\n    return float_value\n\n# Test\ncandidates = ['34.77', '-13', 'jh', '8990', '76_3234_54']\nres_list = list(map(parse_num, candidates))\nprint('Before:')\nprint(candidates)\nprint('After:')\nprint(res_list)\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">Before:\n['34.77', '-13', 'jh', '8990', '76_3234_54']\n\nAfter:\n[34.77, -13, None, 8990, 76323454]\n</code></pre>\n", "abstract": "If you are dealing with mixed integers and floats and want a consistent way to deal with your mixed data, here is my solution with the proper docstring: Output:"}, {"id": 39940402, "score": 1, "vote": 0, "content": "<p>Use:</p>\n<pre><code class=\"python\">def num(s):\n    try:\n        for each in s:\n            yield int(each)\n    except ValueError:\n        yield float(each)\na = num([\"123.55\",\"345\",\"44\"])\nprint a.next()\nprint a.next()\n</code></pre>\n<p>This is the most Pythonic way I could come up with. </p>\n", "abstract": "Use: This is the most Pythonic way I could come up with. "}, {"id": 39437128, "score": 0, "vote": 0, "content": "<p>Use:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; str_float = \"545.2222\"\n&gt;&gt;&gt; float(str_float)\n545.2222\n&gt;&gt;&gt; type(_) # Check its type\n&lt;type 'float'&gt;\n\n&gt;&gt;&gt; str_int = \"31\"\n&gt;&gt;&gt; int(str_int)\n31\n&gt;&gt;&gt; type(_) # Check its type\n&lt;type 'int'&gt;\n</code></pre>\n", "abstract": "Use:"}, {"id": 57458489, "score": 0, "vote": 0, "content": "<p>This is a function which will convert any <code>object</code> (not just <code>str</code>) to <code>int</code> or <code>float</code>, based on if the actual string supplied <em>looks like</em> <code>int</code> or <code>float</code>. Further if it's an object which has both <code>__float</code> and <code>__int__</code> methods, it defaults to using <code>__float__</code></p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">def conv_to_num(x, num_type='asis'):\n    '''Converts an object to a number if possible.\n    num_type: int, float, 'asis'\n    Defaults to floating point in case of ambiguity.\n    '''\n    import numbers\n\n    is_num, is_str, is_other = [False]*3\n\n    if isinstance(x, numbers.Number):\n        is_num = True\n    elif isinstance(x, str):\n        is_str = True\n\n    is_other = not any([is_num, is_str])\n\n    if is_num:\n        res = x\n    elif is_str:\n        is_float, is_int, is_char = [False]*3\n        try:\n            res = float(x)\n            if '.' in x:\n                is_float = True\n            else:\n                is_int = True\n        except ValueError:\n            res = x\n            is_char = True\n\n    else:\n        if num_type == 'asis':\n            funcs = [int, float]\n        else:\n            funcs = [num_type]\n\n        for func in funcs:\n            try:\n                res = func(x)\n                break\n            except TypeError:\n                continue\n        else:\n            res = x\n</code></pre>\n", "abstract": "This is a function which will convert any object (not just str) to int or float, based on if the actual string supplied looks like int or float. Further if it's an object which has both __float and __int__ methods, it defaults to using __float__"}, {"id": 62022268, "score": 0, "vote": 0, "content": "<p>By using int and float methods we can convert a string to integer and floats.</p>\n<pre><code class=\"python\">s=\"45.8\"\nprint(float(s))\n\ny='67'\nprint(int(y))\n</code></pre>\n", "abstract": "By using int and float methods we can convert a string to integer and floats."}, {"id": 62986009, "score": 0, "vote": 0, "content": "<p>For numbers and characters together:</p>\n<pre><code class=\"python\">string_for_int = \"498 results should get\"\nstring_for_float = \"498.45645765 results should get\"\n</code></pre>\n<p>First import <em>re</em>:</p>\n<pre><code class=\"python\"> import re\n\n # For getting the integer part:\n print(int(re.search(r'\\d+', string_for_int).group())) #498\n\n # For getting the float part:\n print(float(re.search(r'\\d+\\.\\d+', string_for_float).group())) #498.45645765\n</code></pre>\n<p>For easy model:</p>\n<pre><code class=\"python\">value1 = \"10\"\nvalue2 = \"10.2\"\nprint(int(value1)) # 10\nprint(float(value2)) # 10.2\n</code></pre>\n", "abstract": "For numbers and characters together: First import re: For easy model:"}, {"id": 379963, "score": -12, "vote": 0, "content": "<p>Here's another interpretation of your question (hint: it's vague). It's possible you're looking for something like this:</p>\n<pre><code class=\"python\">def parseIntOrFloat( aString ):\n    return eval( aString )\n</code></pre>\n<p>It works like this...</p>\n<pre><code class=\"python\">&gt;&gt;&gt; parseIntOrFloat(\"545.2222\")\n545.22220000000004\n&gt;&gt;&gt; parseIntOrFloat(\"545\")\n545\n</code></pre>\n<hr/>\n<p>Theoretically, there's an injection vulnerability. The string could, for example be <code>\"import os; os.abort()\"</code>. Without any background on where the string comes from, however, the possibility is theoretical speculation.  Since the question is vague, it's not at all clear if this vulnerability actually exists or not.</p>\n", "abstract": "Here's another interpretation of your question (hint: it's vague). It's possible you're looking for something like this: It works like this... Theoretically, there's an injection vulnerability. The string could, for example be \"import os; os.abort()\". Without any background on where the string comes from, however, the possibility is theoretical speculation.  Since the question is vague, it's not at all clear if this vulnerability actually exists or not."}]}, {"link": "https://stackoverflow.com/questions/11277432/how-can-i-remove-a-key-from-a-python-dictionary", "question": {"id": "11277432", "title": "How can I remove a key from a Python dictionary?", "content": "<p>Is there a one-line way of deleting a key from a dictionary without raising a <code>KeyError</code>?</p>\n<pre><code class=\"python\">if 'key' in my_dict:\n    del my_dict['key']\n</code></pre>\n", "abstract": "Is there a one-line way of deleting a key from a dictionary without raising a KeyError?"}, "answers": [{"id": 11277439, "score": 4239, "vote": 0, "content": "<p>To delete a key regardless of whether it is in the dictionary, use the two-argument form of <a href=\"http://docs.python.org/library/stdtypes.html#dict.pop\" rel=\"noreferrer\"><code>dict.pop()</code></a>:</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">my_dict.pop('key', None)\n</code></pre>\n<p>This will return <code>my_dict[key]</code> if <code>key</code> exists in the dictionary, and <code>None</code> otherwise. If the second parameter is not specified (i.e. <code>my_dict.pop('key')</code>) and <code>key</code> does not exist, a <code>KeyError</code> is raised.</p>\n<p>To delete a key that is guaranteed to exist, you can also use:</p>\n<pre><code class=\"python\">del my_dict['key']\n</code></pre>\n<p>This will raise a <code>KeyError</code> if the key is not in the dictionary.</p>\n", "abstract": "To delete a key regardless of whether it is in the dictionary, use the two-argument form of dict.pop(): This will return my_dict[key] if key exists in the dictionary, and None otherwise. If the second parameter is not specified (i.e. my_dict.pop('key')) and key does not exist, a KeyError is raised. To delete a key that is guaranteed to exist, you can also use: This will raise a KeyError if the key is not in the dictionary."}, {"id": 11277484, "score": 440, "vote": 0, "content": "<p>Specifically to answer \"is there a one line way of doing this?\"</p>\n<pre><code class=\"python\">if 'key' in my_dict: del my_dict['key']\n</code></pre>\n<p>...well, you <em>asked</em> ;-)</p>\n<p>You should consider, though, that this way of deleting an object from a <code>dict</code> is <a href=\"https://stackoverflow.com/q/17326067/722332\">not atomic</a>\u2014it is possible that <code>'key'</code> may be in <code>my_dict</code> during the <code>if</code> statement, but may be deleted before <code>del</code> is executed, in which case <code>del</code> will fail with a <code>KeyError</code>.  Given this, it would be safest to either <a href=\"https://stackoverflow.com/a/11277439/722332\">use <code>dict.pop</code></a> or something along the lines of</p>\n<pre><code class=\"python\">try:\n    del my_dict['key']\nexcept KeyError:\n    pass\n</code></pre>\n<p>which, of course, is definitely <em>not</em> a one-liner.</p>\n", "abstract": "Specifically to answer \"is there a one line way of doing this?\" ...well, you asked ;-) You should consider, though, that this way of deleting an object from a dict is not atomic\u2014it is possible that 'key' may be in my_dict during the if statement, but may be deleted before del is executed, in which case del will fail with a KeyError.  Given this, it would be safest to either use dict.pop or something along the lines of which, of course, is definitely not a one-liner."}, {"id": 15206537, "score": 189, "vote": 0, "content": "<p>It took me some time to figure out what exactly <code>my_dict.pop(\"key\", None)</code> is doing. So I'll add this as an answer to save others googling time:</p>\n<blockquote>\n<h3><code>pop(key[, default])</code></h3>\n<p>If <em>key</em> is in the dictionary, remove it and return its value, else\nreturn <em>default</em>. If <em>default</em> is not given and <em>key</em> is not in the\ndictionary, a <code>KeyError</code> is raised.</p>\n</blockquote>\n<p><a href=\"https://docs.python.org/2/library/stdtypes.html#dict.pop\" rel=\"noreferrer\">Documentation</a></p>\n", "abstract": "It took me some time to figure out what exactly my_dict.pop(\"key\", None) is doing. So I'll add this as an answer to save others googling time: If key is in the dictionary, remove it and return its value, else\nreturn default. If default is not given and key is not in the\ndictionary, a KeyError is raised. Documentation"}, {"id": 41017333, "score": 77, "vote": 0, "content": "<p><code>del my_dict[key]</code> is slightly faster than <code>my_dict.pop(key)</code> for removing a key from a dictionary when the key exists</p>\n<pre><code class=\"python\">&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; setup = \"d = {i: i for i in range(100000)}\"\n\n&gt;&gt;&gt; timeit.timeit(\"del d[3]\", setup=setup, number=1)\n1.79e-06\n&gt;&gt;&gt; timeit.timeit(\"d.pop(3)\", setup=setup, number=1)\n2.09e-06\n&gt;&gt;&gt; timeit.timeit(\"d2 = {key: val for key, val in d.items() if key != 3}\", setup=setup, number=1)\n0.00786\n</code></pre>\n<p>But when the key doesn't exist <code>if key in my_dict: del my_dict[key]</code> is slightly faster than <code>my_dict.pop(key, None)</code>. Both are at least three times faster than <code>del</code> in a <code>try</code>/<code>except</code> statement:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; timeit.timeit(\"if 'missing key' in d: del d['missing key']\", setup=setup)\n0.0229\n&gt;&gt;&gt; timeit.timeit(\"d.pop('missing key', None)\", setup=setup)\n0.0426\n&gt;&gt;&gt; try_except = \"\"\"\n... try:\n...     del d['missing key']\n... except KeyError:\n...     pass\n... \"\"\"\n&gt;&gt;&gt; timeit.timeit(try_except, setup=setup)\n0.133\n</code></pre>\n", "abstract": "del my_dict[key] is slightly faster than my_dict.pop(key) for removing a key from a dictionary when the key exists But when the key doesn't exist if key in my_dict: del my_dict[key] is slightly faster than my_dict.pop(key, None). Both are at least three times faster than del in a try/except statement:"}, {"id": 32616904, "score": 66, "vote": 0, "content": "<p>If you need to remove a lot of keys from a dictionary in one line of code, I think using map() is quite succinct and Pythonic readable:</p>\n<pre><code class=\"python\">myDict = {'a':1,'b':2,'c':3,'d':4}\nmap(myDict.pop, ['a','c']) # The list of keys to remove\n&gt;&gt;&gt; myDict\n{'b': 2, 'd': 4}\n</code></pre>\n<p>And if you need to catch errors where you pop a value that isn't in the dictionary, use lambda inside map() like this:</p>\n<pre><code class=\"python\">map(lambda x: myDict.pop(x,None), ['a', 'c', 'e'])\n[1, 3, None] # pop returns\n&gt;&gt;&gt; myDict\n{'b': 2, 'd': 4}\n</code></pre>\n<p>or in <code>python3</code>, you must use a list comprehension instead:</p>\n<pre><code class=\"python\">[myDict.pop(x, None) for x in ['a', 'c', 'e']]\n</code></pre>\n<p>It works. And 'e' did not cause an error, even though myDict did not have an 'e' key.</p>\n", "abstract": "If you need to remove a lot of keys from a dictionary in one line of code, I think using map() is quite succinct and Pythonic readable: And if you need to catch errors where you pop a value that isn't in the dictionary, use lambda inside map() like this: or in python3, you must use a list comprehension instead: It works. And 'e' did not cause an error, even though myDict did not have an 'e' key."}, {"id": 41010331, "score": 57, "vote": 0, "content": "<p>You can use a <a href=\"https://docs.python.org/tutorial/datastructures.html#dictionaries\" rel=\"noreferrer\">dictionary comprehension</a> to create a new dictionary with that key removed:</p>\n<pre><code class=\"python\">&gt;&gt;&gt; my_dict = {k: v for k, v in my_dict.items() if k != 'key'}\n</code></pre>\n<p>You can delete by conditions. No error if <code>key</code> doesn't exist.</p>\n", "abstract": "You can use a dictionary comprehension to create a new dictionary with that key removed: You can delete by conditions. No error if key doesn't exist."}, {"id": 50424087, "score": 11, "vote": 0, "content": "<p>We can delete a key from a Python dictionary by the some of the following approaches.</p>\n<p>Using the <code>del</code> keyword; it's almost the same approach like you did though -</p>\n<pre><code class=\"python\"> myDict = {'one': 100, 'two': 200, 'three': 300 }\n print(myDict)  # {'one': 100, 'two': 200, 'three': 300}\n if myDict.get('one') : del myDict['one']\n print(myDict)  # {'two': 200, 'three': 300}\n</code></pre>\n<p><strong>Or</strong></p>\n<p>We can do like the following:</p>\n<p>But one should keep in mind that, in this process actually it won't <strong>delete</strong> any key from the dictionary rather than making a specific key <strong>excluded</strong> from that dictionary. In addition, I observed that it returned a dictionary which was not ordered the same as <code>myDict</code>.</p>\n<pre><code class=\"python\">myDict = {'one': 100, 'two': 200, 'three': 300, 'four': 400, 'five': 500}\n{key:value for key, value in myDict.items() if key != 'one'}\n</code></pre>\n<p>If we run it in the shell, it'll execute something like <code>{'five': 500, 'four': 400, 'three': 300, 'two': 200}</code> - notice that it's not the same ordered as <code>myDict</code>. Again if we try to print <code>myDict</code>, then we can see all keys including which we excluded from the dictionary by this approach. However, we can make a new dictionary by assigning the following statement into a variable:</p>\n<pre><code class=\"python\">var = {key:value for key, value in myDict.items() if key != 'one'}\n</code></pre>\n<p>Now if we try to print it, then it'll follow the parent order:</p>\n<pre><code class=\"python\">print(var) # {'two': 200, 'three': 300, 'four': 400, 'five': 500}\n</code></pre>\n<p><strong>Or</strong></p>\n<p>Using the <code>pop()</code> method.</p>\n<pre><code class=\"python\">myDict = {'one': 100, 'two': 200, 'three': 300}\nprint(myDict)\n\nif myDict.get('one') : myDict.pop('one')\nprint(myDict)  # {'two': 200, 'three': 300}\n</code></pre>\n<p>The difference between <code>del</code> and <code>pop</code> is that, using <code>pop()</code> method, we can actually store the <strong>key's value</strong> if needed, like the following:</p>\n<pre><code class=\"python\">myDict = {'one': 100, 'two': 200, 'three': 300}\nif myDict.get('one') : var = myDict.pop('one')\nprint(myDict) # {'two': 200, 'three': 300}\nprint(var)    # 100\n</code></pre>\n<p>Fork <a href=\"https://gist.github.com/innat/c8d04ef139060b9ef0b7fa8a164f87bc\" rel=\"nofollow noreferrer\">this gist</a> for future reference, if you find this useful.</p>\n", "abstract": "We can delete a key from a Python dictionary by the some of the following approaches. Using the del keyword; it's almost the same approach like you did though - Or We can do like the following: But one should keep in mind that, in this process actually it won't delete any key from the dictionary rather than making a specific key excluded from that dictionary. In addition, I observed that it returned a dictionary which was not ordered the same as myDict. If we run it in the shell, it'll execute something like {'five': 500, 'four': 400, 'three': 300, 'two': 200} - notice that it's not the same ordered as myDict. Again if we try to print myDict, then we can see all keys including which we excluded from the dictionary by this approach. However, we can make a new dictionary by assigning the following statement into a variable: Now if we try to print it, then it'll follow the parent order: Or Using the pop() method. The difference between del and pop is that, using pop() method, we can actually store the key's value if needed, like the following: Fork this gist for future reference, if you find this useful."}, {"id": 56301607, "score": 10, "vote": 0, "content": "<p>You can use exception handling if you want to be very verbose:</p>\n<pre><code class=\"python\">try: \n    del dict[key]\n\nexcept KeyError: pass\n</code></pre>\n<p>This is slower, however, than the <code>pop()</code> method, if the key doesn't exist.</p>\n<pre><code class=\"python\">my_dict.pop('key', None)\n</code></pre>\n<p>It won't matter for a few keys, but if you're doing this repeatedly, then the latter method is a better bet.</p>\n<p>The fastest approach is this:</p>\n<pre><code class=\"python\">if 'key' in dict: \n    del myDict['key']\n</code></pre>\n<p>But this method is dangerous because if <code>'key'</code> is removed in between the two lines, a <code>KeyError</code> will be raised.</p>\n", "abstract": "You can use exception handling if you want to be very verbose: This is slower, however, than the pop() method, if the key doesn't exist. It won't matter for a few keys, but if you're doing this repeatedly, then the latter method is a better bet. The fastest approach is this: But this method is dangerous because if 'key' is removed in between the two lines, a KeyError will be raised."}, {"id": 57980814, "score": 6, "vote": 0, "content": "<p>Another way is by using items() + dict comprehension.</p>\n<p>items() coupled with dict comprehension can also help us achieve the task of key-value pair deletion, but it has the drawback of not being an in place dict technique. Actually a new dict if created except for the key we don\u2019t wish to include.</p>\n<pre><code class=\"python\">test_dict = {\"sai\" : 22, \"kiran\" : 21, \"vinod\" : 21, \"sangam\" : 21}\n\n# Printing dictionary before removal\nprint (\"dictionary before performing remove is : \" + str(test_dict))\n\n# Using items() + dict comprehension to remove a dict. pair\n# removes  vinod\nnew_dict = {key:val for key, val in test_dict.items() if key != 'vinod'}\n\n# Printing dictionary after removal\nprint (\"dictionary after remove is : \" + str(new_dict))\n</code></pre>\n<p>Output:</p>\n<pre><code class=\"python\">dictionary before performing remove is : {'sai': 22, 'kiran': 21, 'vinod': 21, 'sangam': 21}\ndictionary after remove is : {'sai': 22, 'kiran': 21, 'sangam': 21}\n</code></pre>\n", "abstract": "Another way is by using items() + dict comprehension. items() coupled with dict comprehension can also help us achieve the task of key-value pair deletion, but it has the drawback of not being an in place dict technique. Actually a new dict if created except for the key we don\u2019t wish to include. Output:"}, {"id": 56594575, "score": 5, "vote": 0, "content": "<p>I prefer the immutable version</p>\n<pre class=\"lang-py prettyprint-override\"><code class=\"python\">foo = {\n    1:1,\n    2:2,\n    3:3\n}\nremoveKeys = [1,2]\ndef woKeys(dct, keyIter):\n    return {\n        k:v\n        for k,v in dct.items() if k not in keyIter\n    }\n\n&gt;&gt;&gt; print(woKeys(foo, removeKeys))\n{3: 3}\n&gt;&gt;&gt; print(foo)\n{1: 1, 2: 2, 3: 3}\n</code></pre>\n", "abstract": "I prefer the immutable version"}, {"id": 73433357, "score": -3, "vote": 0, "content": "<p>If you want to do that without <code>KeyError</code>, you can declare a temporary class and set it as default value in dict.get, if the value is equal to that class if means that key does not exist</p>\n<h2>Keys and Dict</h2>\n<pre><code class=\"python\">a={\"Assemblyisscary\":3637}\nkey1=\"Assemblyisscary\"\nkey2=\"Binarylangisnightmare\"\n</code></pre>\n<h2>Function for deleting</h2>\n<pre><code class=\"python\">def delkey(dictionary,key):\n    class temp:pass\n    if temp==dictionary.get(key,temp):return False\n    else: del dictionary[key];return True\n</code></pre>\n<h2>Testing</h2>\n<pre><code class=\"python\">delete(a,key2)\ndelete(a,key1)\n</code></pre>\n<h2>Output</h2>\n<pre><code class=\"python\">False\nTrue\n</code></pre>\n", "abstract": "If you want to do that without KeyError, you can declare a temporary class and set it as default value in dict.get, if the value is equal to that class if means that key does not exist"}]}]